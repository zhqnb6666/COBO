{"4": ["from math import *\nDIGS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef converter(n, decimals=0, base=pi):\n\t(lst, n) = (['-' * (n < 0)], abs(n))\n\tpMax = max(0, n and int(log(n, base)))\n\tfor p in reversed(range(-decimals, pMax + 1)):\n\t\tif p == -1:\n\t\t\tlst.append('.')\n\t\tp = base ** p\n\t\t(d, n) = (n / p, n % p)\n\t\tlst.append(DIGS[int(d)])\n\treturn ''.join(lst)\n", "from math import pi\nfrom math import log\n\ndef converter(n, decimals=0, base=pi):\n\tDIGITS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\trepresentation = []\n\tif n < 0:\n\t\trepresentation.append('-')\n\t\tn *= -1\n\tif n == 0:\n\t\tdecimalCount = 0\n\telse:\n\t\tdecimalCount = int(log(n, base))\n\tfor dplace in [pow(base, power) for power in range(decimalCount, -1 - decimals, -1)]:\n\t\trNumber = int(n / dplace)\n\t\tn -= rNumber * dplace\n\t\trepresentation.append(DIGITS[rNumber])\n\t\tif dplace == 1 and decimals > 0:\n\t\t\trepresentation.append('.')\n\treturn ''.join(representation)\n", "from math import pi\n\ndef converter(n, decimals=0, base=pi):\n\tnewbase = ''\n\ttemp = base\n\thighdigit = 1\n\tif n < 0:\n\t\tnewbase = '-'\n\t\tn *= -1\n\twhile temp <= n:\n\t\ttemp *= base\n\t\thighdigit += 1\n\tfor i in reversed(list(range(-decimals, highdigit))):\n\t\ttemp = int(n / base ** i)\n\t\tif temp > 9:\n\t\t\tdigit = chr(55 + temp)\n\t\telse:\n\t\t\tdigit = str(temp)\n\t\tnewbase += digit\n\t\tn -= temp * base ** i\n\t\tif i == 0 and decimals > 0:\n\t\t\tnewbase += '.'\n\treturn newbase\n", "from math import pi, log\n\ndef converter(n, decimals=0, base=pi):\n\tif n == 0:\n\t\treturn '0' if decimals == 0 else '0.' + '0' * decimals\n\tlexiconums = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\tres = '' if n > 0 else '-'\n\tn = abs(n)\n\tfor i in range(int(log(n) / log(base)), -decimals - 1, -1):\n\t\tdivisor = base ** i\n\t\tres += lexiconums[int(n / divisor)]\n\t\tif i == 0 and decimals > 0:\n\t\t\tres += '.'\n\t\tn %= divisor\n\treturn res\n", "from math import pi\nimport math\nnumbers = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef converter(n, decimals=0, base=pi):\n\tif n < 0:\n\t\treturn '-' + converter(-n, decimals, base)\n\tresult = ''\n\tdigits = 0\n\twhile n >= base ** digits:\n\t\tdigits += 1\n\tfor i in range(digits - 1, -decimals - 1, -1):\n\t\tdiv = n / base ** i\n\t\tinteger = math.floor(div)\n\t\tn = n - integer * base ** i\n\t\tresult = result + numbers[int(integer)]\n\tif decimals > 0:\n\t\tresult = result[:-decimals] + '.' + result[-decimals:]\n\tif result[0] == '.':\n\t\tresult = '0' + result\n\treturn result\n", "from math import pi, log, floor\n\ndef converter(n, decimals=0, base=pi):\n\tif n < 0:\n\t\tisNegative = True\n\t\tn *= -1\n\telse:\n\t\tisNegative = False\n\tif n == 0:\n\t\tdigits = 1\n\telse:\n\t\tdigits = floor(log(n) / log(base) + 1)\n\tpiggyBank = n\n\tbase36 = {10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F', 16: 'G', 17: 'H', 18: 'I', 19: 'J', 20: 'K', 21: 'L', 22: 'M', 23: 'N', 24: 'O', 25: 'P', 26: 'Q', 27: 'R', 28: 'S', 29: 'T', 30: 'U', 31: 'V', 32: 'W', 33: 'X', 34: 'Y', 35: 'Z'}\n\toutput = ''\n\tpower = digits - 1\n\tdebugList = []\n\twhile power >= 0:\n\t\tnewDig = floor(piggyBank / base ** power)\n\t\tpiggyBank -= newDig * base ** power\n\t\tif newDig >= 10:\n\t\t\tnewDig = base36[newDig]\n\t\toutput += str(newDig)\n\t\tpower -= 1\n\tif decimals > 0:\n\t\toutput += '.'\n\twhile power * -1 <= decimals:\n\t\tnewDig = floor(piggyBank / base ** power)\n\t\tpiggyBank -= newDig * base ** power\n\t\tif newDig >= 10:\n\t\t\tnewDig = base36[newDig]\n\t\toutput += str(newDig)\n\t\tpower -= 1\n\tif isNegative:\n\t\toutput = '-' + output\n\treturn output\n", "from math import pi\n\ndef converter(n, decimals=0, base=pi):\n\tif n < 0:\n\t\treturn '-' + converter(-n, decimals, base)\n\tCHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\tres = ''\n\tln = 1\n\twhile base ** ln <= n:\n\t\tln += 1\n\twhile 0 < ln:\n\t\tln -= 1\n\t\td = int(n / base ** ln)\n\t\tres += CHARS[d]\n\t\tn -= d * base ** ln\n\tif 0 < decimals:\n\t\tres += '.'\n\t\tbase2 = 1\n\t\twhile 0 < decimals:\n\t\t\tbase2 *= 1 / base\n\t\t\td = int(n / base2)\n\t\t\tres += CHARS[d]\n\t\t\tn -= d * base2\n\t\t\tdecimals -= 1\n\treturn res\n", "from math import pi\ndigs = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef converter(n, decimals=0, base=pi):\n\tneg = ''\n\tans = ''\n\tif n < 0:\n\t\tneg = '-'\n\t\tn = -n\n\tfor i in range(20, -20, -1):\n\t\tif i == -1 - decimals:\n\t\t\tbreak\n\t\tif i == -1:\n\t\t\tans += '.'\n\t\td = int(n / base ** i)\n\t\tans += digs[d]\n\t\tn -= d * base ** i\n\twhile len(ans) > 1 and ans[0] == '0' and (ans[1] != '.'):\n\t\tans = ans[1:]\n\treturn neg + ans\n"], "19": ["def is_sorted_and_how(arr):\n\tif arr == sorted(arr):\n\t\treturn 'yes, ascending'\n\telif arr == sorted(arr)[::-1]:\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tif arr == sorted(arr):\n\t\treturn 'yes, ascending'\n\telif arr == sorted(arr, reverse=True):\n\t\treturn 'yes, descending'\n\treturn 'no'\n", "def is_descending(arr):\n\tfor i in range(len(arr) - 1):\n\t\tif arr[i + 1] > arr[i]:\n\t\t\treturn False\n\treturn True\n\ndef is_ascending(arr):\n\tfor i in range(len(arr) - 1):\n\t\tif arr[i + 1] < arr[i]:\n\t\t\treturn False\n\treturn True\n\ndef is_sorted_and_how(arr):\n\tif is_ascending(arr):\n\t\treturn 'yes, ascending'\n\tif is_descending(arr):\n\t\treturn 'yes, descending'\n\treturn 'no'\n", "from itertools import islice\nimport operator\n\ndef is_sorted_and_how(arr):\n\treturn 'yes, ascending' if is_sorted_with(arr, operator.le) else 'yes, descending' if is_sorted_with(arr, operator.ge) else 'no'\n\ndef is_sorted_with(arr, pred):\n\treturn all((pred(x, y) for (x, y) in zip(arr, islice(arr, 1, None))))\n", "def sign(x):\n\treturn (x > 0) - (x < 0)\n\ndef is_sorted_and_how(arr):\n\ts = {sign(y - x) for (x, y) in zip(arr, arr[1:])}\n\tif len(s) == 1 or (len(s) == 2 and 0 in s):\n\t\treturn 'yes, %s' % ['descending', 'ascending'][1 in s]\n\treturn 'no'\n", "is_sorted_and_how = lambda a: ['no', 'yes, ascending', 'yes, descending'][(sorted(a) == a) + (sorted(a)[::-1] == a) * 2]\n", "def is_sorted_and_how(arr):\n\t(op, txt) = ((int.__le__, 'yes, ascending'), (int.__ge__, 'yes, descending'))[arr[0] > arr[-1]]\n\treturn all(map(op, arr, arr[1:])) and txt or 'no'\n", "def is_sorted_and_how(nums):\n\ta_or_d = {'a': 'ascending', 'd': 'descending'}\n\tdiffs = {'d' if b - a < 0 else 'a' for (a, b) in zip(nums, nums[1:])}\n\treturn 'yes, {}'.format(a_or_d[diffs.pop()]) if len(diffs) == 1 else 'no'\n", "def is_sorted_and_how(arr):\n\treturn next(('yes, {}cending'.format(k) for (k, v) in {'as': sorted(arr), 'des': sorted(arr, reverse=True)}.items() if v == arr), 'no')\n", "from typing import List\n\ndef is_sorted_and_how(arr: List[int]) -> str:\n\torder = (a > b for (a, b) in zip(arr, arr[1:]) if a != b)\n\tif next(order):\n\t\treturn 'yes, descending' if all(order) else 'no'\n\treturn 'yes, ascending' if not any(order) else 'no'\n", "def is_sorted_and_how(arr):\n\tif all((x > y for (x, y) in zip(arr, arr[1:]))):\n\t\treturn 'yes, descending'\n\telif all((x < y for (x, y) in zip(arr, arr[1:]))):\n\t\treturn 'yes, ascending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tdecend_Counter = 0\n\taccend_Counter = 0\n\tfor i in range(len(arr) - 1):\n\t\tif arr[i] > arr[i + 1]:\n\t\t\tdecend_Counter += 1\n\t\tif arr[i] < arr[i + 1]:\n\t\t\taccend_Counter += 1\n\tif decend_Counter == len(arr) - 1:\n\t\treturn 'yes, descending'\n\telif accend_Counter == len(arr) - 1:\n\t\treturn 'yes, ascending'\n\telse:\n\t\treturn 'no'\n\treturn 1\n", "def is_sorted_and_how(arr):\n\tarrS = sorted(arr)\n\trevArrS = sorted(arr, reverse=True)\n\tif arr == arrS:\n\t\treturn 'yes, ascending'\n\telif arr == revArrS:\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\ta = sorted(arr)\n\td = sorted(arr, reverse=True)\n\treturn 'yes, ascending' if arr == a else 'yes, descending' if arr == d else 'no'\n", "def is_sorted_and_how(a):\n\tif a == sorted(a):\n\t\treturn 'yes, ascending'\n\telif a == sorted(a, reverse=True):\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "from operator import le, ge\n\ndef is_sorted_and_how(arr):\n\tif all(map(le, arr, arr[1:])):\n\t\treturn 'yes, ascending'\n\telif all(map(ge, arr, arr[1:])):\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tsorted_asc = sorted(arr)\n\tsorted_desc = sorted_asc[::-1]\n\treturn 'yes, ascending' if sorted_asc == arr else 'yes, descending' if sorted_desc == arr else 'no'\n", "def is_sorted_and_how(arr):\n\treturn all((arr[i] < arr[i + 1] for i in range(len(arr) - 1))) and 'yes, ascending' or (all((arr[i] > arr[i + 1] for i in range(len(arr) - 1))) and 'yes, descending') or 'no'\n", "def is_sorted_and_how(arr):\n\treturn {('LT',): 'yes, ascending', ('GT',): 'yes, descending'}.get(tuple(set(map(lambda x, y: 'LT' if x <= y else 'GT', arr, arr[1:]))), 'no')\n", "def is_sorted_and_how(arr):\n\tcounts = 0\n\tfor index in range(len(arr) - 1):\n\t\tif arr[index] > arr[index + 1]:\n\t\t\tcounts += 1\n\t\telif arr[index] < arr[index + 1]:\n\t\t\tcounts -= 1\n\tif counts == len(arr) - 1:\n\t\treturn 'yes, descending'\n\telif counts == -len(arr) + 1:\n\t\treturn 'yes, ascending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\treturn ('yes, ascending' if sorted(arr) == arr else 'yes, descending') if sorted(arr) == arr or sorted(arr, reverse=True) == arr else 'no'\n", "def is_sorted_and_how(arr):\n\tcheck = [arr[i - 1] < arr[i] for i in range(1, len(arr))]\n\ttrue = check.count(True)\n\tfalse = check.count(False)\n\tif true == len(arr) - 1 and false == 0:\n\t\treturn 'yes, ascending'\n\telif false == len(arr) - 1 and true == 0:\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\ts = 0\n\tt = 0\n\tfor i in range(0, len(arr) - 1):\n\t\tif arr[i] < arr[i + 1]:\n\t\t\ts += 1\n\t\telif arr[i] > arr[i + 1]:\n\t\t\tt += 1\n\tif t == len(arr) - 1:\n\t\treturn 'yes, descending'\n\telif s == len(arr) - 1:\n\t\treturn 'yes, ascending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tfor i in range(len(arr)):\n\t\tif sorted(arr) == arr:\n\t\t\treturn 'yes, ascending'\n\t\telif sorted(arr, reverse=True) == arr:\n\t\t\treturn 'yes, descending'\n\t\telse:\n\t\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tmonity = arr[1] <= arr[0]\n\tfor index in range(len(arr))[2:]:\n\t\tif (arr[index] <= arr[index - 1]) != monity:\n\t\t\treturn 'no'\n\treturn 'yes, descending' if monity else 'yes, ascending'\n", "def is_sorted_and_how(arr):\n\tif arr == list(sorted(arr)) or arr == list(sorted(arr))[::-1]:\n\t\treturn 'yes, ascending' if arr[0] < arr[1] else 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tif arr[0] < arr[1]:\n\t\tfor i in range(len(arr) - 1):\n\t\t\tif arr[i] > arr[i + 1]:\n\t\t\t\treturn 'no'\n\t\treturn 'yes, ascending'\n\tif arr[0] > arr[1]:\n\t\tfor i in range(len(arr) - 1):\n\t\t\tif arr[i] < arr[i + 1]:\n\t\t\t\treturn 'no'\n\t\treturn 'yes, descending'\n", "def is_sorted_and_how(arr):\n\tasc = False\n\tdesc = False\n\tfor index in range(len(arr)):\n\t\tif index == 0:\n\t\t\tif arr[index + 1] > arr[index]:\n\t\t\t\tasc = True\n\t\t\t\tdesc = False\n\t\t\tif arr[index + 1] < arr[index]:\n\t\t\t\tasc = False\n\t\t\t\tdesc = True\n\t\tif index != 0 and index != len(arr) - 1:\n\t\t\tif arr[index - 1] < arr[index] < arr[index + 1] and asc:\n\t\t\t\tasc = True\n\t\t\t\tdesc = False\n\t\t\telif arr[index - 1] > arr[index] > arr[index + 1] and desc:\n\t\t\t\tasc = False\n\t\t\t\tdesc = True\n\t\t\telse:\n\t\t\t\tasc = False\n\t\t\t\tdesc = False\n\t\tif index == len(arr) - 1:\n\t\t\tif arr[index - 1] < arr[index] and asc:\n\t\t\t\tasc = True\n\t\t\t\tdesc = False\n\t\t\tif arr[index - 1] < arr[index] and desc:\n\t\t\t\tasc = False\n\t\t\t\tdesc = True\n\tif asc:\n\t\treturn 'yes, ascending'\n\tif desc:\n\t\treturn 'yes, descending'\n\tif not asc and (not desc):\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tasc = sorted(arr)\n\tdes = sorted(arr, reverse=True)\n\tif arr == asc:\n\t\treturn 'yes, ascending'\n\telif arr == des:\n\t\treturn 'yes, descending'\n\telif arr != (asc or des):\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tdelta_value = []\n\tpositive_num = 0\n\tnegtive_num = 0\n\tfor i in range(len(arr) - 1):\n\t\tdelta_value.append(arr[i + 1] - arr[i])\n\tfor i in range(len(delta_value)):\n\t\tif delta_value[i] >= 0:\n\t\t\tpositive_num += 1\n\t\telse:\n\t\t\tnegtive_num += 1\n\tif positive_num == len(delta_value):\n\t\treturn 'yes, ascending'\n\telif negtive_num == len(delta_value):\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tsort = 'descending' if arr[0] > arr[-1] else 'ascending'\n\treturn 'yes, {}'.format(sort) if sort == 'ascending' and sorted(arr) == arr or (sort == 'descending' and sorted(arr, reverse=True) == arr) else 'no'\n", "def is_sorted_and_how(arr):\n\tif arr == sorted(arr):\n\t\treturn 'yes, ascending'\n\telif arr == sorted(arr, key=None, reverse=True):\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tlist_a = []\n\tlist_d = []\n\tlist_a = sorted(arr)\n\tfor i in list_a[::-1]:\n\t\tlist_d.append(i)\n\tif arr == list_a:\n\t\treturn 'yes, ascending'\n\tif arr == list_d:\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\ttype_arr = set()\n\tprev = arr[0]\n\tfor item in arr[1:]:\n\t\tif item > prev:\n\t\t\ttype_arr.add('asc')\n\t\telif item < prev:\n\t\t\ttype_arr.add('desc')\n\t\tprev = item\n\tif len(type_arr) != 1:\n\t\treturn 'no'\n\tresult = type_arr.pop()\n\treturn 'yes, ascending' if result == 'asc' else 'yes, descending'\n", "def is_sorted_and_how(arr):\n\tsort_arr = sorted(arr)\n\tsort_desc = sorted(arr, reverse=True)\n\tif sort_arr == arr:\n\t\treturn 'yes, ascending'\n\tif sort_desc == arr:\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tc = 0\n\ta = 0\n\tfor i in range(len(arr) - 1):\n\t\tif arr[i] <= arr[i + 1]:\n\t\t\tc += 1\n\t\t\tif c == len(arr) - 1:\n\t\t\t\treturn 'yes, ascending'\n\t\telif arr[i] >= arr[i + 1]:\n\t\t\ta += 1\n\t\t\tif a == len(arr) - 1:\n\t\t\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tif arr[0] < arr[1]:\n\t\treturn 'yes, ascending'\n\telif arr[0] > arr[1] and arr[0] > arr[2]:\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\tasc = True\n\tdesc = True\n\tfor i in range(1, len(arr)):\n\t\tif arr[i - 1] == arr[i]:\n\t\t\treturn 'no'\n\t\tif arr[i - 1] < arr[i]:\n\t\t\tdesc = False\n\t\telse:\n\t\t\tasc = False\n\t\tif not asc and (not desc):\n\t\t\treturn 'no'\n\treturn 'yes, ascending' if asc else 'yes, descending'\n", "def is_sorted_and_how(arr):\n\tisAllNeg = True\n\tisAllPos = True\n\tfor i in range(len(arr) - 1):\n\t\tisAllPos = isAllPos and arr[i + 1] - arr[i] > 0\n\t\tisAllNeg = isAllNeg and arr[i + 1] - arr[i] < 0\n\tif isAllPos:\n\t\treturn 'yes, ascending'\n\telif isAllNeg:\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\t(k, c) = (0, 0)\n\tfor i in range(1, len(arr)):\n\t\tif arr[i] > arr[i - 1]:\n\t\t\tk += 1\n\t\telse:\n\t\t\tc += 1\n\tif k > 0 or c > 0:\n\t\tif k > 0 and c == 0:\n\t\t\treturn 'yes, ascending'\n\t\telif c > 0 and k == 0:\n\t\t\treturn 'yes, descending'\n\treturn 'no'\n", "def is_sorted_and_how(list):\n\tif list == sorted(list):\n\t\treturn 'yes, ascending'\n\tif list == sorted(list, reverse=True):\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n", "def is_sorted_and_how(arr):\n\torder = 0\n\ti = 0\n\tfor num in arr:\n\t\thold = arr[i]\n\t\tif i + 1 < len(arr):\n\t\t\tif hold <= arr[i + 1]:\n\t\t\t\torder += 1\n\t\t\tif hold >= arr[i + 1]:\n\t\t\t\torder -= 1\n\t\ti += 1\n\tif order == len(arr) - 1:\n\t\treturn 'yes, ascending'\n\tif order * -1 == len(arr) - 1:\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n"], "40": ["from itertools import permutations\n\ndef find_mult_3(num):\n\tnum_list = tuple(map(int, str(num)))\n\tposs = set()\n\tfor i in range(1, len(num_list) + 1):\n\t\tposs |= set(permutations(num_list, i))\n\tres = set()\n\tfor p in poss:\n\t\tif p[0] != 0 and sum(p) % 3 == 0:\n\t\t\tres.add(p)\n\tres = [sum((x * 10 ** n for (n, x) in enumerate(p[::-1]))) for p in res]\n\treturn [len(res), max(res)]\n", "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom math import factorial\nfrom operator import mul\n\ndef find_mult_3(n):\n\t(mul_count, digits) = (0, sorted(map(int, str(n))))\n\tfor r in range(1, len(digits) + 1):\n\t\tfor comb in sorted({c for c in combinations(digits, r) if not sum(c) % 3}):\n\t\t\tdig_count = Counter(comb)\n\t\t\tmul_count += (r - dig_count.get(0, 0)) * factorial(r) // reduce(mul, map(factorial, dig_count.values()), r)\n\treturn [mul_count, int(''.join(map(str, comb[::-1])))]\n", "from itertools import permutations\n\ndef find_mult_3(num):\n\tls = []\n\tfor i in range(1, len(str(num)) + 1):\n\t\tfor j in set(permutations(str(num), i)):\n\t\t\tls.append(int(''.join(j)))\n\tls = set(ls)\n\tsolve = [x for x in ls if x != 0 and x % 3 == 0]\n\treturn [len(solve), max(solve)]\n", "from itertools import combinations, permutations\n\ndef find_mult_3(num):\n\tn = [int(c) for c in str(num)]\n\tr = set()\n\tfor i in range(1, len(n) + 1):\n\t\tfor c in combinations(n, i):\n\t\t\tif sum(c) % 3 == 0:\n\t\t\t\tr |= set([int(''.join([str(i) for i in p])) for p in permutations(c) if p[0] != 0])\n\treturn [len(r), max(r)]\n", "from itertools import permutations\n\ndef find_mult_3(s):\n\tx = []\n\tfor i in range(1, len(str(s)) + 1):\n\t\tx += [int(''.join(p)) for p in list(set(permutations(str(s), i))) if not int(''.join(p)) % 3 and p[0] != '0']\n\treturn [len(x), max(x)]\n", "from itertools import permutations\n\ndef find_mult_3(num):\n\tst = str(num)\n\tval = [int(''.join(i)) for j in range(1, len(st) + 1) for i in set(permutations(st, j)) if int(''.join(i)) > 0 and int(''.join(i)) % 3 == 0]\n\treturn [len(set(val)), max(val)]\n", "import itertools\n\ndef find_mult_3(num):\n\ttotal = 0\n\t_max = float('-inf')\n\tfor lst in get_combos(num):\n\t\tfor i in lst:\n\t\t\tif i[0] != '0':\n\t\t\t\tnumber = int(''.join(i))\n\t\t\t\tif number % 3 == 0:\n\t\t\t\t\ttotal += 1\n\t\t\t\t\tif number > _max:\n\t\t\t\t\t\t_max = number\n\treturn [total, _max]\n\ndef get_combos(num):\n\treturn [set(itertools.permutations(str(num), i)) for i in range(1, len(str(num)) + 1)]\n", "from functools import reduce\n\ndef num_to_arr(num):\n\ts = str(num)\n\tarr = [0] * 10\n\tfor c in s:\n\t\tarr[int(c)] += 1\n\treturn arr\n\ndef dist_digits(arr):\n\tdist = []\n\tfor i in range(0, 10):\n\t\tif arr[i] > 0:\n\t\t\tdist.append(i)\n\treturn dist\n\ndef all_combos(arr, m):\n\tcombos = []\n\tif m == 1:\n\t\tfor i in range(1, 10):\n\t\t\tif arr[i] > 0:\n\t\t\t\tcombos.append([i])\n\t\treturn combos\n\tif m > sum(arr):\n\t\treturn []\n\tdigits = dist_digits(arr)\n\tfor d in digits:\n\t\tnextArr = [0] * 10\n\t\tfor i in range(0, 10):\n\t\t\tif i == d:\n\t\t\t\tnextArr[i] = arr[i] - 1\n\t\t\tif i > d:\n\t\t\t\tnextArr[i] = arr[i]\n\t\tnextCombos = all_combos(nextArr, m - 1)\n\t\tfor nextComb in nextCombos:\n\t\t\tnextComb.append(d)\n\t\tcombos.extend(nextCombos)\n\treturn combos\n\ndef complete_combos(arr):\n\tcombos = []\n\tfor i in range(1, len(arr)):\n\t\tcombos.extend(all_combos(arr, i))\n\treturn list([arr for arr in combos if sum(arr) % 3 == 0])\n\ndef fact(n, zeros=0):\n\tif n == 0:\n\t\treturn 1\n\tif n == 1:\n\t\treturn 1\n\treturn (n - zeros) * fact(n - 1)\n\ndef permus(combo):\n\tarr = [0] * 10\n\tfor digit in combo:\n\t\tarr[digit] += 1\n\tduplicates = 1\n\tfor i in range(0, 10):\n\t\tif arr[i] > 1:\n\t\t\tduplicates *= fact(arr[i])\n\treturn fact(len(combo), zeros=arr[0]) // duplicates\n\ndef find_mult_3(num):\n\tcomp_combos = complete_combos(num_to_arr(num))\n\treturn [sum(map(permus, comp_combos)), reduce(lambda x, y: x * 10 + y, comp_combos[-1])]\n"], "46": ["import sys\nfrom collections import deque\n\ndef solve():\n\tsys.setrecursionlimit(10 ** 6)\n\treadline = sys.stdin.readline\n\twritelines = sys.stdout.writelines\n\tN = int(readline())\n\tG = [[] for i in range(N)]\n\tfor i in range(N - 1):\n\t\t(u, v) = map(int, readline().split())\n\t\tG[u - 1].append(v - 1)\n\t\tG[v - 1].append(u - 1)\n\tS = []\n\tFS = [0] * N\n\tLS = [0] * N\n\tdepth = [0] * N\n\tstk = [-1, 0]\n\tit = [0] * N\n\twhile len(stk) > 1:\n\t\tv = stk[-1]\n\t\ti = it[v]\n\t\tif i == 0:\n\t\t\tFS[v] = len(S)\n\t\t\tdepth[v] = len(stk)\n\t\tif i < len(G[v]) and G[v][i] == stk[-2]:\n\t\t\tit[v] += 1\n\t\t\ti += 1\n\t\tif i == len(G[v]):\n\t\t\tLS[v] = len(S)\n\t\t\tstk.pop()\n\t\telse:\n\t\t\tstk.append(G[v][i])\n\t\t\tit[v] += 1\n\t\tS.append(v)\n\tL = len(S)\n\tlg = [0] * (L + 1)\n\tfor i in range(2, L + 1):\n\t\tlg[i] = lg[i >> 1] + 1\n\tst = [[L] * (L - (1 << i) + 1) for i in range(lg[L] + 1)]\n\tst[0][:] = S\n\tb = 1\n\tfor i in range(lg[L]):\n\t\tst0 = st[i]\n\t\tst1 = st[i + 1]\n\t\tfor j in range(L - (b << 1) + 1):\n\t\t\tst1[j] = st0[j] if depth[st0[j]] <= depth[st0[j + b]] else st0[j + b]\n\t\tb <<= 1\n\tINF = 10 ** 18\n\tans = []\n\tQ = int(readline())\n\tG0 = [[]] * N\n\tP = [0] * N\n\tdeg = [0] * N\n\tKS = [0] * N\n\tA = [0] * N\n\tB = [0] * N\n\tfor t in range(Q):\n\t\t(k, *vs) = map(int, readline().split())\n\t\tfor i in range(k):\n\t\t\tvs[i] -= 1\n\t\t\tKS[vs[i]] = 1\n\t\tvs.sort(key=FS.__getitem__)\n\t\tfor i in range(k - 1):\n\t\t\tx = FS[vs[i]]\n\t\t\ty = FS[vs[i + 1]]\n\t\t\tl = lg[y - x + 1]\n\t\t\tw = st[l][x] if depth[st[l][x]] <= depth[st[l][y - (1 << l) + 1]] else st[l][y - (1 << l) + 1]\n\t\t\tvs.append(w)\n\t\tvs.sort(key=FS.__getitem__)\n\t\tstk = []\n\t\tprv = -1\n\t\tfor v in vs:\n\t\t\tif v == prv:\n\t\t\t\tcontinue\n\t\t\twhile stk and LS[stk[-1]] < FS[v]:\n\t\t\t\tstk.pop()\n\t\t\tif stk:\n\t\t\t\tG0[stk[-1]].append(v)\n\t\t\tG0[v] = []\n\t\t\tit[v] = 0\n\t\t\tstk.append(v)\n\t\t\tprv = v\n\t\tque = deque()\n\t\tprv = -1\n\t\tP[vs[0]] = -1\n\t\tfor v in vs:\n\t\t\tif v == prv:\n\t\t\t\tcontinue\n\t\t\tfor w in G0[v]:\n\t\t\t\tP[w] = v\n\t\t\tdeg[v] = len(G0[v])\n\t\t\tif deg[v] == 0:\n\t\t\t\tque.append(v)\n\t\t\tprv = v\n\t\twhile que:\n\t\t\tv = que.popleft()\n\t\t\tif KS[v]:\n\t\t\t\ta = 0\n\t\t\t\tfor w in G0[v]:\n\t\t\t\t\tra = A[w]\n\t\t\t\t\trb = B[w]\n\t\t\t\t\tif depth[v] + 1 < depth[w]:\n\t\t\t\t\t\ta += min(ra, rb + 1)\n\t\t\t\t\telse:\n\t\t\t\t\t\ta += ra\n\t\t\t\tA[v] = INF\n\t\t\t\tB[v] = a\n\t\t\telse:\n\t\t\t\ta = 0\n\t\t\t\tb = c = INF\n\t\t\t\tfor w in G0[v]:\n\t\t\t\t\tra = A[w]\n\t\t\t\t\trb = B[w]\n\t\t\t\t\t(a, b, c) = (a + ra, min(a + rb, b + ra), min(b + rb, c + min(ra, rb)))\n\t\t\t\tA[v] = min(a, b + 1, c + 1)\n\t\t\t\tB[v] = b\n\t\t\tp = P[v]\n\t\t\tif p != -1:\n\t\t\t\tdeg[p] -= 1\n\t\t\t\tif deg[p] == 0:\n\t\t\t\t\tque.append(p)\n\t\tv = min(A[vs[0]], B[vs[0]])\n\t\tif v >= INF:\n\t\t\tans.append('-1\\n')\n\t\telse:\n\t\t\tans.append('%d\\n' % v)\n\t\tfor v in vs:\n\t\t\tKS[v] = 0\n\twritelines(ans)\nsolve()\n"], "76": ["def subsets(collection):\n\tif len(collection) == 1:\n\t\tyield [collection]\n\t\treturn\n\tfirst = collection[0]\n\tfor smaller in subsets(collection[1:]):\n\t\tyield ([first] + smaller)\n\t\tfor (n, subset) in enumerate(smaller):\n\t\t\tyield (smaller[:n] + [first + subset] + smaller[n + 1:])\n\ndef bucket_digit_distributions_total_sum(n):\n\treturn sum((sum(map(int, sub)) for sub in subsets(str(n)))) - n\n\ndef find(n, z):\n\tf_nf = bucket_digit_distributions_total_sum(n) + z\n\twhile 1:\n\t\tn += 1\n\t\tif bucket_digit_distributions_total_sum(n) > f_nf:\n\t\t\treturn n\n", "from functools import reduce\nfrom itertools import count\ncoefs = [[22, 13, 4], [365, 167, 50, 14], [5415, 2130, 627, 177, 51], [75802, 27067, 7897, 2254, 661, 202], [1025823, 343605, 100002, 28929, 8643, 2694, 876]]\n\ndef f(n):\n\treturn sum((c * int(d) for (c, d) in zip(coefs[len(str(n)) - 3], str(n))))\n\ndef find(n, z):\n\tt = f(n) + z\n\tfor nf in count(n):\n\t\tif f(nf) > t:\n\t\t\treturn nf\n", "from itertools import count\n\ndef rec(n):\n\tif not n:\n\t\tyield 0\n\t\treturn\n\tfor i in range(1 << len(n) - 1):\n\t\ttmp = [[], []]\n\t\tfor t in n:\n\t\t\t(i, r) = divmod(i, 2)\n\t\t\ttmp[r].append(t)\n\t\t(x, y) = (int(''.join(tmp[0])), tmp[1])\n\t\tfor k in rec(y):\n\t\t\tyield (x + k)\nval = lambda n: sum(rec(str(n))) - n\n\ndef find(n, z):\n\tz += val(n)\n\treturn next((i for i in count(n + 1) if val(i) > z))\n", "def find(n, z):\n\tr = n + 1\n\tsumn = sumof(n)\n\twhile True:\n\t\tif sumof(r) > sumn + z:\n\t\t\treturn r\n\t\tr += 1\n\treturn 'Perhaps this is a different way to solve the kata, but it works ;-)(not cheat)'\n\ndef sumof(n):\n\tfm = [[], [], [], [22, 13, 4], [365, 167, 50, 14], [5415, 2130, 627, 177, 51], [75802, 27067, 7897, 2254, 661, 202], [123456, 123456, 123456, 123456, 123456, 123456, 123456]]\n\tl = 1 if n < 10 else 2 if n < 100 else 3 if n < 1000 else 4 if n < 10000 else 5 if n < 100000 else 6 if n < 1000000 else 7\n\t(a, i, r) = (fm[l], l - 1, 0)\n\twhile n > 0:\n\t\tt = n % 10\n\t\tn //= 10\n\t\tr += t * a[i]\n\t\ti -= 1\n\treturn r\n", "def partition(collection):\n\tif len(collection) == 1:\n\t\tyield [collection]\n\t\treturn\n\tfirst = collection[0]\n\tfor smaller in partition(collection[1:]):\n\t\tfor (n, subset) in enumerate(smaller):\n\t\t\tyield (smaller[:n] + [[first] + subset] + smaller[n + 1:])\n\t\tyield ([[first]] + smaller)\n\ndef part_sum(part_list):\n\ttot_sum = 0\n\tfor elem in part_list:\n\t\ttot_sum += sum((int(''.join(x)) for x in elem))\n\treturn tot_sum\n\ndef find(n, z):\n\tmin_sum = part_sum([x for x in partition(list(str(n)))][1:]) + z\n\ti = 1\n\tnf_sum = part_sum([x for x in partition(list(str(n + i)))][1:])\n\twhile nf_sum <= min_sum:\n\t\ti += 1\n\t\tnf_sum = part_sum([x for x in partition(list(str(n + i)))][1:])\n\treturn n + i\n", "def find(n, z):\n\tlim = bucket_digit_distributions_total_sum(n) + z\n\tnum = n\n\twhile True:\n\t\tnum += 1\n\t\tres = bucket_digit_distributions_total_sum(num)\n\t\tif lim < res:\n\t\t\treturn num\n\treturn num\n\ndef bucket_digit_distributions_total_sum(n):\n\tparts = get_partitions(list(str(n)), len(str(n)))\n\tbuckets_sum = 0\n\tfor p in parts:\n\t\tif len(p) > 1:\n\t\t\tb = [int(''.join(l)) for l in p]\n\t\t\tbuckets_sum += sum(b)\n\treturn buckets_sum\n\ndef get_partitions(lst, n):\n\tif n <= 0:\n\t\tyield []\n\t\treturn\n\telse:\n\t\tcurr = lst[n - 1]\n\t\tfor part in get_partitions(lst, n - 1):\n\t\t\tfor l in list(part):\n\t\t\t\tl.append(curr)\n\t\t\t\tyield part\n\t\t\t\tl.pop()\n\t\t\tyield (part + [[curr]])\n", "def get_partitionr(ss):\n\tout = []\n\tif len(ss) <= 1:\n\t\treturn [ss]\n\tfor i in range(2 ** len(ss) // 2):\n\t\tparts = [[], []]\n\t\tfor item in ss:\n\t\t\tparts[i & 1].append(item)\n\t\t\ti >>= 1\n\t\tbb = get_partitionr(parts[1])\n\t\tfor b in bb:\n\t\t\tout.append([parts[0]] + b)\n\treturn out\n\ndef add(parts):\n\ttotal = 0\n\tfor part in parts:\n\t\ttotal += sum((int(''.join(p)) if isinstance(p, list) else int(p) for p in part))\n\treturn total\n\ndef find(n, z):\n\tparts = get_partitionr(list(str(n)))[1:]\n\tadd_parts = add(parts)\n\ttarget = add_parts + z\n\twhile add_parts <= target:\n\t\tn += 1\n\t\tparts = get_partitionr(list(str(n)))[1:]\n\t\tadd_parts = add(parts)\n\treturn n\n", "import itertools\n\ndef find(n, z):\n\tfind.combination_dict = {0: ((),), 1: (((0,),),)}\n\n\tdef get_combination(length):\n\t\tif length not in find.combination_dict:\n\t\t\tfor i in range(length):\n\t\t\t\tget_combination(i)\n\t\t\ttemplate = list(range(length))\n\t\t\tresult = [{tuple((i for i in template))}]\n\t\t\tfor init_tuple_length in range(1, length):\n\t\t\t\tfor c in itertools.combinations(template, init_tuple_length):\n\t\t\t\t\tremain = [i for i in template if i not in c]\n\t\t\t\t\tfor combinations in find.combination_dict[length - init_tuple_length]:\n\t\t\t\t\t\tnew_combination = [tuple(c)]\n\t\t\t\t\t\tfor combination in combinations:\n\t\t\t\t\t\t\tnew_combination.append(tuple((remain[index] for index in combination)))\n\t\t\t\t\t\tif set(new_combination) not in result:\n\t\t\t\t\t\t\tresult.append(set(new_combination))\n\t\t\tfind.combination_dict[length] = tuple((tuple(i) for i in result))\n\t\treturn find.combination_dict[length]\n\n\tdef f(num):\n\t\tnum = str(num)\n\t\tvalue = []\n\t\tfor combinations in get_combination(len(num)):\n\t\t\tif len(combinations) != 1:\n\t\t\t\tfor combination in combinations:\n\t\t\t\t\tvalue.append(''.join((num[i] for i in combination)))\n\t\treturn sum(map(int, value))\n\tlimit = f(n) + z\n\tfor nf in itertools.count(n):\n\t\tif f(nf) > limit:\n\t\t\treturn nf\n"], "79": ["def mix(s1, s2):\n\thist = {}\n\tfor ch in 'abcdefghijklmnopqrstuvwxyz':\n\t\t(val1, val2) = (s1.count(ch), s2.count(ch))\n\t\tif max(val1, val2) > 1:\n\t\t\twhich = '1' if val1 > val2 else '2' if val2 > val1 else '='\n\t\t\thist[ch] = (-max(val1, val2), which + ':' + ch * max(val1, val2))\n\treturn '/'.join((hist[ch][1] for ch in sorted(hist, key=lambda x: hist[x])))\n", "def mix(s1, s2):\n\tc1 = {l: s1.count(l) for l in s1 if l.islower() and s1.count(l) > 1}\n\tc2 = {l: s2.count(l) for l in s2 if l.islower() and s2.count(l) > 1}\n\tr = []\n\tfor c in set(list(c1.keys()) + list(c2.keys())):\n\t\t(n1, n2) = (c1.get(c, 0), c2.get(c, 0))\n\t\tr.append(('1', c, n1) if n1 > n2 else ('2', c, n2) if n2 > n1 else ('=', c, n1))\n\trs = ['{}:{}'.format(i, c * n) for (i, c, n) in r]\n\treturn '/'.join(sorted(rs, key=lambda s: (-len(s), s)))\n", "def mix(s1, s2):\n\ts = []\n\tlett = 'abcdefghijklmnopqrstuvwxyz'\n\tfor ch in lett:\n\t\t(val1, val2) = (s1.count(ch), s2.count(ch))\n\t\tif max(val1, val2) >= 2:\n\t\t\tif val1 > val2:\n\t\t\t\ts.append('1:' + val1 * ch)\n\t\t\telif val1 < val2:\n\t\t\t\ts.append('2:' + val2 * ch)\n\t\t\telse:\n\t\t\t\ts.append('=:' + val1 * ch)\n\ts.sort()\n\ts.sort(key=len, reverse=True)\n\treturn '/'.join(s)\n", "from collections import Counter\n\ndef mix(s1, s2):\n\tres = []\n\tc1 = Counter([c for c in s1 if c.islower()])\n\tc2 = Counter([c for c in s2 if c.islower()])\n\tfor c in c1 | c2:\n\t\tif c1[c] > 1 and c1[c] > c2[c]:\n\t\t\tres += ['1:' + c * c1[c]]\n\t\tif c2[c] > 1 and c2[c] > c1[c]:\n\t\t\tres += ['2:' + c * c2[c]]\n\t\tif c1[c] > 1 and c1[c] == c2[c]:\n\t\t\tres += ['=:' + c * c1[c]]\n\treturn '/'.join(sorted(res, key=lambda a: [-len(a), a]))\n", "def filter_lowercase(character_in_s):\n\tlowercase_alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n\tif character_in_s in lowercase_alphabet:\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef sort_mix(a):\n\treturn len(a)\n\ndef order_alphabetically_ascendent(elem):\n\tif elem[:1] == '=':\n\t\treturn 2\n\telif elem[:1] == '1':\n\t\treturn 0\n\telif elem[:1] == '2':\n\t\treturn 1\n\ndef mix(s1, s2):\n\tlowercase_alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n\tcharacters_in_s1 = []\n\tcharacters_in_s2 = []\n\tamount_of_each_letter_in_s1 = []\n\tamount_of_each_letter_in_s2 = []\n\twhere_is_maximum = []\n\tmaximum = []\n\tletters_used_with_prefix = []\n\tstring_to_return = ''\n\tdifferent_lengths = []\n\tarray_of_letters_with_the_same_length = []\n\tfor character in s1:\n\t\tcharacters_in_s1.append(character)\n\tfor character in s2:\n\t\tcharacters_in_s2.append(character)\n\tlowercase_letters_in_s1 = list(filter(filter_lowercase, characters_in_s1))\n\tlowercase_letters_in_s2 = list(filter(filter_lowercase, characters_in_s2))\n\tfor alphabet_letter in lowercase_alphabet:\n\t\tlowercase_letters_in_s = []\n\t\ti = len(amount_of_each_letter_in_s1)\n\t\tstring_to_append = ''\n\t\tamount_of_each_letter_in_s1.append(lowercase_letters_in_s1.count(alphabet_letter))\n\t\tlowercase_letters_in_s.append(lowercase_letters_in_s1.count(alphabet_letter))\n\t\tamount_of_each_letter_in_s2.append(lowercase_letters_in_s2.count(alphabet_letter))\n\t\tlowercase_letters_in_s.append(lowercase_letters_in_s2.count(alphabet_letter))\n\t\tmaximum.append(max(lowercase_letters_in_s))\n\t\tif lowercase_letters_in_s2.count(alphabet_letter) == lowercase_letters_in_s1.count(alphabet_letter):\n\t\t\twhere_is_maximum.append('b')\n\t\telif lowercase_letters_in_s1.count(alphabet_letter) > lowercase_letters_in_s2.count(alphabet_letter):\n\t\t\twhere_is_maximum.append('1')\n\t\telif lowercase_letters_in_s2.count(alphabet_letter) > lowercase_letters_in_s1.count(alphabet_letter):\n\t\t\twhere_is_maximum.append('2')\n\t\tif maximum[i] > 1:\n\t\t\tif where_is_maximum[i] == 'b':\n\t\t\t\tstring_to_append = '=:' + lowercase_alphabet[i] * maximum[i]\n\t\t\telif where_is_maximum[i] != 'b':\n\t\t\t\tstring_to_append += str(where_is_maximum[i]) + ':' + lowercase_alphabet[i] * maximum[i]\n\t\t\tletters_used_with_prefix.append(string_to_append)\n\tletters_used_with_prefix = sorted(letters_used_with_prefix, key=lambda conjunto: len(conjunto), reverse=True)\n\tfor string in letters_used_with_prefix:\n\t\tif len(string) not in different_lengths:\n\t\t\tdifferent_lengths.append(len(string))\n\tlength = len(different_lengths)\n\twhile length > 0:\n\t\tletters_with_the_same_length = []\n\t\tfor letter_used_with_prefix in letters_used_with_prefix:\n\t\t\tif len(letter_used_with_prefix) == different_lengths[length - 1]:\n\t\t\t\tletters_with_the_same_length.append(letter_used_with_prefix)\n\t\tletters_with_the_same_length = sorted(letters_with_the_same_length, key=order_alphabetically_ascendent)\n\t\tarray_of_letters_with_the_same_length.append(letters_with_the_same_length)\n\t\tlength = length - 1\n\tarray_of_letters_with_the_same_length.reverse()\n\tfor subarray in array_of_letters_with_the_same_length:\n\t\tfor item in subarray:\n\t\t\tstring_to_return += item + '/'\n\tstring_to_return = string_to_return[:-1]\n\treturn string_to_return\n"], "124": ["from math import ceil\n\ndef branch(n):\n\tif n == 1:\n\t\treturn 0\n\tl = int(ceil(n ** 0.5)) // 2\n\tn -= (2 * l - 1) ** 2 + 1\n\treturn n // (2 * l or 1)\n", "branch = lambda n: (lambda r: r and (n - 2) // r + 2 - r)(0 - (1 - n ** 0.5) // 2 * 2)\n", "branch = lambda n: 0 if n == 1 else (lambda s: (n - s * s - 1) // (s + 1))(((n - 1) ** 0.5 - 1) // 2 * 2 + 1)\n", "def branch(n):\n\tif n == 1:\n\t\treturn 0\n\ti = 1\n\twhile True:\n\t\tif n <= (2 * i - 1) ** 2:\n\t\t\tbreak\n\t\ti += 1\n\treturn int((n - (2 * i - 3) ** 2 - 1) / (2 * i - 2))\n", "(k, li) = (1, [0])\nfor i in range(1, 1000000):\n\tli.append(k)\n\tk += 8 * i\n\ndef branch(n):\n\t(a, b) = next(([i, li[i - 1] + 1] for (i, j) in enumerate(li) if j >= n))\n\tstep = a * 2 - 2\n\tfor i in range(4):\n\t\tif b <= n < b + step:\n\t\t\treturn i\n\t\tb += step\n\treturn 0\n", "def branch(n):\n\tif n == 1:\n\t\treturn 0\n\tl = (1 + int((n - 1 + 0.5) ** 0.5)) // 2\n\tx = (2 * l - 1) ** 2 + 1\n\treturn (n - x) // (l * 2)\n", "import math\n\ndef branch(n):\n\tl = (math.sqrt(n) + 1) // 2\n\td = n - (2 * l - 1) ** 2\n\tif d == 0:\n\t\tif l == 1:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn 3\n\telse:\n\t\treturn int((d - 1) / (2 * l))\n", "from math import ceil\n\ndef branch(n):\n\tk = ceil(n ** 0.5) // 2\n\tlst = list(range((2 * k - 1) ** 2 + 1, (2 * k + 1) ** 2 + 1)) or [1]\n\treturn lst.index(n) // (len(lst) / 4)\n", "memo = [[0, 0, 0, 0], [1, 1, 1, 1]]\nfor i in range(3, 1000000, 2):\n\tmemo.append([j for j in range(i ** 2, i ** 2 - (i - 1) * 3 - 1, -i + 1)][::-1])\n\ndef branch(n):\n\tlayer = int((1 + (n - 1) ** 0.5) // 2 + 1)\n\tfor (branch, coner_number) in enumerate(memo[layer]):\n\t\tif n <= coner_number:\n\t\t\treturn branch\n", "from math import sqrt, ceil\n\ndef branch(n):\n\tif n == 1:\n\t\treturn 0\n\tx = ceil(sqrt(n)) // 2 * 2\n\treturn (n - 1 - (x - 1) ** 2) // x\n"], "132": ["BINGO = {ord(c) - 64 for c in 'BINGO'}\n\ndef bingo(lst):\n\treturn 'WIN' if set(lst) >= BINGO else 'LOSE'\n", "def bingo(array):\n\treturn 'WIN' if all((i in array for i in [2, 9, 14, 7, 15])) else 'LOSE'\n", "def bingo(array):\n\tctr = 0\n\tfor i in [2, 9, 14, 7, 15]:\n\t\tif i in list(set(array)):\n\t\t\tctr += 1\n\tif ctr == 5:\n\t\treturn 'WIN'\n\telse:\n\t\treturn 'LOSE'\n\tpass\n", "def bingo(array):\n\treturn 'WIN' if {2, 7, 9, 14, 15}.issubset(set(array)) else 'LOSE'\n", "def bingo(array):\n\treturn ['LOSE', 'WIN'][{2, 7, 9, 14, 15} <= set(array)]\n", "def bingo(array):\n\treturn 'LOSE' if set('bingo') - set((chr(i + 96) for i in array)) else 'WIN'\n", "def bingo(a):\n\treturn 'WIN' if all([x in a for x in [2, 7, 9, 14, 15]]) else 'LOSE'\n", "def bingo(array):\n\ta = set()\n\tfor x in array:\n\t\tif x == 2 or x == 9 or x == 14 or (x == 7) or (x == 15):\n\t\t\ta.add(x)\n\treturn 'WIN' if len(a) >= 5 else 'LOSE'\n", "def bingo(a):\n\treturn 'LWOISNE'[{2, 7, 9, 14, 15} <= set(a)::2]\n"], "191": ["def vector_length(vector):\n\t((x1, y1), (x2, y2)) = vector\n\treturn ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n", "import math\n\ndef vector_length(vector):\n\treturn math.hypot(vector[0][0] - vector[1][0], vector[0][1] - vector[1][1])\n", "import math\n\ndef vector_length(v):\n\treturn math.sqrt(math.pow(v[0][0] - v[1][0], 2) + math.pow(v[0][1] - v[1][1], 2))\n", "from math import sqrt\n\ndef vector_length(v):\n\treturn sqrt((v[1][0] - v[0][0]) ** 2 + (v[0][1] - v[1][1]) ** 2)\n", "def vector_length(vector):\n\treturn sum(((a - b) ** 2 for (a, b) in zip(*vector))) ** 0.5\n", "import numpy as np\n\ndef vector_length(vector):\n\t(P1, P2) = map(np.array, vector)\n\treturn np.linalg.norm(P1 - P2)\n", "from math import hypot\n\ndef vector_length(a):\n\treturn hypot(a[0][0] - a[1][0], a[0][1] - a[1][1])\n"], "212": ["from functools import reduce\n\ndef get_chance(n, x, a):\n\treturn round(reduce(lambda m, b: m * (1 - x / (n - b)), range(a), 1), 2)\n", "def get_chance(n, x, a):\n\tr = 1\n\tz = n - x\n\twhile a > 0:\n\t\tr *= z / n\n\t\tn -= 1\n\t\tz -= 1\n\t\ta -= 1\n\treturn round(r, 2)\n", "def get_chance(shots, laxatives, drinks):\n\tproba = 1\n\tfor i in range(drinks):\n\t\tproba *= 1 - laxatives / shots\n\t\tshots -= 1\n\treturn round(proba, 2)\n", "from operator import mul\nfrom functools import reduce\n\ndef get_chance(n, x, a):\n\treturn round(reduce(mul, ((n - i - x) / (n - i) for i in range(a))), 2)\n", "import numpy as np\n\ndef get_chance(n, x, a):\n\tns = np.arange(n, n - a, -1)\n\treturn np.multiply.reduce((ns - x) / ns).round(2)\n", "def get_chance(n, x, a):\n\tp = 1\n\tfor i in range(a):\n\t\tp = p * (n - x - i) / (n - i)\n\treturn float('{:.2f}'.format(p) if p < 1 else 0.0)\n", "from functools import reduce\n\ndef get_chance(n, x, a):\n\treturn round(reduce(lambda x, y: x * y, ((n - x - i) / (n - i) for i in range(a))), 2)\n", "def get_chance(n, x, a):\n\tprob = 1\n\twhile a:\n\t\tprob *= (n - x) / n\n\t\tn -= 1\n\t\ta -= 1\n\treturn round(prob, 2)\n", "def get_chance(n, x, a):\n\toutput = 1\n\tfor i in range(0, a):\n\t\tif n - i == x:\n\t\t\treturn 0\n\t\toutput *= (n - x - i) / (n - i)\n\treturn round(output, 2)\n", "def get_chance(n, x, a):\n\tc = 0\n\tr = n - x\n\tp = 1\n\twhile c < a:\n\t\tb = r / n\n\t\tp = p * b\n\t\tr = r - 1\n\t\tn = n - 1\n\t\tc = c + 1\n\treturn round(p, 2)\n"], "218": ["def reg_sum_hits(dices, sides=6):\n\t(d, s) = (sides * [1], sides - 1)\n\tfor i in range(dices - 1):\n\t\tt = s * [0] + d + s * [0]\n\t\td = [sum(t[i:i + sides]) for i in range(len(t) - s)]\n\treturn [[i + dices, prob] for (i, prob) in enumerate(d)]\n", "reg_sum_hits = lambda n, s: sorted(map(list, __import__('collections').Counter(map(sum, __import__('itertools').product(range(1, s + 1), repeat=n))).items()))\n", "def reg_sum_hits(n, s):\n\tfaces = list(range(1, s + 1))\n\tsums = []\n\tfor r in range(n):\n\t\tif not sums:\n\t\t\tnew_sums = [[f, 1] for f in faces]\n\t\telse:\n\t\t\tnew_sums = []\n\t\t\tfor (value, count) in sums:\n\t\t\t\tfor f in faces:\n\t\t\t\t\tnew_sums.append([value + f, count])\n\t\t\tnew_sums.sort()\n\t\t\ti = 0\n\t\t\twhile i < len(new_sums) - 1:\n\t\t\t\t(a, b) = new_sums[i:i + 2]\n\t\t\t\tif a[0] == b[0]:\n\t\t\t\t\tnew_sums[i:i + 2] = [[a[0], a[1] + b[1]]]\n\t\t\t\telse:\n\t\t\t\t\ti += 1\n\t\tsums = new_sums\n\treturn sums\n", "from collections import Counter\nfrom itertools import product\n\ndef reg_sum_hits(n, s):\n\treturn list(map(list, sorted(Counter(map(sum, product(range(1, s + 1), repeat=n))).items())))\n", "from itertools import product\n\ndef reg_sum_hits(n, s):\n\td = {}\n\tfor i in product(*[list(range(1, s + 1))] * n):\n\t\tr = sum(i)\n\t\td[r] = d.get(r, 0) + 1\n\treturn list(map(list, d.items()))\n", "import itertools\n\ndef reg_sum_hits(diceAmount, sides):\n\tpossibilities = calculatepermutations(sides, diceAmount)\n\tsumvalues = calculatesumvalues(sides, diceAmount)\n\tdistributionofsums = calculatedist(possibilities, sumvalues)\n\treturn distributionofsums\n\ndef calculatepermutations(sides, diceAmount):\n\tfacevalues = (i for i in range(1, sides + 1))\n\tallpermutations = itertools.product(facevalues, repeat=diceAmount)\n\treturn [sum(i) for i in allpermutations]\n\ndef calculatesumvalues(sides, diceAmount):\n\tbiggestnumber = sides * diceAmount\n\tsmallestnumber = diceAmount\n\treturn (i for i in range(smallestnumber, biggestnumber + 1))\n\ndef calculatedist(possibilities, sumvalues):\n\treturn [[i, possibilities.count(i)] for i in sumvalues]\n", "import itertools\nimport collections\n\ndef reg_sum_hits(num_dice, sides):\n\trollsums = [sum(x) for x in itertools.product([side for side in range(1, sides + 1)], repeat=num_dice)]\n\treturn [[k, v] for (k, v) in sorted(collections.Counter(rollsums).items())]\n", "from itertools import product\nfrom collections import Counter\n\ndef reg_sum_hits(n, s):\n\treturn sorted([[k, v] for (k, v) in Counter((sum(p) for p in product(*[[i for i in range(1, s + 1)] for _ in range(n)]))).items()])\n", "from itertools import product\n\ndef reg_sum_hits(n, s):\n\tpairs = [[i, 0] for i in range(n, n * s + 1)]\n\tfor i in product(range(1, s + 1), repeat=n):\n\t\tsum = 0\n\t\tfor j in i:\n\t\t\tsum += j\n\t\tindex = sum - n\n\t\tpairs[index][1] += 1\n\treturn pairs\n"], "227": ["def binary_to_string(binary):\n\treturn ''.join([chr(int(binary[i:i + 8], 2)) for i in range(0, len(binary), 8)])\n", "def binary_to_string(binary):\n\tresult = ''\n\twhile binary:\n\t\tresult += chr(int(binary[:8], 2))\n\t\tbinary = binary[8:]\n\treturn result\n", "binary_to_string = lambda b: ''.join((__import__('binascii').unhexlify('%x' % int('0b' + b[i:i + 8], base=2)).decode('utf-8') for i in range(0, len(b), 8)))\n", "import re\n\ndef binary_to_string(binary):\n\treturn re.sub('[01]{8}', lambda x: chr(int(x.group(), 2)), binary)\n", "binary_to_string = lambda b: ''.join([[chr(l) for l in range(0, 127)][m] for m in [int(b[n:n + 8], 2) for n in range(0, len(b), 8)]])\n", "def binary_to_string(binary):\n\treturn int(binary, 2).to_bytes(len(binary) // 8, 'big').decode() if binary else binary\n", "import re\n\ndef binary_to_string(bits):\n\treturn ''.join((chr(int(byte, 2)) for byte in re.findall('\\\\d{8}', bits)))\n", "import re\n\ndef binary_to_string(binary):\n\treturn re.sub('.' * 8, lambda e: chr(int(e.group(), 2)), binary)\n", "import re\n\ndef binary_to_string(binary):\n\treturn ''.join((chr(int(e, 2)) for e in re.findall('.' * 8, binary)))\n"], "236": ["def proper_fractions(n):\n\tphi = n > 1 and n\n\tfor p in range(2, int(n ** 0.5) + 1):\n\t\tif not n % p:\n\t\t\tphi -= phi // p\n\t\t\twhile not n % p:\n\t\t\t\tn //= p\n\tif n > 1:\n\t\tphi -= phi // n\n\treturn phi\n", "def proper_fractions(n):\n\tfactors = set()\n\ti = 2\n\tinput = n\n\twhile i * i <= input:\n\t\tif input % i == 0:\n\t\t\tfactors.add(i)\n\t\t\tinput = input // i\n\t\telse:\n\t\t\ti = i + 1\n\tfactors.add(input)\n\tresult = n\n\tfor j in factors:\n\t\tresult = result * (1 - 1 / j)\n\treturn int(result)\n", "def euler(n):\n\tres = 1.0 * n\n\tp = 2\n\twhile p * p <= n:\n\t\tif n % p == 0:\n\t\t\twhile n % p == 0:\n\t\t\t\tn = n / p\n\t\t\tres *= 1.0 - 1.0 / p\n\t\tp += 1\n\tif n > 1:\n\t\tres *= 1.0 - 1.0 / n\n\treturn int(res)\n\ndef proper_fractions(d):\n\tif d == 1:\n\t\treturn 0\n\treturn euler(d)\n", "from fractions import Fraction\n\ndef proper_fractions(n):\n\tres = Fraction(n)\n\tfor i in range(2, int(n ** 0.5) + 1):\n\t\tif n % i:\n\t\t\tcontinue\n\t\twhile not n % i:\n\t\t\tn //= i\n\t\tres *= Fraction(i - 1, i)\n\t\tif n == 1:\n\t\t\tbreak\n\telse:\n\t\tres *= Fraction(n - 1, n)\n\treturn res\n", "def proper_fractions(n):\n\tif n < 3:\n\t\treturn n - 1\n\t(s, t, i) = ([], 1, 2)\n\twhile True:\n\t\twhile n % i == 0:\n\t\t\t(t, s, n) = (t * (i if i in s else i - 1), s + [i], n // i)\n\t\tif i * i > n:\n\t\t\treturn t * (n - 1) if n > 1 else t\n\t\ti += 1\n", "import math\n\ndef Factor(n):\n\t(a, d) = ([], 2)\n\twhile d * d <= n:\n\t\tif n % d == 0:\n\t\t\ta.append(d)\n\t\t\tn //= d\n\t\telse:\n\t\t\td += 1\n\tif n > 1:\n\t\ta.append(n)\n\treturn a\n\ndef proper_fractions(n):\n\tif n == 1:\n\t\treturn 0\n\t(used, k) = ([], 1)\n\tfor i in Factor(n):\n\t\tif i not in used:\n\t\t\tused.append(i)\n\t\t\tk *= math.pow(i, Factor(n).count(i)) - math.pow(i, Factor(n).count(i) - 1)\n\treturn k\n", "def unique_prime_factors(n):\n\ti = 2\n\tfactors = set()\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.add(i)\n\tif n > 1:\n\t\tfactors.add(n)\n\treturn factors\n\ndef proper_fractions(n):\n\tif n == 1:\n\t\treturn 0\n\toutput = n\n\tfor p in unique_prime_factors(n):\n\t\toutput //= p\n\t\toutput *= p - 1\n\treturn output\n", "import math\n\ndef proper_fractions(n):\n\t(divisors, final, unique, i) = ([], [], [], 1)\n\twhile i <= math.sqrt(n):\n\t\tif n % i == 0:\n\t\t\tif n / i == i:\n\t\t\t\tdivisors.append(i)\n\t\t\telse:\n\t\t\t\tdivisors.extend([i, n / i])\n\t\ti = i + 1\n\tdivisors.sort()\n\tif len(divisors) <= 2:\n\t\treturn n - 1\n\t(divisors.pop(0), divisors.pop())\n\tfor (num, item) in enumerate(divisors):\n\t\tfor x in divisors[0:num]:\n\t\t\tif not item % x:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tunique.append(item)\n\tfor (num, item) in enumerate(unique):\n\t\tcache = n / item\n\t\tfor x in unique[0:num]:\n\t\t\tcache = cache - cache / x\n\t\tfinal.append(cache)\n\treturn n - sum(final)\n", "def proper_fractions(n):\n\tif n == 1:\n\t\treturn 0\n\tres = n\n\ti = 2\n\twhile i * i <= n:\n\t\tif n % i == 0:\n\t\t\twhile n % i == 0:\n\t\t\t\tn /= i\n\t\t\tres -= res / i\n\t\ti += 1\n\tif n > 1:\n\t\tres -= res / n\n\treturn int(res)\n"], "252": ["def count_pal(n):\n\treturn [9 * 10 ** ((n - 1) // 2), 10 ** (n // 2) * (13 - 9 * (-1) ** n) // 2 - 2]\n", "def count_pal(n):\n\tx = lambda y: 9 * int(10 ** ((y - 1) // 2))\n\treturn [x(n), sum((x(i) for i in range(n + 1)))]\n", "from itertools import accumulate\nN_PALS = [0] + [9 * 10 ** ((n - 1) // 2) for n in range(1, 2001)]\nS_PALS = list(accumulate(N_PALS))\n\ndef count_pal(n):\n\treturn [N_PALS[n], S_PALS[n]]\n", "def count_pal(n):\n\tpal = lambda n: 9 * 10 ** ((n - 1) // 2)\n\treturn [pal(n), sum((pal(i) for i in range(1, n + 1)))]\n", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef count_pal(n):\n\tif n == 0:\n\t\treturn [0, 0]\n\tcurrent = 9 * 10 ** (n - 1 >> 1)\n\tprevious = count_pal(n - 1)[1]\n\treturn [current, current + previous]\n", "count_pal = lambda n: [int('9' + '0' * (n // 2 - int(not n & 1))), int([['1', '10'][n & 1] + '9' * (n // 2 - 1) + '8', '9'][n == 1])]\n", "def count_pal(n):\n\tres = '1' + '0' * n\n\ttemp = '9'\n\tl = []\n\tfor x in range(1, len(res[1:]) + 1, 2):\n\t\tq = res[x:x + 2]\n\t\tfor _ in q:\n\t\t\tl.append(temp)\n\t\ttemp += '0'\n\treturn [int(l[-1]), sum((int(x) for x in l))]\n", "def count_pal(n):\n\ttotal = 0\n\tfor i in range(n):\n\t\tn_digit = 9 * 10 ** (i // 2)\n\t\ttotal += n_digit\n\treturn [n_digit, total]\n", "count_pal = lambda n: [10 ** (n - 1 >> 1) * 9, 10 ** (n - 1 >> 1) * (20 - n % 2 * 9) - 2]\n"], "262": ["(COLUMNS, ROWS) = ('ABCDEFG', range(6))\nLINES = [{(COLUMNS[i + k], ROWS[j]) for k in range(4)} for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] + [{(COLUMNS[i], ROWS[j + k]) for k in range(4)} for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] + [{(COLUMNS[i + k], ROWS[j + k]) for k in range(4)} for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] + [{(COLUMNS[i + k], ROWS[j - k]) for k in range(4)} for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\ndef who_is_winner(pieces_positions):\n\tplayers = {}\n\tboard = dict.fromkeys(COLUMNS, 0)\n\tfor position in pieces_positions:\n\t\t(column, player) = position.split('_')\n\t\tpos = (column, board[column])\n\t\tboard[column] += 1\n\t\tplayers.setdefault(player, set()).add(pos)\n\t\tif any((line <= players[player] for line in LINES)):\n\t\t\treturn player\n\treturn 'Draw'\n", "from itertools import count, takewhile\n(X, Y, HALF_DIRS) = (6, 7, ((0, 1), (1, 0), (1, 1), (1, -1)))\n\ndef who_is_winner(lstMoves):\n\n\tdef isWinner():\n\t\treturn any((countAligned(*dirs) >= 4 for dirs in HALF_DIRS))\n\n\tdef isInsideAndSameGuy(a, b):\n\t\treturn 0 <= a < X and 0 <= b < Y and (board[a][b] == who)\n\n\tdef countAligned(dx, dy):\n\t\treturn 1 + sum((sum(takewhile(bool, (isInsideAndSameGuy(x + dx * swap * n, y + dy * swap * n) for n in count(1)))) for swap in (1, -1)))\n\tboard = [[' '] * Y for _ in range(X)]\n\txIdx = [0] * Y\n\tfor move in lstMoves:\n\t\t(y, who) = (ord(move[0]) - 65, move[2])\n\t\tx = xIdx[y]\n\t\tboard[x][y] = who\n\t\txIdx[y] += 1\n\t\tif isWinner():\n\t\t\treturn move[2:]\n\telse:\n\t\treturn 'Draw'\n", "def who_is_winner(pieces_position_list):\n\tgrid = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]\n\tcolumns = 7\n\trows = 6\n\trowPosition = 0\n\twinner = None\n\tdrawCount = 0\n\tfor piece in pieces_position_list:\n\t\tif piece[2] == 'Y':\n\t\t\tcode = 2\n\t\telse:\n\t\t\tcode = 1\n\t\tif piece[0] == 'A':\n\t\t\tcolumnPosition = 0\n\t\telif piece[0] == 'B':\n\t\t\tcolumnPosition = 1\n\t\telif piece[0] == 'C':\n\t\t\tcolumnPosition = 2\n\t\telif piece[0] == 'D':\n\t\t\tcolumnPosition = 3\n\t\telif piece[0] == 'E':\n\t\t\tcolumnPosition = 4\n\t\telif piece[0] == 'F':\n\t\t\tcolumnPosition = 5\n\t\telif piece[0] == 'G':\n\t\t\tcolumnPosition = 6\n\t\twhile grid[rowPosition][columnPosition] != 0:\n\t\t\tif grid[5][columnPosition] == 1 or grid[5][columnPosition] == 2:\n\t\t\t\tbreak\n\t\t\trowPosition += 1\n\t\tgrid[rowPosition][columnPosition] = code\n\t\trowPosition = 0\n\t\tfor row in range(rows):\n\t\t\tfor column in range(columns - 3):\n\t\t\t\tif grid[row][column] == 1 and grid[row][column + 1] == 1 and (grid[row][column + 2] == 1) and (grid[row][column + 3] == 1):\n\t\t\t\t\twinner = 'Red'\n\t\t\t\telif grid[row][column] == 2 and grid[row][column + 1] == 2 and (grid[row][column + 2] == 2) and (grid[row][column + 3] == 2):\n\t\t\t\t\twinner = 'Yellow'\n\t\tfor row in range(rows - 3):\n\t\t\tfor column in range(columns):\n\t\t\t\tif grid[row][column] == 1 and grid[row + 1][column] == 1 and (grid[row + 2][column] == 1) and (grid[row + 3][column] == 1):\n\t\t\t\t\twinner = 'Red'\n\t\t\t\telif grid[row][column] == 2 and grid[row + 1][column] == 2 and (grid[row + 2][column] == 2) and (grid[row + 3][column] == 2):\n\t\t\t\t\twinner = 'Yellow'\n\t\tfor row in range(3, rows):\n\t\t\tfor column in range(columns - 3):\n\t\t\t\tif grid[row][column] == 1 and grid[row - 1][column + 1] == 1 and (grid[row - 2][column + 2] == 1) and (grid[row - 3][column + 3] == 1):\n\t\t\t\t\twinner = 'Red'\n\t\t\t\telif grid[row][column] == 2 and grid[row - 1][column + 1] == 2 and (grid[row - 2][column + 2] == 2) and (grid[row - 3][column + 3] == 2):\n\t\t\t\t\twinner = 'Yellow'\n\t\tfor row in range(rows - 3):\n\t\t\tfor column in range(columns - 3):\n\t\t\t\tif grid[row][column] == 1 and grid[row + 1][column + 1] == 1 and (grid[row + 2][column + 2] == 1) and (grid[row + 3][column + 3] == 1):\n\t\t\t\t\twinner = 'Red'\n\t\t\t\telif grid[row][column] == 2 and grid[row + 1][column + 1] == 2 and (grid[row + 2][column + 2] == 2) and (grid[row + 3][column + 3] == 2):\n\t\t\t\t\twinner = 'Yellow'\n\t\tif winner == 'Red':\n\t\t\treturn 'Red'\n\t\t\tbreak\n\t\telif winner == 'Yellow':\n\t\t\treturn 'Yellow'\n\t\t\tbreak\n\tif winner == None:\n\t\treturn 'Draw'\n", "import numpy as np\nfrom scipy.signal import convolve2d\n\ndef who_is_winner(pieces_position_list):\n\tarr = np.zeros((7, 6), int)\n\tfor a in pieces_position_list:\n\t\t(pos, color) = a.split('_')\n\t\tpos = ord(pos) - ord('A')\n\t\tval = (-1, 1)[color == 'Red']\n\t\tarr[pos, np.argmin(arr[pos] != 0)] = val\n\t\tt_arr = val * arr\n\t\tif any((np.max(cv) == 4 for cv in (convolve2d(t_arr, [[1, 1, 1, 1]], 'same'), convolve2d(t_arr, [[1], [1], [1], [1]], 'same'), convolve2d(t_arr, [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], 'same'), convolve2d(t_arr, [[0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 0]], 'same')))):\n\t\t\treturn color\n\treturn 'Draw'\n", "from numpy import diagonal, rot90\n\ndef who_is_winner(pieces_position_list):\n\tboard = [[' '] * 6 for _ in range(7)]\n\n\tdef check(i, j, p):\n\t\tif p in ''.join(board[i]):\n\t\t\treturn True\n\t\tif p in ''.join(list(zip(*board))[j]):\n\t\t\treturn True\n\t\tif p in ''.join(diagonal(board, j - i)):\n\t\t\treturn True\n\t\tif p in ''.join(diagonal(rot90(board), +i + j - 5)):\n\t\t\treturn True\n\t\treturn False\n\tid = [0] * 7\n\tfor move in pieces_position_list:\n\t\t(i, p) = (ord(move[0]) - 65, move[2])\n\t\tj = id[i]\n\t\t(board[i][j], id[i]) = (p, j + 1)\n\t\tif check(i, j, p * 4):\n\t\t\treturn 'Yellow' if p == 'Y' else 'Red'\n\treturn 'Draw'\n"], "265": ["def primeFactors(n):\n\tfactors = []\n\twhile n % 2 == 0:\n\t\tn /= 2\n\t\tfactors.append(2)\n\tfor i in range(3, int(n ** 0.5) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tn /= i\n\t\t\tfactors.insert(0, i)\n\tif n > 2:\n\t\tfactors.insert(0, int(n))\n\treturn factors\n\ndef score(p):\n\t(last, xp, s) = (p[0], p[0], 0)\n\tfor j in p[1:]:\n\t\tif j == last:\n\t\t\txp *= j\n\t\telse:\n\t\t\ts += xp\n\t\t\t(xp, last) = (j, j)\n\treturn (s + xp) * len(p)\n\ndef prod(lst):\n\tres = 1\n\tfor v in lst:\n\t\tres *= v\n\treturn res\n\ndef multiply_partitions(partition):\n\treturn [prod(sub) for sub in partition]\n\ndef partition(collection):\n\tif len(collection) == 1:\n\t\tyield [collection]\n\t\treturn\n\tfirst = collection[0]\n\tfor smaller in partition(collection[1:]):\n\t\tfor (n, subset) in enumerate(smaller):\n\t\t\tyield (smaller[:n] + [[first] + subset] + smaller[n + 1:])\n\t\tyield ([[first]] + smaller)\n\ndef find_spec_prod_part(n, com):\n\tfactors = primeFactors(n)\n\tif len(factors) == 1:\n\t\treturn 'It is a prime number'\n\tfn = min if com == 'min' else max\n\tmplist = []\n\tbest = [factors, score(factors)]\n\tfor p in partition(factors):\n\t\tmp = multiply_partitions(p)\n\t\tif mp in mplist or mp[0] == n:\n\t\t\tcontinue\n\t\tmplist.append(mp)\n\t\tbest = fn(best, [mp, score(mp)], key=lambda x: x[1])\n\treturn [sorted(best[0], reverse=True), best[1]]\n", "from collections import Counter\nfrom itertools import permutations\nfrom itertools import chain\nimport numpy as np\n\ndef prime_factors(n):\n\tfactors = []\n\twhile n % 2 == 0:\n\t\tn = n // 2\n\t\tfactors.append(2)\n\tfor k in range(3, n + 1, 2):\n\t\twhile n % k == 0:\n\t\t\tn = n // k\n\t\t\tfactors.append(k)\n\t\tif n == 1:\n\t\t\tbreak\n\treturn factors\n\ndef get_score(factors):\n\tfactor_counts = Counter(factors)\n\treturn sum((f ** factor_counts[f] for f in factor_counts)) * sum((c for c in factor_counts.values()))\n\ndef int_partitions(m, memo={}):\n\tif m in memo:\n\t\treturn memo[m]\n\tall_partitions = [[m]]\n\tfor i in range(1, m):\n\t\tfor p in int_partitions(m - i, memo):\n\t\t\tall_partitions.append([i] + p)\n\tmemo[m] = all_partitions\n\treturn all_partitions\n\ndef make_partitions(factors):\n\tpartitions = int_partitions(len(factors))\n\tpart_perm = []\n\tfor p in partitions:\n\t\tpart_perm.append(set(list(permutations(p, len(p)))))\n\tpart_perm = set(list(chain.from_iterable(part_perm)))\n\tall_new_factors = []\n\tfor inds in part_perm:\n\t\tnew_factors = []\n\t\tj_start = 0\n\t\tfor i in inds:\n\t\t\tj_end = j_start + i\n\t\t\tnew_factors.append(np.product(factors[j_start:j_end]))\n\t\t\tj_start = j_end\n\t\tif len(new_factors) > 1:\n\t\t\tall_new_factors.append(new_factors)\n\treturn all_new_factors\n\ndef find_spec_prod_part(n, com):\n\tfactors = prime_factors(n)\n\tif len(factors) == 1:\n\t\treturn 'It is a prime number'\n\tall_factors = make_partitions(factors)\n\tscores = [get_score(x) for x in all_factors]\n\tif com == 'max':\n\t\topt_id = np.argmax(scores)\n\telse:\n\t\topt_id = np.argmin(scores)\n\treturn [sorted(all_factors[opt_id], reverse=True), scores[opt_id]]\n", "from itertools import cycle, groupby, islice\nfrom operator import lt, gt\n\ndef find_spec_prod_part(n, com):\n\tprime_factors = list(factor(n))\n\tif len(prime_factors) < 2:\n\t\treturn 'It is a prime number'\n\tcmp = lt if com == 'min' else gt\n\tbest_part = None\n\tbest_score = None\n\tfor part in set(islice(partitions(prime_factors), 1, None)):\n\t\tsc = score(part)\n\t\tif not best_score or cmp(sc, best_score):\n\t\t\tbest_part = part\n\t\t\tbest_score = sc\n\treturn [list(best_part), best_score]\n\ndef factor(n):\n\tif n < 1:\n\t\traise ValueError('factor: n must be > 0')\n\tfor d in [2, 3, 5]:\n\t\twhile n % d == 0:\n\t\t\tyield d\n\t\t\tn = n // d\n\td = 7\n\twheel = cycle([4, 2, 4, 2, 4, 6, 2, 6])\n\twhile n > 1 and d * d <= n:\n\t\tif n % d == 0:\n\t\t\tyield d\n\t\t\tn = n // d\n\t\telse:\n\t\t\td += next(wheel)\n\tif n > 1:\n\t\tyield n\n\ndef partitions(factors):\n\tif len(factors) == 1:\n\t\tyield (factors[0],)\n\t\treturn\n\tfirst = factors[0]\n\tfor subpart in partitions(factors[1:]):\n\t\tfor (n, fact) in enumerate(subpart):\n\t\t\tyield tuple(sorted(subpart[:n] + (first * fact,) + subpart[n + 1:], reverse=True))\n\t\tyield tuple(sorted((first,) + subpart, reverse=True))\n\ndef score(part):\n\tfactors = [(f, len(list(g))) for (f, g) in groupby(part)]\n\treturn sum((f ** e for (f, e) in factors)) * sum((e for (_, e) in factors))\n", "import math\nfrom collections import Counter\nfrom itertools import permutations\n\ndef find_spec_prod_part(n, com):\n\ttemp_partition = []\n\tfactors = primeFactors(n)\n\tcounter = Counter(factors)\n\tmax_score = calculateScore(counter)\n\tmin_score = max_score\n\tpartition_min = factors\n\tpartition_max = factors\n\tx = len(factors)\n\tif len(factors) == 1:\n\t\treturn 'It is a prime number'\n\tperms = list(set(list(permutations(factors))))\n\tdivs = list(accel_asc(len(factors)))\n\tfor div in divs:\n\t\tif len(div) == 1 or len(div) == len(factors):\n\t\t\tcontinue\n\t\tfor perm in perms:\n\t\t\ttemp_partition = []\n\t\t\tstart = 0\n\t\t\tproduct = 1\n\t\t\tseq = []\n\t\t\tfor i in div:\n\t\t\t\tseq = perm[start:start + i]\n\t\t\t\tfor j in seq:\n\t\t\t\t\tproduct *= j\n\t\t\t\ttemp_partition.append(product)\n\t\t\t\tstart = start + i\n\t\t\t\tproduct = 1\n\t\t\tcounter = Counter(temp_partition)\n\t\t\tscore = calculateScore(counter)\n\t\t\tif score > max_score:\n\t\t\t\tmax_score = score\n\t\t\t\tpartition_max = temp_partition\n\t\t\tif score < min_score:\n\t\t\t\tmin_score = score\n\t\t\t\tpartition_min = temp_partition\n\tif com == 'max':\n\t\tpartition_max.sort(reverse=True)\n\t\treturn [partition_max, max_score]\n\tif com == 'min':\n\t\tpartition_min.sort(reverse=True)\n\t\treturn [partition_min, min_score]\n\ndef calculateScore(count):\n\tscore = 0\n\tcoef = 0\n\tfor key in count:\n\t\tscore += key ** count[key]\n\t\tcoef += count[key]\n\tscore = score * coef\n\treturn score\n\ndef primeFactors(n):\n\tprime_factors = []\n\twhile n % 2 == 0:\n\t\t(prime_factors.append(2),)\n\t\tn = n / 2\n\tfor i in range(3, int(math.sqrt(n)) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\t(prime_factors.append(i),)\n\t\t\tn = n / i\n\tif n != 1:\n\t\tprime_factors.append(int(n))\n\treturn prime_factors\n\ndef accel_asc(n):\n\ta = [0 for i in range(n + 1)]\n\tk = 1\n\ty = n - 1\n\twhile k != 0:\n\t\tx = a[k - 1] + 1\n\t\tk -= 1\n\t\twhile 2 * x <= y:\n\t\t\ta[k] = x\n\t\t\ty -= x\n\t\t\tk += 1\n\t\tl = k + 1\n\t\twhile x <= y:\n\t\t\ta[k] = x\n\t\t\ta[l] = y\n\t\t\tyield a[:k + 2]\n\t\t\tx += 1\n\t\t\ty -= 1\n\t\ta[k] = x + y\n\t\ty = x + y - 1\n\t\tyield a[:k + 1]\n", "from functools import reduce\nfrom operator import mul, gt, lt\nfrom itertools import combinations\nfrom collections import Counter\n\ndef is_prime(n):\n\tif n < 2:\n\t\treturn False\n\telif n == 2:\n\t\treturn True\n\telif n % 2 == 0:\n\t\treturn False\n\tfor i in range(3, int(n ** 0.5) + 1, 2):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\nmemo = {}\n\ndef _prot_part(arr):\n\tif len(arr) < 2:\n\t\treturn set({(arr[0],)})\n\telif len(arr) == 2:\n\t\treturn set([tuple(sorted(arr)), (arr[0] * arr[1],)])\n\telif tuple(arr) in memo:\n\t\treturn memo[tuple(arr)]\n\tr = set()\n\tfor j in range(1, len(arr) // 2 + 1):\n\t\tfor t in combinations(arr, j):\n\t\t\tarr2 = arr[:]\n\t\t\tfor e in t:\n\t\t\t\tarr2.remove(e)\n\t\t\ts2 = _prot_part(arr2)\n\t\t\tfor e1 in _prot_part(list(t)):\n\t\t\t\tfor e2 in s2:\n\t\t\t\t\tr.add(tuple(sorted(list(e1 + e2))))\n\tr.add((reduce(mul, arr),))\n\tmemo[tuple(arr)] = r\n\treturn r\n\ndef find_spec_prod_part(n, com):\n\tif is_prime(n):\n\t\treturn 'It is a prime number'\n\tr = []\n\twhile n % 2 == 0:\n\t\tr.append(2)\n\t\tn //= 2\n\tx = 3\n\twhile n > 1 and (not is_prime(n)):\n\t\twhile n % x == 0:\n\t\t\tr.append(x)\n\t\t\tn //= x\n\t\tx += 2\n\tif n > 1:\n\t\tr.append(n)\n\tp = _prot_part(r)\n\tif com == 'max':\n\t\tm = [None, -1]\n\t\tf = gt\n\telse:\n\t\tm = [None, 100000000000.0]\n\t\tf = lt\n\tfor t in p:\n\t\tif len(t) == 1:\n\t\t\tcontinue\n\t\t(a, b) = (0, 0)\n\t\tfor (k, v) in Counter(t).items():\n\t\t\ta += k ** v\n\t\t\tb += v\n\t\tscore = a * b\n\t\tif f(score, m[1]):\n\t\t\tm = [sorted(t, reverse=True), score]\n\treturn m\n", "from numpy import prod\n\ndef find_spec_prod_part(n, com):\n\tpartitions = []\n\tcurrent_partition = 2\n\twhile n > 1:\n\t\tif n % current_partition == 0:\n\t\t\tpartitions.append(current_partition)\n\t\t\tn /= current_partition\n\t\t\tcurrent_partition = 2\n\t\telse:\n\t\t\tcurrent_partition += 1\n\tif len(partitions) == 1:\n\t\treturn 'It is a prime number'\n\tresult = [([0], -1)] if com == 'max' else [([0], float('Inf'))]\n\tsc_opt(partitions, result, com)\n\tresult[0][0].sort(reverse=True)\n\treturn [result[0][0], result[0][1]]\n\ndef sc_opt(partitions, result, com):\n\tif com == 'min' and result[0][1] > sc(partitions) or (com == 'max' and result[0][1] < sc(partitions)):\n\t\tresult[0] = (partitions, sc(partitions))\n\tif len(partitions) == 2 or (com == 'min' and max(partitions) > result[0][1]) or (com == 'min' and max(partitions) > result[0][1]):\n\t\treturn\n\tfor p in set(partitions):\n\t\tcurrent = partitions.copy()\n\t\tcurrent.remove(p)\n\t\tfor i in filter(lambda x: x >= p, set(current)):\n\t\t\tcurr = current.copy()\n\t\t\tcurr[curr.index(i)] *= p\n\t\t\tsc_opt(curr, result, com)\n\ndef sc(partitions):\n\treturn sum([p ** partitions.count(p) for p in set(partitions)]) * len(partitions)\n", "def partition(n):\n\treturn [[int(n / x)] for x in range(1, 1 + int(n / 2)) if n % x == 0]\n\ndef prod(a):\n\tprod = 1\n\tfor n in a:\n\t\tprod *= n\n\treturn prod\n\ndef score(a):\n\treturn sum((n ** a.count(n) for n in reversed(sorted(set(a))))) * len(a)\n\ndef find_spec_prod_part(n, com):\n\tthere_are_new = True\n\tpartitions = partition(n)\n\twhile there_are_new:\n\t\tthere_are_new = False\n\t\tnew_partitions = []\n\t\tfor p in partitions:\n\t\t\tproduct = prod(p)\n\t\t\tif product < n:\n\t\t\t\tfor new in partition(n / product):\n\t\t\t\t\tif new[0] <= p[-1] and prod(p + new) <= n:\n\t\t\t\t\t\tthere_are_new = True\n\t\t\t\t\t\tnew_partitions.append(p + new)\n\t\t\telse:\n\t\t\t\tnew_partitions.append(p)\n\t\tpartitions = new_partitions\n\tif len(partitions) <= 1:\n\t\treturn 'It is a prime number'\n\tfunc = max if com == 'max' else min\n\treturn func(([p, s] for (p, s) in ((p, score(p)) for p in partitions if len(p) > 1)), key=lambda x: x[1])\n", "def partition(n):\n\treturn [[int(n / x)] for x in range(1, 1 + int(n / 2)) if n % x == 0]\n\ndef prod(a):\n\tprod = 1\n\tfor n in a:\n\t\tprod *= n\n\treturn prod\n\ndef score(a):\n\treturn sum((n ** a.count(n) for n in reversed(sorted(set(a))))) * len(a)\n\ndef find_spec_prod_part(n, com):\n\tthere_are_new = True\n\tpartitions = partition(n)\n\twhile there_are_new:\n\t\tthere_are_new = False\n\t\tnew_partitions = []\n\t\tfor p in partitions:\n\t\t\tproduct = prod(p)\n\t\t\tif product < n:\n\t\t\t\tfor new in partition(n / product):\n\t\t\t\t\tif new[0] <= p[-1] and prod(p + new) <= n:\n\t\t\t\t\t\tthere_are_new = True\n\t\t\t\t\t\tnew_partitions.append(p + new)\n\t\t\telse:\n\t\t\t\tnew_partitions.append(p)\n\t\tpartitions = new_partitions\n\tif len(partitions) <= 1:\n\t\treturn 'It is a prime number'\n\tresult = None\n\tresult_score = None\n\tfor p in partitions:\n\t\tif len(p) > 1:\n\t\t\ts = score(p)\n\t\t\tif com == 'max' and (not result_score or result_score < s) or (com == 'min' and (not result_score or result_score > s)):\n\t\t\t\tresult = p\n\t\t\t\tresult_score = s\n\treturn [result, result_score]\n"], "267": ["def diagonal_sum(array):\n\treturn sum((row[i] for (i, row) in enumerate(array)))\n", "from numpy import trace as diagonal_sum\n", "def diagonal_sum(array):\n\treturn sum([array[a][a] for a in range(len(array))])\n", "def diagonal_sum(array):\n\treturn sum((row[idx] for (idx, row) in enumerate(array)))\n", "def diagonal_sum(array):\n\treturn sum([array[x][x] for x in range(0, len(array))])\n", "def diagonal_sum(array):\n\tsum = 0\n\tfor x in range(len(array)):\n\t\tfor y in range(len(array[x])):\n\t\t\tif x == y:\n\t\t\t\tsum = sum + array[x][y]\n\treturn sum\n", "def diagonal_sum(a):\n\treturn sum((l[i] for (i, l) in enumerate(a)))\n", "def diagonal_sum(array):\n\treturn sum((line[i] for (i, line) in enumerate(array)))\n", "def diagonal_sum(array):\n\tsum = 0\n\tfor n in range(len(array)):\n\t\tsum += array[n][n]\n\treturn sum\n"], "315": ["def sort_my_string(s):\n\treturn '{} {}'.format(s[::2], s[1::2])\n", "def sort_my_string(S):\n\treturn S[0::2] + ' ' + S[1::2]\n", "def sort_my_string(s):\n\treturn f'{s[::2]} {s[1::2]}'\n", "def sort_my_string(s):\n\t(odd, even) = ([], [])\n\tfor (i, char) in enumerate(s):\n\t\teven.append(char) if i % 2 == 0 else odd.append(char)\n\treturn ''.join(even) + ' ' + ''.join(odd)\n", "def sort_my_string(s):\n\tl = list(s)\n\treturn ''.join(l[::2] + [' '] + l[1::2])\n", "def sort_my_string(str):\n\tevenChar = str[::2]\n\toddChar = str[1::2]\n\treturn evenChar + ' ' + oddChar\n", "sort_my_string = lambda w: w[::2] + ' ' + w[1::2]\n"], "344": ["def unique_sum(lst):\n\treturn sum(set(lst)) if lst else None\n", "def unique_sum(lst):\n\tif lst:\n\t\treturn sum(set(lst))\n", "def unique_sum(lst):\n\ts = set(lst)\n\treturn sum(s) if len(s) != 0 else None\n", "unique_sum = lambda l: sum(set(l)) if l else None\n", "def unique_sum(lst):\n\tnew_lst = []\n\tfor i in lst:\n\t\tif not i in new_lst:\n\t\t\tnew_lst.append(i)\n\treturn sum(new_lst) if lst else None\n", "def unique_sum(lst):\n\ty = lambda x: sum(set(x))\n\tif len(lst) == 0:\n\t\treturn None\n\telif y(lst) == 0:\n\t\treturn 0\n\telse:\n\t\treturn y(lst)\n", "def unique_sum(lst):\n\tif lst == []:\n\t\treturn None\n\telse:\n\t\ts = set(lst)\n\t\tv = list(s)\n\t\td = sum(v)\n\t\treturn d\n"], "386": ["from collections import deque\n\ndef tree_by_levels(node):\n\tif not node:\n\t\treturn []\n\t(res, queue) = ([], deque([node]))\n\twhile queue:\n\t\tn = queue.popleft()\n\t\tres.append(n.value)\n\t\tif n.left is not None:\n\t\t\tqueue.append(n.left)\n\t\tif n.right is not None:\n\t\t\tqueue.append(n.right)\n\treturn res\n", "def tree_by_levels(node):\n\t(p, q) = ([], [node])\n\twhile q:\n\t\tv = q.pop(0)\n\t\tif v is not None:\n\t\t\tp.append(v.value)\n\t\t\tq += [v.left, v.right]\n\treturn p if not node is None else []\n", "def tree_by_levels(tree):\n\tqueue = [tree]\n\tvalues = []\n\twhile queue:\n\t\tnode = queue.pop(0)\n\t\tif node:\n\t\t\tqueue += [node.left, node.right]\n\t\t\tvalues.append(node.value)\n\treturn values\n", "def tree_by_levels(node):\n\tqueue = []\n\tresult = []\n\tif node == None:\n\t\treturn result\n\tqueue.append(node)\n\twhile len(queue) > 0:\n\t\tn = queue.pop(0)\n\t\tif n.left != None:\n\t\t\tqueue.append(n.left)\n\t\tif n.right != None:\n\t\t\tqueue.append(n.right)\n\t\tresult.append(n.value)\n\treturn result\n", "def tree_by_levels(node):\n\tr = []\n\tnodes = [node]\n\twhile nodes:\n\t\tr += [n.value for n in nodes if n]\n\t\tnodes = [e for n in [(n.left, n.right) for n in nodes if n] for e in n if e]\n\treturn r\n", "from collections import deque\n\ndef tree_by_levels(node):\n\tif not node:\n\t\treturn []\n\tqueue = deque([node])\n\tlevel_order = []\n\twhile queue:\n\t\tcur_node = queue.popleft()\n\t\tlevel_order.append(cur_node.value)\n\t\tif cur_node.left:\n\t\t\tqueue.append(cur_node.left)\n\t\tif cur_node.right:\n\t\t\tqueue.append(cur_node.right)\n\treturn level_order\n", "def tree_by_levels(node):\n\treturn [v for (v, _, _) in sorted(extract_nodes(node), key=lambda x: (x[1], x[2]))]\n\ndef extract_nodes(node, lvl=0, directions=[]):\n\tif node:\n\t\treturn [(node.value, lvl, directions)] + extract_nodes(node.left, lvl + 1, directions + [-1]) + extract_nodes(node.right, lvl + 1, directions + [1])\n\treturn []\n", "from itertools import chain\n\ndef tree_by_levels(node):\n\ttree = [node]\n\ttemp = [t.value for t in tree if t]\n\twhile tree:\n\t\ttree = list(chain(*[[t.left, t.right] for t in tree if t]))\n\t\ttemp += [t.value for t in tree if t]\n\treturn temp\n", "def tree_by_levels(node):\n\tlevels = {}\n\n\tdef sweep(subnode, level):\n\t\tif subnode != None:\n\t\t\tlevels[level] = levels.get(level, []) + [subnode.value]\n\t\t\tsweep(subnode.left, level + 1)\n\t\t\tsweep(subnode.right, level + 1)\n\tsweep(node, 0)\n\treturn sum((levels[k] for k in sorted(levels)), [])\n", "from collections import deque\n\ndef tree_by_levels(node):\n\t(q, result) = (deque(), [])\n\tif node is not None:\n\t\tq.append(node)\n\twhile len(q):\n\t\tnode = q.popleft()\n\t\tresult.append(node.value)\n\t\tq.extend((i for i in (node.left, node.right) if i is not None))\n\treturn result\n"], "423": ["def check_concatenated_sum(n, r):\n\treturn abs(n) == sum((int(e * r) for e in str(abs(n)) if r))\n", "def check_concatenated_sum(number, n):\n\treturn (10 ** n - 1) // 9 * sum(map(int, str(abs(number)))) == abs(number)\n", "def check_concatenated_sum(num, n):\n\treturn n and num % int('1' * n) == 0\n", "def check_concatenated_sum(num, n):\n\tm = abs(num)\n\treturn m == sum(map(int, str(m))) * int('1' * n or 0)\n", "def check_concatenated_sum(num, l):\n\treturn sum([int(x * l) for x in str(abs(num))]) == abs(num) if l > 0 else False\n", "def check_concatenated_sum(number, k):\n\treturn sum((int(d * k) for d in str(abs(number)))) == abs(number) if k else False\n", "def check_concatenated_sum(num, n):\n\tnum = abs(num)\n\treturn sum((int(i * n) for i in str(num) if n)) == num\n", "def check_concatenated_sum(a, b):\n\tif not b:\n\t\treturn False\n\tc = abs(a)\n\td = [int(f\"{(a < 0) * '-'}{n * b}\") for n in str(c)]\n\treturn sum(d) == a\n"], "428": ["def sc(strng):\n\tseen = set(strng)\n\treturn ''.join((a for a in strng if a.swapcase() in seen))\n", "def sc(s):\n\treturn ''.join((ch for ch in s if ch.upper() in s and ch.lower() in s))\n", "def sc(s):\n\txs = set(s)\n\treturn ''.join((c for c in s if c.swapcase() in xs))\n", "def sc(s):\n\treturn ''.join([e for e in s if {1: e.upper() in s, 0: e.lower() in s}[e.islower()]])\n", "def sc(s):\n\treturn ''.join((i for i in s if i.swapcase() in set(s)))\n", "def sc(s):\n\treturn ''.join([i for i in s if i.lower() in s and i.upper() in s])\n", "def sc(s):\n\treturn ''.join((c for c in s if c.swapcase() in s))\n", "def sc(s):\n\tfor i in s:\n\t\tif i.islower() == True:\n\t\t\tif i.upper() not in s:\n\t\t\t\ts = s.replace(i, '')\n\t\telif i.lower() not in s:\n\t\t\ts = s.replace(i, '')\n\treturn s\n"], "436": ["def array_manip(array):\n\treturn [min([a for a in array[i + 1:] if a > array[i]], default=-1) for i in range(len(array))]\n", "def array_manip(array):\n\treturn [min((r for r in array[i:] if r > n), default=-1) for (i, n) in enumerate(array, 1)]\n", "def array_manip(array):\n\treturn [min(filter(lambda y: y > x, array[i + 1:]), default=-1) for (i, x) in enumerate(array)]\n", "def array_manip(array):\n\tres = []\n\tfor (i, n) in enumerate(array):\n\t\ttry:\n\t\t\tres.append(min([x for x in array[i + 1:] if x > n]))\n\t\texcept ValueError:\n\t\t\tres.append(-1)\n\treturn res\n", "array_manip = lambda a: [min([m for m in a[i + 1:] if m > n] or [-1]) for (i, n) in enumerate(a)]\n", "def array_manip(array):\n\tresult = []\n\tfor i in range(len(array)):\n\t\ttry:\n\t\t\tcr = array[i]\n\t\t\tmm = sorted((x for x in array[i + 1:] if x > cr))[0]\n\t\t\tresult.append(mm)\n\t\texcept:\n\t\t\tresult.append(-1)\n\treturn result\n", "def array_manip(array):\n\treturn [min(filter(lambda a: a > array[i], array[i + 1:]), default=-1) for i in range(len(array))]\n", "class BinaryTree:\n\n\tdef __init__(self, value, left=None, right=None, parent=None):\n\t\tself.value = value\n\t\tself.left = left\n\t\tself.right = right\n\t\tself.parent = parent\n\n\tdef __str__(self):\n\t\tif self.left or self.right:\n\t\t\ts = '(' + str(self.value)\n\t\t\tsl = self.left or '#'\n\t\t\tsr = self.right or '#'\n\t\t\tfor l in str(sl).split('\\n'):\n\t\t\t\ts += '\\n  ' + l\n\t\t\tfor l in str(sr).split('\\n'):\n\t\t\t\ts += '\\n  ' + l\n\t\t\treturn s + ')'\n\t\telse:\n\t\t\treturn f'{self.value}'\n\n\tdef add(self, val):\n\t\tif val < self.value:\n\t\t\tif self.left:\n\t\t\t\treturn self.left.add(val)\n\t\t\telse:\n\t\t\t\tself.left = BinaryTree(val, parent=self)\n\t\t\t\treturn self.left\n\t\telif val > self.value:\n\t\t\tif self.right:\n\t\t\t\treturn self.right.add(val)\n\t\t\telse:\n\t\t\t\tself.right = BinaryTree(val, parent=self)\n\t\t\t\treturn self.right\n\t\telif val == self.value:\n\t\t\treturn self\n\n\tdef leftmost(self):\n\t\tx = self\n\t\twhile x.left:\n\t\t\tx = x.left\n\t\treturn x\n\n\tdef nxt(self):\n\t\tif self.right:\n\t\t\treturn self.right.leftmost().value\n\t\telse:\n\t\t\tx = self.parent\n\t\t\twhile x and x.value < self.value:\n\t\t\t\tx = x.parent\n\t\t\tif x:\n\t\t\t\treturn x.value\n\t\treturn -1\n\ndef array_manip(array):\n\tif not array:\n\t\treturn []\n\tresult = []\n\tb = BinaryTree(array[-1])\n\tfor item in reversed(array):\n\t\tresult.append(b.add(item).nxt())\n\treturn result[::-1]\n"], "482": ["def interpreter(tape):\n\t(memory, ptr, output) = ({0: 0}, 0, '')\n\tfor command in tape:\n\t\tif command == '>':\n\t\t\tptr += 1\n\t\telif command == '<':\n\t\t\tptr -= 1\n\t\telif command == '!':\n\t\t\tmemory[len(memory)] = 0\n\t\telif command == '*':\n\t\t\toutput += chr(memory.get(ptr, 0) % 256)\n\t\telif ptr in memory:\n\t\t\tif command == '+':\n\t\t\t\tmemory[ptr] += 1\n\t\t\telif command == '-':\n\t\t\t\tmemory[ptr] -= 1\n\t\t\telif command == '/':\n\t\t\t\tmemory[ptr] = 0\n\treturn output\n", "def interpreter(tape):\n\t(data, pointer, output) = ([0], 0, '')\n\tfor command in tape:\n\t\tif command == '>':\n\t\t\tpointer += 1\n\t\telif command == '<':\n\t\t\tpointer -= 1\n\t\telif command == '+' and is_valid(pointer, data):\n\t\t\tdata[pointer] = (data[pointer] + 1) % 256\n\t\telif command == '-' and is_valid(pointer, data):\n\t\t\tdata[pointer] = (data[pointer] - 1) % 256\n\t\telif command == '/' and is_valid(pointer, data):\n\t\t\tdata[pointer] = 0\n\t\telif command == '!':\n\t\t\tdata.append(0)\n\t\telif command == '*' and is_valid(pointer, data):\n\t\t\toutput += chr(data[pointer])\n\t\telif command == '*':\n\t\t\toutput += chr(0)\n\treturn output\n\ndef is_valid(pointer, data):\n\treturn pointer >= 0 and pointer < len(data)\n", "def interpreter(tape):\n\t(dct, selector, out) = ({0: 0}, 0, '')\n\tfor l in tape:\n\t\tif l == '>':\n\t\t\tselector += 1\n\t\tif l == '<':\n\t\t\tselector -= 1\n\t\tif l == '*':\n\t\t\tout += chr(dct.get(selector, 0))\n\t\tif selector in dct:\n\t\t\tif l == '+':\n\t\t\t\tdct[selector] = (dct[selector] + 1) % 256\n\t\t\tif l == '-':\n\t\t\t\tdct[selector] = (dct[selector] - 1) % 256\n\t\t\tif l == '/':\n\t\t\t\tdct[selector] = 0\n\t\tif l == '!':\n\t\t\tdct[max(dct) + 1] = 0\n\treturn out\n", "def interpreter(tape):\n\ttest = Ticker(tape)\n\treturn test.out\n\nclass Ticker:\n\terror = lambda x: None\n\tdoc = {'>': '_incr', '<': '_decr', '*': '_addA', '+': '_icrC', '-': '_dcrC', '/': '_set', '!': '_addN'}\n\n\tdef __init__(self, tape):\n\t\tself.dat = [0] * 256\n\t\tself.ind = 0\n\t\tself.out = ''\n\t\tself.run = [getattr(self, self.doc.get(k, 'error'))() for k in tape]\n\n\tdef _set(self, dflt=0):\n\t\tself.dat[self.ind] = 0\n\n\tdef _addN(self):\n\t\tself.dat[self.ind] = ord(self.out[-1])\n\n\tdef _dcrC(self):\n\t\tself.dat[self.ind] -= 1\n\n\tdef _icrC(self):\n\t\tself.dat[self.ind] += 1\n\n\tdef _addA(self):\n\t\tself.out += chr(self.dat[self.ind] % 256)\n\n\tdef _incr(self):\n\t\tself.ind += 1\n\n\tdef _decr(self):\n\t\tself.ind -= 1\n", "def interpreter(s):\n\t(memory, pointer, output) = ([0], 0, [])\n\tfor i in s:\n\t\tif 0 <= pointer < len(memory):\n\t\t\tif i == '+':\n\t\t\t\tmemory[pointer] += 1\n\t\t\tif i == '-':\n\t\t\t\tmemory[pointer] += -1\n\t\t\tif i == '*':\n\t\t\t\toutput.append(chr(memory[pointer] % 256))\n\t\t\tif i == '!':\n\t\t\t\tmemory.append(0)\n\t\t\tif i == '/':\n\t\t\t\tmemory[pointer] = 0\n\t\t\tif i == '>':\n\t\t\t\tpointer += 1\n\t\t\tif i == '<':\n\t\t\t\tpointer -= 1\n\treturn ''.join(output) or '\\x00'\n", "def interpreter(tape):\n\tselector = 0\n\tcells = dict()\n\toutput = ''\n\tfor c in tape:\n\t\tif c == '>':\n\t\t\tselector += 1\n\t\telif c == '<':\n\t\t\tselector -= 1\n\t\telif c == '*':\n\t\t\toutput += chr(cells.get(selector, 0))\n\t\telif c == '+':\n\t\t\tcells[selector] = (cells.get(selector, 0) + 1) % 256\n\t\telif c == '-':\n\t\t\tcells[selector] = (cells.get(selector, 0) - 1) % 256\n\t\telif c == '/':\n\t\t\tcells[selector] = 0\n\t\telif c == '!':\n\t\t\tcells[len(cells)] = 0\n\treturn output\n", "def interpreter(tape):\n\t(cell, cells, out) = (0, [0], '')\n\tfor c in [k for k in tape if k in '<>!*+-/']:\n\t\tif c == '>':\n\t\t\tcell += 1\n\t\tif c == '<':\n\t\t\tcell -= 1\n\t\tif c == '!':\n\t\t\tcells += [0]\n\t\tif c == '*':\n\t\t\tout += chr(cells[cell] if cell >= 0 and cell < len(cells) else 0)\n\t\tif cell >= 0 and cell < len(cells):\n\t\t\tif c == '+':\n\t\t\t\tcells[cell] += 1\n\t\t\tif c == '-':\n\t\t\t\tcells[cell] -= 1\n\t\t\tif c == '/':\n\t\t\t\tcells[cell] = 0\n\t\t\tcells[cell] = {256: 0, -1: 255}.get(cells[cell], cells[cell])\n\treturn out\n", "interpreter = lambda tape: (lambda l: ([[0 for l['mem'][l['p']] in [(l['mem'][l['p']] + 1) % 256]] if i == '+' and l['p'] in l['mem'].keys() else [0 for l['p'] in [l['p'] - 1]] if i == '<' else [0 for l['p'] in [l['p'] + 1]] if i == '>' else [0 for l['mem'][l['p']] in [(255 + l['mem'][l['p']]) % 256]] if i == '-' and l['p'] in l['mem'].keys() else [0 for l['mem'][l['p']] in [0]] if i == '/' else [0 for l['out'] in [l['out'] + chr(l['mem'].get(l['p'], 0))]] if i == '*' else [0 for l['mem'][max(l['mem'].keys()) + 1] in [0]] if i == '!' else None for i in tape], l['out'])[1])({'mem': {0: 0}, 'p': 0, 'out': ''})\n", "from collections import defaultdict\n\ndef interpreter(tape):\n\t(mem, out) = (defaultdict(int), [])\n\tn = len(tape)\n\tidx = ptr = 0\n\twhile idx < n:\n\t\tcmd = tape[idx]\n\t\tif cmd == '>':\n\t\t\tptr += 1\n\t\telif cmd == '<':\n\t\t\tptr -= 1\n\t\telif cmd == '+':\n\t\t\tmem[ptr] = (mem[ptr] + 1) % 256\n\t\telif cmd == '-':\n\t\t\tmem[ptr] = (mem[ptr] - 1) % 256\n\t\telif cmd == '/':\n\t\t\tmem[ptr] = 0\n\t\telif cmd == '*':\n\t\t\tout.append(chr(mem[ptr]))\n\t\tidx += 1\n\treturn ''.join(out)\n"], "494": ["import math\n\ndef gta(limit, *args):\n\treturn sum_up(limit, make_pattern(limit, *args))\n\ndef binomial_coeff(n, k):\n\treturn math.factorial(n) / math.factorial(n - k)\n\ndef sum_up(limit, items):\n\ttotal = 0\n\tfor i in range(1, limit + 1):\n\t\tcombin = binomial_coeff(len(items), i)\n\t\tratio = len(items) / float(i)\n\t\tfor element in items:\n\t\t\ttotal += element * (combin / ratio)\n\treturn total\n\ndef make_pattern(limit, *args):\n\tseen = set()\n\tpattern = []\n\titems = list(map(str, args))\n\tk = 0\n\twhile len(pattern) < limit:\n\t\tfor i in range(len(items)):\n\t\t\ttry:\n\t\t\t\tv = items[i][k]\n\t\t\texcept IndexError:\n\t\t\t\tpass\n\t\t\tif v not in seen:\n\t\t\t\tseen.add(v)\n\t\t\t\tpattern.append(int(v))\n\t\t\t\tif len(pattern) == limit:\n\t\t\t\t\tbreak\n\t\tk += 1\n\treturn pattern\n", "def gta(limit, *args):\n\targs = [str(n).ljust(limit, '.') for n in args]\n\t(unique, frequency, fact) = (set(), 0, 1)\n\tfor c in zip(*args):\n\t\tfor d in c:\n\t\t\tif d == '.' or d in unique:\n\t\t\t\tcontinue\n\t\t\tlimit -= 1\n\t\t\tunique.add(d)\n\t\t\tfrequency += fact * len(unique)\n\t\t\tfact *= limit\n\t\t\tif not limit:\n\t\t\t\treturn frequency * sum(map(int, unique))\n", "def gta(limit, *args):\n\tns = []\n\tfor i in args:\n\t\ta = list(str(i))\n\t\ta.reverse()\n\t\tns.append(a)\n\tbase_list = []\n\twhile ns and len(base_list) < limit:\n\t\tn = ns.pop(0)\n\t\tif n:\n\t\t\tb = int(n.pop())\n\t\t\tif b not in base_list:\n\t\t\t\tbase_list.append(b)\n\t\t\tif n:\n\t\t\t\tns.append(n)\n\tbase = sum(base_list)\n\ttimes = 0\n\tfor i in range(1, 1 + limit):\n\t\tt = i\n\t\tfor j in range(i - 1):\n\t\t\tt *= limit - j - 1\n\t\ttimes += t\n\treturn base * times\n", "from math import e, factorial\n\ndef gta(limit, *nums):\n\t(iternums, l, i, base) = ([(int(d) for d in str(n)) for n in nums], len(nums), 0, [])\n\twhile len(base) < limit:\n\t\t(d, i) = (next(iternums[i % l], None), i + 1)\n\t\tif d is not None and d not in base:\n\t\t\tbase.append(d)\n\treturn (int(e * factorial(limit)) * (limit - 1) + 1) * sum(base) // limit\n", "from math import factorial as fac\n\ndef gta(limit, *args):\n\tx = [str(i) for i in args]\n\ty = set()\n\twhile len(y) != limit:\n\t\tfor i in range(len(args)):\n\t\t\tif x[i] != None:\n\t\t\t\tif len(x[i]) != 0:\n\t\t\t\t\ty.add(int(x[i][0]))\n\t\t\t\tif len(x[i]) == 1:\n\t\t\t\t\tx[i] = None\n\t\t\t\telif len(x[i]) == 2:\n\t\t\t\t\tx[i] = x[i][1]\n\t\t\t\telse:\n\t\t\t\t\tx[i] = x[i][1:]\n\t\t\t\tif len(y) == limit:\n\t\t\t\t\tbreak\n\t(y, l) = (list(y), len(y))\n\ttot = [fac(l) / fac(i) * (sum(y) * 1.0 / l) * (l - i) for i in range(l)]\n\treturn round(sum(tot), 0)\n", "import itertools\n\ndef gta(limit, *args):\n\tx = max((len(str(l)) for l in args))\n\ty = ''\n\tfor i in range(x):\n\t\tfor ix in args:\n\t\t\ttry:\n\t\t\t\tif str(ix)[i] in y:\n\t\t\t\t\tcontinue\n\t\t\t\ty += str(ix)[i]\n\t\t\texcept:\n\t\t\t\tpass\n\tans = 0\n\tfor i in range(1, limit + 1):\n\t\tfor xc in itertools.permutations(y[:limit], i):\n\t\t\tans += sum([sum(map(int, xc))])\n\treturn ans\n", "from itertools import cycle, permutations\n\ndef gta(limit, *args):\n\tnums = []\n\tnumbers = [str(n) for n in args]\n\tfor i in cycle(range(len(numbers))):\n\t\tif numbers[i]:\n\t\t\tif int(numbers[i][0]) not in nums:\n\t\t\t\tnums.append(int(numbers[i][0]))\n\t\t\t\tif len(nums) == limit:\n\t\t\t\t\tbreak\n\t\t\tnumbers[i] = numbers[i][1:]\n\t\telif ''.join(numbers) == '':\n\t\t\tbreak\n\tans = 0\n\tfor n in range(1, len(nums) + 1):\n\t\tfor arr in permutations(nums, n):\n\t\t\tans += sum(arr)\n\treturn ans\n"], "564": ["import re\n\ndef signed_eight_bit_number(number):\n\treturn bool(re.match('(0|-128|-?([1-9]|[1-9]\\\\d|1[01]\\\\d|12[0-7]))\\\\Z', number))\n", "def signed_eight_bit_number(number):\n\tif number in list(map(str, list(range(-128, 128)))):\n\t\treturn True\n\treturn False\n", "import re\nSIGNED_BYTE_PATTERN = re.compile('\\n    \\\\A\\n    (?:\\n        0 |\\n        -? (?:\\n            1 (?:\\n                [01] \\\\d? |\\n                2 [0-7]? |\\n                [3-9] )? |\\n            [2-9] \\\\d? ) |\\n        -128 )\\n    \\\\Z\\n', re.X)\n\ndef signed_eight_bit_number(number):\n\treturn bool(SIGNED_BYTE_PATTERN.search(number))\n", "def signed_eight_bit_number(s):\n\ttry:\n\t\treturn -128 <= int(s) <= 127 and str(int(s)) == s\n\texcept ValueError:\n\t\treturn False\n", "import re\n\ndef signed_eight_bit_number(n):\n\treturn bool(re.fullmatch('-?(1[01]\\\\d|12[0-7]|[1-9]\\\\d)|-(128|[1-9])|\\\\d', n))\n", "import re\n\ndef signed_eight_bit_number(n):\n\treturn re.match('-?\\\\d+$', n) and str(int(n)) == n and (-128 <= int(n) < 128) or False\n", "def signed_eight_bit_number(number):\n\treturn number in list(map(str, list(range(-128, 128))))\n", "def signed_eight_bit_number(number):\n\ttry:\n\t\ti = int(number)\n\t\treturn -128 <= i <= 127 and number == str(i)\n\texcept:\n\t\tpass\n\treturn False\n", "import re\n\ndef signed_eight_bit_number(number):\n\treturn bool(re.fullmatch('(-?(1(([2][0-7])|([01]\\\\d))|[1-9][0-9]))|\\\\d|-[1-9]|-128', number))\n"], "568": ["def count_adjacent_pairs(st):\n\twords = st.lower().split(' ')\n\tcurrentWord = None\n\tcount = 0\n\tfor (i, word) in enumerate(words):\n\t\tif i + 1 < len(words):\n\t\t\tif word == words[i + 1]:\n\t\t\t\tif word != currentWord:\n\t\t\t\t\tcurrentWord = word\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcurrentWord = None\n\treturn count\n", "from itertools import groupby\n\ndef count_adjacent_pairs(st):\n\treturn len([name for (name, group) in groupby(st.lower().split(' ')) if len(list(group)) >= 2])\n", "import re\n\ndef count_adjacent_pairs(s):\n\treturn len(re.findall('(\\\\b.+\\\\b)\\\\1+', s + ' ', re.I))\n", "from itertools import groupby\n\ndef count_adjacent_pairs(s):\n\treturn sum((next(y) == next(y, 0) for (x, y) in groupby(s.lower().split())))\n", "def count_adjacent_pairs(st):\n\t(s, one, two, c) = (st.lower().split(' '), None, None, 0)\n\tfor w in s:\n\t\tc += w == one and w != two\n\t\ttwo = one\n\t\tone = w\n\treturn c\n", "def count_adjacent_pairs(st):\n\tst = st.lower().split()\n\t(check, ret, k) = (None, 0, 0)\n\tfor e in st:\n\t\tif e == check and k:\n\t\t\tcontinue\n\t\tif e == check and (not k):\n\t\t\t(ret, k) = (ret + 1, 1)\n\t\telse:\n\t\t\t(check, k) = (e, 0)\n\treturn ret\n", "import re\ncount_adjacent_pairs = lambda s: len(re.findall('(\\\\b\\\\w+)(\\\\s+\\\\1)+', s, re.I))\n", "from itertools import groupby\n\ndef count_adjacent_pairs(stg):\n\treturn sum((1 for (_, g) in groupby(stg.lower().split()) if len(list(g)) > 1))\n", "def count_adjacent_pairs(st):\n\tif not st:\n\t\treturn 0\n\tres = 0\n\tarr = [i.lower() for i in st.split()]\n\tfor i in range(len(arr) - 1):\n\t\tif i == 0:\n\t\t\tif arr[i] == arr[i + 1]:\n\t\t\t\tres += 1\n\t\telif arr[i] == arr[i + 1] != arr[i - 1]:\n\t\t\tres += 1\n\treturn res\n", "def count_adjacent_pairs(st):\n\tst = st.lower().split()\n\tcnt = 0\n\ton = False\n\tfor i in range(1, len(st)):\n\t\tif st[i] == st[i - 1]:\n\t\t\tif not on:\n\t\t\t\tcnt += 1\n\t\t\t\ton = True\n\t\telse:\n\t\t\ton = False\n\treturn cnt\n"], "593": ["def count_change(money, coins):\n\tif money < 0:\n\t\treturn 0\n\tif money == 0:\n\t\treturn 1\n\tif money > 0 and (not coins):\n\t\treturn 0\n\treturn count_change(money - coins[-1], coins) + count_change(money, coins[:-1])\n", "def count_change(money, coins):\n\tways = [1] + [0] * (money + 1)\n\tfor coin in coins:\n\t\tfor i in range(coin, money + 1):\n\t\t\tways[i] += ways[i - coin]\n\treturn ways[money]\n", "def count_change(money, coins):\n\tA = [1] + [0] * money\n\tfor c in coins:\n\t\tA = [sum(A[:k + 1][::-c]) for k in range(money + 1)]\n\treturn A[-1]\n", "def count_change(money, coins):\n\tresults = [0] * (money + 1)\n\tresults[0] = 1\n\tfor i in coins:\n\t\tfor j in range(i, money + 1):\n\t\t\tresults[j] += results[j - i]\n\treturn results[money]\n", "def count_change(N, coins):\n\tcount = [0] * (N + 1)\n\tcount[0] = 1\n\tfor i in range(len(coins)):\n\t\tj = coins[i]\n\t\twhile j <= N:\n\t\t\tcount[j] += count[j - coins[i]]\n\t\t\tj += 1\n\treturn count[N]\n", "def count_change(money, coins):\n\t(_, coin, rest) = (coins.sort(reverse=True), coins[0], coins[1:])\n\tif not rest:\n\t\treturn int(not money % coin)\n\treturn sum((count_change(money - i, rest) for i in range(0, money + 1, coin)))\n", "def count_change(money, coins):\n\tif len(coins) == 0 or money < 0:\n\t\treturn 0\n\tif money == 0:\n\t\treturn 1\n\treturn count_change(money - coins[0], coins) + count_change(money, coins[1:])\n", "def count_change(money, coins):\n\tif len(coins) == 1:\n\t\treturn 1 if money % coins[0] == 0 else 0\n\tcoins = sorted(coins, reverse=True)\n\treturn sum([count_change(money - i * coins[0], coins[1:]) for i in range(money // coins[0] + 1)])\n"], "607": ["def alan(arr):\n\ts = {'Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway'}\n\treturn 'Smell my cheese you mother!' if s.issubset(arr) else 'No, seriously, run. You will miss it.'\n", "def alan(arr):\n\ta = ['Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway']\n\tfor i in a:\n\t\tif i not in arr:\n\t\t\treturn 'No, seriously, run. You will miss it.'\n\treturn 'Smell my cheese you mother!'\n", "def alan(arr):\n\treturn 'Smell my cheese you mother!' if len(set(arr).intersection(['Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway'])) == 4 else 'No, seriously, run. You will miss it.'\n", "def alan(arr):\n\ta = ['Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway']\n\ts = 0\n\tr = 0\n\td = 0\n\tb = 0\n\tsd = 0\n\tfor x in arr:\n\t\tfor y in a:\n\t\t\tif x == y:\n\t\t\t\ts += 1\n\t\t\t\tif y == 'Rejection':\n\t\t\t\t\tr += 1\n\t\t\t\telif y == 'Disappointment':\n\t\t\t\t\td += 1\n\t\t\t\telif y == 'Backstabbing Central':\n\t\t\t\t\tb += 1\n\t\t\t\telse:\n\t\t\t\t\tsd += 1\n\tif s >= 4 and r > 0 and (d > 0) and (b > 0) and (sd > 0):\n\t\treturn 'Smell my cheese you mother!'\n\telse:\n\t\treturn 'No, seriously, run. You will miss it.'\n", "stops = {'Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway'}\n\ndef alan(lst):\n\treturn 'No, seriously, run. You will miss it.' if stops - set(lst) else 'Smell my cheese you mother!'\n", "alan = lambda l: 'Smell my cheese you mother!' if 'Rejection' in l and 'Disappointment' in l and ('Backstabbing Central' in l) and ('Shattered Dreams Parkway' in l) else 'No, seriously, run. You will miss it.'\n", "alan = lambda a, s={'Shattered Dreams Parkway', 'Backstabbing Central', 'Disappointment', 'Rejection', 'Norwich', 'London'}: ('No, seriously, run. You will miss it.', 'Smell my cheese you mother!')[set(a) & s == s]\n", "def alan(arr):\n\tstops = ['Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway']\n\tcounter = 0\n\tfor i in stops:\n\t\tif i in arr:\n\t\t\tcounter += 1\n\tif counter == len(stops):\n\t\treturn 'Smell my cheese you mother!'\n\treturn 'No, seriously, run. You will miss it.'\n"], "616": ["def animals(heads, legs):\n\t(chickens, cows) = (2 * heads - legs / 2, legs / 2 - heads)\n\tif chickens < 0 or cows < 0 or (not chickens == int(chickens)) or (not cows == int(cows)):\n\t\treturn 'No solutions'\n\treturn (chickens, cows)\n", "def animals(heads, legs):\n\tsolution = (2 * heads - legs / 2, legs / 2 - heads)\n\treturn solution if legs % 2 == 0 and solution[0] >= 0 and (solution[1] >= 0) else 'No solutions'\n", "def animals(heads, legs):\n\tcows = (legs - 2 * heads) / 2\n\tchicken = heads - cows\n\treturn (chicken, cows) if cows == int(cows) and cows >= 0 and (chicken >= 0) else 'No solutions'\n", "def animals(h, l):\n\tco = (l - 2 * h) / 2\n\tch = h - co\n\treturn 'No solutions' if co.is_integer() == False else (h - co, co) if (co < 0 or ch < 0) == False else 'No solutions'\n", "def animals(heads, legs):\n\t(ch, co) = (2 * heads - legs / 2, legs / 2 - heads)\n\treturn (0, 0) if heads == 0 and legs == 0 else (ch, co) if ch == int(ch) and co == int(co) and (ch >= 0) and (co >= 0) else 'No solutions'\n", "def animals(heads, legs):\n\tif heads == 0 and legs == 0:\n\t\treturn (0, 0)\n\tif legs % 2:\n\t\treturn 'No solutions'\n\ty = (legs - 2 * heads) / 2\n\tif int(y) != y or heads - y < 0 or y < 0:\n\t\treturn 'No solutions'\n\telse:\n\t\treturn (heads - y, y)\n", "def animals(heads, legs):\n\taus = ((4 * heads - legs) / 2, (legs - 2 * heads) / 2)\n\treturn aus if all((v >= 0 and v.is_integer() for v in aus)) else 'No solutions'\n", "def animals(heads, legs):\n\t(Chickens, Cows) = (2 * heads - legs / 2, legs / 2 - heads)\n\tif Chickens < 0 or Cows < 0 or (not Chickens == int(Chickens)) or (not Cows == int(Cows)):\n\t\treturn 'No solutions'\n\treturn (Chickens, Cows)\n", "def animals(heads, legs):\n\ta = (4 * heads - legs) / 2\n\tb = (legs - 2 * heads) / 2\n\tif a == int(a) and 0 <= a <= 1000 and (0 <= b <= 1000) and (b == int(b)):\n\t\treturn (a, b)\n\telse:\n\t\treturn 'No solutions'\n", "def animals(heads, legs):\n\tcows = abs((legs - 2 * heads) // 2)\n\tchicken = abs((4 * heads - legs) // 2)\n\treturn (chicken, cows) if cows + chicken == heads else 'No solutions'\n", "animals = lambda h, l: (lambda c=(l - h * 2) / 2: (lambda ch=h - c: (ch, c) if abs(ch) + int(abs(c)) == h else 'No solutions')())()\n", "def animals(heads, legs):\n\tif heads == 0 and legs == 0:\n\t\treturn (0, 0)\n\telif heads <= 0 or legs <= 0:\n\t\treturn 'No solutions'\n\telif heads >= 1000 or legs >= 1000:\n\t\treturn 'No solutions'\n\telif heads * 2 == legs:\n\t\treturn (heads, 0)\n\telif heads * 4 == legs:\n\t\treturn (0, heads)\n\telse:\n\t\tnumber_of_animals = heads\n\t\tchicken = number_of_animals * 2\n\t\tcows = (legs - chicken) / 4 * 2\n\t\tchicken = number_of_animals - cows\n\t\tif chicken <= 0 or cows <= 0:\n\t\t\treturn 'No solutions'\n\t\telif chicken.is_integer():\n\t\t\treturn (chicken, cows)\n\t\telse:\n\t\t\treturn 'No solutions'\n", "from typing import Tuple, Union\n\ndef animals(heads: int, legs: int) -> Union[str, Tuple[int]]:\n\t(chickens, cows) = (heads - (legs / 2 - heads), legs / 2 - heads)\n\treturn (chickens, cows) if not any([chickens < 0, cows < 0, not chickens.is_integer(), not cows.is_integer()]) else 'No solutions'\n", "def animals(heads, legs):\n\treturn (2 * heads - legs // 2, legs // 2 - heads) if not legs % 2 and 2 * heads >= legs // 2 >= heads >= 0 else 'No solutions'\n", "def animals(heads, legs):\n\tif heads * 2 > legs or heads * 4 < legs or legs % 2:\n\t\treturn 'No solutions'\n\tcows = legs // 2 - heads\n\treturn (heads - cows, cows)\n", "def animals(heads, legs):\n\ty = legs / 2 - heads\n\tx = heads - y\n\treturn (x, y) if all([int(x) == x, int(y) == y, x >= 0, y >= 0]) else 'No solutions'\n", "def animals(heads, legs):\n\tfor x in range(heads + 1):\n\t\tif 2 * x + 4 * (heads - x) == legs:\n\t\t\treturn (x, heads - x)\n\treturn 'No solutions'\n", "def animals(heads, legs):\n\tcows = (legs - 2 * heads) / 2\n\tchickens = heads - cows\n\tif '.5' in str(cows) or cows < 0 or chickens < 0:\n\t\treturn 'No solutions'\n\treturn (chickens, cows)\n", "def animals(heads, legs):\n\tif legs < 2 * heads or 4 * heads - legs < 0 or legs * heads < 0 or legs % 2:\n\t\treturn 'No solutions'\n\treturn (int((4 * heads - legs) / 2), int((legs - 2 * heads) / 2))\n", "animals = lambda h, l: l % 2 < 1 and h <= l // 2 <= h * 2 and (2 * h - l // 2, l // 2 - h) or 'No solutions'\n", "animals = lambda h, l: (lambda c: 'No solutions' if c < 0 or c > h or c % 1 != 0 else (h - c, c))((l - 2 * h) / 2.0)\n", "def animals(heads, legs):\n\tchickens = heads - (legs - heads * 2) / 2\n\tcows = (legs - heads * 2) / 2\n\tif heads == 0 and legs == 0:\n\t\treturn (0, 0)\n\telif chickens.is_integer() and chickens >= 0 and cows.is_integer and (cows >= 0):\n\t\treturn (chickens, cows)\n\telse:\n\t\treturn 'No solutions'\n", "def animals(heads, legs):\n\tresult = ((heads * 4 - legs) / 2, heads - (heads * 4 - legs) / 2)\n\tif heads < 0 or legs < 0 or legs % 2 or (min(result) < 0):\n\t\treturn 'No solutions'\n\treturn result\n", "def animals(heads, legs):\n\tchickens = 2 * heads - legs / 2\n\tcows = legs / 2 - heads\n\tif legs >= heads >= 0 and chickens >= 0 and (cows >= 0) and (chickens == chickens // 1) and (cows == cows // 1):\n\t\treturn (chickens, cows)\n\telse:\n\t\treturn 'No solutions'\n"], "634": ["from itertools import combinations\n\ndef count_col_triang(a):\n\t(p, r) = ({}, {})\n\tfor (xy, col) in a:\n\t\tp[col] = p.get(col, []) + [xy]\n\tfor k in p:\n\t\tr[k] = sum((1 for c in combinations(p[k], 3) if triangle(*c)))\n\tmx = max(r.values())\n\treturn [len(a), len(p), sum(r.values()), sorted((k for k in r if r[k] == mx)) + [mx] if mx else []]\n\ndef triangle(a, b, c):\n\treturn area(*[((p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2) ** 0.5 for (p, q) in [(a, b), (a, c), (b, c)]]) > 0.0\n\ndef area(a, b, c):\n\ts = 0.5 * (a + b + c)\n\treturn round(max(s * ((s - a) * (s - b) * (s - c)), 0.0) ** 0.5, 4)\n", "from itertools import combinations\n\ndef grad(a, b):\n\t(rise, tread) = (b[1] - a[1], b[0] - a[0])\n\tif rise == 0 or tread == 0:\n\t\tif rise == tread:\n\t\t\treturn 'p'\n\t\telif rise == 0:\n\t\t\treturn 'y'\n\t\treturn 'x'\n\telse:\n\t\treturn rise / tread\n\ndef collinear(a, b, c):\n\treturn grad(a, b) == grad(b, c)\n\ndef count_col_triang(input_):\n\tcolors = set(map(lambda t: t[1], input_))\n\tpoints = {col: set() for col in colors}\n\tfor (coord, color) in input_:\n\t\tpoints[color].add(tuple(coord))\n\tpoints = {k: list(sorted(v)) for (k, v) in points.items() if len(v) > 2}\n\ttotal = 0\n\tcounts = {}\n\tfor (color, point_list) in points.items():\n\t\tcount = 0\n\t\tfor (a, b, c) in combinations(point_list, 3):\n\t\t\tif not collinear(a, b, c):\n\t\t\t\tcount += 1\n\t\tcounts[color] = count\n\t\ttotal += count\n\tmost_count = max(counts.values())\n\tmost = [c for (c, n) in counts.items() if n == most_count]\n\tmost = [] if most_count == 0 else list(sorted(most)) + [most_count]\n\treturn [len(input_), len(colors), total, most]\n", "def det(m):\n\treturn m[0][0] * (m[1][1] - m[2][1]) + m[1][0] * (m[2][1] - m[0][1]) + m[2][0] * (m[0][1] - m[1][1])\n\ndef count_col_triang(input_):\n\tcolored = []\n\tcolors = {}\n\tn_tri = []\n\tncol = 0\n\tfor (point, color) in input_:\n\t\tif color not in colors:\n\t\t\tcolors[color] = ncol\n\t\t\tcolored.append([])\n\t\t\tn_tri.append(0)\n\t\t\tncol += 1\n\t\tcolored[colors[color]].append(point)\n\tfor (color, cpts) in enumerate(colored):\n\t\tif len(cpts) < 3:\n\t\t\tcontinue\n\t\tfor k in range(len(cpts)):\n\t\t\tfor l in range(k + 1):\n\t\t\t\tfor m in range(l + 1):\n\t\t\t\t\tif det([cpts[k], cpts[l], cpts[m]]) != 0:\n\t\t\t\t\t\tn_tri[color] += 1\n\ttmax = max(n_tri)\n\tclrmax = []\n\tif tmax > 0:\n\t\tfor color in sorted(colors):\n\t\t\tif n_tri[colors[color]] == tmax:\n\t\t\t\tclrmax.append(color)\n\t\tclrmax.append(tmax)\n\treturn [len(input_), ncol, sum(n_tri), clrmax]\n", "from collections import defaultdict\nfrom itertools import combinations\n\ndef count_col_triang(points_colors):\n\tpoint_count = len(points_colors)\n\tcolors = set((color for (points, color) in points_colors))\n\tcolor_count = len(colors)\n\tcolor_points = defaultdict(lambda : False)\n\tfor c in colors:\n\t\tcolor_points[c] = [points for (points, color) in points_colors if color == c]\n\tcolor_points = defaultdict(lambda : False, ((color, points) for (color, points) in color_points.items() if len(points) >= 3))\n\ttriangle_count = 0\n\tcolor_triangle_count = defaultdict(lambda : False)\n\tfor (color, points) in color_points.items():\n\t\tcomb_points = combinations(points, 3)\n\t\tcolor_triangle_count[color] = 0\n\t\t(x, y) = (0, 1)\n\t\tfor vertices in comb_points:\n\t\t\t(va, vb, vc) = vertices\n\t\t\ta = ((vb[x] - va[x]) ** 2 + (vb[y] - va[y]) ** 2) ** 0.5\n\t\t\tb = ((vc[x] - vb[x]) ** 2 + (vc[y] - vb[y]) ** 2) ** 0.5\n\t\t\tc = ((va[x] - vc[x]) ** 2 + (va[y] - vc[y]) ** 2) ** 0.5\n\t\t\ts = (a + b + c) / 2\n\t\t\tarea = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n\t\t\tif area != 0:\n\t\t\t\ttriangle_count += 1\n\t\t\t\tcolor_triangle_count[color] += 1\n\tmax_count = max(color_triangle_count.values())\n\tcolors_max_count = sorted([color for (color, count) in color_triangle_count.items() if count == max_count])\n\tcolors_max_count.append(max_count)\n\tif max_count <= 0:\n\t\tcolors_max_count = []\n\treturn [point_count, color_count, triangle_count, colors_max_count]\n", "from itertools import combinations as combos\n\ndef count_col_triang(in_):\n\tcl = list(set([i[1] for i in in_]))\n\td = {}\n\tfor c in cl:\n\t\ttriples = combos([i[0] + [1] for i in in_ if i[1] == c], 3)\n\t\ttest_matrices = list(map(list, triples))\n\t\td[c] = len([i for i in test_matrices if determinant(i)])\n\tmc = max(d, key=d.get)\n\tmaxcl = sorted([c for c in cl if d[c] and d[c] == d[mc]])\n\tsumtri = sum([d[i] for i in d])\n\treturn [len(in_), len(cl), sumtri, maxcl + [d[mc]] if sumtri else []]\n\ndef determinant(m):\n\t(a, b, c, d, e, f, g, h, i) = tuple(m[0] + m[1] + m[2])\n\treturn a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n", "import numpy as np\nfrom itertools import combinations\n\ndef ctri(lst):\n\tif len(lst) < 3:\n\t\treturn 0\n\treturn sum((1 for j in combinations(lst, 3) if abs(np.linalg.det(np.mat([i + [1] for i in j]))) > 0.001))\n\ndef count_col_triang(ipt):\n\td = {}\n\tfor i in ipt:\n\t\tif i[1] not in d:\n\t\t\td[i[1]] = [i[0]]\n\t\telse:\n\t\t\td[i[1]].append(i[0])\n\tp = {i: ctri(d[i]) for i in d}\n\tpmax = max(p.values())\n\tplst = [] if pmax == 0 else sorted([i for i in p if p[i] == pmax]) + [pmax]\n\treturn [len(ipt), len(p), sum(p.values()), plst]\n", "from itertools import combinations\nfrom collections import defaultdict\n\ndef crossProd(v1, v2):\n\treturn v1[0] * v2[1] - v2[0] * v1[1]\n\ndef vectorize(pt1, pt2):\n\treturn [b - a for (a, b) in zip(pt1, pt2)]\n\ndef notOnSameLine(*pts):\n\treturn bool(crossProd(vectorize(*pts[:2]), vectorize(*pts[1:])))\n\ndef count_col_triang(input_):\n\tdctPts = defaultdict(list)\n\tfor (pos, color) in input_:\n\t\tdctPts[color].append(pos)\n\tdctTriangles = {color: sum((notOnSameLine(*threePts) for threePts in combinations(lst, 3))) for (color, lst) in dctPts.items()}\n\tmaxTriangles = max(dctTriangles.values())\n\treturn [len(input_), len(dctPts), sum(dctTriangles.values()), sorted((color for (color, n) in dctTriangles.items() if n == maxTriangles)) + [maxTriangles] if maxTriangles else []]\n", "from itertools import combinations, groupby, starmap\nis_triangle = lambda a, b, c: (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) != 0\nis_triangle = lambda a, b, c: a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1]) != 0\n\ndef count_col_triang(input_):\n\tgrouped = groupby(sorted(input_, key=lambda p: p[1]), key=lambda p: p[1])\n\tcolored_triangles = {k: sum(starmap(is_triangle, combinations((p for (p, _) in g), 3))) for (k, g) in grouped}\n\tmax_colored = max(colored_triangles.values())\n\treturn [len(input_), len(colored_triangles), sum(colored_triangles.values()), sorted((c for (c, n) in colored_triangles.items() if n == max_colored)) + [max_colored] if max_colored else []]\n"], "685": ["l = {'one': 5, 'two': 4, 'three': 3, 'four': 2, 'five': 1, 'six': 0}\ny = {'hhh': '----o----', 'hht': '---- ----', 'htt': '---------', 'ttt': '----x----'}\n\ndef oracle(arr):\n\ts = [''] * 6\n\tfor x in arr:\n\t\ts[l[x[0]]] = y[''.join(sorted(x[1:]))]\n\treturn '\\n'.join(s)\n", "ORDER = 'one two three four five six'.split()[::-1]\nTBL = {'ttt': '----x----', 'htt': '---------', 'hht': '---- ----', 'hhh': '----o----'}\n\ndef oracle(arr):\n\td = {n: TBL[''.join(sorted(rest))] for (n, *rest) in arr}\n\treturn '\\n'.join((d[o] for o in ORDER))\n", "nums = ['six', 'five', 'four', 'three', 'two', 'one']\nlines = {'hhh': '----o----', 'hht': '---- ----', 'htt': '---------', 'ttt': '----x----'}\n\ndef oracle(arr):\n\treturn '\\n'.join((lines[''.join(sorted(l[1:]))] for l in sorted(arr, key=lambda l: nums.index(l[0]))))\n", "def oracle(arr):\n\treturn '\\n'.join(('----{}----'.format('x- o'[item.count('h')]) for item in sorted(arr, key=lambda x: 'six five four three two one'.index(x[0]))))\n", "POS = {'one': 5, 'two': 4, 'three': 3, 'four': 2, 'five': 1, 'six': 0}\nTYPE = {'ttt': 'x', 'htt': '-', 'hht': ' ', 'hhh': 'o'}\nLINE = '----{}----'\n\ndef oracle(arr):\n\tlst = [0] * 6\n\tfor params in arr:\n\t\tlst[POS[params[0]]] = LINE.format(TYPE[''.join(sorted(params[1:]))])\n\treturn '\\n'.join(lst)\n", "ORDER = ('six', 'five', 'four', 'three', 'two', 'one')\nYIN_YANG = {'hhh': '----o----', 'hht': '---- ----', 'htt': '---------', 'ttt': '----x----'}\n\ndef oracle(arr):\n\treturn '\\n'.join((YIN_YANG[''.join(sorted(a[1:]))] for a in sorted(arr, key=lambda b: ORDER.index(b[0]))))\n", "def oracle(arr):\n\tlines = ['----x----', '---------', '---- ----', '----o----']\n\tdata = {row[0]: row[1:].count('h') for row in arr}\n\tarr = [data[key] for key in ['six', 'five', 'four', 'three', 'two', 'one']]\n\treturn '\\n'.join((lines[count] for count in arr))\n", "oracle = lambda a: '\\n'.join(('----%s----' % 'x- o'[i.count('h')] for i in sorted(a, key=lambda x: -ord(x[0][2]))))\n", "def oracle(arr):\n\treturn '\\n'.join((f\"----{'x- o'[l.count('h')]}----\" for l in sorted(arr, key=lambda l: 'xvuroe'.index(l[0][2]))))\n", "d = {'one': 5, 'two': 4, 'three': 3, 'four': 2, 'five': 1, 'six': 0}\nok = {(2, 1): '---- ----', (1, 2): '---------', (3, 0): '----o----', (0, 3): '----x----'}\noracle = lambda a: '\\n'.join([ok[i[1:].count('h'), i[1:].count('t')] for i in sorted(a, key=lambda x: d[x[0]])])\n"], "689": ["from itertools import combinations_with_replacement\n\ndef find_all(sum_dig, digs):\n\tcombs = combinations_with_replacement(list(range(1, 10)), digs)\n\ttarget = [''.join((str(x) for x in list(comb))) for comb in combs if sum(comb) == sum_dig]\n\tif not target:\n\t\treturn []\n\treturn [len(target), int(target[0]), int(target[-1])]\n", "def find_all(s, d):\n\txs = [x for x in digs(d) if sum(x) == s]\n\tif not xs:\n\t\treturn []\n\telse:\n\t\treduce_int = lambda xs: int(''.join(map(str, xs)))\n\t\tmin = reduce_int(xs[0])\n\t\tmax = reduce_int(xs[-1])\n\t\treturn [len(xs), min, max]\n\ndef digs(d, start=1):\n\tif d == 1:\n\t\tfor x in range(start, 10):\n\t\t\tyield [x]\n\telse:\n\t\tfor x in range(start, 10):\n\t\t\tfor y in digs(d - 1, x):\n\t\t\t\tyield ([x] + y)\n", "from itertools import combinations_with_replacement\n\ndef find_all(sum_dig, digs):\n\tx = [int(''.join(x)) for x in combinations_with_replacement('123456789', digs) if sum(map(int, x)) == sum_dig]\n\treturn [len(x), min(x), max(x)] if len(x) > 0 else []\n", "def next_contig_number(n):\n\tn = [int(x) for x in str(n + 1)]\n\tfor i in range(1, len(n)):\n\t\tn[i] = max(n[i], n[i - 1])\n\treturn int(''.join(map(str, n)))\n\ndef find_all(sum_dig, digs):\n\tcount = 0\n\tsmallest = float('Inf')\n\tlargest = float('-Inf')\n\tn = 10 ** (digs - 1)\n\tlimit = 10 ** digs - 1\n\twhile n < limit:\n\t\tn = next_contig_number(n)\n\t\ttotal = 0\n\t\tfor x in map(int, str(n)):\n\t\t\ttotal += x\n\t\t\tif total > sum_dig:\n\t\t\t\tbreak\n\t\tif total == sum_dig:\n\t\t\tcount += 1\n\t\t\tsmallest = min(smallest, n)\n\t\t\tlargest = max(largest, n)\n\treturn [count, smallest, largest] if count else []\n", "def ways(t, n, d):\n\treturn [e for l in [[int(str(i) + str(e)) for e in ways(t - i, n - 1, [k for k in d if k >= i])] for i in d] for e in l] if n > 1 else [t] if t in d else []\n\ndef find_all(target, n):\n\tr = ways(target, n, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\treturn [len(r), min(r), max(r)] if r else []\n", "def find_all(sum_dig, digits):\n\tif sum_dig > digits * 9:\n\t\treturn []\n\tnum = [1] * digits\n\tres = []\n\twhile num[0] != 10:\n\t\tif sum(num) == sum_dig:\n\t\t\tres.append(int(''.join(map(str, num))))\n\t\tfor i in range(digits - 1, -1, -1):\n\t\t\tnum[i] += 1\n\t\t\tif num[i] != 10:\n\t\t\t\tbreak\n\t\tfor i in range(1, digits):\n\t\t\tif num[i] == 10:\n\t\t\t\tnum = num[:i] + [num[i - 1]] * (digits - i)\n\t\t\t\tbreak\n\treturn [len(res), res[0], res[-1]]\n", "def num_ways(sum_dig, digs, ceiling=8):\n\tif sum_dig < 0:\n\t\treturn 0\n\tif sum_dig == 0:\n\t\treturn 1\n\tif sum_dig > digs * ceiling:\n\t\treturn 0\n\tif sum_dig == 1:\n\t\treturn 1\n\tif digs == 1:\n\t\treturn 1 if 0 <= sum_dig <= ceiling else 0\n\ttarg_num = 0\n\tfor i in range(10):\n\t\ttarg_num += num_ways(sum_dig - i * digs, digs - 1, ceiling=ceiling - i)\n\treturn targ_num\n\ndef find_all(sum_dig, digs):\n\tmin_sum = digs\n\tmax_sum = digs * 9\n\tif sum_dig < min_sum or sum_dig > max_sum:\n\t\treturn []\n\tmin_list = [1 for i in range(digs)]\n\tmin_sum_dig = sum_dig - digs\n\tfor i in reversed(list(range(digs))):\n\t\tif min_sum_dig <= 8:\n\t\t\tmin_list[i] += min_sum_dig\n\t\t\tbreak\n\t\telse:\n\t\t\tmin_list[i] += 8\n\t\t\tmin_sum_dig -= 8\n\tmin_num = int(''.join([str(i) for i in min_list]))\n\tmax_base = int(sum_dig / digs)\n\tmax_list = [max_base for i in range(digs)]\n\tfor i in range(sum_dig % digs):\n\t\tmax_list[-1 - i] += 1\n\tmax_num = int(''.join([str(i) for i in max_list]))\n\tnum_way = num_ways(sum_dig - digs, digs)\n\treturn [num_way, min_num, max_num]\n", "def find_all(sum_dig, digs):\n\tif sum_dig > 9 * digs:\n\t\treturn []\n\tall = [x for x in growing_digits(digs - 1) if digit_sum(x) == sum_dig]\n\treturn [len(all), all[0], all[-1]]\n\ndef digit_sum(num):\n\treturn sum((int(digit) for digit in str(num)))\n\ndef growing_digits(order, start=1):\n\tfor l in range(start, 10):\n\t\tif order == 0:\n\t\t\tyield l\n\t\telse:\n\t\t\tfor r in growing_digits(order - 1, start=l):\n\t\t\t\tyield (l * 10 ** order + r)\n", "def find_all(sum_dig, digs):\n\tmn = float('inf')\n\tmx = -float('inf')\n\n\tdef rec(i, sm, path):\n\t\tnonlocal mn, mx\n\t\tif i >= digs:\n\t\t\tif sum_dig == sm:\n\t\t\t\tnum = int(''.join(path))\n\t\t\t\tmn = min(mn, num)\n\t\t\t\tmx = max(mn, num)\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tj = 1\n\t\tif path:\n\t\t\tj = int(path[-1])\n\t\tres = 0\n\t\tfor k in range(j, 10):\n\t\t\tres += rec(i + 1, sm + k, path + [str(k)])\n\t\treturn res\n\tcnt = rec(0, 0, [])\n\tif mn == float('inf') or mx == -float('inf'):\n\t\treturn []\n\treturn [cnt, mn, mx]\n", "def find_all(sum_dig, digs):\n\n\tdef rec(ds=digs, min_dig=1, sum_prev=0):\n\t\tfor i in range(min_dig, 10):\n\t\t\tsum_cur = sum_prev + i\n\t\t\tif ds == 1:\n\t\t\t\tif sum_cur == sum_dig:\n\t\t\t\t\tyield str(i)\n\t\t\telif sum_cur < sum_dig:\n\t\t\t\tfor r in rec(ds - 1, i, sum_cur):\n\t\t\t\t\tyield (str(i) + r)\n\tresults = [int(s) for s in rec()]\n\treturn [len(results), min(results), max(results)] if results else []\n"], "694": ["triangular_sum = lambda n: (-0.5 + (1 + 8 * n) ** 0.5 / 2.0) ** 0.5 % 1 == 0\n", "from math import sqrt\n\ndef triangular_sum(n):\n\treturn sqrt(2 * (sqrt(8 * n + 1) - 1)) % 2 == 0\n", "def triangular_sum(n):\n\tr = int((n * 2) ** 0.5)\n\treturn r * (r + 1) / 2 == n and round(r ** 0.5) ** 2 == r\n", "def triangular_sum(n):\n\treturn ((2 * n + 0.25) ** 0.5 - 0.5) ** 0.5 % 1 == 0\n", "triangular_sum = lambda n: not ((32 * n + 4) ** 0.5 - 2) ** 0.5 % 1\n", "t = [n * (n + 1) // 2 for n in range(2, 32000)]\nmemo = {a ** 2 + b ** 2 for (a, b) in zip(t, t[1:])}\n\ndef triangular_sum(n):\n\treturn n in memo\n", "a = [i * (i + 1) // 2 for i in range(211)]\nb = [i ** 2 + j ** 2 for (i, j) in zip(a, a[1:])]\n\ndef triangular_sum(n):\n\treturn n in b\n", "def triangular_sum(n):\n\treturn ((((1 + 8 * n) ** 0.5 - 1) / 2) ** 0.5).is_integer()\n", "def triangular_sum(t):\n\ttriangles = [1]\n\tn = 2\n\twhile triangles[-1] < t ** 0.5:\n\t\ttriangles.append(triangles[-1] + n)\n\t\tn += 1\n\tfor n1 in triangles:\n\t\tfor n2 in triangles:\n\t\t\tif n1 != n2 and n1 * n1 + n2 * n2 == t:\n\t\t\t\treturn True\n\treturn False\n"], "706": ["def logistic_map(width, height, xs, ys):\n\treturn [[min([abs(x - x2) + abs(y - ys[i]) for (i, x2) in enumerate(xs)]) if len(xs) else None for x in range(width)] for y in range(height)]\n", "def logistic_map(w, h, xs, ys):\n\tmd = lambda i, j: min((abs(x - i) + abs(y - j) for (x, y) in zip(xs, ys)), default=None)\n\treturn [[md(i, j) for i in range(w)] for j in range(h)]\n", "from sklearn.neighbors import NearestNeighbors\nfrom itertools import product\n\ndef logistic_map(width, height, xs, ys):\n\tif not xs:\n\t\treturn [[None] * width for _ in range(height)]\n\tneigh = NearestNeighbors(1, metric='manhattan')\n\tneigh.fit(list(zip(ys, xs)))\n\tit = iter(neigh.kneighbors(list(product(range(height), range(width))))[0])\n\treturn [[next(it)[0] for _ in range(width)] for _ in range(height)]\n", "def logistic_map(n, m, x, y):\n\tco = [[i, j] for (i, j) in zip(y, x)]\n\treturn [[min([abs(k - i) + abs(l - j) for (k, l) in co]) if co else None for j in range(n)] for i in range(m)]\n", "def smallest_dist(x, y, xs, ys):\n\tmin = None\n\tfor i in range(len(xs)):\n\t\tv = abs(xs[i] - x) + abs(ys[i] - y)\n\t\tmin = (min, v)[min == None or min > v]\n\treturn min\n\ndef logistic_map(w, h, xs, ys):\n\treturn [[smallest_dist(x, y, xs, ys) for x in range(w)] for y in range(h)]\n", "def logistic_map(width, height, xs, ys):\n\tneighbours = lambda c: {(c[0] + i, c[1] + j) for (i, j) in [(0, 1), (1, 0), (0, -1), (-1, 0)] if 0 <= c[0] + i < width and 0 <= c[1] + j < height}\n\tgrid = [[None] * width for _ in range(height)]\n\t(distance, seen, bag) = (0, set(), set(zip(xs, ys)))\n\twhile bag:\n\t\tfor (x, y) in bag:\n\t\t\tgrid[y][x] = distance\n\t\tseen |= bag\n\t\tbag = set.union(*map(neighbours, bag)) - seen\n\t\tdistance += 1\n\treturn grid\n", "def logistic_map(width, height, xs, ys):\n\tgrid = []\n\tsupply = [(xs[i], ys[i]) for i in range(len(xs))]\n\tfor y in range(height):\n\t\tgrid.append([])\n\t\tfor x in range(width):\n\t\t\tgrid[y].append(min([abs(x - sx) + abs(y - sy) for (sx, sy) in supply]) if supply else None)\n\treturn grid\n", "def logistic_map(width, height, xs, ys):\n\tsupply_stops = zip(*[xs, ys])\n\tpoints = [[None for x in range(width)] for x in range(height)]\n\tfor s in supply_stops:\n\t\tfor i in range(width):\n\t\t\tfor j in range(height):\n\t\t\t\td_cur = abs(s[0] - i) + abs(s[1] - j)\n\t\t\t\td_pnt = points[j][i]\n\t\t\t\tif d_pnt == None or d_cur < d_pnt:\n\t\t\t\t\tpoints[j][i] = d_cur\n\treturn points\n", "def manhattan_distance(x, y, x2, y2):\n\treturn abs(x - x2) + abs(y - y2)\n\ndef logistic_map(width, height, x_list, y_list):\n\tmatrix = [[None for __ in range(width)] for _ in range(height)]\n\tif not x_list or not y_list:\n\t\treturn matrix\n\tsupply_points = set(zip(y_list, x_list))\n\tfor (r, row) in enumerate(matrix):\n\t\tfor (c, col_item) in enumerate(row):\n\t\t\tif col_item != 0:\n\t\t\t\tmatrix[r][c] = min((manhattan_distance(r, c, x2, y2) for (x2, y2) in supply_points))\n\treturn matrix\n"], "714": ["def ipv4__parser(addr, mask):\n\treturn tuple(('.'.join((str(n) for n in a)) for a in zip(*((a & m, a & ~m) for (a, m) in zip((int(n) for n in addr.split('.')), (int(n) for n in mask.split('.')))))))\n", "from socket import inet_aton, inet_ntoa\nfrom struct import Struct\nAddr = Struct('>I')\n\ndef ipv4__parser(ip_addr, mask):\n\t(i,) = Addr.unpack(inet_aton(ip_addr))\n\t(m,) = Addr.unpack(inet_aton(mask))\n\treturn (inet_ntoa(Addr.pack(i & m)), inet_ntoa(Addr.pack(i & ~m)))\n", "from socket import inet_aton, inet_ntoa\nfrom struct import unpack, pack\nto_int = lambda s: unpack('>L', inet_aton(s))[0]\nto_ip = lambda x: inet_ntoa(pack('>L', x))\n\ndef ipv4__parser(ip_addr, mask):\n\t(ip, m) = (to_int(ip_addr), to_int(mask))\n\treturn (to_ip(ip & m), to_ip(ip & ~m))\n", "def ipv4__parser(ip_addr, mask):\n\tarr = [(int(p), int(m)) for (p, m) in zip(ip_addr.split('.'), mask.split('.'))]\n\treturn ('.'.join((str(a & b) for (a, b) in arr)), '.'.join((str(a & b ^ a) for (a, b) in arr)))\n", "def ipv4__parser(ip_addr, mask):\n\tnet_addr = '.'.join((str(int(a) & int(b)) for (a, b) in zip(ip_addr.split('.'), mask.split('.'))))\n\thost_addr = '.'.join((str(int(a) & 255 - int(b)) for (a, b) in zip(ip_addr.split('.'), mask.split('.'))))\n\treturn (net_addr, host_addr)\n", "def ipv4__parser(ip_addr, mask):\n\thost = []\n\tnetwork = []\n\tip_addr = [int(s) for s in ip_addr.split('.')]\n\tmask = [int(s) for s in mask.split('.')]\n\tfor octet in range(4):\n\t\thost += [ip_addr[octet] & mask[octet]]\n\t\tnetwork += [ip_addr[octet] & ~mask[octet]]\n\thost = [str(i) for i in host]\n\tnetwork = [str(i) for i in network]\n\treturn ('.'.join(host), '.'.join(network))\n", "def ipv4__parser(ip, m):\n\t(n, h) = ('', '')\n\tfor (i, j) in zip(ip.split('.'), m.split('.')):\n\t\tr = int(''.join([str(int(k) & int(l)) for (k, l) in zip(bin(int(i))[2:].zfill(8), bin(int(j))[2:].zfill(8))]), 2)\n\t\tn += str(r) + '.'\n\t\th += str(int(i) - r) + '.'\n\treturn (n.strip('.'), h.strip('.'))\n", "def ipv4__parser(ip_addr, mask):\n\t(ip, sMask) = (ip_addr.split('.'), mask.split('.'))\n\tnb = [str(int(a) & int(b)) for (a, b) in zip(ip, sMask)]\n\thi = [str(int(a) - int(b)) for (a, b) in zip(ip, nb)]\n\treturn ('.'.join(nb), '.'.join(hi))\n", "def ipv4__parser(ip_addr, mask):\n\tnet_addr = '.'.join([str(int(i) & int(m)) for (i, m) in zip(ip_addr.split('.'), mask.split('.'))])\n\thost_addr = '.'.join([str(int(i) - int(n)) for (i, n) in zip(ip_addr.split('.'), net_addr.split('.'))])\n\treturn (net_addr, host_addr)\n", "def to_int(n):\n\treturn sum((int(i) * 256 ** e for (e, i) in enumerate(reversed(n.split('.')))))\n\ndef to_ip(n):\n\treturn '.'.join((str(n // 256 ** e & 255) for e in range(3, -1, -1)))\n\ndef ipv4__parser(ip_addr, mask):\n\taddr = to_int(ip_addr)\n\tmask = to_int(mask)\n\treturn (to_ip(addr & mask), to_ip(addr & ~mask))\n"], "746": ["from fractions import Fraction\n\ndef expand(x, digit):\n\tstep = 0\n\tfact = 1\n\texpo = Fraction(1)\n\tn = 10 ** len(str(x).split('.')[-1])\n\tx = Fraction(int(x * n), n)\n\twhile expo.numerator < 10 ** (digit - 1):\n\t\tstep += 1\n\t\tfact *= step\n\t\texpo += x ** step / fact\n\treturn [expo.numerator, expo.denominator]\n", "from fractions import Fraction, gcd\nfrom math import floor\nfrom decimal import Decimal\n\ndef expand(x, digit):\n\tx = Fraction(Decimal(str(x)))\n\tres = Fraction(1)\n\tnew = Fraction(1)\n\texponent = 0\n\twhile len(str(res.numerator)) < digit:\n\t\texponent += 1\n\t\tnew *= x / exponent\n\t\tres += new\n\treturn [res.numerator, res.denominator]\n", "from fractions import Fraction\nfrom math import factorial\n\ndef expand(x, digit, i=0, s=0):\n\tif x == 1 and digit == 5:\n\t\treturn [109601, 40320]\n\ts = s + Fraction(Fraction(x).limit_denominator(digit) ** i, factorial(i))\n\tif len(str(s.numerator)) >= digit:\n\t\treturn [s.numerator, s.denominator]\n\treturn expand(x, digit, i=i + 1, s=s)\n", "import math\nfrom fractions import Fraction\nfrom decimal import Decimal\n\ndef expand(x, digit):\n\tx = Fraction(Decimal(x)).limit_denominator(digit)\n\tincr = 0\n\tex = 0\n\twhile len(str(ex.numerator)) < digit:\n\t\tex += Fraction(x ** incr, math.factorial(incr))\n\t\tincr = incr + 1\n\treturn [ex.numerator, ex.denominator]\n", "from math import factorial, gcd\nfrom fractions import Fraction\n\ndef expand(x, digit):\n\t(n, d) = (1, factorial(0))\n\ti = 1\n\tx = Fraction(x).limit_denominator(10000)\n\tx1 = x.numerator\n\tx2 = x.denominator\n\twhile True:\n\t\tb = factorial(i)\n\t\tif len(str(n)) < digit:\n\t\t\tn = pow(x1, i) * d + n * b * pow(x2, i)\n\t\t\td *= b * pow(x2, i)\n\t\t\tc = gcd(n, d)\n\t\t\tn //= c\n\t\t\td //= c\n\t\telse:\n\t\t\tbreak\n\t\ti += 1\n\treturn [n, d]\n", "from collections import defaultdict\nfrom fractions import Fraction\nfrom itertools import count\nPOWER = defaultdict(list)\nF = [1]\n\ndef fact(x):\n\twhile len(F) <= x:\n\t\tF.append(F[-1] * len(F))\n\treturn F[x]\n\ndef expand(x, digit):\n\tif type(x) == float:\n\t\t(a, b) = str(x).split('.')\n\t\tl = 10 ** len(b)\n\t\tx = Fraction(int(a) * l + int(b), l)\n\t(res, mini) = (Fraction(0), 10 ** (digit - 1))\n\tif not x in POWER:\n\t\tPOWER[x].append(1)\n\tfor i in count():\n\t\tres += Fraction(POWER[x][i], fact(i))\n\t\tif mini <= res.numerator:\n\t\t\treturn [res.numerator, res.denominator]\n\t\tif len(POWER[x]) <= i + 1:\n\t\t\tPOWER[x].append(POWER[x][-1] * x)\n", "import fractions as fr\nfrom decimal import Decimal as Dec\n\ndef expand(x, digit):\n\tf = fr.Fraction(Dec(x)).limit_denominator()\n\t(xn, xd) = (f.numerator, f.denominator)\n\t(i, n, num, den) = (0, 1, 1, 1)\n\twhile len(str(n)) < digit:\n\t\ti += 1\n\t\tnum = num * i * xd + xn ** i\n\t\tden *= i * xd\n\t\tf = fr.Fraction(num, den)\n\t\t(n, d) = (f.numerator, f.denominator)\n\treturn [n, d]\n", "from fractions import Fraction, gcd\nfrom math import floor\n\ndef float_to_rat(x):\n\n\tdef is_int(x):\n\t\treturn x == floor(x)\n\td = 1\n\twhile not is_int(x):\n\t\tx *= 10\n\t\td *= 10\n\tx = int(x)\n\tg = gcd(x, d)\n\treturn [x // g, d // g]\n\ndef expand(x, digit):\n\t[a, b] = float_to_rat(x)\n\tx = Fraction(a, b)\n\tres = Fraction(1)\n\tnew = Fraction(1)\n\texponent = 0\n\twhile len(str(res.numerator)) < digit:\n\t\texponent += 1\n\t\tnew *= x / exponent\n\t\tres += new\n\treturn [res.numerator, res.denominator]\n", "import math\nfrom fractions import Fraction\n\ndef expand(x, digit):\n\tanswer = Fraction(1, 1)\n\tn = 1\n\twhile len(str(answer.numerator)) < digit:\n\t\tanswer += Fraction(Fraction(str(x)) ** n, math.factorial(n))\n\t\tn += 1\n\tf_answer = [answer.numerator, answer.denominator]\n\treturn f_answer\n"], "748": ["def zombie_shootout(zombies, distance, ammo, shot=0):\n\tif not zombies:\n\t\treturn f'You shot all {shot} zombies.'\n\tif distance <= 0:\n\t\treturn f'You shot {shot} zombies before being eaten: overwhelmed.'\n\tif not ammo:\n\t\treturn f'You shot {shot} zombies before being eaten: ran out of ammo.'\n\treturn zombie_shootout(zombies - 1, distance - 0.5, ammo - 1, shot + 1)\n", "def zombie_shootout(z, r, a):\n\ts = min(r * 2, a)\n\treturn f'You shot all {z} zombies.' if s >= z else f\"You shot {s} zombies before being eaten: {('overwhelmed' if s == 2 * r else 'ran out of ammo')}.\"\n", "def zombie_shootout(zombies, distance, ammo):\n\tif distance * 2 < min(ammo + 1, zombies):\n\t\treturn f'You shot {distance * 2} zombies before being eaten: overwhelmed.'\n\tif ammo < zombies:\n\t\treturn f'You shot {ammo} zombies before being eaten: ran out of ammo.'\n\treturn f'You shot all {zombies} zombies.'\n", "def zombie_shootout(zombies, range, ammo):\n\tdistance = range * 2\n\tif zombies > ammo < distance:\n\t\treturn f'You shot {ammo} zombies before being eaten: ran out of ammo.'\n\telif zombies > distance:\n\t\treturn f'You shot {distance} zombies before being eaten: overwhelmed.'\n\treturn f'You shot all {zombies} zombies.'\n", "def zombie_shootout(zombies, distance, ammo):\n\tsa = ammo - zombies\n\tsd = distance * 2 - zombies\n\tif sa < 0 or sd < 0:\n\t\tif sd > sa:\n\t\t\treturn f'You shot {ammo} zombies before being eaten: ran out of ammo.'\n\t\telse:\n\t\t\treturn f'You shot {distance * 2} zombies before being eaten: overwhelmed.'\n\treturn f'You shot all {zombies} zombies.'\n", "def zombie_shootout(zombies, distance, ammo):\n\tresults = {f'You shot all {zombies} zombies.': zombies, f'You shot {distance * 2} zombies before being eaten: overwhelmed.': distance * 2, f'You shot {ammo} zombies before being eaten: ran out of ammo.': ammo}\n\treturn min(results, key=results.get)\n", "def zombie_shootout(zombies, distance, ammo):\n\tshot = 0\n\twhile distance > 0 and ammo > 0 and (zombies > 0):\n\t\tzombies -= 1\n\t\tammo -= 1\n\t\tdistance -= 0.5\n\t\tshot += 1\n\tif zombies == 0:\n\t\treturn 'You shot all ' + str(shot) + ' zombies.'\n\telif distance == 0:\n\t\treturn 'You shot ' + str(shot) + ' zombies before being eaten: overwhelmed.'\n\telse:\n\t\treturn 'You shot ' + str(shot) + ' zombies before being eaten: ran out of ammo.'\n", "def zombie_shootout(zombies, distance, ammo):\n\tif ammo >= zombies and 2 * distance >= zombies:\n\t\treturn 'You shot all {} zombies.'.format(zombies)\n\telif ammo < zombies and ammo < 2 * distance:\n\t\treturn 'You shot {} zombies before being eaten: ran out of ammo.'.format(ammo)\n\telse:\n\t\treturn 'You shot {} zombies before being eaten: overwhelmed.'.format(2 * distance)\n"], "756": ["MEMO = []\n\ndef sum_dif_rev(n):\n\ti = MEMO[-1] if MEMO else 0\n\twhile len(MEMO) < n:\n\t\ti += 1\n\t\tr = int(str(i)[::-1])\n\t\tif i % 10 and r != i and ((i + r) % abs(r - i) == 0):\n\t\t\tMEMO.append(i)\n\treturn MEMO[n - 1]\n", "from itertools import count\n\ndef gen():\n\tfor x in count(0, 9):\n\t\ty = int(str(x)[::-1])\n\t\tif x != y and x % 10 and ((x + y) % abs(x - y) == 0):\n\t\t\tyield x\n(numbers, result) = (gen(), [])\n\ndef sum_dif_rev(n):\n\twhile len(result) < n:\n\t\tresult.append(next(numbers))\n\treturn result[n - 1]\n", "def sum_dif_rev(num):\n\tn = 36\n\twhile num:\n\t\tn += 9\n\t\tif n % 10 == 0:\n\t\t\tcontinue\n\t\tr = int(str(n)[::-1])\n\t\tif n != r and (n + r) % abs(n - r) == 0:\n\t\t\tnum -= 1\n\treturn n\n", "def memoize_sum_dif(f):\n\tmemory = {}\n\n\tdef inner(n):\n\t\tif n not in memory:\n\t\t\tmemory[n] = f(n)\n\t\treturn memory[n]\n\treturn inner\n\n@memoize_sum_dif\ndef sum_dif_rev(n):\n\tif n == 1:\n\t\treturn 45\n\tnum = sum_dif_rev(n - 1)\n\twhile True:\n\t\tnum = num + 1\n\t\tif str(num)[::-1][0] == '0' or abs(num - int(str(num)[::-1])) == 0:\n\t\t\tcontinue\n\t\tif (num + int(str(num)[::-1])) % abs(num - int(str(num)[::-1])) == 0:\n\t\t\tbreak\n\treturn num\n", "def sum_dif():\n\tyield 45\n\tyield 54\n\tyield 495\n\tyield 594\n\tn1 = 595\n\twhile True:\n\t\tn_rev = str(n1)[::-1]\n\t\tif n_rev[0] == '0':\n\t\t\tn1 += 1\n\t\t\tcontinue\n\t\tn_rev_int = int(n_rev)\n\t\tif n1 - n_rev_int != 0 and (n1 + n_rev_int) % abs(n1 - n_rev_int) == 0:\n\t\t\tyield n1\n\t\tn1 += 1\n\ndef sum_dif_rev(n):\n\tp = sum_dif()\n\treturn [next(p) for x in range(1, n + 1)][-1]\n", "def sum_dif_rev(n):\n\tk = 0\n\ti = 1\n\twhile i <= n:\n\t\tk += 1\n\t\tif str(k)[-1] != '0':\n\t\t\tp = int(str(k)[::-1])\n\t\t\tif abs(p - k) != 0:\n\t\t\t\tif (p + k) % abs(p - k) == 0:\n\t\t\t\t\ti += 1\n\treturn k\n", "buf = [45, 54, 495, 594]\n\ndef sum_dif_rev(n):\n\ti = buf[-1]\n\twhile len(buf) < n:\n\t\ti += 1\n\t\tj = int(str(i)[::-1])\n\t\td = abs(i - j)\n\t\tif i % 10 and d and (not (i + j) % d):\n\t\t\tbuf.append(i)\n\treturn buf[n - 1]\n"], "763": ["def pig_latin(word):\n\treturn word[1:] + word[0] + 'ay' if len(word) > 3 else word\n", "def pig_latin(word):\n\treturn word if len(word) < 4 else word[1:] + word[0] + 'ay'\n", "def pig_latin(word):\n\treturn word if len(word) < 4 else f'{word[1:]}{word[:1]}ay'\n", "def pig_latin(s):\n\treturn '{}{}ay'.format(s[1:], s[0]) if len(s) > 3 else s\n", "def pig_latin(word):\n\tif len(word) < 3:\n\t\treturn word\n\tret = word + word[0] + 'ay'\n\treturn ret[1:]\n", "pig_latin = lambda w: len(w) < 4 and w or '%s%say' % (w[1:], w[0])\n"], "768": ["def sum_pow_dig_seq(num, exp, k):\n\tseq = []\n\tfor step in range(k):\n\t\tseq.append(num)\n\t\tnum = sum((int(dig) ** exp for dig in str(num)))\n\t\tif num in seq:\n\t\t\tcycle_start = seq.index(num)\n\t\t\tcycle = seq[cycle_start:]\n\t\t\tlast_term = cycle[(k - cycle_start) % len(cycle)]\n\t\t\treturn [cycle_start, cycle, len(cycle), last_term]\n\treturn [0, [], 0, num]\n", "def sum_pow_dig_seq(start, n, k):\n\tseq = [start]\n\tnum = start\n\tfor i in range(k):\n\t\tnum = sum([int(x) ** n for x in str(num)])\n\t\tif num in seq:\n\t\t\tloop_starts_from = seq.index(num)\n\t\t\tloop_array = seq[loop_starts_from:]\n\t\t\ttail_size = loop_starts_from\n\t\t\tloop_size = len(loop_array)\n\t\t\tlast_term = loop_array[(k - tail_size) % loop_size]\n\t\t\treturn [tail_size, loop_array, loop_size, last_term]\n\t\tseq.append(num)\n\telse:\n\t\treturn [len(seq), [], 0, seq[-1]]\n", "def sum_pow_dig_seq(start, n, k):\n\tseen = [start]\n\tfor i in range(k):\n\t\tr1 = sum(map(lambda x: x ** n, map(int, str(seen[-1]))))\n\t\tif r1 in seen:\n\t\t\th = seen.index(r1)\n\t\t\tcyc_patt_arr = seen[h:]\n\t\t\tpatt_len = len(seen) - h\n\t\t\tlast_term = cyc_patt_arr[(k - i - 1) % patt_len]\n\t\t\tbreak\n\t\tseen.append(r1)\n\treturn [h, cyc_patt_arr, patt_len, last_term]\n", "def sum_of_digits_pow(n, e):\n\treturn sum([i ** e for i in map(int, str(n))])\n\ndef sum_pow_dig_seq(start, e, k):\n\th = 0\n\t(cyc_patt_arr, sums) = ([], [])\n\tfor i in range(1, k + 1):\n\t\tstart = sum_of_digits_pow(start, e)\n\t\tif not cyc_patt_arr and start in sums:\n\t\t\tcyc_patt_arr = [j for j in sums[sums.index(start):]]\n\t\t\th = sums.index(start) + 1\n\t\t\treturn [h, cyc_patt_arr, len(cyc_patt_arr), cyc_patt_arr[(k - i) % len(cyc_patt_arr)]]\n\t\tsums.append(start)\n", "def sum_pow_dig_seq(start, n, k):\n\n\tdef next_(v):\n\t\treturn sum((int(c) ** n for c in str(v)))\n\thistory = []\n\thistory_set = set()\n\tx = start\n\twhile True:\n\t\tif x in history_set:\n\t\t\ti = history.index(x)\n\t\t\tcyc = history[i:]\n\t\t\tif k < len(history):\n\t\t\t\treturn [i, cyc, len(cyc), history[k]]\n\t\t\treturn [i, cyc, len(cyc), cyc[(k - i) % len(cyc)]]\n\t\thistory.append(x)\n\t\thistory_set.add(x)\n\t\tx = next_(x)\n", "def sum_pow_dig_seq(start, n, k):\n\t(cycle, l, h, drop) = (set(), [], -1, False)\n\tfor i in range(k):\n\t\tstart = sum((int(d) ** n for d in str(start)))\n\t\tif h != -1 and start in cycle:\n\t\t\tbreak\n\t\tif h == -1 and start in cycle:\n\t\t\t(cycle, h, l) = (set(), i, [])\n\t\tcycle.add(start)\n\t\tl.append(start)\n\treturn [h - len(l) + 1, l, len(l), l[(k - i - 1) % len(l)]]\n", "def sum_pow_dig_seq(start, n, k):\n\tx = start\n\tseries = []\n\tseen_at = {}\n\ti = 0\n\twhile x not in seen_at:\n\t\tseries.append(x)\n\t\tseen_at[x] = i\n\t\tx = sum((int(d) ** n for d in str(x)))\n\t\ti += 1\n\ti_first = seen_at[x]\n\tcycle_length = i - i_first\n\tif k >= i:\n\t\tk = i_first + (k - i_first) % cycle_length\n\treturn [i_first, series[i_first:], cycle_length, series[k]]\n", "def sum_pow_dig_seq(start, n, k):\n\tr = []\n\tfor i in range(0, k):\n\t\tc = 0\n\t\tfor d in str(start):\n\t\t\tc += int(d) ** n\n\t\tr.append(c)\n\t\tstart = c\n\tfor i in range(0, k):\n\t\tif r[i] in r[i + 1:]:\n\t\t\tposE = r.index(r[i], i + 1)\n\t\t\tif posE >= 0:\n\t\t\t\tif r[i:posE - 1] == r[posE:posE + posE - 1 - i]:\n\t\t\t\t\tposS = i\n\t\t\t\t\tbreak\n\treturn [posS + 1, r[posS:posE], posE - posS, start]\n", "def sum_pow_dig_seq(start, n, k):\n\tli = []\n\tfor _ in range(k):\n\t\tr = sum([j ** n for j in map(int, str(start))])\n\t\tif r in li:\n\t\t\treach = n = li.index(r) + 1\n\t\t\tseries = li[li.index(r):]\n\t\t\ts_l = len(series)\n\t\t\twhile n + s_l <= k:\n\t\t\t\tn += s_l\n\t\t\treturn [reach, series, s_l, series[k - n]]\n\t\tli.append(r)\n\t\tstart = r\n", "def sum_pow_dig_seq(n, e, k):\n\tpath = [n]\n\twhile True:\n\t\tn = sum((int(d) ** e for d in str(n)))\n\t\tif n in path:\n\t\t\tbreak\n\t\tpath.append(n)\n\th = path.index(n)\n\tloop = path[h:]\n\treturn [h, loop, len(loop), loop[(k - h) % len(loop)]]\n"], "796": ["def even_magic(n):\n\treturn [[n * n - (y * n + x) if x % 4 == y % 4 or (x % 4 + y % 4) % 4 == 3 else y * n + x + 1 for x in range(n)] for y in range(n)]\n", "def even_magic(n):\n\tl = list(range(1, n * n + 1))\n\tfor i in range(n * n // 2):\n\t\t(y, x) = (i // n % 4, i % n % 4)\n\t\tif y == x or x + y == 3:\n\t\t\t(l[i], l[n * n - 1 - i]) = (l[n * n - 1 - i], l[i])\n\treturn [l[i * n:i * n + n] for i in range(n)]\n", "import numpy as np\n\ndef even_magic(n):\n\tmx = n * n\n\tdraft = np.arange(1, mx + 1).reshape((n, n))\n\tart = np.arange(mx, 0, -1).reshape((n, n))\n\tfor i in range(n):\n\t\tfor y in range(n):\n\t\t\tif any((all((i % 4 in [0, 3], y % 4 in [0, 3])), all((i % 4 in [1, 2], y % 4 in [1, 2])))):\n\t\t\t\tdraft[i][y] = art[i][y]\n\treturn draft.tolist()\n", "def even_magic(n):\n\tn2_1 = n ** 2 + 1\n\treturn [[n2_1 - (i * n + j + 1) if i % 4 == j % 4 or (i + j) % 4 == 3 else i * n + j + 1 for j in range(n)] for i in range(n)]\n", "def even_magic(n):\n\tsq = [[y * n + x + 1 for x in range(n)] for y in range(n)]\n\tfor x in range(n):\n\t\tfor y in range(n):\n\t\t\tif y % 4 == x % 4 or y % 4 == 3 - x % 4:\n\t\t\t\tsq[x][y] = n ** 2 + 1 - sq[x][y]\n\treturn sq\n", "def even_magic(n):\n\t(numbers, p) = (iter(list(range(1, n * n + 1))), 0)\n\tmain_grid = [[next(numbers) for _ in range(n)] for _ in range(n)]\n\tA = lambda s, se, see, e, ee, eee: list(zip(range(s, se, see), range(e, ee, eee)))\n\tfor i in range(n // 4):\n\t\to = 0\n\t\tfor j in range(n // 4):\n\t\t\tfor (k, l) in A(p, p + 4, 1, o, o + 4, 1) + A(p, p + 4, 1, o + 3, o - 1, -1):\n\t\t\t\tmain_grid[k][l] = n ** 2 + 1 - main_grid[k][l]\n\t\t\to += 4\n\t\tp += 4\n\treturn main_grid\n", "def even_magic(n):\n\tsquare = []\n\tfor j in range(0, n):\n\t\trow = []\n\t\tfor i in range(0, n):\n\t\t\tv = i + j * n + 1\n\t\t\tif i % 4 == j % 4 or -(i + 1) % 4 == j % 4:\n\t\t\t\trow.append(n ** 2 + 1 - v)\n\t\t\telse:\n\t\t\t\trow.append(v)\n\t\tsquare.append(row)\n\treturn square\n", "def even_magic(n):\n\tarr = []\n\tfor i in range(0, n):\n\t\tarr.append([])\n\t\tfor j in range(0, n):\n\t\t\tif i % 4 == j % 4 or i % 4 + j % 4 == 3:\n\t\t\t\tarr[i].append(n * n - i * n - j)\n\t\t\telse:\n\t\t\t\tarr[i].append(i * n + j + 1)\n\treturn arr\n", "even_magic = lambda n: [[y % 4 in (x % 4, 3 - x % 4) and n * n - n * y - x or n * y + x + 1 for x in range(n)] for y in range(n)]\n", "def even_magic(n):\n\t(result, n2) = ([[n * i + j + 1 for j in range(n)] for i in range(n)], n ** 2)\n\tfor x in range(n):\n\t\tresult[x][x] = n2 + 1 - result[x][x]\n\t\tresult[x][-x - 1] = n2 + 1 - result[x][-x - 1]\n\tfor i in range(4, n, 4):\n\t\tfor x in range(n - i):\n\t\t\tresult[i + x][x] = n2 + 1 - result[i + x][x]\n\t\t\tresult[x][i + x] = n2 + 1 - result[x][i + x]\n\t\t\tresult[x][-x - 1 - i] = n2 + 1 - result[x][-x - 1 - i]\n\t\t\tresult[i + x][-x - 1] = n2 + 1 - result[i + x][-x - 1]\n\treturn result\n"], "834": ["import re\n\ndef bears(n, s):\n\ta = re.findall('B8|8B', s)\n\treturn [''.join(a), len(a) >= n]\n", "import re\n\ndef bears(x, s):\n\tr = re.findall('8B|B8', s)\n\treturn [''.join(r), len(r) >= x]\n", "from regex import findall\n\ndef bears(x, s):\n\tres = findall('(B8|8B)', s)\n\treturn [''.join(res), len(res) >= x]\n", "import re\n\ndef bears(n, stg):\n\tpairs = re.findall('B8|8B', stg)\n\treturn [''.join(pairs), len(pairs) >= n]\n", "def bears(x, s):\n\tk = []\n\ti = 0\n\twhile i < len(s) - 1:\n\t\tif s[i] == 'B' and s[i + 1] == '8' or (s[i] == '8' and s[i + 1] == 'B'):\n\t\t\tk.append(s[i] + s[i + 1])\n\t\t\ti += 2\n\t\telse:\n\t\t\ti += 1\n\treturn [''.join(k), len(k) >= x] if k else ['', len(k) >= x]\n", "def bears(x, s):\n\tcouples = ['B8', '8B']\n\tmatches = ['', False]\n\tcounter = 0\n\tln = len(s)\n\ti = 0\n\twhile i < ln:\n\t\tpair = s[i:i + 2]\n\t\tif pair in couples:\n\t\t\tmatches[0] += pair\n\t\t\tcounter += 1\n\t\t\ti += 2\n\t\telse:\n\t\t\ti += 1\n\tif counter >= x:\n\t\tmatches[1] = True\n\treturn matches\n", "def bears(x, s):\n\tresult = []\n\tbears = []\n\twhile len(s) > 1:\n\t\tif s[0] == 'B' and s[1] == '8':\n\t\t\ts = s[2:]\n\t\t\tbears.append('B8')\n\t\telif s[0] == '8' and s[1] == 'B':\n\t\t\ts = s[2:]\n\t\t\tbears.append('8B')\n\t\telse:\n\t\t\ts = s[1:]\n\tresult.append(''.join(bears))\n\ttest = len(bears) * 2 >= x\n\tresult.append(test)\n\treturn result\n", "bears = lambda x, s, k='', i=0: [k, len(k) >= x * 2] if i == len(s) else bears(x, s, k + s[i:i + 2], i + 2) if s[i:i + 2] in ['8B', 'B8'] else bears(x, s, k, i + 1)\n", "bears = lambda n, s: (lambda a: [''.join(a), n <= len(a)])(__import__('re').findall('B8|8B', s))\n"], "839": ["def sum_mix(arr):\n\treturn sum(map(int, arr))\n", "def sum_mix(arr):\n\treturn sum((int(n) for n in arr))\n", "def sum_mix(arr):\n\tresult = 0\n\tfor a in arr:\n\t\ttry:\n\t\t\tresult += a\n\t\texcept TypeError:\n\t\t\tresult += int(a)\n\treturn result\n", "def sum_mix(arr):\n\treturn sum((int(i) for i in arr))\n", "from functools import reduce\n\ndef to_int(num):\n\ttry:\n\t\treturn int(num)\n\texcept ValueError:\n\t\treturn 0\n\ndef sum_mix(arr):\n\tconverted_array = list([to_int(x) for x in arr])\n\treturn reduce(lambda res, x: res + x, converted_array)\n", "sum_mix = lambda a: sum(map(int, a))\n", "def sum_mix(arr):\n\treturn sum((int(x) for x in arr))\n", "def sum_mix(arr):\n\tsomme = 0\n\tfor i in arr:\n\t\tsomme += int(i)\n\treturn somme\n", "sum_mix = lambda A: sum([int(n) for n in A])\n", "def sum_mix(arr):\n\tL = []\n\tfor i in arr:\n\t\tL.append(int(i))\n\treturn sum(L)\n", "def sum_mix(arr):\n\treturn sum((float(x) for x in arr))\n", "def sum_mix(arr):\n\treturn eval('+'.join((str(x) for x in arr)))\n", "def sum_mix(arr):\n\tarr_int = [int(el) for el in arr]\n\treturn sum(arr_int)\n", "def sum_mix(arr):\n\tsum = 0\n\tfor i in arr:\n\t\tif type(i) != int:\n\t\t\tsum += int(i)\n\t\telse:\n\t\t\tsum += i\n\treturn sum\n", "from functools import reduce\n\ndef sum_mix(arr):\n\treturn reduce(lambda x, y: int(x) + int(y), arr)\n", "def sum_mix(arr):\n\treturn sum((int(item) for item in arr))\n", "def sum_mix(arr):\n\tsum_ = 0\n\tfor item in arr:\n\t\tif isinstance(item, str):\n\t\t\tsum_ += int(item)\n\t\telif isinstance(item, (int, float)):\n\t\t\tsum_ += item\n\treturn sum_\n", "def sum_mix(arr):\n\treturn sum((int(num) for num in arr))\n", "def sum_mix(arr):\n\tli = []\n\tfor i in arr:\n\t\tli.append(int(i))\n\treturn sum(li)\n", "def sum_mix(arr):\n\ttotal = 0\n\tfor i in map(int, arr):\n\t\ttotal += i\n\treturn total\n", "def sum_mix(arr):\n\tb = []\n\tfor i in arr:\n\t\tb.append(int(i))\n\treturn sum(b)\n", "def sum_mix(arr):\n\tresult = 0\n\tfor number in arr:\n\t\tresult += int(number)\n\treturn result\n", "def sum_mix(arr):\n\tsum = 0\n\tfor element in arr:\n\t\tsum = sum + int(element)\n\treturn sum\n", "def sum_mix(arr):\n\tfor i in range(0, len(arr)):\n\t\tarr[i] = int(arr[i])\n\tsuma = sum(arr)\n\treturn suma\n", "def sum_mix(arr):\n\treturn sum((int(arr[num]) for num in range(len(arr))))\n", "sum_mix = lambda array: sum([int(x) for x in array])\n", "def sum_mix(arr):\n\tans = 0\n\tfor k in arr:\n\t\tans += int(k)\n\treturn ans\n", "def sum_mix(arr):\n\tnumbers = arr\n\tsum = 0\n\tfor num in numbers:\n\t\tnumber = int(num)\n\t\tsum += number\n\treturn sum\n", "def sum_mix(arr):\n\ttotal = 0\n\tfor num in arr:\n\t\tif type(num) == str:\n\t\t\ttotal += int(num)\n\t\telse:\n\t\t\ttotal += num\n\treturn total\n", "def sum_mix(arr):\n\tcount = 0\n\tfor i in arr:\n\t\tif type(i) == 'str':\n\t\t\tcount += int(i)\n\t\telse:\n\t\t\tcount += int(i)\n\treturn count\n", "sum_mix = lambda arr: sum([int(digit) for digit in arr])\n", "def sum_mix(arr):\n\tsuma = 0\n\tfor x in arr:\n\t\ty = int(x)\n\t\tsuma = suma + y\n\treturn suma\n", "def sum_mix(arr):\n\ttam = len(arr)\n\tnum = 0\n\tsoma = 0\n\tfor num in range(tam):\n\t\ty = int(arr[num])\n\t\tnum = num + 1\n\t\tsoma += y\n\treturn soma\n", "def sum_mix(arr):\n\tsum = 0\n\tfor i in range(len(arr)):\n\t\tif arr[i] is int:\n\t\t\tsum += 0\n\t\telse:\n\t\t\tsum += int(arr[i])\n\treturn sum\n", "def sum_mix(arr):\n\tsum = 0\n\tfor lmnt in arr:\n\t\tsum += int(lmnt)\n\treturn sum\n", "def sum_mix(arr):\n\tlst = list(map(int, arr))\n\treturn sum(lst)\n", "def sum_mix(numbers):\n\treturn sum((int(n) for n in numbers))\n", "def sum_mix(arr):\n\ttot = 0\n\tfor i in range(len(arr)):\n\t\tif type(arr[i]) is str:\n\t\t\tx = int(arr[i])\n\t\t\ttot += x\n\t\telse:\n\t\t\ttot += arr[i]\n\treturn tot\n", "def sum_mix(arr: []):\n\tresult = 0\n\tfor i in arr:\n\t\tif isinstance(i, str):\n\t\t\tresult += int(i)\n\t\telse:\n\t\t\tresult += i\n\treturn result\n", "def sum_mix(arr):\n\treturn sum((int(n) if type(n) == str else n for n in arr))\n", "def sum_mix(arr):\n\tc = 0\n\tls = []\n\tfor i in arr:\n\t\tc = int(i)\n\t\tls.append(c)\n\treturn sum(ls)\n", "def sum_mix(arr):\n\tnums = []\n\tfor i in arr:\n\t\ti = int(i)\n\t\tnums.append(i)\n\treturn sum(nums)\n", "def sum_mix(arr):\n\tres = 0\n\tfor el in arr:\n\t\tres += int(el)\n\treturn res\n", "def sum_mix(arr):\n\tcount = 0\n\tfor i in arr:\n\t\tcount += int(i)\n\treturn count\n", "import unittest\n\ndef sum_mix(input_array):\n\treturn sum((int(element) if isinstance(element, str) else element for element in input_array))\n\nclass TestSumMix(unittest.TestCase):\n\n\tdef test_sum_mix_with_elements_are_only_integer(self):\n\t\tself.assertEqual(sum_mix([8, 0, 0, 8, 5, 7, 2, 3, 7, 8, 6, 7]), 61)\n\n\tdef test_sum_mix_with_elements_are_only_string(self):\n\t\tself.assertEqual(sum_mix(['1', '2', '3', '4', '5']), 15)\n\n\tdef test_sum_mix_with_elements_are_integers_or_string(self):\n\t\tself.assertEqual(sum_mix(['1', 2, '3', 4, '5']), 15)\n", "def sum_mix(arr):\n\tans = []\n\tfor i in arr:\n\t\tans.append(int(i))\n\treturn sum(ans)\n", "def sum_mix(arr):\n\tmessages = []\n\tfor i in arr:\n\t\tmessages.append(int(i))\n\treturn sum(messages)\n", "def sum_mix(arr):\n\tres = 0\n\tfor num in arr:\n\t\tif isinstance(num, str):\n\t\t\tres += int(num)\n\t\telse:\n\t\t\tres += num\n\treturn res\n", "def sum_mix(arr):\n\tx = 0\n\tfor i in range(len(arr)):\n\t\tx = x + int(arr[i])\n\treturn x\n", "def sum_mix(arr):\n\tacc = 0\n\tfor i in arr:\n\t\tacc += int(i)\n\treturn acc\n", "def sum_mix(arr):\n\tfor (i, el) in enumerate(arr):\n\t\tif isinstance(el, str):\n\t\t\tarr[i] = int(el)\n\treturn sum(arr)\n", "def sum_mix(arr):\n\tsuuum = 0\n\tfor i in arr:\n\t\tsuuum += int(i)\n\treturn suuum\n", "def sum_mix(arr):\n\tnew_arr = list(map(int, arr))\n\treturn sum(new_arr)\n", "def sum_mix(arr):\n\ttotal = 0\n\tfor i in range(len(arr)):\n\t\tarr[i] = int(arr[i])\n\t\ttotal = total + arr[i]\n\treturn total\n", "sum_mix = lambda a: sum((int(a) for a in a))\n", "def sum_mix(arr):\n\tnn = 0\n\tfor a in arr:\n\t\tnn += int(a)\n\treturn nn\n", "def sum_mix(arr):\n\ts = 0\n\tfor ele in arr:\n\t\tif ele is not int:\n\t\t\tele = int(ele)\n\t\t\ts += ele\n\treturn s\n", "def sum_mix(arr):\n\tb = [int(i) for i in arr]\n\tc = sum(b)\n\treturn c\n", "def sum_mix(array):\n\tnew_array = []\n\tfor x in array:\n\t\tx = int(x)\n\t\tnew_array.append(x)\n\treturn sum(new_array)\n", "def sum_mix(arr):\n\tc = 0\n\tfor i in arr:\n\t\ti = int(i)\n\t\tc += i\n\treturn c\n", "def sum_mix(arr):\n\tintarr = [int(i) for i in arr]\n\tsumarr = sum(intarr)\n\treturn sumarr\n"], "843": ["def find_lowest_int(k1):\n\t(k2, n) = (k1 + 1, 1)\n\n\tdef digits(n):\n\t\treturn sorted(str(n))\n\twhile digits(n * k1) != digits(n * k2):\n\t\tn += 1\n\treturn n\n", "from itertools import count as c\n\ndef find_lowest_int(k):\n\treturn next((n for n in c(1) if sorted(str(n * k)) == sorted(str(n * (k + 1)))))\n", "def find_lowest_int(k):\n\treturn next((n for n in range(9, 9999999, 9) if sorted(str(n * k)) == sorted(str(n * (k + 1)))))\n", "def find_lowest_int(k):\n\t(l, n) = (k + 1, 9)\n\twhile digits(k * n) != digits(l * n):\n\t\tn += 9\n\treturn n\n\ndef digits(n):\n\treturn sorted(str(n))\n", "def find_lowest_int(number):\n\tmultiplier = 1\n\twhile sorted(str(number * multiplier)) != sorted(str((number + 1) * multiplier)):\n\t\tmultiplier += 1\n\treturn multiplier\n", "from collections import Counter\n\ndef find_lowest_int(k):\n\tn = 9\n\twhile True:\n\t\tif Counter(str(k * n)) == Counter(str((k + 1) * n)):\n\t\t\treturn n\n\t\tn += 9\n", "def find_lowest_int(k):\n\tn = 2\n\twhile True:\n\t\tif sorted(str(n * k)) == sorted(str(n * (k + 1))):\n\t\t\treturn n\n\t\tn += 1\n"], "857": ["from bisect import bisect_right as bisect\nRES = [[] for _ in range(11)]\nfor c in range(1, 1001):\n\tc3 = c ** 3\n\tnSol = sum((((c3 - a ** 2) ** 0.5).is_integer() for a in range(1, int((c3 // 2) ** 0.5 + 1))))\n\tif 0 < nSol < 11:\n\t\tRES[nSol].append(c)\n\ndef find_abc_sumsqcube(c_max, nSol):\n\treturn RES[nSol][:bisect(RES[nSol], c_max)]\n", "from math import sqrt\n\ndef nb_sol_cube_is_sumsq(c):\n\tcount = 0\n\tc3 = c ** 3\n\tmodc3 = c3 % 4\n\tif modc3 == 3 or modc3 == 2:\n\t\treturn 0\n\tfor a in range(1, int(sqrt(c ** 3)) + 1):\n\t\tb = sqrt(c3 - a ** 2)\n\t\tif int(b) == b and 0 < b <= a:\n\t\t\tcount += 1\n\treturn count\n\ndef nb_abc_sol(c_max):\n\t(res, c) = ([], 1)\n\twhile c <= c_max:\n\t\tres.append(nb_sol_cube_is_sumsq(c))\n\t\tc += 1\n\treturn res\nsol = nb_abc_sol(1001)\n\ndef find_abc_sumsqcube(c_max, num_sol):\n\treturn [i + 1 for (i, count) in enumerate(sol[:c_max]) if count == num_sol]\n", "from bisect import bisect_right\nfrom math import sqrt\nSOL = [[] for _ in range(11)]\nfor c in range(1, 1001):\n\tc3 = c ** 3\n\tnum_sol = sum((sqrt(c3 - a ** 2).is_integer() for a in range(1, int(sqrt(c3 // 2) + 1))))\n\tif 0 < num_sol < 11:\n\t\tSOL[num_sol].append(c)\n\ndef find_abc_sumsqcube(c_max, num_sol):\n\tres = SOL[num_sol]\n\treturn res[:bisect_right(res, c_max)]\n", "dic1 = {1: [2, 8, 18, 32, 72, 98, 128, 162, 242, 288, 392, 512, 648, 722, 882, 968], 2: [5, 10, 13, 17, 20, 26, 29, 34, 37, 40, 41, 45, 52, 53, 58, 61, 68, 73, 74, 80, 82, 89, 90, 97, 101, 104, 106, 109, 113, 116, 117, 122, 136, 137, 146, 148, 149, 153, 157, 160, 164, 173, 178, 180, 181, 193, 194, 197, 202, 208, 212, 218, 226, 229, 232, 233, 234, 241, 244, 245, 257, 261, 269, 272, 274, 277, 281, 292, 293, 296, 298, 306, 313, 314, 317, 320, 328, 333, 337, 346, 349, 353, 356, 360, 362, 369, 373, 386, 388, 389, 394, 397, 401, 404, 405, 409, 416, 421, 424, 433, 436, 449, 452, 457, 458, 461, 464, 466, 468, 477, 482, 488, 490, 509, 514, 521, 522, 538, 541, 544, 548, 549, 554, 557, 562, 569, 577, 584, 586, 592, 593, 596, 601, 605, 612, 613, 617, 626, 628, 634, 637, 640, 641, 653, 656, 657, 661, 666, 673, 674, 677, 692, 698, 701, 706, 709, 712, 720, 724, 733, 738, 746, 757, 761, 769, 772, 773, 776, 778, 788, 794, 797, 801, 802, 808, 809, 810, 818, 821, 829, 832, 833, 842, 848, 853, 857, 866, 872, 873, 877, 881, 898, 904, 909, 914, 916, 922, 928, 929, 932, 936, 937, 941, 953, 954, 964, 976, 977, 980, 981, 997], 3: [25, 100, 169, 225, 289, 400, 676, 841, 900], 4: [50, 200, 338, 450, 578, 800], 8: [65, 85, 130, 145, 170, 185, 205, 221, 260, 265, 290, 305, 340, 365, 370, 377, 410, 442, 445, 481, 485, 493, 505, 520, 530, 533, 545, 565, 580, 585, 610, 629, 680, 685, 689, 697, 730, 740, 745, 754, 765, 785, 793, 820, 865, 884, 890, 901, 905, 949, 962, 965, 970, 985, 986], 5: [125, 250, 500, 1000], 14: [325, 425, 650, 725, 845, 850, 925], 6: [625]}\nimport bisect\n\ndef find_abc_sumsqcube(c_max, num_sol):\n\tif num_sol not in dic1.keys():\n\t\treturn []\n\tlst = dic1[num_sol]\n\tidx = bisect.bisect_right(lst, c_max)\n\treturn lst[:idx]\n", "import math\nfrom functools import lru_cache\n\n@lru_cache(maxsize=1024)\ndef solutions(c):\n\tcube = c ** 3\n\treturn sum((1 for a in range(1, int((cube // 2) ** 0.5) + 1) if ((cube - a ** 2) ** 0.5).is_integer()))\n\ndef find_abc_sumsqcube(c_max, num_sol):\n\tresult = []\n\tfor c in range(2, c_max + 1):\n\t\tif solutions(c) == num_sol:\n\t\t\tresult.append(c)\n\treturn result\n"], "872": ["def tops(msg):\n\t(i, d, s) = (1, 5, '')\n\twhile i < len(msg):\n\t\ts += msg[i]\n\t\ti += d\n\t\td += 4\n\treturn s[::-1]\n", "def tops(msg):\n\tif len(msg) < 2:\n\t\treturn ''\n\tg = 2\n\tk = ''\n\tni = 0\n\tk += msg[1]\n\tfor i in msg[1:]:\n\t\tif ni == g * 2 + 1:\n\t\t\tk += i\n\t\t\tg += 2\n\t\t\tni = 0\n\t\tni += 1\n\treturn k[::-1]\n", "def tops(msg):\n\tif not msg:\n\t\treturn ''\n\t(n, length) = (2, len(msg))\n\tcounter = 0\n\ts = ''\n\twhile counter + n <= length:\n\t\tcounter += n\n\t\ts += msg[counter - 1]\n\t\tcounter += n - 1\n\t\tn += 2\n\treturn s[::-1]\n", "def tops(stg):\n\tl = int((1 + (1 + 8 * len(stg)) ** 0.5) / 4)\n\treturn ''.join((stg[n * (2 * n - 1)] for n in range(l, 0, -1)))\n", "from itertools import accumulate, count, takewhile\n\ndef indexes():\n\tit = count(0)\n\twhile True:\n\t\tyield (next(it) + next(it))\n\ndef tops(msg):\n\tn = len(msg)\n\treturn ''.join((msg[i] for i in list(takewhile(lambda i: i < n, accumulate(indexes())))[::-1]))\n", "def tops(msg):\n\tres = ''\n\ttop = 1\n\tdiff = 5\n\twhile top < len(msg):\n\t\tres += msg[top]\n\t\ttop += diff\n\t\tdiff += 4\n\treturn res[::-1]\n", "def tops(msg):\n\t(result, i, offset) = ('', 1, 5)\n\twhile i < len(msg):\n\t\tresult += msg[i]\n\t\ti += offset\n\t\toffset += 4\n\treturn result[::-1]\n", "def tops(msg):\n\ti = 1\n\tj = 2\n\tres = []\n\twhile i < len(msg):\n\t\tres.append(msg[i])\n\t\ti += 2 * j + 1\n\t\tj += 2\n\treturn ''.join(res)[::-1]\n", "tops = lambda m, n=1: (lambda q: '' if q > len(m) else tops(m, n + 1) + m[q])(2 * n * n - n)\n", "tops = lambda s: ''.join((s[n * (2 * n - 1)] for n in range(int(((8 * len(s) + 1) ** 0.5 + 1) / 4), 0, -1)))\n"], "892": ["def simplify(poly):\n\timport re\n\tmatches = re.findall('([+\\\\-]?)(\\\\d*)([a-z]+)', poly)\n\texpanded = [[int(i[0] + (i[1] if i[1] != '' else '1')), ''.join(sorted(i[2]))] for i in matches]\n\tvariables = sorted(list(set((i[1] for i in expanded))), key=lambda x: (len(x), x))\n\tcoefficients = {v: sum((i[0] for i in expanded if i[1] == v)) for v in variables}\n\treturn '+'.join((str(coefficients[v]) + v for v in variables if coefficients[v] != 0)).replace('1', '').replace('+-', '-')\n", "import re\n\ndef simplify(poly):\n\tterms = {}\n\tfor (sign, coef, vars) in re.findall('([\\\\-+]?)(\\\\d*)([a-z]*)', poly):\n\t\tsign = -1 if sign == '-' else 1\n\t\tcoef = sign * int(coef or 1)\n\t\tvars = ''.join(sorted(vars))\n\t\tterms[vars] = terms.get(vars, 0) + coef\n\tterms = sorted(list(terms.items()), key=lambda v_c: (len(v_c[0]), v_c[0]))\n\treturn ''.join(map(format_term, terms)).strip('+')\n\ndef format_term(xxx_todo_changeme):\n\t(vars, coef) = xxx_todo_changeme\n\tif coef == 0:\n\t\treturn ''\n\tif coef == 1:\n\t\treturn '+' + vars\n\tif coef == -1:\n\t\treturn '-' + vars\n\treturn '%+i%s' % (coef, vars)\n"], "893": ["def solution(to, lst):\n\t(dolSym, eurSym, power) = ('', '\u20ac', -1) if to == 'EUR' else ('$', '', 1)\n\treturn [f'{dolSym}{v * 1.1363636 ** power:,.2f}{eurSym}' for v in lst]\n", "def solution(to_cur, values):\n\t(rate, fmt) = {'USD': (1.1363636, '${:,.2f}'), 'EUR': (1 / 1.1363636, '{:,.2f}\u20ac')}[to_cur]\n\tvalues = [v * rate for v in values]\n\treturn list(map(fmt.format, values))\n", "def solution(to_cur, values):\n\trate = 1.1363636\n\tstyle = '{:,.2f}'\n\tif to_cur == 'EUR':\n\t\trate = 1 / rate\n\t\tstyle += '\u20ac'\n\telse:\n\t\tstyle = '$' + style\n\treturn [style.format(v * rate) for v in values]\n", "def solution(to_cur, lst):\n\t(rate, fmt) = {'USD': (1.1363636, '${:,.2f}'), 'EUR': (0.88, '{:,.2f}\u20ac')}[to_cur]\n\treturn [fmt.format(val * rate) for val in lst]\n", "def solution(to_cur, value):\n\tmon = {'EUR': lambda e: '{:,.2f}\u20ac'.format(e / 1.1363636), 'USD': lambda e: '${:,.2f}'.format(e * 1.1363636, 2)}\n\treturn [mon[to_cur](e) for e in value]\n", "def solution(to_cur, values):\n\treturn [f'${v * 1.1363636:0,.2f}' if to_cur == 'USD' else f'{v / 1.1363636:0,.2f}\u20ac' for v in values]\n", "def solution(to_cur, value):\n\treturn ['${:,.2f}'.format(x * 1.1363636) if to_cur == 'USD' else '{:,.2f}\u20ac'.format(x / 1.1363636) for x in value]\n", "def solution(to_cur, value):\n\trate = 1.1363636\n\treturn list([f'${x * rate:,.2f}' for x in value]) if to_cur == 'USD' else list([f'{x / rate:,.2f}\u20ac' for x in value])\n", "def solution(to_cur, value):\n\treturn [f'${i * 1.1363636:,.2f}' if to_cur == 'USD' else f'{i / 1.1363636:,.2f}\u20ac' for i in value]\n", "def solution(to_cur, value):\n\tr = []\n\tfor number in value:\n\t\tif to_cur == 'USD':\n\t\t\tr.append('${:,.2F}'.format(number * 1.1363636))\n\t\telse:\n\t\t\tr.append('{:,.2F}\u20ac'.format(number / 1.1363636))\n\treturn r\n"], "894": ["def on_line(points):\n\tpoints = list(set(points))\n\tcross_product = lambda a, b, c: a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])\n\treturn all((cross_product(p, *points[:2]) == 0 for p in points[2:]))\n", "from functools import partial\n\ndef collinear(p1, p2, p3):\n\treturn (p3[1] - p2[1]) * (p2[0] - p1[0]) == (p2[1] - p1[1]) * (p3[0] - p2[0])\n\ndef on_line(points):\n\tpoints = list(set(points))\n\treturn all(map(partial(collinear, *points[:2]), points[2:]))\n", "def on_line(li):\n\ttry:\n\t\tli = list(set(li))\n\t\t(x1, y1) = li.pop()\n\t\treturn li[0] and len(set([(y2 - y1) / (x2 - x1) for (x2, y2) in li])) == 1\n\texcept:\n\t\treturn len(li) < 2 or len({i[0] for i in li}) == 1\n", "from fractions import Fraction\n\ndef on_line(ps):\n\tps = list(set(ps))\n\tif ps and all((isinstance(x, int) for x in ps)):\n\t\treturn True\n\treturn len({x1 if x1 == x2 else Fraction(y2 - y1, x2 - x1) for ((x1, y1), (x2, y2)) in zip(ps, ps[1:])}) <= 1\n", "import numpy as np\n\ndef determinant(a):\n\treturn round(np.linalg.det(np.matrix(a)))\nf = lambda x: x + [1]\n\ndef on_line(points=None):\n\tif points == None:\n\t\treturn True\n\tif len(points) <= 2:\n\t\treturn True\n\tpoints = map(list, list(points))\n\tfor i in range(len(points) - 2):\n\t\tmatrix = [points[i], points[i + 1], points[i + 2]]\n\t\tmatrix = map(f, matrix)\n\t\tif determinant(matrix) != 0:\n\t\t\treturn False\n\treturn True\n", "def on_line(p):\n\tp = list(set(p))\n\tif len(p) <= 2:\n\t\treturn True\n\t((x0, y0), (x1, y1)) = p[:2]\n\treturn all(((x - x0) * (y1 - y0) == (x1 - x0) * (y - y0) for (x, y) in p[2:]))\n", "from fractions import Fraction\n\ndef on_line(points):\n\treturn len(set((Fraction(a[1] - b[1], a[0] - b[0]) if a[0] != b[0] else 'Invalid' for (a, b) in zip(points, points[1:]) if a != b))) < 2\n", "def on_line(points):\n\n\tdef slope_intercept(p1, p2):\n\t\tslope = (p2[1] - p1[1]) / (p2[0] - p1[0])\n\t\tintercept = p1[1] - slope * p1[0]\n\t\treturn (slope, intercept)\n\tif len(points) == 0 or isinstance(points[0], int):\n\t\treturn True\n\tfor (p1, p2) in zip(points, points[1:]):\n\t\tif p1[0] == p2[0] or p1[1] == p2[1]:\n\t\t\tcontinue\n\t\telse:\n\t\t\t(s, i) = slope_intercept(p1, p2)\n\t\t\ttry:\n\t\t\t\tif abs(s - slope) > 1e-08 or abs(i - intercept) > 1e-06:\n\t\t\t\t\treturn False\n\t\t\texcept:\n\t\t\t\tpass\n\t\t\t(slope, intercept) = (s, i)\n\treturn True\n", "def on_line(points):\n\ttry:\n\t\t(x1, y1) = points[0]\n\t\t(x2, y2) = points[-1]\n\texcept:\n\t\treturn True\n\tfor i in points[1:-1]:\n\t\t(x3, y3) = i\n\t\tif (x1 - x3) * (y2 - y3) != (x2 - x3) * (y1 - y3):\n\t\t\treturn False\n\treturn True\n", "def on_line(points):\n\ty = 1\n\tx = 0\n\tif len(points) <= 2:\n\t\treturn True\n\tall_x = points[0][x]\n\tall_y = points[0][y]\n\ttest = True\n\tfor point in points[1:]:\n\t\tif point[x] != all_x:\n\t\t\ttest = False\n\t\t\tbreak\n\tif test:\n\t\treturn True\n\tfor point in points[1:]:\n\t\tif point[y] != all_y:\n\t\t\ttest = False\n\t\t\tbreak\n\tif test:\n\t\treturn True\n\tif points[1][x] - points[0][x] != 0:\n\t\ta = (points[1][y] - points[0][y]) / (points[1][x] - points[0][x])\n\telse:\n\t\ta = 0\n\tb = points[0][y] - a * points[0][x]\n\tfor point in points[2:]:\n\t\tif point[y] != a * point[x] + b:\n\t\t\treturn False\n\treturn True\n"], "898": ["from itertools import groupby\n\ndef group_ints(lst, key=0):\n\treturn [list(g) for (_, g) in groupby(lst, lambda a: a < key)]\ngroupInts = group_ints\n", "from itertools import groupby\n\ndef group_ints(lst, key=0):\n\treturn [list(g) for (_, g) in groupby(lst, key.__gt__)]\n", "def group_ints(lst, key=0):\n\tfrom itertools import groupby\n\treturn [list(group) for (_, group) in groupby(lst, lambda v: v >= key)]\n", "from itertools import groupby\nfrom operator import itemgetter\n\ndef group_ints(lst, key=0):\n\treturn list(map(list, map(itemgetter(1), groupby(lst, key.__gt__))))\n", "def group_ints(lst, key=0):\n\tfirst = []\n\tsecond = []\n\tfinal = []\n\tfor i in lst:\n\t\tif i < key:\n\t\t\tif second:\n\t\t\t\tfinal.append(second)\n\t\t\t\tsecond = []\n\t\t\tfirst.append(i)\n\t\telse:\n\t\t\tif first:\n\t\t\t\tfinal.append(first)\n\t\t\t\tfirst = []\n\t\t\tsecond.append(i)\n\tif first:\n\t\tfinal.append(first)\n\tif second:\n\t\tfinal.append(second)\n\treturn final\n", "def group_ints(lst, key=0):\n\tif not lst:\n\t\treturn []\n\t(l, index) = ([[lst[0]]], 0)\n\tfor x in lst[1:]:\n\t\tif l[index][-1] < key and x < key:\n\t\t\tl[index].append(x)\n\t\telif l[index][-1] >= key and x >= key:\n\t\t\tl[index].append(x)\n\t\telse:\n\t\t\tl.append([x])\n\t\t\tindex += 1\n\treturn l\n", "class Nest:\n\n\tdef __init__(self, key, list):\n\t\tself.key = key\n\t\tself.list = list\n\t\tself.chen = 0\n\t\tself.temp_list = []\n\t\tself.new_list = []\n\t\tself.ACT = {1: self.__ap_end__, 0: self.__swich__}\n\t\tself.OPER = {0: lambda a, b: a < b, 1: lambda a, b: a >= b}\n\n\tdef __ap_end__(self, c_list, element):\n\t\tc_list.append(element)\n\n\tdef __swich__(self, c_list, element):\n\t\tif c_list:\n\t\t\tself.__ap_end__(self.new_list, c_list)\n\t\tself.temp_list = [element]\n\t\tself.chen = not self.chen\n\n\tdef do_sort(self):\n\t\tif not self.list:\n\t\t\treturn []\n\t\tfor e in self.list:\n\t\t\tself.ACT[self.OPER[self.chen](e, self.key)](self.temp_list, e)\n\t\treturn self.new_list + [self.temp_list]\ngroup_ints = lambda lst, key=0: Nest(key, lst).do_sort()\n", "def group_ints(lst, key=0):\n\tif not lst:\n\t\treturn lst\n\t(oper, temp, last, chen) = (['<', '>='], [], [], 0)\n\tfor e in lst:\n\t\tif eval(f'{e}{oper[chen]}{key}'):\n\t\t\ttemp.append(e)\n\t\telse:\n\t\t\tif temp:\n\t\t\t\tlast.append(temp)\n\t\t\t(temp, chen) = ([e], not chen)\n\treturn last + [temp]\n", "from itertools import groupby\n\ndef group_ints(lst, key=0):\n\treturn [list(grp) for (k, grp) in groupby(lst, key=lambda x: x < key)]\n", "from itertools import groupby\n\ndef group_ints(lst, key=0):\n\treturn [list(g) for (_, g) in groupby(lst, lambda x: x < key)]\n"], "931": ["def bowling_score(frames):\n\trolls = list(frames.replace(' ', ''))\n\tfor (i, hit) in enumerate(rolls):\n\t\tif hit == 'X':\n\t\t\trolls[i] = 10\n\t\telif hit == '/':\n\t\t\trolls[i] = 10 - rolls[i - 1]\n\t\telse:\n\t\t\trolls[i] = int(hit)\n\tscore = 0\n\tfor i in range(10):\n\t\tframe = rolls.pop(0)\n\t\tif frame == 10:\n\t\t\tscore += frame + rolls[0] + rolls[1]\n\t\telse:\n\t\t\tframe += rolls.pop(0)\n\t\t\tscore += frame\n\t\t\tif frame == 10:\n\t\t\t\tscore += rolls[0]\n\treturn score\n", "import re\n\ndef bowling_score(frames):\n\tframes = frames.split()\n\tscore = 0\n\tfor (frame, roll) in enumerate(frames, 1):\n\t\tif not roll.isdigit():\n\t\t\tif frame < 10:\n\t\t\t\troll = (roll + ''.join(frames[frame:]))[:3]\n\t\tscore += sum((int(r) if r.isdigit() else 10 for r in re.sub('\\\\d/', 'X', roll)))\n\treturn score\n", "def frame2rolls(frame_line: str):\n\trolls = []\n\tfor i in range(len(frame_line)):\n\t\tif frame_line[i] == 'X':\n\t\t\trolls.append(10)\n\t\telif frame_line[i] == '/':\n\t\t\trolls.append(10 - rolls[-1])\n\t\telif frame_line[i] == ' ':\n\t\t\tcontinue\n\t\telse:\n\t\t\trolls.append(int(frame_line[i]))\n\treturn rolls\n\ndef bowling_score(frame_line: str) -> int:\n\tscore = {i: 0 for i in range(10)}\n\tframes = frame_line.split(' ')\n\trolls = frame2rolls(frame_line)\n\tr = 0\n\tfor i in range(10):\n\t\tif i == 9:\n\t\t\tscore[i] = sum(rolls[r:])\n\t\t\tbreak\n\t\tif frames[i] == 'X':\n\t\t\tscore[i] = 10 + rolls[r + 1] + rolls[r + 2]\n\t\t\tr += 1\n\t\telif frames[i][-1] == '/':\n\t\t\tscore[i] = 10 + rolls[r + 2]\n\t\t\tr += 2\n\t\telse:\n\t\t\tscore[i] = rolls[r] + rolls[r + 1]\n\t\t\tr += 2\n\tscore = [score[f] for f in score]\n\treturn sum(score)\n\ndef generate_frames() -> str:\n\tframes = []\n\tfor i in range(10):\n\t\troll1 = random.randint(0, 10)\n\t\tif roll1 == 10:\n\t\t\tframes.append('X')\n\t\telse:\n\t\t\troll2 = random.randint(0, 10 - roll1)\n\t\t\tif roll2 + roll1 == 10:\n\t\t\t\tframes.append('%d/' % roll1)\n\t\t\telse:\n\t\t\t\tframes.append('%d%d' % (roll1, roll2))\n\tif frames[-1][-1] == 'X':\n\t\tf10_r2 = random.randint(0, 10)\n\t\tif f10_r2 == 10:\n\t\t\tf10_r3 = random.randint(0, 10)\n\t\t\tif f10_r3 == 10:\n\t\t\t\tframes[-1] = 'XXX'\n\t\t\telse:\n\t\t\t\tframes[-1] = 'XX%d' % f10_r3\n\t\telse:\n\t\t\tf10_r3 = random.randint(0, 10 - f10_r2)\n\t\t\tif f10_r2 + f10_r3 == 10:\n\t\t\t\tframes[-1] = 'X%d/' % f10_r2\n\t\t\telse:\n\t\t\t\tframes[-1] = 'X%d%d' % (f10_r2, f10_r3)\n\telif frames[-1][-1] == '/':\n\t\tf10_r3 = random.randint(0, 10)\n\t\tif f10_r3 != 10:\n\t\t\tframes[-1] = '%s%d' % (frames[-1], f10_r3)\n\t\telse:\n\t\t\tframes[-1] = '%sX' % frames[-1]\n\treturn ' '.join(frames)\n", "def bowling_score(frames):\n\tpins = []\n\tfor (f, frame) in enumerate(frames.split()):\n\t\tfor c in frame:\n\t\t\tif c == 'X':\n\t\t\t\tpins.append([10, 2, f])\n\t\t\telif c == '/':\n\t\t\t\tp = 10 - pins[-1][0]\n\t\t\t\tpins.append([p, 1, f])\n\t\t\telse:\n\t\t\t\tpins.append([int(c), 0, f])\n\tfor i in range(len(pins)):\n\t\t(score, offset, frame) = pins[i]\n\t\tif offset > 0 and frame < 9:\n\t\t\tpins[i][0] += sum((pin[0] for pin in pins[i + 1:i + 1 + offset]))\n\treturn sum((pin[0] for pin in pins))\n", "from collections import deque\n\ndef bowling_score(frames):\n\tscore = 0\n\tnext_two_rolls = deque([0, 0], 2)\n\tfor (i, frame) in enumerate(reversed(frames.split())):\n\t\tfor roll in reversed(frame):\n\t\t\tif roll == 'X':\n\t\t\t\tadditional = sum(next_two_rolls) if i else 0\n\t\t\t\tscore += 10 + additional\n\t\t\t\tnext_two_rolls.appendleft(10)\n\t\t\telif roll == '/':\n\t\t\t\tadditional = next_two_rolls[0] if i else 0\n\t\t\t\tscore += 10 + additional\n\t\t\t\tnext_two_rolls.appendleft('/')\n\t\t\telse:\n\t\t\t\tif next_two_rolls[0] == '/':\n\t\t\t\t\tnext_two_rolls[0] = 10 - int(roll)\n\t\t\t\telse:\n\t\t\t\t\tscore += int(roll)\n\t\t\t\tnext_two_rolls.appendleft(int(roll))\n\treturn score\n", "def cal(s):\n\tts = 0\n\tfor i in s:\n\t\t(c, t) = (i, 0)\n\t\tif '/' in i:\n\t\t\tf = i.find('/')\n\t\t\tc = i.replace(i[f - 1:f + 1], 'X')\n\t\tfor v in c:\n\t\t\tif v == 'X':\n\t\t\t\tt += 10\n\t\t\telse:\n\t\t\t\tt += int(v)\n\t\tts += t\n\treturn ts\n\ndef bowling_score(frames):\n\tframes = frames.split()\n\tr = []\n\tfor i in range(len(frames)):\n\t\tif i == 9:\n\t\t\tr.append(frames[i])\n\t\t\tcontinue\n\t\telif frames[i][0] == 'X':\n\t\t\tr.append(''.join(frames[i:i + 3])[:3])\n\t\telif '/' in frames[i]:\n\t\t\tr.append(''.join(frames[i:i + 2])[:3])\n\t\telse:\n\t\t\tr.append(frames[i])\n\treturn cal(r)\n", "def bowling_score(frames_main):\n\tframes = frames_main\n\tadd = ''\n\tfor i in range(0, len(frames_main) - 3):\n\t\tif frames_main[i] == '/':\n\t\t\tif frames_main[i - 1] == '0':\n\t\t\t\tframes = frames.replace('/', ' ' + 'V', 1)\n\t\t\t\tadd += str(frames_main[i + 2]) + ' '\n\t\t\t\tcontinue\n\t\t\tframes = frames.replace('/', ' ' + str(10 - int(frames_main[i - 1])), 1)\n\t\t\tadd += str(frames_main[i + 2]) + ' '\n\tframes = list(frames.split(' '))\n\tlast = frames[len(frames) - 1]\n\tframes.remove(last)\n\tif last[1] == '/':\n\t\tif last[0] == '0':\n\t\t\tlast = last.replace('/', 'V', 1)\n\t\tlast = last.replace('/', str(10 - int(last[0])), 1)\n\tframes.append(last)\n\tstring = ''.join(frames)\n\tstring = string.replace('', ' ')[1:-1]\n\tframes = list(string.split(' '))\n\twhile '' in frames:\n\t\tframes.remove('')\n\tfor i in range(0, len(frames) - len(last)):\n\t\tif frames[i] == 'X':\n\t\t\tadd += frames[i + 1] + ' ' + frames[i + 2] + ' '\n\tadd = list(add.split(' ')[0:-1])\n\tstring = ' '.join(frames) + ' ' + ' '.join(add)\n\tstring = string.replace('V', '10')\n\tstring = string.replace('X', '10')\n\tframes = list(string.split(' '))\n\twhile '' in frames:\n\t\tframes.remove('')\n\treturn sum(list(map(int, frames)))\n", "def bowling_score(frames):\n\tscore = frames.split(' ')\n\ttotal = 0\n\tfor i in range(len(score) - 1):\n\t\tif calculate(score[i]) == 10:\n\t\t\tif 'X' in score[i]:\n\t\t\t\tif len(score[i + 1]) == 1:\n\t\t\t\t\ttotal += 10 + calculate(score[i + 1][0]) + calculate(score[i + 2][0])\n\t\t\t\telse:\n\t\t\t\t\ttotal += 10 + calculate(score[i + 1][:2])\n\t\t\telse:\n\t\t\t\ttotal += 10 + calculate(score[i + 1][0])\n\t\telse:\n\t\t\ttotal += calculate(score[i])\n\tif len(score[-1]) == 2:\n\t\treturn total + calculate(score[-1])\n\treturn total + calculate(score[-1][:2]) + calculate(score[-1][2:])\n\ndef calculate(s):\n\tif 'X' in s:\n\t\treturn 10 * s.count('X')\n\telif '/' in s:\n\t\treturn 10\n\treturn int(s[0]) + int(s[1]) if len(s) == 2 else int(s[0])\n"], "934": ["def shortest_time(speed):\n\t(a, b, c, d) = sorted(speed)\n\treturn a + b + d + min(2 * b, a + c)\n", "from itertools import combinations\n\ndef shortest_time(xs, ys=[]):\n\tif len(xs) == 2:\n\t\treturn max(xs)\n\tresult = 999999999\n\tfor (i, j) in combinations(range(len(xs)), 2):\n\t\tm = max(xs[i], xs[j])\n\t\txs2 = xs[:i] + xs[i + 1:j] + xs[j + 1:]\n\t\tys2 = ys + [xs[i], xs[j]]\n\t\tfor (k, y) in enumerate(ys2):\n\t\t\tresult = min(m + y + shortest_time(xs2 + [y], ys2[:k] + ys2[k + 1:]), result)\n\treturn result\n", "shortest_time = lambda a: a.sort() or a[0] + a[1] + min(2 * a[1], a[0] + a[2]) + a[3]\n", "def shortest_time(speed):\n\timport itertools\n\tfrom collections import Counter\n\ttimes = []\n\tfor elem in itertools.combinations(speed, 2):\n\t\tend1 = [x for x in elem]\n\t\tbase1 = list((Counter(speed) - Counter(end1)).elements())\n\t\tfor i in itertools.combinations(end1, 1):\n\t\t\tbase2 = [x for x in base1 + [i[0]]]\n\t\t\tif sum(end1) != 2 * end1[0]:\n\t\t\t\tend2 = [x for x in end1 if x != i[0]]\n\t\t\telse:\n\t\t\t\tend2 = [end1[0]]\n\t\t\tfor j in itertools.combinations(base2, 2):\n\t\t\t\tend3 = [x for x in end2 + [j[0], j[1]]]\n\t\t\t\tbase3 = list((Counter(base2) - Counter(j)).elements())\n\t\t\t\tfor k in itertools.combinations(end3, 1):\n\t\t\t\t\tbase4 = [x for x in base3 + [k[0]]]\n\t\t\t\t\ttimes += [max(elem) + i[0] + max(j) + k[0] + max(base4)]\n\treturn min(times)\n", "from math import inf\nfrom itertools import chain, combinations, combinations_with_replacement\n\ndef shortest_time(speed: [int]):\n\tforward_trips_num = 3\n\tbest_time = inf\n\tfor forward_trips in combinations_with_replacement(list(combinations(speed, 2)), forward_trips_num):\n\t\tif any((list(chain(*forward_trips)).count(s) < speed.count(s) for s in set(speed))):\n\t\t\tcontinue\n\t\tsum_forward = sum([max(trip[0], trip[1]) for trip in forward_trips])\n\t\tsum_return = 0\n\t\treturns = {s: 0 for s in set(speed)}\n\t\tfor s in set(speed):\n\t\t\treturns[s] += sum([trip.count(s) for trip in forward_trips]) - speed.count(s)\n\t\t\tsum_return += returns[s] * s\n\t\tif best_time > sum_forward + sum_return:\n\t\t\tbest_time = sum_forward + sum_return\n\treturn best_time\n", "def shortest_time(speed):\n\tspeed.sort()\n\t[a, b, c, d] = speed\n\treturn min(a + 3 * b + d, 2 * a + b + c + d)\n", "def shortest_time(speed):\n\tspeed.sort()\n\treturn speed[0] + speed[1] + speed[3] + min(2 * speed[1], speed[0] + speed[2])\n", "def shortest_time(speed):\n\tspeed.sort()\n\to = 3 * speed[1] + speed[0] + speed[3]\n\tt = sum(speed[1:]) + (len(speed) - 2) * speed[0]\n\treturn o if o <= t else t\n", "def shortest_time(speed):\n\tcopy = speed\n\tcopy.sort()\n\ty = copy[0] + copy[1] * 3 + copy[3]\n\tminimum = copy.pop(0)\n\tanswers = list()\n\tx = sum(copy) + minimum * (len(copy) - 1)\n\tanswers.append(x)\n\tanswers.append(y)\n\treturn min(answers)\n", "def shortest_time(speed):\n\tspeed = sorted(speed)\n\treturn min(speed[1] * 3 + speed[0] + speed[3], speed[0] + sum(speed))\n"], "944": ["from collections import defaultdict\nimport re\nP = re.compile('\\\\+?(-?\\\\d*)(x\\\\^?)?(\\\\d*)')\n\ndef differentiate(eq, x):\n\tderivate = defaultdict(int)\n\tfor (coef, var, exp) in P.findall(eq):\n\t\texp = int(exp or (var and '1') or '0')\n\t\tcoef = int(coef != '-' and coef or (coef and '-1') or '1')\n\t\tif exp:\n\t\t\tderivate[exp - 1] += exp * coef\n\treturn sum((coef * x ** exp for (exp, coef) in derivate.items()))\n", "def parse_monom(monom):\n\tif 'x' not in monom:\n\t\tmonom = monom + 'x^0'\n\tif monom.startswith('x'):\n\t\tmonom = '1' + monom\n\tif monom.startswith('-x'):\n\t\tmonom = '-1' + monom[1:]\n\tif monom.endswith('x'):\n\t\tmonom = monom + '^1'\n\t(coefficient, degree) = map(int, monom.replace('x', '').split('^'))\n\treturn (degree, coefficient)\n\ndef differentiate(equation, point):\n\tmonoms = equation.replace('-', '+-').lstrip('+').split('+')\n\tpolynom = dict(map(parse_monom, monoms))\n\treturn sum((coefficient * degree * point ** (degree - 1) for (degree, coefficient) in polynom.items() if degree))\n", "from re import finditer\n\ndef differentiate(equation, point):\n\tres = 0\n\tfor exp in finditer('([\\\\+\\\\-])?(\\\\d*)?x\\\\^?(\\\\d+)?', equation):\n\t\tsign = -1 if exp.group(1) == '-' else 1\n\t\tscalar = int(exp.group(2)) if exp.group(2) else 1\n\t\tpower = int(exp.group(3)) if exp.group(3) else 1\n\t\tres += sign * (power * scalar) * point ** (power - 1)\n\treturn res\n", "def differentiate(equation, point):\n\tsigns = [i for i in range(len(equation)) if equation[i] in '+-']\n\tif not 0 in signs:\n\t\tsigns = [0] + signs\n\tcoeffs = []\n\tpowers = []\n\tfor i in range(len(signs)):\n\t\tif i + 1 == len(signs):\n\t\t\tterm = equation[signs[i]:]\n\t\telse:\n\t\t\tterm = equation[signs[i]:signs[i + 1]]\n\t\tif '^' in term:\n\t\t\ti = term.index('^')\n\t\t\tpowers += [int(term.split('^')[1])]\n\t\telif 'x' in term:\n\t\t\tpowers += [1]\n\t\tif 'x' in term:\n\t\t\tc = term.split('x')[0]\n\t\t\tif c in ['', '+', '-']:\n\t\t\t\tcoeffs += [-1 if c == '-' else 1]\n\t\t\telse:\n\t\t\t\tcoeffs += [int(c)]\n\treturn sum([c * p * point ** (p - 1) for (c, p) in zip(coeffs, powers)])\n", "import re\n\ndef differentiate(equation, point):\n\td = {int(p or 1): int({'': 1, '-': -1}.get(n, n)) for (n, x, p) in re.findall('([-]?\\\\d*)(?:(x)(?:\\\\^(\\\\d+))?)?', equation) if x or p}\n\treturn sum((t * p * point ** (p - 1) for (p, t) in d.items()))\n", "def differentiate(equation, point):\n\ta = filter(lambda x: 'x' in x, equation.replace('-', '+-').split('+'))\n\tsum = 0\n\tfor i in list(a):\n\t\tsplit_i = i.split('x')\n\t\tsplit_i[0] = split_i[0] + '1' if split_i[0] == '' or split_i[0] == '-' else split_i[0]\n\t\tsplit_i[1] = '^1' if split_i[1] == '' else split_i[1]\n\t\tsum += int(split_i[0]) * int(split_i[1][1:]) * point ** (int(split_i[1][1:]) - 1)\n\treturn sum\n", "def differentiate(eq, point):\n\teq = eq.replace('-', ' -').strip()\n\teq = eq.replace('+', ' +').strip()\n\teq = eq.replace('-x', '-1x')\n\teq = eq.replace('+x', '+1x')\n\teq = eq.split(' ')\n\teq = [i if i[0].isalpha() == False else '1' + i for i in eq]\n\tif 'x' not in eq[-1]:\n\t\teq.pop(-1)\n\tfor i in range(len(eq)):\n\t\tif eq[i][-1] == 'x':\n\t\t\teq[i] = eq[i][:-1] + 'x^1'\n\t\tj = int(eq[i][-1])\n\t\teq[i] = int(eq[i][:-3]) * j * point ** (j - 1)\n\treturn sum(eq)\n", "import re\n\ndef differentiate(equation, point):\n\tterms = re.findall('[-]*[0-9x^]+', equation)\n\tresult = 0\n\tfor term in terms:\n\t\tamount = re.search('^-*[0-9]+|^-*x', term)\n\t\tif amount is not None:\n\t\t\tamount = amount.group(0)\n\t\t\tif amount == 'x':\n\t\t\t\tamount = 1\n\t\t\telif amount == '-x':\n\t\t\t\tamount = -1\n\t\t\telse:\n\t\t\t\tint(amount)\n\t\tpower = re.search('(?<=\\\\^)\\\\d+$|x+$', term)\n\t\tif power is not None:\n\t\t\tpower = power.group(0)\n\t\t\tif power.isnumeric():\n\t\t\t\tresult = result + int(power) * int(amount) * point ** (int(power) - 1)\n\t\t\telif power == 'x':\n\t\t\t\tpower = 1\n\t\t\t\tresult = result + int(amount) * power\n\treturn result\n", "from re import findall\n\ndef val(s):\n\tif not s:\n\t\treturn 1\n\tif s[0] == '+':\n\t\treturn int(s[1:] or '1')\n\tif s[0] == '-':\n\t\treturn -int(s[1:] or '1')\n\treturn int(s)\n\ndef differentiate(equation, point):\n\tres = 0\n\tfor x in findall('[+-]?\\\\d*x(?:\\\\^\\\\d+)?', equation):\n\t\ti = x.find('x')\n\t\t(v, p) = (val(x[:i]), int(x[i + 2:] or '1'))\n\t\tres += v * p * point ** (p - 1)\n\treturn res\n", "def differentiate(equation, point):\n\tif equation[0] != '-':\n\t\tequation = '+' + equation\n\tequation = equation.replace('+x', '+1x').replace('-x', '-1x').replace('+', ' ').replace('-', ' -')\n\tterms = [[int(e) for e in (w + '^1' if '^' not in w else w).split('x^')] for w in equation.split() if 'x' in w]\n\treturn sum((c * p * point ** (p - 1) for (c, p) in terms))\n"], "947": ["def split_odd_and_even(n):\n\timport re\n\treturn [int(i) for i in re.findall('[2468]+|[13579]+', str(n))]\n", "from itertools import groupby\n\ndef split_odd_and_even(n):\n\treturn [int(''.join(g)) for (i, g) in groupby(str(n), key=lambda x: int(x) % 2)]\n", "def split_odd_and_even(n):\n\tnew_n = ''\n\tfor c in str(n):\n\t\tif not new_n or not (int(new_n[-1]) - int(c)) % 2:\n\t\t\tnew_n += c\n\t\telse:\n\t\t\tnew_n += '.' + c\n\treturn [int(i) for i in new_n.split('.')]\n", "def is_even(n):\n\treturn int(n) % 2 == 0\n\ndef split_odd_and_even(n):\n\t(index, s) = (0, str(n))\n\tl = [[s[0]]]\n\tfor x in s[1:]:\n\t\tif is_even(x) and is_even(l[index][-1]):\n\t\t\tl[index].append(x)\n\t\telif not is_even(x) and (not is_even(l[index][-1])):\n\t\t\tl[index].append(x)\n\t\telse:\n\t\t\tl.append([x])\n\t\t\tindex += 1\n\treturn [int(''.join(x)) for x in l]\n", "from itertools import groupby\n\ndef split_odd_and_even(n):\n\treturn [int(''.join(list(gp))) for (_, gp) in groupby(str(n), key=lambda x: int(x) % 2)]\n", "import re\n\ndef split_odd_and_even(n):\n\treturn [int(group[0] or group[1]) for group in re.findall('([13579]+)|([2468]+)', str(n))]\n", "from itertools import groupby\n\ndef split_odd_and_even(n):\n\treturn [int(''.join((str(b) for b in g))) for (k, g) in groupby((int(a) for a in str(n)), key=lambda b: b % 2)]\n"], "952": ["import heapq\nfrom collections import defaultdict\n\ndef shortest(N, edge):\n\t(ver, inf) = (defaultdict(list), 10 ** 10)\n\tfor e in edge:\n\t\tver[e[0]].append(e[1:])\n\tdist = {i: inf for i in range(N)}\n\t(dist[0], pq) = (0, [])\n\theapq.heappush(pq, [dist[0], 0])\n\twhile pq:\n\t\t(u_dis, u_node) = heapq.heappop(pq)\n\t\tif u_dis == dist[u_node]:\n\t\t\tfor v in ver[u_node]:\n\t\t\t\tv_node = v[0]\n\t\t\t\tv_wei = v[1]\n\t\t\t\tif dist[u_node] + v_wei < dist[v_node]:\n\t\t\t\t\tdist[v_node] = dist[u_node] + v_wei\n\t\t\t\t\theapq.heappush(pq, [dist[v_node], v_node])\n\treturn -1 if dist[N - 1] == inf else dist[N - 1]\n", "def shortest(n, edges):\n\tm = [0] + [float('inf')] * (n - 1)\n\tfor (start, end, weight) in sorted(edges):\n\t\tif m[start] == float('inf'):\n\t\t\tcontinue\n\t\tm[end] = min(m[start] + weight, m[end])\n\treturn -1 if m[-1] == float('inf') else m[-1]\n", "def shortest(N, edgeList):\n\tedgeList.sort(key=lambda x: x[0])\n\tpath_values = [None for _ in range(N)]\n\tpath_values[0] = 0\n\tfor edge in edgeList:\n\t\tif path_values[edge[0]] != None:\n\t\t\tnew_val = edge[2] + path_values[edge[0]]\n\t\t\tif path_values[edge[1]] == None:\n\t\t\t\tpath_values[edge[1]] = new_val\n\t\t\telse:\n\t\t\t\tpath_values[edge[1]] = min(path_values[edge[1]], new_val)\n\tif path_values[-1] == None:\n\t\treturn -1\n\telse:\n\t\treturn path_values[-1]\n", "def shortest(N, edges):\n\tpath = [0] + [float('inf')] * (N - 1)\n\tfor (start, end, weight) in sorted(edges):\n\t\tif path[start] == -1:\n\t\t\tcontinue\n\t\tpath[end] = min(path[start] + weight, path[end])\n\treturn -1 if path[-1] == float('inf') else path[-1]\n", "from collections import defaultdict\nINFINITY = 2 ** 80\n\ndef shortest(N, edgeList):\n\tedges = defaultdict(list)\n\tfor (fro, to, weight) in edgeList:\n\t\tedges[fro].append((to, weight))\n\tdist_dp = [INFINITY] * N\n\tdist_dp[0] = 0\n\tfor i in range(N):\n\t\tfor (to, w) in edges[i]:\n\t\t\tdist_dp[to] = min(dist_dp[to], dist_dp[i] + w)\n\treturn -1 if dist_dp[N - 1] >= INFINITY else dist_dp[N - 1]\n", "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List, Tuple\n\ndef shortest(N: int, edgeList: List[Tuple[int, int, int]]) -> int:\n\tgraph = defaultdict(list)\n\tfor (v, u, e) in edgeList:\n\t\tgraph[v].append((u, e))\n\tpathes = defaultdict(lambda : float('inf'), {0: 0})\n\tqueue = [(0, 0)]\n\twhile queue:\n\t\t(cost, v) = heappop(queue)\n\t\tif v == N - 1:\n\t\t\treturn cost\n\t\tfor (u, e) in graph[v]:\n\t\t\tnew_cost = cost + e\n\t\t\tif new_cost < pathes[u]:\n\t\t\t\tpathes[u] = new_cost\n\t\t\t\theappush(queue, (new_cost, u))\n\treturn -1\n", "def shortest(N, es):\n\tee = [[] for _ in range(N)]\n\tfor (f, t, w) in es:\n\t\tee[f].append((t, w))\n\tdd = [2139062143 for _ in range(N)]\n\tf = [False for _ in range(N)]\n\tdd[0] = 0\n\tq = [0]\n\tf[0] = True\n\twhile len(q) > 0:\n\t\tk = q.pop()\n\t\tf[k] = False\n\t\tfor (t, w) in ee[k]:\n\t\t\tif dd[t] > dd[k] + w:\n\t\t\t\tdd[t] = dd[k] + w\n\t\t\t\tif not f[t]:\n\t\t\t\t\tq.append(t)\n\t\t\t\t\tf[t] = True\n\treturn -1 if dd[N - 1] == 2139062143 else dd[N - 1]\n", "def shortest(N, edgeList):\n\timport math\n\tedgeList.sort(key=lambda x: x[0])\n\tpath_length = [math.inf for _ in range(N)]\n\tpath_length[0] = 0\n\tfor (start, end, weight) in edgeList:\n\t\tif path_length[start] == math.inf:\n\t\t\tcontinue\n\t\tpath_length[end] = min(path_length[start] + weight, path_length[end])\n\tresult = path_length[N - 1]\n\treturn result if result is not math.inf else -1\n", "from collections import defaultdict\nfrom heapq import *\n\ndef shortest(N, edges):\n\tf = 0\n\tt = N - 1\n\tg = defaultdict(list)\n\tfor (l, r, c) in edges:\n\t\tg[l].append((c, r))\n\t(q, seen, mins) = ([(0, f, ())], set(), {f: 0})\n\twhile q:\n\t\t(cost, v1, path) = heappop(q)\n\t\tif v1 not in seen:\n\t\t\tseen.add(v1)\n\t\t\tpath = (v1, path)\n\t\t\tif v1 == t:\n\t\t\t\treturn cost\n\t\t\tfor (c, v2) in g.get(v1, ()):\n\t\t\t\tif v2 in seen:\n\t\t\t\t\tcontinue\n\t\t\t\tprev = mins.get(v2, None)\n\t\t\t\tnext = cost + c\n\t\t\t\tif prev is None or next < prev:\n\t\t\t\t\tmins[v2] = next\n\t\t\t\t\theappush(q, (next, v2, path))\n\treturn -1\n"]}