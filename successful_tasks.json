[
    {
        "task_id": 20,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def is_sorted_and_how(arr):\n\tif arr == sorted(arr):\n\t\treturn 'yes, ascending'\n\telif arr == sorted(arr)[::-1]:\n\t\treturn 'yes, descending'\n\telse:\n\t\treturn 'no'\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 5,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 0.21929240226745605,
        "fastest_time": 0.0,
        "fastest_solution": "from math import *\nDIGS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef converter(n, decimals=0, base=pi):\n\t(lst, n) = (['-' * (n < 0)], abs(n))\n\tpMax = max(0, n and int(log(n, base)))\n\tfor p in reversed(range(-decimals, pMax + 1)):\n\t\tif p == -1:\n\t\t\tlst.append('.')\n\t\tp = base ** p\n\t\t(d, n) = (n / p, n % p)\n\t\tlst.append(DIGS[int(d)])\n\treturn ''.join(lst)\n",
        "slowest_solution": "from math import pi\nimport math\n\ndef converter(n, decimals=0, base=pi):\n\tprint(n)\n\tprint(decimals)\n\tprint(base)\n\tnegative = False\n\tretVal = ''\n\tif n == 0:\n\t\tleft = 0\n\telse:\n\t\tif n < 0:\n\t\t\tn = n * -1\n\t\t\tnegative = True\n\t\t\tretVal = '-'\n\t\tleft = math.floor(math.log(abs(n)) / math.log(base))\n\tcharList = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n\tfor p in range(left, 0 - decimals - 1, -1):\n\t\tif p == -1:\n\t\t\tretVal += '.'\n\t\tcoeff = math.pow(base, p)\n\t\tprint('XXXXXXXX')\n\t\tprint(n)\n\t\tprint(coeff)\n\t\tprint('XXXXXXXX')\n\t\tprint(math.floor(n / coeff))\n\t\tretVal += charList[math.floor(n / coeff)]\n\t\tn = n - math.floor(n / coeff) * coeff\n\tprint(retVal)\n\treturn retVal\n"
    },
    {
        "task_id": 14,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.5346474647521973,
        "fastest_time": 3.5346474647521973,
        "fastest_solution": "from sys import stdin\ninput = stdin.readline\n\ndef main():\n\tmod = 10 ** 9 + 7\n\t(n, l, m) = map(int, input().split())\n\tar = [0 for i in range(m)]\n\tar3 = [0 for i in range(m)]\n\n\tdef f(num):\n\t\treturn int(num) % m\n\n\tdef f2(num):\n\t\treturn num % 1000000007\n\tai1 = list(map(f, input().split()))\n\tai2 = list(map(f, input().split()))\n\tai3 = list(map(f, input().split()))\n\tmm = m ** 2\n\tar2 = [0 for i in range(mm)]\n\n\tdef mult(m1, m2):\n\t\tans = [0 for i in range(mm)]\n\t\tm12 = [0 for i in range(m)]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tm12[i] += m1[i + j * m]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\ttemp = (i + j) % m\n\t\t\t\tfor j2 in range(m):\n\t\t\t\t\tans[temp + j2 * m] += m12[i] * m2[j + j2 * m]\n\t\tans = list(map(f2, ans))\n\t\treturn ans\n\n\tdef mult2(m1, m2):\n\t\tans = [0] * m\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tans[(i + j) % m] += m1[i] * m2[j]\n\t\tprint(ans[0] % mod)\n\n\tdef mult3(m1, m2):\n\t\tm12 = [0 for i in range(m)]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tm12[i] += m1[i + j * m]\n\t\t\t\tm12[i] %= mod\n\t\tm22 = [0 for i in range(m)]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tm22[i] += m2[i + j * m]\n\t\t\t\tm22[i] %= mod\n\t\tans = [0 for i in range(mm)]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tans[(i + j) % m] += m12[i] * m22[j]\n\t\t\t\tans[(i + j) % m] %= mod\n\t\treturn ans\n\n\tdef power(number, n):\n\t\tn -= 1\n\t\tif n == -1:\n\t\t\treturn number\n\t\tres = number\n\t\tnumber2 = [number[i] for i in range(mm)]\n\t\twhile n:\n\t\t\tif n & 1:\n\t\t\t\tres = mult3(res, number)\n\t\t\tnumber = mult3(number, number)\n\t\t\tn >>= 1\n\t\treturn mult(res, number2)\n\tfor i in range(n):\n\t\tar[ai1[i]] += 1\n\t\tar2[ai2[i] + ai3[i] * m] += 1\n\t\tar3[ai2[i]] += 1\n\tif l == 1:\n\t\tmult2(ar, ar3)\n\t\treturn\n\tans = power(ar2, l - 2)\n\tar4 = [0] * m\n\tfor i in range(m):\n\t\tfor j in range(m):\n\t\t\tar4[(i + j) % m] += ans[i + j * m]\n\tmult2(ar, ar4)\nmain()\n",
        "slowest_solution": "from sys import stdin\ninput = stdin.readline\n\ndef main():\n\tmod = 10 ** 9 + 7\n\t(n, l, m) = map(int, input().split())\n\tar = [0 for i in range(m)]\n\tar3 = [0 for i in range(m)]\n\n\tdef f(num):\n\t\treturn int(num) % m\n\n\tdef f2(num):\n\t\treturn num % 1000000007\n\tai1 = list(map(f, input().split()))\n\tai2 = list(map(f, input().split()))\n\tai3 = list(map(f, input().split()))\n\tmm = m ** 2\n\tar2 = [0 for i in range(mm)]\n\n\tdef mult(m1, m2):\n\t\tans = [0 for i in range(mm)]\n\t\tm12 = [0 for i in range(m)]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tm12[i] += m1[i + j * m]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\ttemp = (i + j) % m\n\t\t\t\tfor j2 in range(m):\n\t\t\t\t\tans[temp + j2 * m] += m12[i] * m2[j + j2 * m]\n\t\tans = list(map(f2, ans))\n\t\treturn ans\n\n\tdef mult2(m1, m2):\n\t\tans = [0] * m\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tans[(i + j) % m] += m1[i] * m2[j]\n\t\tprint(ans[0] % mod)\n\n\tdef mult3(m1, m2):\n\t\tm12 = [0 for i in range(m)]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tm12[i] += m1[i + j * m]\n\t\t\t\tm12[i] %= mod\n\t\tm22 = [0 for i in range(m)]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tm22[i] += m2[i + j * m]\n\t\t\t\tm22[i] %= mod\n\t\tans = [0 for i in range(mm)]\n\t\tfor i in range(m):\n\t\t\tfor j in range(m):\n\t\t\t\tans[(i + j) % m] += m12[i] * m22[j]\n\t\t\t\tans[(i + j) % m] %= mod\n\t\treturn ans\n\n\tdef power(number, n):\n\t\tn -= 1\n\t\tif n == -1:\n\t\t\treturn number\n\t\tres = number\n\t\tnumber2 = [number[i] for i in range(mm)]\n\t\twhile n:\n\t\t\tif n & 1:\n\t\t\t\tres = mult3(res, number)\n\t\t\tnumber = mult3(number, number)\n\t\t\tn >>= 1\n\t\treturn mult(res, number2)\n\tfor i in range(n):\n\t\tar[ai1[i]] += 1\n\t\tar2[ai2[i] + ai3[i] * m] += 1\n\t\tar3[ai2[i]] += 1\n\tif l == 1:\n\t\tmult2(ar, ar3)\n\t\treturn\n\tans = power(ar2, l - 2)\n\tar4 = [0] * m\n\tfor i in range(m):\n\t\tfor j in range(m):\n\t\t\tar4[(i + j) % m] += ans[i + j * m]\n\tmult2(ar, ar4)\nmain()\n"
    },
    {
        "task_id": 18,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.6754186153411865,
        "fastest_time": 3.6754186153411865,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom math import ceil\n\ndef prod(a, mod=10 ** 9 + 7):\n\tans = 1\n\tfor each in a:\n\t\tans = ans * each % mod\n\treturn ans\n\ndef gcd(x, y):\n\twhile y:\n\t\t(x, y) = (y, x % y)\n\treturn x\n\ndef lcm(a, b):\n\treturn a * b // gcd(a, b)\n\ndef binary(x, length=16):\n\ty = bin(x)[2:]\n\treturn y if len(y) >= length else '0' * (length - len(y)) + y\nfor _ in range(int(input()) if not True else 1):\n\t(n, k) = map(int, input().split())\n\tt = list(map(int, input().split()))\n\ta = list(map(int, input().split()))\n\tfor i in range(n):\n\t\tif t[i] == 2:\n\t\t\ta[i] *= -1\n\tcount = [0] * (n + 1)\n\tpre = [0]\n\tfor i in a:\n\t\tpre += [pre[-1] + i]\n\tindex = {}\n\tcc = list(set(pre))\n\tfor i in range(len(cc)):\n\t\tindex[cc[i]] = i\n\tminusK = [-1] * (n + 1)\n\tplusK = [-1] * (n + 1)\n\tzero = [-1] * (n + 1)\n\tfor i in range(n + 1):\n\t\tif pre[i] - k in index:\n\t\t\tminusK[i] = index[pre[i] - k]\n\t\tif pre[i] + k in index:\n\t\t\tplusK[i] = index[pre[i] + k]\n\t\tzero[i] = index[pre[i]]\n\tBLOCK_SIZE = 320\n\tblocks = [[] for i in range(BLOCK_SIZE)]\n\tq = int(input())\n\tans = [0] * q\n\tfor i in range(q):\n\t\t(l, r) = map(int, input().split())\n\t\tblocks[l // BLOCK_SIZE] += [[l - 1, r, i]]\n\tfor i in range(len(blocks)):\n\t\tif not blocks[i]:\n\t\t\tcontinue\n\t\tblocks[i] = sorted(blocks[i], key=lambda x: x[1])\n\t\tleft = right = BLOCK_SIZE * i\n\t\tres = 0\n\t\tcount[zero[left]] += 1\n\t\tfor (l, r, ind) in blocks[i]:\n\t\t\twhile right < r:\n\t\t\t\tright += 1\n\t\t\t\tif minusK[right] != -1:\n\t\t\t\t\tres += count[minusK[right]]\n\t\t\t\tcount[zero[right]] += 1\n\t\t\twhile left < l:\n\t\t\t\tcount[zero[left]] -= 1\n\t\t\t\tif plusK[left] != -1:\n\t\t\t\t\tres -= count[plusK[left]]\n\t\t\t\tleft += 1\n\t\t\twhile left > l:\n\t\t\t\tleft -= 1\n\t\t\t\tif plusK[left] != -1:\n\t\t\t\t\tres += count[plusK[left]]\n\t\t\t\tcount[zero[left]] += 1\n\t\t\tans[ind] = res\n\t\twhile left <= right:\n\t\t\tcount[zero[left]] -= 1\n\t\t\tif plusK[left] != -1:\n\t\t\t\tres -= count[plusK[left]]\n\t\t\tleft += 1\n\t\tassert res == 0\n\tfor i in ans:\n\t\tprint(i)\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom math import ceil\n\ndef prod(a, mod=10 ** 9 + 7):\n\tans = 1\n\tfor each in a:\n\t\tans = ans * each % mod\n\treturn ans\n\ndef gcd(x, y):\n\twhile y:\n\t\t(x, y) = (y, x % y)\n\treturn x\n\ndef lcm(a, b):\n\treturn a * b // gcd(a, b)\n\ndef binary(x, length=16):\n\ty = bin(x)[2:]\n\treturn y if len(y) >= length else '0' * (length - len(y)) + y\nfor _ in range(int(input()) if not True else 1):\n\t(n, k) = map(int, input().split())\n\tt = list(map(int, input().split()))\n\ta = list(map(int, input().split()))\n\tfor i in range(n):\n\t\tif t[i] == 2:\n\t\t\ta[i] *= -1\n\tcount = [0] * (n + 1)\n\tpre = [0]\n\tfor i in a:\n\t\tpre += [pre[-1] + i]\n\tindex = {}\n\tcc = list(set(pre))\n\tfor i in range(len(cc)):\n\t\tindex[cc[i]] = i\n\tminusK = [-1] * (n + 1)\n\tplusK = [-1] * (n + 1)\n\tzero = [-1] * (n + 1)\n\tfor i in range(n + 1):\n\t\tif pre[i] - k in index:\n\t\t\tminusK[i] = index[pre[i] - k]\n\t\tif pre[i] + k in index:\n\t\t\tplusK[i] = index[pre[i] + k]\n\t\tzero[i] = index[pre[i]]\n\tBLOCK_SIZE = 320\n\tblocks = [[] for i in range(BLOCK_SIZE)]\n\tq = int(input())\n\tans = [0] * q\n\tfor i in range(q):\n\t\t(l, r) = map(int, input().split())\n\t\tblocks[l // BLOCK_SIZE] += [[l - 1, r, i]]\n\tfor i in range(len(blocks)):\n\t\tif not blocks[i]:\n\t\t\tcontinue\n\t\tblocks[i] = sorted(blocks[i], key=lambda x: x[1])\n\t\tleft = right = BLOCK_SIZE * i\n\t\tres = 0\n\t\tcount[zero[left]] += 1\n\t\tfor (l, r, ind) in blocks[i]:\n\t\t\twhile right < r:\n\t\t\t\tright += 1\n\t\t\t\tif minusK[right] != -1:\n\t\t\t\t\tres += count[minusK[right]]\n\t\t\t\tcount[zero[right]] += 1\n\t\t\twhile left < l:\n\t\t\t\tcount[zero[left]] -= 1\n\t\t\t\tif plusK[left] != -1:\n\t\t\t\t\tres -= count[plusK[left]]\n\t\t\t\tleft += 1\n\t\t\twhile left > l:\n\t\t\t\tleft -= 1\n\t\t\t\tif plusK[left] != -1:\n\t\t\t\t\tres += count[plusK[left]]\n\t\t\t\tcount[zero[left]] += 1\n\t\t\tans[ind] = res\n\t\twhile left <= right:\n\t\t\tcount[zero[left]] -= 1\n\t\t\tif plusK[left] != -1:\n\t\t\t\tres -= count[plusK[left]]\n\t\t\tleft += 1\n\t\tassert res == 0\n\tfor i in ans:\n\t\tprint(i)\n"
    },
    {
        "task_id": 32,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 4.152597188949585,
        "fastest_time": 4.152597188949585,
        "fastest_solution": "F = {}\n\ndef f(k):\n\tif not k in F:\n\t\t(s, i, j) = (0, 4, 4)\n\t\twhile i <= k:\n\t\t\ts += i * f(k // i)\n\t\t\ti += j + 1\n\t\t\tj += 2\n\t\tF[k] = k * (k + 1) // 2 - s\n\treturn F[k]\n\ndef g(k):\n\t(s, i, j) = (0, 4, 4)\n\twhile i <= k:\n\t\ts += (i - 1) * f(k // i)\n\t\ti += j + 1\n\t\tj += 2\n\treturn k * (k + 1) // 2 - s\n(a, n) = map(int, input().split())\nprint(g(a + n - 1) - g(a - 1))\n",
        "slowest_solution": "F = {}\n\ndef f(k):\n\tif not k in F:\n\t\t(s, i, j) = (0, 4, 4)\n\t\twhile i <= k:\n\t\t\ts += i * f(k // i)\n\t\t\ti += j + 1\n\t\t\tj += 2\n\t\tF[k] = k * (k + 1) // 2 - s\n\treturn F[k]\n\ndef g(k):\n\t(s, i, j) = (0, 4, 4)\n\twhile i <= k:\n\t\ts += (i - 1) * f(k // i)\n\t\ti += j + 1\n\t\tj += 2\n\treturn k * (k + 1) // 2 - s\n(a, n) = map(int, input().split())\nprint(g(a + n - 1) - g(a - 1))\n"
    },
    {
        "task_id": 11,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.688265323638916,
        "fastest_time": 3.688265323638916,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\n(K, A0, B0, A1, B1) = ([], [], [], [], [])\nfor _ in range(n):\n\tk = int(input())\n\t(a0, b0) = map(int, input().split())\n\t(a1, b1) = map(int, input().split())\n\tK.append(k)\n\tA0.append(a0)\n\tB0.append(b0)\n\tA1.append(a1)\n\tB1.append(b1)\nans = []\n(C0, D0, C1, D1) = ([0] * (n + 1), [0] * (n + 1), [0] * (n + 1), [0] * (n + 1))\n(C0[n], D0[n], C1[n], D1[n]) = (0, m, 0, m)\nfor i in range(n - 1, -1, -1):\n\t(C0[i], D0[i], C1[i], D1[i]) = (m + 1, 0, m + 1, 0)\n\tif A0[i] <= K[i] <= B0[i]:\n\t\tif C0[i + 1] <= K[i] <= D0[i + 1]:\n\t\t\t(C1[i], D1[i]) = (A1[i], B1[i])\n\t\telse:\n\t\t\t(C1[i], D1[i]) = (max(A1[i], C1[i + 1]), min(B1[i], D1[i + 1]))\n\tif A1[i] <= K[i] <= B1[i]:\n\t\tif C1[i + 1] <= K[i] <= D1[i + 1]:\n\t\t\t(C0[i], D0[i]) = (A0[i], B0[i])\n\t\telse:\n\t\t\t(C0[i], D0[i]) = (max(A0[i], C0[i + 1]), min(B0[i], D0[i + 1]))\nif C0[0] <= 0 <= D0[0] or C1[0] <= 0 <= D1[0]:\n\tprint('Yes')\n\t(x, y) = (0, 0)\n\tfor i in range(n):\n\t\tif A0[i] <= K[i] <= B0[i] and A1[i] <= y <= B1[i] and (C0[i + 1] <= K[i] <= D0[i + 1] or C1[i + 1] <= y <= D1[i + 1]):\n\t\t\tx = K[i]\n\t\t\tans.append(0)\n\t\telse:\n\t\t\ty = K[i]\n\t\t\tans.append(1)\n\tprint(*ans)\nelse:\n\tprint('No')\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\n(K, A0, B0, A1, B1) = ([], [], [], [], [])\nfor _ in range(n):\n\tk = int(input())\n\t(a0, b0) = map(int, input().split())\n\t(a1, b1) = map(int, input().split())\n\tK.append(k)\n\tA0.append(a0)\n\tB0.append(b0)\n\tA1.append(a1)\n\tB1.append(b1)\nans = []\n(C0, D0, C1, D1) = ([0] * (n + 1), [0] * (n + 1), [0] * (n + 1), [0] * (n + 1))\n(C0[n], D0[n], C1[n], D1[n]) = (0, m, 0, m)\nfor i in range(n - 1, -1, -1):\n\t(C0[i], D0[i], C1[i], D1[i]) = (m + 1, 0, m + 1, 0)\n\tif A0[i] <= K[i] <= B0[i]:\n\t\tif C0[i + 1] <= K[i] <= D0[i + 1]:\n\t\t\t(C1[i], D1[i]) = (A1[i], B1[i])\n\t\telse:\n\t\t\t(C1[i], D1[i]) = (max(A1[i], C1[i + 1]), min(B1[i], D1[i + 1]))\n\tif A1[i] <= K[i] <= B1[i]:\n\t\tif C1[i + 1] <= K[i] <= D1[i + 1]:\n\t\t\t(C0[i], D0[i]) = (A0[i], B0[i])\n\t\telse:\n\t\t\t(C0[i], D0[i]) = (max(A0[i], C0[i + 1]), min(B0[i], D0[i + 1]))\nif C0[0] <= 0 <= D0[0] or C1[0] <= 0 <= D1[0]:\n\tprint('Yes')\n\t(x, y) = (0, 0)\n\tfor i in range(n):\n\t\tif A0[i] <= K[i] <= B0[i] and A1[i] <= y <= B1[i] and (C0[i + 1] <= K[i] <= D0[i + 1] or C1[i + 1] <= y <= D1[i + 1]):\n\t\t\tx = K[i]\n\t\t\tans.append(0)\n\t\telse:\n\t\t\ty = K[i]\n\t\t\tans.append(1)\n\tprint(*ans)\nelse:\n\tprint('No')\n"
    },
    {
        "task_id": 3,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 3.651397705078125,
        "fastest_time": 3.109307050704956,
        "fastest_solution": "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nif n < a[0] or n > a[k - 1]:\n\tprint(-1)\nelse:\n\tb = []\n\tb.append(a[0])\n\tfor i in a:\n\t\tif i != b[len(b) - 1]:\n\t\t\tb.append(i)\n\td = {}\n\tfor i in range(len(b)):\n\t\tb[i] -= n\n\t\td[b[i]] = 1\n\tans = 1\n\twhile 0 not in d:\n\t\td1 = {}\n\t\tfor i in d:\n\t\t\tfor j in b:\n\t\t\t\tif -1001 < i + j < 1001:\n\t\t\t\t\td1[i + j] = 1\n\t\td = d1\n\t\tans += 1\n\tprint(ans)\n",
        "slowest_solution": "from collections import deque\nMAX_A = 1000\n\ndef main():\n\t(n, k) = map(int, input().split())\n\ta = set((int(x) - n for x in input().split()))\n\tvisited = [False] * (2 * MAX_A + 1)\n\tvisited[n] = True\n\tQ = deque()\n\tQ.append((n, 0))\n\tresult = None\n\twhile Q:\n\t\t(u, l) = Q.popleft()\n\t\tl += 1\n\t\tfor ai in a:\n\t\t\tv = u + ai\n\t\t\tif v == n:\n\t\t\t\tresult = l\n\t\t\t\tbreak\n\t\t\tif 0 <= v < len(visited) and (not visited[v]):\n\t\t\t\tvisited[v] = True\n\t\t\t\tQ.append((v, l))\n\t\tif result is not None:\n\t\t\tbreak\n\tif result is None:\n\t\tresult = -1\n\tprint(result)\nmain()\n"
    },
    {
        "task_id": 36,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.147613763809204,
        "fastest_time": 3.147613763809204,
        "fastest_solution": "import sys\nfrom array import array\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\nn = int(input())\nbeaver = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\ndeg = [0] * n\nfor (u, v) in (map(int, input().split()) for _ in range(n - 1)):\n\tadj[u - 1].append(v - 1)\n\tadj[v - 1].append(u - 1)\n\tdeg[u - 1] += 1\n\tdeg[v - 1] += 1\nstart = int(input()) - 1\ndeg[start] += 1000000\nif n == 1:\n\tprint(0)\n\texit()\ndp = [0] * n\nstack = [i for i in range(n) if i != start and deg[i] == 1]\nwhile stack:\n\tv = stack.pop()\n\tdeg[v] = 0\n\tchild = []\n\tchild_dp = []\n\tfor dest in adj[v]:\n\t\tif deg[dest] == 0:\n\t\t\tchild.append(dest)\n\t\t\tchild_dp.append(dp[dest])\n\t\telse:\n\t\t\tdeg[dest] -= 1\n\t\t\tif deg[dest] == 1:\n\t\t\t\tstack.append(dest)\n\tchild_dp.sort(reverse=True)\n\tx = min(beaver[v] - 1, len(child))\n\tdp[v] = 1 + sum(child_dp[:x]) + x\n\tbeaver[v] -= x + 1\n\tfor c in child:\n\t\tx = min(beaver[v], beaver[c])\n\t\tbeaver[v] -= x\n\t\tdp[v] += 2 * x\nx = min(beaver[start], len(adj[start]))\nchild_dp = sorted((dp[v] for v in adj[start]), reverse=True)\nans = sum(child_dp[:x]) + x\nbeaver[start] -= x\nfor c in adj[start]:\n\tx = min(beaver[start], beaver[c])\n\tbeaver[start] -= x\n\tans += 2 * x\nprint(ans)\n",
        "slowest_solution": "import sys\nfrom array import array\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\nn = int(input())\nbeaver = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\ndeg = [0] * n\nfor (u, v) in (map(int, input().split()) for _ in range(n - 1)):\n\tadj[u - 1].append(v - 1)\n\tadj[v - 1].append(u - 1)\n\tdeg[u - 1] += 1\n\tdeg[v - 1] += 1\nstart = int(input()) - 1\ndeg[start] += 1000000\nif n == 1:\n\tprint(0)\n\texit()\ndp = [0] * n\nstack = [i for i in range(n) if i != start and deg[i] == 1]\nwhile stack:\n\tv = stack.pop()\n\tdeg[v] = 0\n\tchild = []\n\tchild_dp = []\n\tfor dest in adj[v]:\n\t\tif deg[dest] == 0:\n\t\t\tchild.append(dest)\n\t\t\tchild_dp.append(dp[dest])\n\t\telse:\n\t\t\tdeg[dest] -= 1\n\t\t\tif deg[dest] == 1:\n\t\t\t\tstack.append(dest)\n\tchild_dp.sort(reverse=True)\n\tx = min(beaver[v] - 1, len(child))\n\tdp[v] = 1 + sum(child_dp[:x]) + x\n\tbeaver[v] -= x + 1\n\tfor c in child:\n\t\tx = min(beaver[v], beaver[c])\n\t\tbeaver[v] -= x\n\t\tdp[v] += 2 * x\nx = min(beaver[start], len(adj[start]))\nchild_dp = sorted((dp[v] for v in adj[start]), reverse=True)\nans = sum(child_dp[:x]) + x\nbeaver[start] -= x\nfor c in adj[start]:\n\tx = min(beaver[start], beaver[c])\n\tbeaver[start] -= x\n\tans += 2 * x\nprint(ans)\n"
    },
    {
        "task_id": 35,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 4.438503980636597,
        "fastest_time": 2.6047871112823486,
        "fastest_solution": "from collections import deque\nrows = int(input())\nstk = deque()\nans = 1\n\ndef overlap(l1, r1, l2, r2):\n\t(x, y) = (max(l1, l2), min(r1, r2))\n\tif x > r1 or x > r2 or y < l1 or (y < l2):\n\t\treturn None\n\treturn (x, y)\nfor j in range(rows):\n\t(lt, rt) = map(int, input().split())\n\tstkb = deque()\n\twhile stk and (stk[-1][0][0] < lt or stk[-1][0][1] > rt):\n\t\ttop = stk.pop()\n\t\t(x, y) = top[0]\n\t\twidth = top[0][1] - top[0][0] + 1\n\t\theight = j - 1 - top[1] + 1\n\t\tans = max(ans, min(width, height))\n\t\teval = overlap(lt, rt, x, y)\n\t\tif eval is not None:\n\t\t\tstkb.append((eval, top[1]))\n\twhile stkb:\n\t\ttop = stkb.pop()\n\t\tif top[0][1] - top[0][0] + 1 > ans:\n\t\t\tstk.append(top)\n\tif not stk or not (stk[-1][0][0] == lt and stk[-1][0][1] == rt):\n\t\tif rt - lt + 1 > ans:\n\t\t\tstk.append(((lt, rt), j))\nwhile stk:\n\ttop = stk.pop()\n\t(x, y) = top[0]\n\t(height, width) = (rows - top[1], y - x + 1)\n\tans = max(ans, min(height, width))\nprint(ans)\n",
        "slowest_solution": "from collections import deque\nn = int(input())\nq1 = deque()\nres = 1\n\ndef helper(left1, right1, left2, right2):\n\t(temp1, temp2) = (max(left1, left2), min(right1, right2))\n\tif temp1 > right1 or temp1 > right2 or temp2 < left1 or (temp2 < left2):\n\t\treturn None\n\treturn (temp1, temp2)\nfor i in range(n):\n\t(left, right) = map(int, input().split())\n\tq2 = deque()\n\twhile q1 and (q1[0][0][0] < left or q1[0][0][1] > right):\n\t\ttop = q1.pop()\n\t\t(temp1, temp2) = top[0]\n\t\twidth = top[0][1] - top[0][0] + 1\n\t\theight = i - 1 - top[1] + 1\n\t\tres = max(res, min(width, height))\n\t\tvalues = helper(left, right, temp1, temp2)\n\t\tif eval is not None:\n\t\t\tq2.append((values, top[1]))\n\twhile q2:\n\t\ttop = q2.pop()\n\t\tif top[0][1] - top[0][0] + 1 > res:\n\t\t\tq1.append(top)\n\tif not q1 or not (q1[-1][0][0] == left and q1[-1][0][1] == right):\n\t\tif right - left + 1 > res:\n\t\t\tq1.append(((left, right), i))\nwhile q1:\n\ttop = q1.pop()\n\t(temp1, temp2) = top[0]\n\t(height, width) = (n - top[1], temp2 - temp1 + 1)\n\tres = max(res, min(height, width))\nprint(res)\n"
    },
    {
        "task_id": 40,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.1494312286376953,
        "fastest_time": 3.1494312286376953,
        "fastest_solution": "from sys import stdin\ninput = stdin.readline\n(n, k) = [int(i) for i in input().split()]\npairs = [i + k for i in range(k)] + [i for i in range(k)]\ninitial_condition = list(map(lambda x: x == '1', input().strip()))\ndata = [i for i in range(2 * k)]\nconstrain = [-1] * (2 * k)\nh = [0] * (2 * k)\nL = [1] * k + [0] * k\ndp1 = [-1 for i in range(n)]\ndp2 = [-1 for i in range(n)]\nfor i in range(k):\n\tinput()\n\tinp = [int(j) for j in input().split()]\n\tfor s in inp:\n\t\tif dp1[s - 1] == -1:\n\t\t\tdp1[s - 1] = i\n\t\telse:\n\t\t\tdp2[s - 1] = i\npfsums = 0\nans = []\n\ndef remove_pfsum(s1):\n\tglobal pfsums\n\tif constrain[s1] == 1:\n\t\tpfsums -= L[s1]\n\telif constrain[pairs[s1]] == 1:\n\t\tpfsums -= L[pairs[s1]]\n\telse:\n\t\tpfsums -= min(L[s1], L[pairs[s1]])\n\ndef sh(i):\n\twhile i != data[i]:\n\t\ti = data[i]\n\treturn i\n\ndef upd_pfsum(s1):\n\tglobal pfsums\n\tif constrain[s1] == 1:\n\t\tpfsums += L[s1]\n\telif constrain[pairs[s1]] == 1:\n\t\tpfsums += L[pairs[s1]]\n\telse:\n\t\tpfsums += min(L[s1], L[pairs[s1]])\n\ndef ms(i, j):\n\ti = sh(i)\n\tj = sh(j)\n\tcons = max(constrain[i], constrain[j])\n\tif h[i] < h[j]:\n\t\tdata[i] = j\n\t\tL[j] += L[i]\n\t\tconstrain[j] = cons\n\t\treturn j\n\telse:\n\t\tdata[j] = i\n\t\tif h[i] == h[j]:\n\t\t\th[i] += 1\n\t\tL[i] += L[j]\n\t\tconstrain[i] = cons\n\t\treturn i\nfor i in range(n):\n\tif dp1[i] == -1 and dp2[i] == -1:\n\t\tpass\n\telif dp2[i] == -1:\n\t\ts1 = sh(dp1[i])\n\t\tremove_pfsum(s1)\n\t\tconstrain[s1] = 0 if initial_condition[i] else 1\n\t\tconstrain[pairs[s1]] = 1 if initial_condition[i] else 0\n\t\tupd_pfsum(s1)\n\telse:\n\t\ts1 = sh(dp1[i])\n\t\ts2 = sh(dp2[i])\n\t\tif s1 == s2 or pairs[s1] == s2:\n\t\t\tpass\n\t\telse:\n\t\t\tremove_pfsum(s1)\n\t\t\tremove_pfsum(s2)\n\t\t\tif initial_condition[i]:\n\t\t\t\tnew_s1 = ms(s1, s2)\n\t\t\t\tnew_s2 = ms(pairs[s1], pairs[s2])\n\t\t\telse:\n\t\t\t\tnew_s1 = ms(s1, pairs[s2])\n\t\t\t\tnew_s2 = ms(pairs[s1], s2)\n\t\t\tpairs[new_s1] = new_s2\n\t\t\tpairs[new_s2] = new_s1\n\t\t\tupd_pfsum(new_s1)\n\tans.append(pfsums)\nfor i in ans:\n\tprint(i)\n",
        "slowest_solution": "from sys import stdin\ninput = stdin.readline\n(n, k) = [int(i) for i in input().split()]\npairs = [i + k for i in range(k)] + [i for i in range(k)]\ninitial_condition = list(map(lambda x: x == '1', input().strip()))\ndata = [i for i in range(2 * k)]\nconstrain = [-1] * (2 * k)\nh = [0] * (2 * k)\nL = [1] * k + [0] * k\ndp1 = [-1 for i in range(n)]\ndp2 = [-1 for i in range(n)]\nfor i in range(k):\n\tinput()\n\tinp = [int(j) for j in input().split()]\n\tfor s in inp:\n\t\tif dp1[s - 1] == -1:\n\t\t\tdp1[s - 1] = i\n\t\telse:\n\t\t\tdp2[s - 1] = i\npfsums = 0\nans = []\n\ndef remove_pfsum(s1):\n\tglobal pfsums\n\tif constrain[s1] == 1:\n\t\tpfsums -= L[s1]\n\telif constrain[pairs[s1]] == 1:\n\t\tpfsums -= L[pairs[s1]]\n\telse:\n\t\tpfsums -= min(L[s1], L[pairs[s1]])\n\ndef sh(i):\n\twhile i != data[i]:\n\t\ti = data[i]\n\treturn i\n\ndef upd_pfsum(s1):\n\tglobal pfsums\n\tif constrain[s1] == 1:\n\t\tpfsums += L[s1]\n\telif constrain[pairs[s1]] == 1:\n\t\tpfsums += L[pairs[s1]]\n\telse:\n\t\tpfsums += min(L[s1], L[pairs[s1]])\n\ndef ms(i, j):\n\ti = sh(i)\n\tj = sh(j)\n\tcons = max(constrain[i], constrain[j])\n\tif h[i] < h[j]:\n\t\tdata[i] = j\n\t\tL[j] += L[i]\n\t\tconstrain[j] = cons\n\t\treturn j\n\telse:\n\t\tdata[j] = i\n\t\tif h[i] == h[j]:\n\t\t\th[i] += 1\n\t\tL[i] += L[j]\n\t\tconstrain[i] = cons\n\t\treturn i\nfor i in range(n):\n\tif dp1[i] == -1 and dp2[i] == -1:\n\t\tpass\n\telif dp2[i] == -1:\n\t\ts1 = sh(dp1[i])\n\t\tremove_pfsum(s1)\n\t\tconstrain[s1] = 0 if initial_condition[i] else 1\n\t\tconstrain[pairs[s1]] = 1 if initial_condition[i] else 0\n\t\tupd_pfsum(s1)\n\telse:\n\t\ts1 = sh(dp1[i])\n\t\ts2 = sh(dp2[i])\n\t\tif s1 == s2 or pairs[s1] == s2:\n\t\t\tpass\n\t\telse:\n\t\t\tremove_pfsum(s1)\n\t\t\tremove_pfsum(s2)\n\t\t\tif initial_condition[i]:\n\t\t\t\tnew_s1 = ms(s1, s2)\n\t\t\t\tnew_s2 = ms(pairs[s1], pairs[s2])\n\t\t\telse:\n\t\t\t\tnew_s1 = ms(s1, pairs[s2])\n\t\t\t\tnew_s2 = ms(pairs[s1], s2)\n\t\t\tpairs[new_s1] = new_s2\n\t\t\tpairs[new_s2] = new_s1\n\t\t\tupd_pfsum(new_s1)\n\tans.append(pfsums)\nfor i in ans:\n\tprint(i)\n"
    },
    {
        "task_id": 44,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.9355881214141846,
        "fastest_time": 2.9355881214141846,
        "fastest_solution": "import os, sys, itertools, bisect\nfrom collections import defaultdict, Counter\nMOD = 10 ** 9 + 7\nDEBUG = [False]\n\ndef mod_power(x, k):\n\tif k == 0:\n\t\treturn 1\n\tp = 1\n\twhile k:\n\t\tif k & 1:\n\t\t\tp = p * x % MOD\n\t\tx = x * x % MOD\n\t\tk = k // 2\n\treturn p\n\ndef find_good_point(colors):\n\tN = len(colors)\n\tcolor_counts = Counter(colors)\n\tfor (k, c) in enumerate(colors):\n\t\tleftSet = set()\n\t\trightSet = set()\n\t\tbad = False\n\t\tfor i in range(N - 1):\n\t\t\tc2 = colors[(k + 1 + i) % N]\n\t\t\tif c2 == c:\n\t\t\t\tbad = True\n\t\t\t\tbreak\n\t\t\tif c2 in rightSet:\n\t\t\t\tbreak\n\t\t\trightSet.add(c2)\n\t\tif bad:\n\t\t\tcontinue\n\t\tfor i in range(N - 1):\n\t\t\tc2 = colors[(k - 1 - i) % N]\n\t\t\tif c2 == c:\n\t\t\t\tbad = True\n\t\t\t\tbreak\n\t\t\tif c2 in leftSet:\n\t\t\t\tbreak\n\t\t\tleftSet.add(c2)\n\t\tif bad:\n\t\t\tcontinue\n\t\tif leftSet and rightSet and (not leftSet & rightSet):\n\t\t\treturn k\n\treturn None\n\ndef solve_recursive(colors):\n\tN = len(colors)\n\tcolor_counts = Counter(colors)\n\tcolor_to_most_recent = {}\n\tdistance_to_previous = [None] * N\n\tfor (k, c) in enumerate(colors):\n\t\tilastc = color_to_most_recent.get(c)\n\t\tdistance_to_previous[k] = None if ilastc is None else k - ilastc\n\t\tcolor_to_most_recent[c] = k\n\n\tdef S(n):\n\t\tif n < 0:\n\t\t\traise ValueError(n)\n\t\tif n == 0:\n\t\t\treturn 1\n\t\tfn = distance_to_previous[n - 1]\n\t\tif fn is None:\n\t\t\treturn 2 * S(n - 1)\n\t\treturn 2 * S(n - 1) - T(n - 1, fn)\n\n\tdef T(n, k):\n\t\tif k == 0:\n\t\t\treturn S(n)\n\t\tfn = distance_to_previous[n - 1]\n\t\tif fn is None:\n\t\t\treturn T(n - 1, k - 1)\n\t\tif k > fn:\n\t\t\treturn 0\n\t\treturn T(n - 1, k - 1) - T(n - 1, fn)\n\tif False and len(colors) == 3:\n\t\tprint(f' ==> Sequence {colors}')\n\t\tprint(f'S(3) = {S(3)}')\n\t\tprint(f'S(2) = {S(2)}')\n\t\tprint(f'S(1) = {S(1)}')\n\t\tprint(f'S(0) = {S(0)}')\n\t\tprint(f'f[3] = {distance_to_previous[2]}')\n\t\tprint(f'f[2] = {distance_to_previous[1]}')\n\t\tprint(f'T(2,1) = {T(2, 1)}')\n\t\tprint(f'T(2,0) = {T(2, 0)}')\n\t\tprint(f'T(1,1) = {T(1, 1)}')\n\t\tprint(f'T(1,0) = {T(1, 0)}')\n\treturn S(N)\n\ndef OBVIOUSLY_WRONG_solve(colors):\n\tN = len(colors)\n\tcolor_to_indices = defaultdict(list)\n\tindices = None\n\tfor (k, c) in enumerate(colors):\n\t\tlst = color_to_indices[c]\n\t\tlst.append(k)\n\t\tif len(lst) >= 2:\n\t\t\tindices = lst\n\t\t\tbreak\n\tif not indices:\n\t\treturn (mod_power(2, N) - N - 1) % MOD\n\t(k1, k2) = indices\n\tif k1 > k2:\n\t\t(k1, k2) = (k2, k1)\n\tpath1 = colors[:k1] + colors[k1 + 1:]\n\tpath2 = colors[:k2] + colors[k2 + 1:]\n\tpath3 = colors[k1 + 1:k2]\n\tpath4 = colors[k2 + 1:] + colors[:k1]\n\tcolor_counts = Counter(colors)\n\thasColourRepeatedAtLeast3Times = False\n\tcolorRepeatedTwiceCountLowerBound = 0\n\tfor (c, count) in color_counts.items():\n\t\tif count == 2:\n\t\t\tcolorRepeatedTwiceCountLowerBound += 1\n\t\telif count >= 3:\n\t\t\thasColourRepeatedAtLeast3Times = True\n\t\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\t\tbreak\n\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\tnumberOfAdmissibleCoSingletons = 0\n\telif colorRepeatedTwiceCountLowerBound >= 1:\n\t\tnumberOfAdmissibleCoSingletons = 2\n\telse:\n\t\tnumberOfAdmissibleCoSingletons = n\n\tcount = (solve_path(path1) + solve_path(path2) - solve_path(path3) * solve_path(path4) - numberOfAdmissibleCoSingletons) % MOD\n\treturn count\n\ndef solve_fallback(colors):\n\tn = len(colors)\n\tif not colors:\n\t\treturn 0\n\ttotal_count = 0\n\tcolor_counts = Counter(colors)\n\thasColourRepeatedAtLeast3Times = False\n\tcolorRepeatedTwiceCountLowerBound = 0\n\tfor (c, count) in color_counts.items():\n\t\tif count == 2:\n\t\t\tcolorRepeatedTwiceCountLowerBound += 1\n\t\telif count >= 3:\n\t\t\thasColourRepeatedAtLeast3Times = True\n\t\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\t\tbreak\n\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\tnumberOfAdmissibleCoSingletons = 0\n\telif colorRepeatedTwiceCountLowerBound >= 1:\n\t\tnumberOfAdmissibleCoSingletons = 2\n\telse:\n\t\tnumberOfAdmissibleCoSingletons = n\n\tcounts = Counter()\n\tfor (k, c) in enumerate(colors):\n\t\tif k == 0:\n\t\t\tcounts[tuple(), tuple()] = 1\n\t\t\tif color_counts[c] == 1:\n\t\t\t\tcounts[tuple(), False] += 1\n\t\t\telse:\n\t\t\t\tcounts[(c,), False] = 1\n\t\t\tcontinue\n\t\telif k == n - 1:\n\t\t\tfor ((left_set, right_set), count) in counts.items():\n\t\t\t\ttotal_count = (total_count + count) % MOD\n\t\t\t\tif right_set != False and c not in left_set and (c not in right_set) and (not set(left_set) & set(right_set)):\n\t\t\t\t\ttotal_count = (total_count + count) % MOD\n\t\t\tbreak\n\t\tprev_counts = counts\n\t\tcounts = Counter()\n\t\tif color_counts[c] == 1:\n\t\t\tfor ((left_set, right_set), count) in prev_counts.items():\n\t\t\t\tcounts[left_set, tuple()] += count\n\t\t\t\tif right_set == False:\n\t\t\t\t\tcounts[left_set, False] += count\n\t\t\t\telse:\n\t\t\t\t\tcounts[left_set, right_set] += count\n\t\telse:\n\t\t\tfor ((left_set, right_set), count) in prev_counts.items():\n\t\t\t\tcounts[left_set, tuple()] += count\n\t\t\t\tif right_set == False:\n\t\t\t\t\tif c not in left_set:\n\t\t\t\t\t\tleft_set2 = tuple(sorted(left_set + (c,)))\n\t\t\t\t\t\tcounts[left_set2, False] += count\n\t\t\t\telif c not in right_set:\n\t\t\t\t\tright_set2 = tuple(sorted(right_set + (c,)))\n\t\t\t\t\tcounts[left_set, right_set2] += count\n\ttotal_count = (total_count - numberOfAdmissibleCoSingletons) % MOD\n\treturn total_count\n\ndef solve(colors):\n\tN = len(colors)\n\tcut_point = find_good_point(colors)\n\tif cut_point is None:\n\t\treturn solve_fallback(colors)\n\tpath = colors[cut_point + 1:] + colors[:cut_point]\n\tcolor_counts = Counter(colors)\n\thasColourRepeatedAtLeast3Times = False\n\tcolorRepeatedTwiceCountLowerBound = 0\n\tfor (c, count) in color_counts.items():\n\t\tif count == 2:\n\t\t\tcolorRepeatedTwiceCountLowerBound += 1\n\t\telif count >= 3:\n\t\t\thasColourRepeatedAtLeast3Times = True\n\t\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\t\tbreak\n\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\tnumberOfAdmissibleCoSingletons = 0\n\telif colorRepeatedTwiceCountLowerBound >= 1:\n\t\tnumberOfAdmissibleCoSingletons = 2\n\telse:\n\t\tnumberOfAdmissibleCoSingletons = n\n\tcount = (2 * solve_path(path) - numberOfAdmissibleCoSingletons) % MOD\n\treturn count\n\ndef solve_path(colors):\n\tn = len(colors)\n\tcolor_counts = Counter(colors)\n\tcolor_to_most_recent = {}\n\tdistance_to_previous = [None] * n\n\tfor (k, c) in enumerate(colors):\n\t\tilastc = color_to_most_recent.get(c)\n\t\tdistance_to_previous[k] = None if ilastc is None else k - ilastc\n\t\tcolor_to_most_recent[c] = k\n\ttotal_count = 1\n\tT = [total_count]\n\tfor (k, c) in enumerate(colors):\n\t\tfk = distance_to_previous[k]\n\t\tif fk is None:\n\t\t\tnew_total = 2 * total_count % MOD\n\t\t\tT = [new_total] + T\n\t\t\ttotal_count = new_total\n\t\telse:\n\t\t\tdc = T[fk] if fk < len(T) else 0\n\t\t\tnew_total = (2 * total_count - dc) % MOD\n\t\t\tT = [new_total] + [x - dc for x in T[:fk + 1]]\n\t\t\ttotal_count = new_total\n\treturn total_count\n\ndef brute(colors):\n\tn = len(colors)\n\tcount = 0\n\tfor p in itertools.product([0, 1], repeat=n):\n\t\tk = sum(p)\n\t\tif k >= n - 1:\n\t\t\tcontinue\n\t\tcurcomp = set()\n\t\tbad = False\n\t\tfor (i, px) in enumerate(p):\n\t\t\tif not px:\n\t\t\t\tcurcomp = set()\n\t\t\telse:\n\t\t\t\tc = colors[i]\n\t\t\t\tif c in curcomp:\n\t\t\t\t\tbad = True\n\t\t\t\t\tbreak\n\t\t\t\tcurcomp.add(c)\n\t\tif not bad:\n\t\t\tfor (i, px) in enumerate(p):\n\t\t\t\tif not px:\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tc = colors[i]\n\t\t\t\t\tif c in curcomp:\n\t\t\t\t\t\tbad = True\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcurcomp.add(c)\n\t\t\tif not bad:\n\t\t\t\tcount = (count + 1) % MOD\n\treturn count\n\ndef brute_path_no_conditions(colors):\n\tn = len(colors)\n\tcount = 0\n\tfor p in itertools.product([0, 1], repeat=n):\n\t\tk = sum(p)\n\t\tcurcomp = set()\n\t\tbad = False\n\t\tfor (i, px) in enumerate(p):\n\t\t\tif not px:\n\t\t\t\tcurcomp = set()\n\t\t\telse:\n\t\t\t\tc = colors[i]\n\t\t\t\tif c in curcomp:\n\t\t\t\t\tbad = True\n\t\t\t\t\tbreak\n\t\t\t\tcurcomp.add(c)\n\t\tif not bad:\n\t\t\tcount = (count + 1) % MOD\n\treturn count\n\ndef run_tests():\n\tpath_mode = False\n\tcontinue_on_fail = os.environ.get('CONTINUE123') is not None\n\talways_print_failures = os.environ.get('PRINTFAIL123') is not None\n\tif path_mode:\n\t\tprint('\\n** Note: Testing match with path not cycle case\\n')\n\tfail_count = 0\n\ttest_case_count = 0\n\tsum_pct_error = 0\n\tmax_error_diff = 0\n\tmin_error_diff = 0\n\tfor n in range(2, 9):\n\t\tif continue_on_fail and fail_count > 0:\n\t\t\tprint(f'... {100 * fail_count / test_case_count:.3f}% = {fail_count} failed cases out of {test_case_count} with avg %error {sum_pct_error / test_case_count:.3f} and diff from {min_error_diff} to {max_error_diff}')\n\t\tprint(f'Testing {n} ...')\n\t\tlastx0 = None\n\t\tfor p in itertools.product(range(n), repeat=n):\n\t\t\tif p[0] != lastx0:\n\t\t\t\tlastx0 = p[0]\n\t\t\tif path_mode:\n\t\t\t\tansexp = brute_path_no_conditions(p) % MOD\n\t\t\telse:\n\t\t\t\tansexp = brute(p) % MOD\n\t\t\tans = solve(p)\n\t\t\ttest_case_count += 1\n\t\t\tif ans != ansexp:\n\t\t\t\tfail_count += 1\n\t\t\t\tif ansexp != 0:\n\t\t\t\t\tsum_pct_error += 100 * abs(ans - ansexp) / ansexp\n\t\t\t\t\tmax_error_diff = max(max_error_diff, ans - ansexp)\n\t\t\t\t\tmin_error_diff = min(min_error_diff, ans - ansexp)\n\t\t\t\tif always_print_failures or not continue_on_fail:\n\t\t\t\t\tprint(f'FAIL: {p}: Got {ans} expected {ansexp}')\n\t\t\t\tif not continue_on_fail:\n\t\t\t\t\tbreak\n\t\t\tif continue_on_fail and fail_count > 0 and (test_case_count % 10000 == 0):\n\t\t\t\tprint(f'... {100 * fail_count / test_case_count:.3f}% = {fail_count} failed cases out of {test_case_count} with avg %error {sum_pct_error / test_case_count:.3f} and diff from {min_error_diff} to {max_error_diff}')\n\t\tif fail_count and (not continue_on_fail):\n\t\t\tbreak\n\tif continue_on_fail and fail_count > 0:\n\t\tprint(f'FAIL: {fail_count} failed cases out of {test_case_count} with avg %error {sum_pct_error / test_case_count:.3f} and diff from {min_error_diff} to {max_error_diff}')\n\ndef main():\n\tif os.environ.get('DEBUG123'):\n\t\tDEBUG[0] = True\n\tif os.environ.get('TEST123'):\n\t\tDEBUG[0] = False\n\t\trun_tests()\n\telse:\n\t\tn = int(sys.stdin.readline())\n\t\tcolors = list(map(int, sys.stdin.readline().split()))\n\t\tprint(solve(colors))\nmain()\n",
        "slowest_solution": "import os, sys, itertools, bisect\nfrom collections import defaultdict, Counter\nMOD = 10 ** 9 + 7\nDEBUG = [False]\n\ndef mod_power(x, k):\n\tif k == 0:\n\t\treturn 1\n\tp = 1\n\twhile k:\n\t\tif k & 1:\n\t\t\tp = p * x % MOD\n\t\tx = x * x % MOD\n\t\tk = k // 2\n\treturn p\n\ndef find_good_point(colors):\n\tN = len(colors)\n\tcolor_counts = Counter(colors)\n\tfor (k, c) in enumerate(colors):\n\t\tleftSet = set()\n\t\trightSet = set()\n\t\tbad = False\n\t\tfor i in range(N - 1):\n\t\t\tc2 = colors[(k + 1 + i) % N]\n\t\t\tif c2 == c:\n\t\t\t\tbad = True\n\t\t\t\tbreak\n\t\t\tif c2 in rightSet:\n\t\t\t\tbreak\n\t\t\trightSet.add(c2)\n\t\tif bad:\n\t\t\tcontinue\n\t\tfor i in range(N - 1):\n\t\t\tc2 = colors[(k - 1 - i) % N]\n\t\t\tif c2 == c:\n\t\t\t\tbad = True\n\t\t\t\tbreak\n\t\t\tif c2 in leftSet:\n\t\t\t\tbreak\n\t\t\tleftSet.add(c2)\n\t\tif bad:\n\t\t\tcontinue\n\t\tif leftSet and rightSet and (not leftSet & rightSet):\n\t\t\treturn k\n\treturn None\n\ndef solve_recursive(colors):\n\tN = len(colors)\n\tcolor_counts = Counter(colors)\n\tcolor_to_most_recent = {}\n\tdistance_to_previous = [None] * N\n\tfor (k, c) in enumerate(colors):\n\t\tilastc = color_to_most_recent.get(c)\n\t\tdistance_to_previous[k] = None if ilastc is None else k - ilastc\n\t\tcolor_to_most_recent[c] = k\n\n\tdef S(n):\n\t\tif n < 0:\n\t\t\traise ValueError(n)\n\t\tif n == 0:\n\t\t\treturn 1\n\t\tfn = distance_to_previous[n - 1]\n\t\tif fn is None:\n\t\t\treturn 2 * S(n - 1)\n\t\treturn 2 * S(n - 1) - T(n - 1, fn)\n\n\tdef T(n, k):\n\t\tif k == 0:\n\t\t\treturn S(n)\n\t\tfn = distance_to_previous[n - 1]\n\t\tif fn is None:\n\t\t\treturn T(n - 1, k - 1)\n\t\tif k > fn:\n\t\t\treturn 0\n\t\treturn T(n - 1, k - 1) - T(n - 1, fn)\n\tif False and len(colors) == 3:\n\t\tprint(f' ==> Sequence {colors}')\n\t\tprint(f'S(3) = {S(3)}')\n\t\tprint(f'S(2) = {S(2)}')\n\t\tprint(f'S(1) = {S(1)}')\n\t\tprint(f'S(0) = {S(0)}')\n\t\tprint(f'f[3] = {distance_to_previous[2]}')\n\t\tprint(f'f[2] = {distance_to_previous[1]}')\n\t\tprint(f'T(2,1) = {T(2, 1)}')\n\t\tprint(f'T(2,0) = {T(2, 0)}')\n\t\tprint(f'T(1,1) = {T(1, 1)}')\n\t\tprint(f'T(1,0) = {T(1, 0)}')\n\treturn S(N)\n\ndef OBVIOUSLY_WRONG_solve(colors):\n\tN = len(colors)\n\tcolor_to_indices = defaultdict(list)\n\tindices = None\n\tfor (k, c) in enumerate(colors):\n\t\tlst = color_to_indices[c]\n\t\tlst.append(k)\n\t\tif len(lst) >= 2:\n\t\t\tindices = lst\n\t\t\tbreak\n\tif not indices:\n\t\treturn (mod_power(2, N) - N - 1) % MOD\n\t(k1, k2) = indices\n\tif k1 > k2:\n\t\t(k1, k2) = (k2, k1)\n\tpath1 = colors[:k1] + colors[k1 + 1:]\n\tpath2 = colors[:k2] + colors[k2 + 1:]\n\tpath3 = colors[k1 + 1:k2]\n\tpath4 = colors[k2 + 1:] + colors[:k1]\n\tcolor_counts = Counter(colors)\n\thasColourRepeatedAtLeast3Times = False\n\tcolorRepeatedTwiceCountLowerBound = 0\n\tfor (c, count) in color_counts.items():\n\t\tif count == 2:\n\t\t\tcolorRepeatedTwiceCountLowerBound += 1\n\t\telif count >= 3:\n\t\t\thasColourRepeatedAtLeast3Times = True\n\t\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\t\tbreak\n\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\tnumberOfAdmissibleCoSingletons = 0\n\telif colorRepeatedTwiceCountLowerBound >= 1:\n\t\tnumberOfAdmissibleCoSingletons = 2\n\telse:\n\t\tnumberOfAdmissibleCoSingletons = n\n\tcount = (solve_path(path1) + solve_path(path2) - solve_path(path3) * solve_path(path4) - numberOfAdmissibleCoSingletons) % MOD\n\treturn count\n\ndef solve_fallback(colors):\n\tn = len(colors)\n\tif not colors:\n\t\treturn 0\n\ttotal_count = 0\n\tcolor_counts = Counter(colors)\n\thasColourRepeatedAtLeast3Times = False\n\tcolorRepeatedTwiceCountLowerBound = 0\n\tfor (c, count) in color_counts.items():\n\t\tif count == 2:\n\t\t\tcolorRepeatedTwiceCountLowerBound += 1\n\t\telif count >= 3:\n\t\t\thasColourRepeatedAtLeast3Times = True\n\t\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\t\tbreak\n\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\tnumberOfAdmissibleCoSingletons = 0\n\telif colorRepeatedTwiceCountLowerBound >= 1:\n\t\tnumberOfAdmissibleCoSingletons = 2\n\telse:\n\t\tnumberOfAdmissibleCoSingletons = n\n\tcounts = Counter()\n\tfor (k, c) in enumerate(colors):\n\t\tif k == 0:\n\t\t\tcounts[tuple(), tuple()] = 1\n\t\t\tif color_counts[c] == 1:\n\t\t\t\tcounts[tuple(), False] += 1\n\t\t\telse:\n\t\t\t\tcounts[(c,), False] = 1\n\t\t\tcontinue\n\t\telif k == n - 1:\n\t\t\tfor ((left_set, right_set), count) in counts.items():\n\t\t\t\ttotal_count = (total_count + count) % MOD\n\t\t\t\tif right_set != False and c not in left_set and (c not in right_set) and (not set(left_set) & set(right_set)):\n\t\t\t\t\ttotal_count = (total_count + count) % MOD\n\t\t\tbreak\n\t\tprev_counts = counts\n\t\tcounts = Counter()\n\t\tif color_counts[c] == 1:\n\t\t\tfor ((left_set, right_set), count) in prev_counts.items():\n\t\t\t\tcounts[left_set, tuple()] += count\n\t\t\t\tif right_set == False:\n\t\t\t\t\tcounts[left_set, False] += count\n\t\t\t\telse:\n\t\t\t\t\tcounts[left_set, right_set] += count\n\t\telse:\n\t\t\tfor ((left_set, right_set), count) in prev_counts.items():\n\t\t\t\tcounts[left_set, tuple()] += count\n\t\t\t\tif right_set == False:\n\t\t\t\t\tif c not in left_set:\n\t\t\t\t\t\tleft_set2 = tuple(sorted(left_set + (c,)))\n\t\t\t\t\t\tcounts[left_set2, False] += count\n\t\t\t\telif c not in right_set:\n\t\t\t\t\tright_set2 = tuple(sorted(right_set + (c,)))\n\t\t\t\t\tcounts[left_set, right_set2] += count\n\ttotal_count = (total_count - numberOfAdmissibleCoSingletons) % MOD\n\treturn total_count\n\ndef solve(colors):\n\tN = len(colors)\n\tcut_point = find_good_point(colors)\n\tif cut_point is None:\n\t\treturn solve_fallback(colors)\n\tpath = colors[cut_point + 1:] + colors[:cut_point]\n\tcolor_counts = Counter(colors)\n\thasColourRepeatedAtLeast3Times = False\n\tcolorRepeatedTwiceCountLowerBound = 0\n\tfor (c, count) in color_counts.items():\n\t\tif count == 2:\n\t\t\tcolorRepeatedTwiceCountLowerBound += 1\n\t\telif count >= 3:\n\t\t\thasColourRepeatedAtLeast3Times = True\n\t\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\t\tbreak\n\tif hasColourRepeatedAtLeast3Times or colorRepeatedTwiceCountLowerBound >= 2:\n\t\tnumberOfAdmissibleCoSingletons = 0\n\telif colorRepeatedTwiceCountLowerBound >= 1:\n\t\tnumberOfAdmissibleCoSingletons = 2\n\telse:\n\t\tnumberOfAdmissibleCoSingletons = n\n\tcount = (2 * solve_path(path) - numberOfAdmissibleCoSingletons) % MOD\n\treturn count\n\ndef solve_path(colors):\n\tn = len(colors)\n\tcolor_counts = Counter(colors)\n\tcolor_to_most_recent = {}\n\tdistance_to_previous = [None] * n\n\tfor (k, c) in enumerate(colors):\n\t\tilastc = color_to_most_recent.get(c)\n\t\tdistance_to_previous[k] = None if ilastc is None else k - ilastc\n\t\tcolor_to_most_recent[c] = k\n\ttotal_count = 1\n\tT = [total_count]\n\tfor (k, c) in enumerate(colors):\n\t\tfk = distance_to_previous[k]\n\t\tif fk is None:\n\t\t\tnew_total = 2 * total_count % MOD\n\t\t\tT = [new_total] + T\n\t\t\ttotal_count = new_total\n\t\telse:\n\t\t\tdc = T[fk] if fk < len(T) else 0\n\t\t\tnew_total = (2 * total_count - dc) % MOD\n\t\t\tT = [new_total] + [x - dc for x in T[:fk + 1]]\n\t\t\ttotal_count = new_total\n\treturn total_count\n\ndef brute(colors):\n\tn = len(colors)\n\tcount = 0\n\tfor p in itertools.product([0, 1], repeat=n):\n\t\tk = sum(p)\n\t\tif k >= n - 1:\n\t\t\tcontinue\n\t\tcurcomp = set()\n\t\tbad = False\n\t\tfor (i, px) in enumerate(p):\n\t\t\tif not px:\n\t\t\t\tcurcomp = set()\n\t\t\telse:\n\t\t\t\tc = colors[i]\n\t\t\t\tif c in curcomp:\n\t\t\t\t\tbad = True\n\t\t\t\t\tbreak\n\t\t\t\tcurcomp.add(c)\n\t\tif not bad:\n\t\t\tfor (i, px) in enumerate(p):\n\t\t\t\tif not px:\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tc = colors[i]\n\t\t\t\t\tif c in curcomp:\n\t\t\t\t\t\tbad = True\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcurcomp.add(c)\n\t\t\tif not bad:\n\t\t\t\tcount = (count + 1) % MOD\n\treturn count\n\ndef brute_path_no_conditions(colors):\n\tn = len(colors)\n\tcount = 0\n\tfor p in itertools.product([0, 1], repeat=n):\n\t\tk = sum(p)\n\t\tcurcomp = set()\n\t\tbad = False\n\t\tfor (i, px) in enumerate(p):\n\t\t\tif not px:\n\t\t\t\tcurcomp = set()\n\t\t\telse:\n\t\t\t\tc = colors[i]\n\t\t\t\tif c in curcomp:\n\t\t\t\t\tbad = True\n\t\t\t\t\tbreak\n\t\t\t\tcurcomp.add(c)\n\t\tif not bad:\n\t\t\tcount = (count + 1) % MOD\n\treturn count\n\ndef run_tests():\n\tpath_mode = False\n\tcontinue_on_fail = os.environ.get('CONTINUE123') is not None\n\talways_print_failures = os.environ.get('PRINTFAIL123') is not None\n\tif path_mode:\n\t\tprint('\\n** Note: Testing match with path not cycle case\\n')\n\tfail_count = 0\n\ttest_case_count = 0\n\tsum_pct_error = 0\n\tmax_error_diff = 0\n\tmin_error_diff = 0\n\tfor n in range(2, 9):\n\t\tif continue_on_fail and fail_count > 0:\n\t\t\tprint(f'... {100 * fail_count / test_case_count:.3f}% = {fail_count} failed cases out of {test_case_count} with avg %error {sum_pct_error / test_case_count:.3f} and diff from {min_error_diff} to {max_error_diff}')\n\t\tprint(f'Testing {n} ...')\n\t\tlastx0 = None\n\t\tfor p in itertools.product(range(n), repeat=n):\n\t\t\tif p[0] != lastx0:\n\t\t\t\tlastx0 = p[0]\n\t\t\tif path_mode:\n\t\t\t\tansexp = brute_path_no_conditions(p) % MOD\n\t\t\telse:\n\t\t\t\tansexp = brute(p) % MOD\n\t\t\tans = solve(p)\n\t\t\ttest_case_count += 1\n\t\t\tif ans != ansexp:\n\t\t\t\tfail_count += 1\n\t\t\t\tif ansexp != 0:\n\t\t\t\t\tsum_pct_error += 100 * abs(ans - ansexp) / ansexp\n\t\t\t\t\tmax_error_diff = max(max_error_diff, ans - ansexp)\n\t\t\t\t\tmin_error_diff = min(min_error_diff, ans - ansexp)\n\t\t\t\tif always_print_failures or not continue_on_fail:\n\t\t\t\t\tprint(f'FAIL: {p}: Got {ans} expected {ansexp}')\n\t\t\t\tif not continue_on_fail:\n\t\t\t\t\tbreak\n\t\t\tif continue_on_fail and fail_count > 0 and (test_case_count % 10000 == 0):\n\t\t\t\tprint(f'... {100 * fail_count / test_case_count:.3f}% = {fail_count} failed cases out of {test_case_count} with avg %error {sum_pct_error / test_case_count:.3f} and diff from {min_error_diff} to {max_error_diff}')\n\t\tif fail_count and (not continue_on_fail):\n\t\t\tbreak\n\tif continue_on_fail and fail_count > 0:\n\t\tprint(f'FAIL: {fail_count} failed cases out of {test_case_count} with avg %error {sum_pct_error / test_case_count:.3f} and diff from {min_error_diff} to {max_error_diff}')\n\ndef main():\n\tif os.environ.get('DEBUG123'):\n\t\tDEBUG[0] = True\n\tif os.environ.get('TEST123'):\n\t\tDEBUG[0] = False\n\t\trun_tests()\n\telse:\n\t\tn = int(sys.stdin.readline())\n\t\tcolors = list(map(int, sys.stdin.readline().split()))\n\t\tprint(solve(colors))\nmain()\n"
    },
    {
        "task_id": 41,
        "slowest_solution_id": 3,
        "fastest_solution_id": 1,
        "slowest_time": 1.8009490966796875,
        "fastest_time": 0.0010058879852294922,
        "fastest_solution": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom math import factorial\nfrom operator import mul\n\ndef find_mult_3(n):\n\t(mul_count, digits) = (0, sorted(map(int, str(n))))\n\tfor r in range(1, len(digits) + 1):\n\t\tfor comb in sorted({c for c in combinations(digits, r) if not sum(c) % 3}):\n\t\t\tdig_count = Counter(comb)\n\t\t\tmul_count += (r - dig_count.get(0, 0)) * factorial(r) // reduce(mul, map(factorial, dig_count.values()), r)\n\treturn [mul_count, int(''.join(map(str, comb[::-1])))]\n",
        "slowest_solution": "from itertools import combinations, permutations\n\ndef find_mult_3(num):\n\tn = [int(c) for c in str(num)]\n\tr = set()\n\tfor i in range(1, len(n) + 1):\n\t\tfor c in combinations(n, i):\n\t\t\tif sum(c) % 3 == 0:\n\t\t\t\tr |= set([int(''.join([str(i) for i in p])) for p in permutations(c) if p[0] != 0])\n\treturn [len(r), max(r)]\n"
    },
    {
        "task_id": 47,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.2052226066589355,
        "fastest_time": 3.2052226066589355,
        "fastest_solution": "import sys\nfrom collections import deque\n\ndef solve():\n\tsys.setrecursionlimit(10 ** 6)\n\treadline = sys.stdin.readline\n\twritelines = sys.stdout.writelines\n\tN = int(readline())\n\tG = [[] for i in range(N)]\n\tfor i in range(N - 1):\n\t\t(u, v) = map(int, readline().split())\n\t\tG[u - 1].append(v - 1)\n\t\tG[v - 1].append(u - 1)\n\tS = []\n\tFS = [0] * N\n\tLS = [0] * N\n\tdepth = [0] * N\n\tstk = [-1, 0]\n\tit = [0] * N\n\twhile len(stk) > 1:\n\t\tv = stk[-1]\n\t\ti = it[v]\n\t\tif i == 0:\n\t\t\tFS[v] = len(S)\n\t\t\tdepth[v] = len(stk)\n\t\tif i < len(G[v]) and G[v][i] == stk[-2]:\n\t\t\tit[v] += 1\n\t\t\ti += 1\n\t\tif i == len(G[v]):\n\t\t\tLS[v] = len(S)\n\t\t\tstk.pop()\n\t\telse:\n\t\t\tstk.append(G[v][i])\n\t\t\tit[v] += 1\n\t\tS.append(v)\n\tL = len(S)\n\tlg = [0] * (L + 1)\n\tfor i in range(2, L + 1):\n\t\tlg[i] = lg[i >> 1] + 1\n\tst = [[L] * (L - (1 << i) + 1) for i in range(lg[L] + 1)]\n\tst[0][:] = S\n\tb = 1\n\tfor i in range(lg[L]):\n\t\tst0 = st[i]\n\t\tst1 = st[i + 1]\n\t\tfor j in range(L - (b << 1) + 1):\n\t\t\tst1[j] = st0[j] if depth[st0[j]] <= depth[st0[j + b]] else st0[j + b]\n\t\tb <<= 1\n\tINF = 10 ** 18\n\tans = []\n\tQ = int(readline())\n\tG0 = [[]] * N\n\tP = [0] * N\n\tdeg = [0] * N\n\tKS = [0] * N\n\tA = [0] * N\n\tB = [0] * N\n\tfor t in range(Q):\n\t\t(k, *vs) = map(int, readline().split())\n\t\tfor i in range(k):\n\t\t\tvs[i] -= 1\n\t\t\tKS[vs[i]] = 1\n\t\tvs.sort(key=FS.__getitem__)\n\t\tfor i in range(k - 1):\n\t\t\tx = FS[vs[i]]\n\t\t\ty = FS[vs[i + 1]]\n\t\t\tl = lg[y - x + 1]\n\t\t\tw = st[l][x] if depth[st[l][x]] <= depth[st[l][y - (1 << l) + 1]] else st[l][y - (1 << l) + 1]\n\t\t\tvs.append(w)\n\t\tvs.sort(key=FS.__getitem__)\n\t\tstk = []\n\t\tprv = -1\n\t\tfor v in vs:\n\t\t\tif v == prv:\n\t\t\t\tcontinue\n\t\t\twhile stk and LS[stk[-1]] < FS[v]:\n\t\t\t\tstk.pop()\n\t\t\tif stk:\n\t\t\t\tG0[stk[-1]].append(v)\n\t\t\tG0[v] = []\n\t\t\tit[v] = 0\n\t\t\tstk.append(v)\n\t\t\tprv = v\n\t\tque = deque()\n\t\tprv = -1\n\t\tP[vs[0]] = -1\n\t\tfor v in vs:\n\t\t\tif v == prv:\n\t\t\t\tcontinue\n\t\t\tfor w in G0[v]:\n\t\t\t\tP[w] = v\n\t\t\tdeg[v] = len(G0[v])\n\t\t\tif deg[v] == 0:\n\t\t\t\tque.append(v)\n\t\t\tprv = v\n\t\twhile que:\n\t\t\tv = que.popleft()\n\t\t\tif KS[v]:\n\t\t\t\ta = 0\n\t\t\t\tfor w in G0[v]:\n\t\t\t\t\tra = A[w]\n\t\t\t\t\trb = B[w]\n\t\t\t\t\tif depth[v] + 1 < depth[w]:\n\t\t\t\t\t\ta += min(ra, rb + 1)\n\t\t\t\t\telse:\n\t\t\t\t\t\ta += ra\n\t\t\t\tA[v] = INF\n\t\t\t\tB[v] = a\n\t\t\telse:\n\t\t\t\ta = 0\n\t\t\t\tb = c = INF\n\t\t\t\tfor w in G0[v]:\n\t\t\t\t\tra = A[w]\n\t\t\t\t\trb = B[w]\n\t\t\t\t\t(a, b, c) = (a + ra, min(a + rb, b + ra), min(b + rb, c + min(ra, rb)))\n\t\t\t\tA[v] = min(a, b + 1, c + 1)\n\t\t\t\tB[v] = b\n\t\t\tp = P[v]\n\t\t\tif p != -1:\n\t\t\t\tdeg[p] -= 1\n\t\t\t\tif deg[p] == 0:\n\t\t\t\t\tque.append(p)\n\t\tv = min(A[vs[0]], B[vs[0]])\n\t\tif v >= INF:\n\t\t\tans.append('-1\\n')\n\t\telse:\n\t\t\tans.append('%d\\n' % v)\n\t\tfor v in vs:\n\t\t\tKS[v] = 0\n\twritelines(ans)\nsolve()\n",
        "slowest_solution": "import sys\nfrom collections import deque\n\ndef solve():\n\tsys.setrecursionlimit(10 ** 6)\n\treadline = sys.stdin.readline\n\twritelines = sys.stdout.writelines\n\tN = int(readline())\n\tG = [[] for i in range(N)]\n\tfor i in range(N - 1):\n\t\t(u, v) = map(int, readline().split())\n\t\tG[u - 1].append(v - 1)\n\t\tG[v - 1].append(u - 1)\n\tS = []\n\tFS = [0] * N\n\tLS = [0] * N\n\tdepth = [0] * N\n\tstk = [-1, 0]\n\tit = [0] * N\n\twhile len(stk) > 1:\n\t\tv = stk[-1]\n\t\ti = it[v]\n\t\tif i == 0:\n\t\t\tFS[v] = len(S)\n\t\t\tdepth[v] = len(stk)\n\t\tif i < len(G[v]) and G[v][i] == stk[-2]:\n\t\t\tit[v] += 1\n\t\t\ti += 1\n\t\tif i == len(G[v]):\n\t\t\tLS[v] = len(S)\n\t\t\tstk.pop()\n\t\telse:\n\t\t\tstk.append(G[v][i])\n\t\t\tit[v] += 1\n\t\tS.append(v)\n\tL = len(S)\n\tlg = [0] * (L + 1)\n\tfor i in range(2, L + 1):\n\t\tlg[i] = lg[i >> 1] + 1\n\tst = [[L] * (L - (1 << i) + 1) for i in range(lg[L] + 1)]\n\tst[0][:] = S\n\tb = 1\n\tfor i in range(lg[L]):\n\t\tst0 = st[i]\n\t\tst1 = st[i + 1]\n\t\tfor j in range(L - (b << 1) + 1):\n\t\t\tst1[j] = st0[j] if depth[st0[j]] <= depth[st0[j + b]] else st0[j + b]\n\t\tb <<= 1\n\tINF = 10 ** 18\n\tans = []\n\tQ = int(readline())\n\tG0 = [[]] * N\n\tP = [0] * N\n\tdeg = [0] * N\n\tKS = [0] * N\n\tA = [0] * N\n\tB = [0] * N\n\tfor t in range(Q):\n\t\t(k, *vs) = map(int, readline().split())\n\t\tfor i in range(k):\n\t\t\tvs[i] -= 1\n\t\t\tKS[vs[i]] = 1\n\t\tvs.sort(key=FS.__getitem__)\n\t\tfor i in range(k - 1):\n\t\t\tx = FS[vs[i]]\n\t\t\ty = FS[vs[i + 1]]\n\t\t\tl = lg[y - x + 1]\n\t\t\tw = st[l][x] if depth[st[l][x]] <= depth[st[l][y - (1 << l) + 1]] else st[l][y - (1 << l) + 1]\n\t\t\tvs.append(w)\n\t\tvs.sort(key=FS.__getitem__)\n\t\tstk = []\n\t\tprv = -1\n\t\tfor v in vs:\n\t\t\tif v == prv:\n\t\t\t\tcontinue\n\t\t\twhile stk and LS[stk[-1]] < FS[v]:\n\t\t\t\tstk.pop()\n\t\t\tif stk:\n\t\t\t\tG0[stk[-1]].append(v)\n\t\t\tG0[v] = []\n\t\t\tit[v] = 0\n\t\t\tstk.append(v)\n\t\t\tprv = v\n\t\tque = deque()\n\t\tprv = -1\n\t\tP[vs[0]] = -1\n\t\tfor v in vs:\n\t\t\tif v == prv:\n\t\t\t\tcontinue\n\t\t\tfor w in G0[v]:\n\t\t\t\tP[w] = v\n\t\t\tdeg[v] = len(G0[v])\n\t\t\tif deg[v] == 0:\n\t\t\t\tque.append(v)\n\t\t\tprv = v\n\t\twhile que:\n\t\t\tv = que.popleft()\n\t\t\tif KS[v]:\n\t\t\t\ta = 0\n\t\t\t\tfor w in G0[v]:\n\t\t\t\t\tra = A[w]\n\t\t\t\t\trb = B[w]\n\t\t\t\t\tif depth[v] + 1 < depth[w]:\n\t\t\t\t\t\ta += min(ra, rb + 1)\n\t\t\t\t\telse:\n\t\t\t\t\t\ta += ra\n\t\t\t\tA[v] = INF\n\t\t\t\tB[v] = a\n\t\t\telse:\n\t\t\t\ta = 0\n\t\t\t\tb = c = INF\n\t\t\t\tfor w in G0[v]:\n\t\t\t\t\tra = A[w]\n\t\t\t\t\trb = B[w]\n\t\t\t\t\t(a, b, c) = (a + ra, min(a + rb, b + ra), min(b + rb, c + min(ra, rb)))\n\t\t\t\tA[v] = min(a, b + 1, c + 1)\n\t\t\t\tB[v] = b\n\t\t\tp = P[v]\n\t\t\tif p != -1:\n\t\t\t\tdeg[p] -= 1\n\t\t\t\tif deg[p] == 0:\n\t\t\t\t\tque.append(p)\n\t\tv = min(A[vs[0]], B[vs[0]])\n\t\tif v >= INF:\n\t\t\tans.append('-1\\n')\n\t\telse:\n\t\t\tans.append('%d\\n' % v)\n\t\tfor v in vs:\n\t\t\tKS[v] = 0\n\twritelines(ans)\nsolve()\n"
    },
    {
        "task_id": 31,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 4.295788526535034,
        "fastest_time": 3.277669668197632,
        "fastest_solution": "Q = int(input())\nwhile Q > 0:\n\tQ -= 1\n\t(N, u, v) = map(int, input().strip().split())\n\tif u > v:\n\t\t(u, v) = (v, u)\n\t(p, q) = (0, 1)\n\twhile u != v:\n\t\tif u > v:\n\t\t\tu >>= 1\n\t\t\tcontinue\n\t\tif v & 1:\n\t\t\tp += q\n\t\tv >>= 1\n\t\tq <<= 1\n\tans = (N - p) // q\n\tprint(ans)\n",
        "slowest_solution": "for t in range(int(input())):\n\t(n, p, q) = map(int, input().split())\n\t(v1, v2) = (n, n)\n\twhile p != q:\n\t\tif p > q:\n\t\t\tif p & 1 == 1:\n\t\t\t\tv1 -= 1\n\t\t\tv1 //= 2\n\t\t\tp //= 2\n\t\telse:\n\t\t\tif q & 1 == 1:\n\t\t\t\tv2 -= 1\n\t\t\tv2 //= 2\n\t\t\tq //= 2\n\tprint(min(v1, v2))\n"
    },
    {
        "task_id": 28,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 4.453950643539429,
        "fastest_time": 2.9494388103485107,
        "fastest_solution": "import atexit\nimport io\nimport sys\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n\tsys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\nclass Arista:\n\n\tdef __init__(self, salida, llegada, capacidad, flujo, costo, indice):\n\t\tself.salida = salida\n\t\tself.llegada = llegada\n\t\tself.capacidad = capacidad\n\t\tself.flujo = flujo\n\t\tself.costo = costo\n\t\tself.indice = indice\n\n\tdef __str__(self):\n\t\ts = ''\n\t\ts = s + 'salida =' + str(self.salida) + '\\n'\n\t\ts = s + 'llegada =' + str(self.llegada) + '\\n'\n\t\ts = s + 'capacidad =' + str(self.capacidad) + '\\n'\n\t\ts = s + 'flujo =' + str(self.flujo) + '\\n'\n\t\ts = s + 'costo =' + str(self.costo) + '\\n'\n\t\ts = s + 'indice =' + str(self.indice) + '\\n'\n\t\ts = s + '------------'\n\t\treturn s\n\nclass Red:\n\n\tdef __init__(self, s, t):\n\t\tself.lista_aristas = []\n\t\tself.lista_adyacencia = {}\n\t\tself.vertices = set()\n\t\tself.fuente = s\n\t\tself.sumidero = t\n\n\tdef agregar_vertice(self, vertice):\n\t\tself.vertices.add(vertice)\n\n\tdef agregar_arista(self, arista):\n\t\tself.vertices.add(arista.salida)\n\t\tself.vertices.add(arista.llegada)\n\t\tself.lista_aristas.append(arista)\n\t\tif arista.salida not in self.lista_adyacencia:\n\t\t\tself.lista_adyacencia[arista.salida] = set()\n\t\tself.lista_adyacencia[arista.salida].add(arista.indice)\n\n\tdef agregar_lista_aristas(self, lista_aristas):\n\t\tfor arista in lista_aristas:\n\t\t\tself.agregar_arista(arista)\n\n\tdef cantidad_de_vertices(self):\n\t\treturn len(self.vertices)\n\n\tdef vecinos(self, vertice):\n\t\tif vertice not in self.lista_adyacencia:\n\t\t\treturn set()\n\t\telse:\n\t\t\treturn self.lista_adyacencia[vertice]\n\n\tdef buscar_valor_critico(self, padre):\n\t\tINFINITO = 1000000000\n\t\tvalor_critico = INFINITO\n\t\tactual = self.sumidero\n\t\twhile actual != self.fuente:\n\t\t\tarista_camino = self.lista_aristas[padre[actual]]\n\t\t\tvalor_critico = min(valor_critico, arista_camino.capacidad - arista_camino.flujo)\n\t\t\tactual = arista_camino.salida\n\t\treturn valor_critico\n\n\tdef actualizar_camino(self, padre, valor_critico):\n\t\tactual = self.sumidero\n\t\tcosto_actual = 0\n\t\twhile actual != self.fuente:\n\t\t\tself.lista_aristas[padre[actual]].flujo += valor_critico\n\t\t\tself.lista_aristas[padre[actual] ^ 1].flujo -= valor_critico\n\t\t\tcosto_actual += valor_critico * self.lista_aristas[padre[actual]].costo\n\t\t\tactual = self.lista_aristas[padre[actual]].salida\n\t\treturn (costo_actual, True)\n\n\tdef camino_de_aumento(self):\n\t\tINFINITO = 1000000000\n\t\tdistancia = {v: INFINITO for v in self.vertices}\n\t\tpadre = {v: -1 for v in self.vertices}\n\t\tdistancia[self.fuente] = 0\n\t\t(capa_actual, capa_nueva) = (set([self.fuente]), set())\n\t\twhile capa_actual:\n\t\t\tfor v in capa_actual:\n\t\t\t\tfor arista_indice in self.vecinos(v):\n\t\t\t\t\tarista = self.lista_aristas[arista_indice]\n\t\t\t\t\tif arista.flujo < arista.capacidad and distancia[arista.salida] + arista.costo < distancia[arista.llegada]:\n\t\t\t\t\t\tdistancia[arista.llegada] = distancia[arista.salida] + arista.costo\n\t\t\t\t\t\tpadre[arista.llegada] = arista.indice\n\t\t\t\t\t\tcapa_nueva.add(arista.llegada)\n\t\t\tcapa_actual = set()\n\t\t\t(capa_actual, capa_nueva) = (capa_nueva, capa_actual)\n\t\tif distancia[self.sumidero] < INFINITO:\n\t\t\tvalor_critico = self.buscar_valor_critico(padre)\n\t\t\t(costo_actual, hay_camino) = self.actualizar_camino(padre, valor_critico)\n\t\t\treturn (valor_critico, costo_actual, hay_camino)\n\t\telse:\n\t\t\treturn (-1, -1, False)\n\n\tdef max_flow_min_cost(self):\n\t\tflujo_total = 0\n\t\tcosto_total = 0\n\t\thay_camino = True\n\t\twhile hay_camino:\n\t\t\t(flujo_actual, costo_actual, hay_camino) = self.camino_de_aumento()\n\t\t\tif hay_camino:\n\t\t\t\tflujo_total += flujo_actual\n\t\t\t\tcosto_total += costo_actual\n\t\treturn (flujo_total, costo_total)\nINFINITO = 10000000000000\n(n, q) = map(int, input().split())\nmaxi = [n for i in range(n)]\nmini = [1 for i in range(n)]\nR = Red(0, 2 * n + 1)\nprohibidos = {i: set() for i in range(n)}\nfor i in range(n):\n\tfor k in range(n + 1):\n\t\tR.agregar_arista(Arista(R.fuente, i + 1, 1, 0, 2 * k + 1, len(R.lista_aristas)))\n\t\tR.agregar_arista(Arista(i + 1, R.fuente, 0, 0, -2 * k - 1, len(R.lista_aristas)))\nfor j in range(n):\n\tR.agregar_arista(Arista(n + j + 1, R.sumidero, 1, 0, 0, len(R.lista_aristas)))\n\tR.agregar_arista(Arista(R.sumidero, n + j + 1, 0, 0, 0, len(R.lista_aristas)))\nfor z in range(q):\n\t(t, l, r, v) = map(int, input().split())\n\tif t == 1:\n\t\tfor i in range(v - 1):\n\t\t\tfor j in range(l, r + 1):\n\t\t\t\tprohibidos[i].add(j)\n\telse:\n\t\tfor i in range(v, n):\n\t\t\tfor j in range(l, r + 1):\n\t\t\t\tprohibidos[i].add(j)\nfor i in range(n):\n\tfor j in range(mini[i], maxi[i] + 1):\n\t\tif j not in prohibidos[i]:\n\t\t\tR.agregar_arista(Arista(i + 1, n + j, 1, 0, 0, len(R.lista_aristas)))\n\t\t\tR.agregar_arista(Arista(n + j, i + 1, 0, 0, 0, len(R.lista_aristas)))\n(flujo_total, costo_total) = R.max_flow_min_cost()\nif flujo_total < n:\n\tprint('-1')\nelse:\n\tprint(costo_total)\n",
        "slowest_solution": "import sys\n\ndef is_feasible(cnt, L, R):\n\tn = len(R)\n\tinter = [(L[i], R[i]) for i in range(n)]\n\tright = []\n\tfeasible = True\n\tfor x in range(n):\n\t\tfor p in inter:\n\t\t\tif p[0] == x:\n\t\t\t\tright.append(p[1])\n\t\twhile right and min(right) < x:\n\t\t\tright.remove(min(right))\n\t\tfor quantity in range(cnt[x]):\n\t\t\tif right:\n\t\t\t\tright.remove(min(right))\n\t\t\telse:\n\t\t\t\tfeasible = False\n\treturn feasible\n(n, q) = list(map(int, sys.stdin.readline().split()))\nL = [0 for i in range(n)]\nR = [n - 1 for i in range(n)]\nfor restriction in range(q):\n\t(t, l, r, v) = list(map(int, sys.stdin.readline().split()))\n\tif t == 1:\n\t\tfor k in range(l - 1, r):\n\t\t\tL[k] = max(L[k], v - 1)\n\telse:\n\t\tfor k in range(l - 1, r):\n\t\t\tR[k] = min(R[k], v - 1)\nis_possible = all(map(lambda x, y: x <= y, L, R))\nif not is_possible:\n\tprint(-1)\nelse:\n\tcnt = {x: L.count(x) for x in range(n)}\n\thad_pair = True\n\twhile had_pair:\n\t\thad_pair = False\n\t\tfor x in range(n):\n\t\t\tfor y in range(n):\n\t\t\t\tif cnt[x] > cnt[y] + 1:\n\t\t\t\t\tcnt[x] -= 1\n\t\t\t\t\tcnt[y] += 1\n\t\t\t\t\thas_pair = True\n\t\t\t\t\tif not is_feasible(cnt, L, R):\n\t\t\t\t\t\tcnt[x] += 1\n\t\t\t\t\t\tcnt[y] -= 1\n\t\t\t\t\t\thas_pair = False\n\t\t\t\t\thad_pair = had_pair or has_pair\n\tans = sum([cnt[x] * cnt[x] for x in range(n)])\n\tprint(ans)\n"
    },
    {
        "task_id": 6,
        "slowest_solution_id": 7,
        "fastest_solution_id": 7,
        "slowest_time": 3.5679938793182373,
        "fastest_time": 3.5679938793182373,
        "fastest_solution": "from math import ceil, sqrt\n\ndef rec(n):\n\tsquare = ceil(sqrt(n - 1)) ** 2\n\tnum = n - (square - (n - 1))\n\ts = ''\n\tn -= 1\n\tfor i in range(num):\n\t\ts += str(n) + ' '\n\t\tn -= 1\n\treturn (s, n + 1)\niter = int(input())\nfor z in range(iter):\n\tn = int(input())\n\tans = ''\n\twhile n:\n\t\t(tp, n) = rec(n)\n\t\tans = tp + ans\n\tprint(ans)\n",
        "slowest_solution": "from math import ceil, sqrt\n\ndef rec(n):\n\tsquare = ceil(sqrt(n - 1)) ** 2\n\tnum = n - (square - (n - 1))\n\ts = ''\n\tn -= 1\n\tfor i in range(num):\n\t\ts += str(n) + ' '\n\t\tn -= 1\n\treturn (s, n + 1)\niter = int(input())\nfor z in range(iter):\n\tn = int(input())\n\tans = ''\n\twhile n:\n\t\t(tp, n) = rec(n)\n\t\tans = tp + ans\n\tprint(ans)\n"
    },
    {
        "task_id": 50,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.815919876098633,
        "fastest_time": 2.815919876098633,
        "fastest_solution": "from sys import stdin, stdout\n(n, m) = map(int, stdin.readline().split())\nd = []\nev = [set() for _ in range(n + 1)]\nans = [0] * m\nfor i in range(m):\n\t(u, v, w) = map(int, stdin.readline().split())\n\td.append((w, u, v))\n\tev[u].add(i)\n\tev[v].add(i)\n\tans[i] = w\nd.sort()\npar = [i for i in range(n + 1)]\nst = []\npush = st.append\ng = 0\n\ndef find(u):\n\tif u == par[u]:\n\t\treturn u\n\tpar[u] = find(par[u])\n\treturn par[u]\nfor (w, u, v) in d:\n\t(u, v) = (find(u), find(v))\n\tif u != v:\n\t\tg += w\n\t\tif len(ev[u]) < len(ev[v]):\n\t\t\t(u, v) = (v, u)\n\t\tpar[v] = u\n\t\tfor j in ev[v] & ev[u]:\n\t\t\tans[j] -= w\n\t\tev[u] ^= ev[v]\nfor i in range(m):\n\tans[i] += g\nstdout.write('\\n'.join(map(str, ans)))\n",
        "slowest_solution": "from sys import stdin, stdout\n(n, m) = map(int, stdin.readline().split())\nd = []\nev = [set() for _ in range(n + 1)]\nans = [0] * m\nfor i in range(m):\n\t(u, v, w) = map(int, stdin.readline().split())\n\td.append((w, u, v))\n\tev[u].add(i)\n\tev[v].add(i)\n\tans[i] = w\nd.sort()\npar = [i for i in range(n + 1)]\nst = []\npush = st.append\ng = 0\n\ndef find(u):\n\tif u == par[u]:\n\t\treturn u\n\tpar[u] = find(par[u])\n\treturn par[u]\nfor (w, u, v) in d:\n\t(u, v) = (find(u), find(v))\n\tif u != v:\n\t\tg += w\n\t\tif len(ev[u]) < len(ev[v]):\n\t\t\t(u, v) = (v, u)\n\t\tpar[v] = u\n\t\tfor j in ev[v] & ev[u]:\n\t\t\tans[j] -= w\n\t\tev[u] ^= ev[v]\nfor i in range(m):\n\tans[i] += g\nstdout.write('\\n'.join(map(str, ans)))\n"
    },
    {
        "task_id": 46,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 3.707058906555176,
        "fastest_time": 3.0195913314819336,
        "fastest_solution": "n = int(input())\na = [tuple(map(int, input().split())) for i in range(n)]\na = [(y, x, k) for (x, y, k) in a]\na.sort(reverse=True)\ndp = [[-1] * (n + 1) for i in range(n)]\n\ndef f(i, j):\n\tif i < 0 or j < -1:\n\t\treturn 0\n\tif dp[i][j] == -1:\n\t\t(y, x, k) = a[i]\n\t\tdp[i][j] = f(i - 1, j) + max(0, x - k * y)\n\t\tif 0 <= j < k:\n\t\t\tdp[i][j] = max(dp[i][j], x - j * y + f(i - 1, j - 1))\n\treturn dp[i][j]\nprint(max((f(n - 1, j) for j in range(-1, n))))\n",
        "slowest_solution": "from sys import stdin\nn = int(input())\nt = stdin.read().splitlines()\na = [list(map(int, i.split())) for i in t]\na.sort(reverse=True, key=lambda k: (k[1], k[0], k[2]))\ndp = [[0] * (n + 1) for _ in range(n + 1)]\nfor i in range(n):\n\tfor l in range(n + 1):\n\t\tdp[i + 1][l] = max(dp[i + 1][l], dp[i][l], dp[i][l] + a[i][0] - a[i][1] * a[i][2])\n\t\tif l < n:\n\t\t\tdp[i + 1][l + 1] = max(dp[i + 1][l + 1], dp[i][l] + a[i][0] - a[i][1] * l)\nprint(max(dp[n]))\n"
    },
    {
        "task_id": 56,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7741963863372803,
        "fastest_time": 2.7741963863372803,
        "fastest_solution": "from heapq import *\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nwhile t:\n\tt -= 1\n\t(n, m) = map(int, input().split())\n\tvalchef = list(map(int, input().split()))\n\tchm = input()\n\tvalchefina = list(map(int, input().split()))\n\tchfm = input()\n\tchefa = []\n\tchefd = []\n\tchefinaa = []\n\tchefinad = []\n\tfor i in range(n):\n\t\tif chm[i] == 'A':\n\t\t\tchefa.append(valchef[i])\n\t\telse:\n\t\t\tchefd.append(-valchef[i])\n\tfor i in range(m):\n\t\tif chfm[i] == 'A':\n\t\t\tchefinaa.append(valchefina[i])\n\t\telse:\n\t\t\tchefinad.append(-valchefina[i])\n\theapify(chefa)\n\theapify(chefd)\n\theapify(chefinaa)\n\theapify(chefinad)\n\tres = []\n\tref = sum(valchef) - sum(valchefina)\n\t(c1, c2) = (0, -10000000000000)\n\tres.append(ref)\n\tturn = 0\n\twhile len(chefd) != 0 or len(chefinad) != 0:\n\t\tif turn % 2 == 0:\n\t\t\ttry:\n\t\t\t\tx = heappop(chefinad)\n\t\t\t\ty = heappop(chefa)\n\t\t\t\theappush(chefd, -y)\n\t\t\t\tres.append(ref - x)\n\t\t\t\tref = ref - x\n\t\t\texcept:\n\t\t\t\tbreak\n\t\telse:\n\t\t\ttry:\n\t\t\t\tx = heappop(chefd)\n\t\t\t\ty = heappop(chefinaa)\n\t\t\t\theappush(chefinad, -y)\n\t\t\t\tres.append(ref + x)\n\t\t\t\tref = ref + x\n\t\t\texcept:\n\t\t\t\tbreak\n\t\tturn += 1\n\tans = res[0]\n\tfor i in range(len(res) - 1, 0, -1):\n\t\tif i % 2:\n\t\t\tans = max(ans, res[i - 1])\n\t\telse:\n\t\t\tans = min(ans, res[i - 1])\n\tprint(ans)\n",
        "slowest_solution": "from heapq import *\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nwhile t:\n\tt -= 1\n\t(n, m) = map(int, input().split())\n\tvalchef = list(map(int, input().split()))\n\tchm = input()\n\tvalchefina = list(map(int, input().split()))\n\tchfm = input()\n\tchefa = []\n\tchefd = []\n\tchefinaa = []\n\tchefinad = []\n\tfor i in range(n):\n\t\tif chm[i] == 'A':\n\t\t\tchefa.append(valchef[i])\n\t\telse:\n\t\t\tchefd.append(-valchef[i])\n\tfor i in range(m):\n\t\tif chfm[i] == 'A':\n\t\t\tchefinaa.append(valchefina[i])\n\t\telse:\n\t\t\tchefinad.append(-valchefina[i])\n\theapify(chefa)\n\theapify(chefd)\n\theapify(chefinaa)\n\theapify(chefinad)\n\tres = []\n\tref = sum(valchef) - sum(valchefina)\n\t(c1, c2) = (0, -10000000000000)\n\tres.append(ref)\n\tturn = 0\n\twhile len(chefd) != 0 or len(chefinad) != 0:\n\t\tif turn % 2 == 0:\n\t\t\ttry:\n\t\t\t\tx = heappop(chefinad)\n\t\t\t\ty = heappop(chefa)\n\t\t\t\theappush(chefd, -y)\n\t\t\t\tres.append(ref - x)\n\t\t\t\tref = ref - x\n\t\t\texcept:\n\t\t\t\tbreak\n\t\telse:\n\t\t\ttry:\n\t\t\t\tx = heappop(chefd)\n\t\t\t\ty = heappop(chefinaa)\n\t\t\t\theappush(chefinad, -y)\n\t\t\t\tres.append(ref + x)\n\t\t\t\tref = ref + x\n\t\t\texcept:\n\t\t\t\tbreak\n\t\tturn += 1\n\tans = res[0]\n\tfor i in range(len(res) - 1, 0, -1):\n\t\tif i % 2:\n\t\t\tans = max(ans, res[i - 1])\n\t\telse:\n\t\t\tans = min(ans, res[i - 1])\n\tprint(ans)\n"
    },
    {
        "task_id": 60,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.7184195518493652,
        "fastest_time": 2.6906979084014893,
        "fastest_solution": "DEBUG = False\nfrom random import randrange\n\ndef gen_one(D, limit, limit_int=100):\n\treturn [tuple([randrange(limit_int) for _ in range(D)]) for _ in range(limit)]\n\ndef dist(a, b):\n\tret = 0\n\tfor (av, bv) in zip(a, b):\n\t\tret += abs(av - bv)\n\treturn ret\n\ndef prims(pts, dist_func=dist, extra_info=False):\n\troot = pts[0]\n\tfront = list(range(1, len(pts)))\n\tfront_dist = [0] + [dist_func(root, pt) for pt in pts[1:]]\n\tret = 0\n\tmin_edge = None\n\twhile len(front) > 0:\n\t\tbest = 0\n\t\tbest_dist = front_dist[front[0]]\n\t\tfor ind in range(1, len(front)):\n\t\t\tcand = front[ind]\n\t\t\tif front_dist[cand] > best_dist:\n\t\t\t\tbest_dist = front_dist[cand]\n\t\t\t\tbest = ind\n\t\tpt = pts[front[best]]\n\t\tfront[best] = front[-1]\n\t\tfront.pop()\n\t\tfor f in front:\n\t\t\tfront_dist[f] = max(front_dist[f], dist_func(pts[f], pt))\n\t\tret += best_dist\n\t\tif min_edge is None or min_edge > best_dist:\n\t\t\tmin_edge = best_dist\n\tif not extra_info:\n\t\treturn ret\n\telse:\n\t\treturn min_edge\n\ndef bin_array(D):\n\tif D > 1:\n\t\tfor arr in bin_array(D - 1):\n\t\t\tyield (arr + [False])\n\t\t\tyield (arr + [True])\n\telse:\n\t\tyield [False]\n\t\tyield [True]\n\ndef gen_box_pts(pts):\n\troot = pts[0]\n\tdim = []\n\tfor d in root:\n\t\tdim.append([d, d])\n\tfor pt in pts:\n\t\tfor (i, d) in enumerate(pt):\n\t\t\tif d < dim[i][0]:\n\t\t\t\tdim[i][0] = d\n\t\t\tif d > dim[i][1]:\n\t\t\t\tdim[i][1] = d\n\tret = []\n\tfor incs in bin_array(len(root)):\n\t\tpt = []\n\t\tfor (ind, inc) in enumerate(incs):\n\t\t\tif inc:\n\t\t\t\tpt.append(dim[ind][1])\n\t\t\telse:\n\t\t\t\tpt.append(dim[ind][0])\n\t\tret.append(tuple(pt))\n\treturn ret\n\ndef biggest_dist(root, pts):\n\tbest_dist = -1\n\tfor pt in pts:\n\t\tcand = dist(root, pt)\n\t\tif cand > best_dist:\n\t\t\tbest_dist = cand\n\treturn best_dist\n\ndef biggest_dist_cached_distances(root, pts, pts_dists, dist_limit):\n\tcands = [(dist(root, pt), i) for (i, pt) in enumerate(pts)]\n\t(best_dist, best_ind) = max(cands)\n\tif best_dist > dist_limit:\n\t\tfor (d, i) in cands:\n\t\t\tif d > dist_limit and i != best_ind and (d > pts_dists[best_ind][i]):\n\t\t\t\tpts_dists[best_ind][i] = d\n\t\t\t\tpts_dists[i][best_ind] = d\n\treturn best_dist\n\ndef biggest_dist_index(root, pts):\n\tbest_dist = -1\n\tfor (index, pt) in enumerate(pts):\n\t\tcand = dist(root, pt)\n\t\tif cand > best_dist:\n\t\t\tbest_dist = cand\n\t\t\tbest = index\n\treturn best\n\ndef solve(pts):\n\tD = len(pts[0])\n\tif len(pts) <= 2 ** D:\n\t\treturn prims(pts)\n\tif DEBUG and len(pts) < 10:\n\t\tprint(pts)\n\tbox_pts = gen_box_pts(pts)\n\tif DEBUG:\n\t\tprint(box_pts)\n\tboundry = []\n\tfor corner in box_pts:\n\t\ti = biggest_dist_index(corner, pts)\n\t\tb = pts[i]\n\t\tpts[i] = pts[-1]\n\t\tpts.pop()\n\t\tboundry.append(b)\n\tif DEBUG:\n\t\tprint(boundry)\n\tcached_dist = [[dist(i, j) for j in boundry] for i in boundry]\n\tmin_edge = prims(boundry, extra_info=True)\n\textra_dist_func = lambda x, y: cached_dist[x][y]\n\tif DEBUG:\n\t\tprint(cached_dist)\n\tif DEBUG:\n\t\tprint(min_edge)\n\tret = 0\n\tfor pt in pts:\n\t\td = biggest_dist_cached_distances(pt, boundry, cached_dist, min_edge)\n\t\tif DEBUG:\n\t\t\tprint('Max corner dist for {} is {}'.format(pt, d))\n\t\tret += d\n\tif DEBUG:\n\t\tprint(cached_dist)\n\tprim_tree = prims(list(range(len(boundry))), dist_func=extra_dist_func)\n\tif DEBUG:\n\t\tprint(prim_tree)\n\tret += prim_tree\n\treturn ret\n\ndef loop():\n\t(N, _) = map(int, input().split())\n\tpts = list((tuple(map(int, input().split())) for _ in range(N)))\n\tprint(solve(pts))\nloop()\n\ndef test_all():\n\tbig_test()\n\ndef test2D():\n\tfor _ in range(100):\n\t\tif not test(2, 5, 5):\n\t\t\tbreak\n\tfor _ in range(100):\n\t\tif not test(2, 10, 100):\n\t\t\tbreak\n\tfor _ in range(100):\n\t\tif not test(2, 100, 1000):\n\t\t\tbreak\n\ndef test3D():\n\tfor _ in range(100):\n\t\tif not test(3, 9, 5):\n\t\t\tbreak\n\tfor _ in range(100):\n\t\tif not test(3, 10, 100):\n\t\t\tbreak\n\tfor _ in range(100):\n\t\tif not test(3, 100, 1000):\n\t\t\tbreak\n\ndef test5D():\n\tfor _ in range(100):\n\t\tif not test(5, 33, 5):\n\t\t\tbreak\n\tfor _ in range(100):\n\t\tif not test(5, 100, 100):\n\t\t\tbreak\n\tfor _ in range(10):\n\t\tif not test(5, 1000, 1000):\n\t\t\tbreak\n\ndef test1D():\n\tfor _ in range(100):\n\t\tif not test(1, 5, 5):\n\t\t\tbreak\n\tfor _ in range(100):\n\t\tif not test(1, 10, 100):\n\t\t\tbreak\n\tfor _ in range(100):\n\t\tif not test(1, 100, 1000):\n\t\t\tbreak\n\ndef big_test():\n\tpts = gen_one(5, 200000, 100000)\n\ts = solve(pts)\n\treturn s\n\ndef test(D, num_pts, limit):\n\ttry:\n\t\tpts = gen_one(D, num_pts, limit)\n\t\tpts1 = pts[:]\n\t\tp = prims(pts)\n\t\ts = solve(pts1)\n\t\tret = p == s\n\t\tif not ret:\n\t\t\tprint(pts)\n\t\t\tprint(p)\n\t\t\tprint(s)\n\texcept:\n\t\tprint(pts)\n\t\tprint(p)\n\t\tprint(s)\n\treturn ret\n\ndef cur_bad25():\n\tpts = [(0, 3), (0, 2), (4, 3), (4, 0), (1, 0)]\n\tpts1 = pts[:]\n\tp = prims(pts)\n\tprint(p)\n\ts = solve(pts1)\n\tprint(s)\n",
        "slowest_solution": "distance = lambda X, Y: sum((abs(x - y) for (x, y) in zip(X, Y)))\nparent = []\nrank = []\n\ndef findRoot(node):\n\tglobal parent\n\twhile parent[node] != node:\n\t\tparent[node] = parent[parent[node]]\n\t\tnode = parent[node]\n\treturn node\n\ndef unionRoot(node1, node2):\n\tglobal parent, rank\n\troot1 = findRoot(node1)\n\troot2 = findRoot(node2)\n\tif root1 != root2:\n\t\tif rank[root1] > rank[root2]:\n\t\t\tparent[root2] = root1\n\t\telif rank[root2] > rank[root1]:\n\t\t\tparent[root1] = root2\n\t\telse:\n\t\t\tparent[root1] = root2\n\t\t\trank[root2] += 1\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef kruskal(n, edges):\n\tglobal parent, rank\n\tparent = [node for node in range(n)]\n\trank = [0] * n\n\tlength = 0\n\tedges = sorted(edges, key=lambda x: x[0])\n\tn -= 1\n\tfor (c, u, v) in edges:\n\t\tif unionRoot(u, v):\n\t\t\tlength += c\n\t\t\tn -= 1\n\t\t\tif n == 0:\n\t\t\t\tbreak\n\treturn length\n\ndef specialsum(mask, X):\n\tresult = 0\n\tfor (i, x) in zip(mask, X):\n\t\tif i == '0':\n\t\t\tresult += x\n\t\telse:\n\t\t\tresult -= x\n\treturn result\n\ndef solve(N, D, points, specialdists):\n\textrema = set([])\n\tfor i in range(2 ** (D - 1)):\n\t\t(i_min, i_max) = (-1, -1)\n\t\t(d_min, d_max) = (float('inf'), -float('inf'))\n\t\tfor index in range(N):\n\t\t\td = specialdists[index][i]\n\t\t\tif d <= d_min:\n\t\t\t\td_min = d\n\t\t\t\ti_min = index\n\t\t\tif d >= d_max:\n\t\t\t\td_max = d\n\t\t\t\ti_max = index\n\t\textrema.add((i_min, i))\n\t\textrema.add((i_max, i))\n\tedges = []\n\tfor (i, point) in enumerate(points):\n\t\tfor (j, k) in extrema:\n\t\t\tif i != j:\n\t\t\t\tdist = abs(specialdists[i][k] - specialdists[j][k])\n\t\t\t\tedges.append((-dist, i, j))\n\treturn -kruskal(N, edges)\n(N, D) = list(map(int, input().strip().split()))\npoints = []\nspecialdists = []\nfor point in range(N):\n\tcoordinates = list(map(int, input().strip().split()))\n\tspecial = []\n\tfor i in range(2 ** (D - 1)):\n\t\tmask = bin(i)[2:]\n\t\tmask = '0' * (D - len(mask)) + mask\n\t\tspecial.append(specialsum(mask, coordinates))\n\tspecialdists.append(special)\n\tpoints.append(coordinates)\nif N == 1:\n\tprint(0)\nelse:\n\tprint(solve(N, D, points, specialdists))\n"
    },
    {
        "task_id": 2,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 3.644977331161499,
        "fastest_time": 2.634263515472412,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n\ndef prog():\n\tans = 0\n\tcurr_total = 0\n\tlast_loc_with_val = [-1] * 500001\n\tn = int(input())\n\ts = input().strip()\n\ti = 0\n\twhile i < n:\n\t\tif s[i] == '0':\n\t\t\tans += curr_total\n\t\telse:\n\t\t\tl = i\n\t\t\tr = i\n\t\t\twhile r + 1 < n and s[r + 1] == '1':\n\t\t\t\tr += 1\n\t\t\tfor length in range(1, r - l + 2):\n\t\t\t\tcurr_total += l + length - 1 - last_loc_with_val[length]\n\t\t\t\tans += curr_total\n\t\t\t\tlast_loc_with_val[length] = r - length + 1\n\t\t\ti = r\n\t\ti += 1\n\tprint(ans)\nprog()\n",
        "slowest_solution": "hist = [0] * 1000005\n\ndef solve(n, s):\n\ttot = 0\n\tcur = 0\n\ti = 0\n\twhile i < n:\n\t\tif s[i] == '0':\n\t\t\ttot += cur\n\t\telse:\n\t\t\tl = i\n\t\t\tr = i\n\t\t\twhile r + 1 < n and s[r + 1] == '1':\n\t\t\t\tr += 1\n\t\t\tfor x in range(r - l + 1):\n\t\t\t\tcur += l + x + 1 - hist[x]\n\t\t\t\ttot += cur\n\t\t\t\thist[x] = r - x + 1\n\t\t\ti = r\n\t\ti += 1\n\treturn tot\nn = int(input())\ns = input()\nprint(solve(n, s))\n"
    },
    {
        "task_id": 9,
        "slowest_solution_id": 3,
        "fastest_solution_id": 8,
        "slowest_time": 3.6054253578186035,
        "fastest_time": 2.680471181869507,
        "fastest_solution": "import bisect as b\nfor _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tc = list(map(int, input().split()))\n\td = list(map(int, input().split()))\n\tp = [[], []]\n\tq = [[], []]\n\tfor i in range(n):\n\t\tif c[i] > 0:\n\t\t\tp[0].append(c[i])\n\t\telse:\n\t\t\tp[1].append(abs(c[i]))\n\tfor i in range(m):\n\t\tif d[i] > 0:\n\t\t\tq[0].append(d[i])\n\t\telse:\n\t\t\tq[1].append(abs(d[i]))\n\tp[1] = p[1][::-1]\n\tq[1] = q[1][::-1]\n\tan = 0\n\tfor j in range(2):\n\t\tx = p[j]\n\t\ty = q[j]\n\t\tn = len(x)\n\t\tm = len(y)\n\t\tif m == 0:\n\t\t\tcontinue\n\t\tl1 = [0 for _ in range(m)]\n\t\tl2 = [0 for _ in range(m)]\n\t\ta1 = b.bisect(x, y[0])\n\t\ta2 = b.bisect_left(x, y[0])\n\t\tif a1 != a2:\n\t\t\tl1[0] = 1\n\t\tl2[0] = 1 - b.bisect(y, y[0] - a1)\n\t\tfor i in range(1, m):\n\t\t\ta1 = b.bisect(x, y[i])\n\t\t\ta2 = b.bisect_left(x, y[i])\n\t\t\tif a1 != a2:\n\t\t\t\tl1[i] = l1[i - 1] + 1\n\t\t\telse:\n\t\t\t\tl1[i] = l1[i - 1]\n\t\t\tl2[i] = i + 1 - b.bisect(y, y[i] - a1)\n\t\tans = 0\n\t\tfor i in range(m):\n\t\t\tans = max(ans, l2[i] + l1[-1] - l1[i])\n\t\tan += ans\n\tprint(an)\n",
        "slowest_solution": "def read_list_of_input():\n\treturn [x for x in input().split()]\n\ndef read_list_of_int():\n\treturn [int(x) for x in read_list_of_input()]\n\ndef optimal_num(boxes, postions):\n\tans = 0\n\t(n, m) = (len(boxes), len(postions))\n\tafter_nth_box_best = [0 for _ in range(n + 1)]\n\tb = m - 1\n\tfor x in range(n - 1, -1, -1):\n\t\tafter_nth_box_best[x] = after_nth_box_best[x + 1]\n\t\twhile b >= 0 and boxes[x] < postions[b]:\n\t\t\tb -= 1\n\t\tif b >= 0 and boxes[x] == postions[b]:\n\t\t\tafter_nth_box_best[x] += 1\n\tj = 0\n\tr = 0\n\tfor x in range(m):\n\t\twhile j < n and postions[x] + j >= boxes[j]:\n\t\t\tj += 1\n\t\twhile r < m and postions[r] < j + postions[x]:\n\t\t\tr += 1\n\t\tans = max(ans, after_nth_box_best[j] + r - x)\n\treturn ans\n\ndef solve():\n\t(n, m) = read_list_of_int()\n\tbox_pos = read_list_of_int()\n\tspecial_pos = read_list_of_int()\n\tbox_left = [-1 * x for x in box_pos if x < 0]\n\tbox_left.reverse()\n\tbox_right = [x for x in box_pos if x >= 0]\n\tspecial_left = [-1 * x for x in special_pos if x < 0]\n\tspecial_left.reverse()\n\tspecial_right = [x for x in special_pos if x >= 0]\n\tprint(optimal_num(box_left, special_left) + optimal_num(box_right, special_right))\ntest = int(input())\nfor x in range(test):\n\tsolve()\n"
    },
    {
        "task_id": 61,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.671096086502075,
        "fastest_time": 2.595106363296509,
        "fastest_solution": "def solve():\n\tinput()\n\t(n, k) = map(int, input().split())\n\tf = list(enumerate(list(map(lambda x: int(x) - 1, input().split()))))\n\tg = {i: [] for i in range(n)}\n\tfor i in range(n - 1):\n\t\t(a, b) = map(int, input().split())\n\t\ta -= 1\n\t\tb -= 1\n\t\tg[a].append(b)\n\t\tg[b].append(a)\n\tneeded = {}\n\tvlad = [0]\n\tvisited = [False] * n\n\tfriends = [-1] * n\n\twhile len(vlad):\n\t\tnf = []\n\t\tfor (i, f1) in f:\n\t\t\tif friends[f1] != -1:\n\t\t\t\tcontinue\n\t\t\tfriends[f1] = i\n\t\t\tfor e in g[f1]:\n\t\t\t\tnf.append((i, e))\n\t\tf = nf\n\t\tnew_vlad = []\n\t\tfor v in vlad:\n\t\t\tif friends[v] != -1:\n\t\t\t\tneeded[friends[v]] = True\n\t\t\t\tcontinue\n\t\t\tif visited[v] == True:\n\t\t\t\tcontinue\n\t\t\tvisited[v] = True\n\t\t\tif len(g[v]) == 1 and v != 0:\n\t\t\t\treturn -1\n\t\t\tfor e in g[v]:\n\t\t\t\tnew_vlad.append(e)\n\t\tvlad = new_vlad\n\treturn len(needed)\nn = int(input())\nfor i in range(n):\n\tprint(solve())\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\ta = input()\n\t(n, k) = map(int, input().split())\n\tx = list(map(int, input().split()))\n\tfor i in range(k):\n\t\tx[i] -= 1\n\tM = [list() for i in range(n)]\n\tfor i in range(n - 1):\n\t\t(p, q) = map(int, input().split())\n\t\tM[p - 1].append(q - 1)\n\t\tM[q - 1].append(p - 1)\n\tF = [-1] * n\n\t(S, d) = (set(x), 0)\n\twhile len(S) > 0:\n\t\tT = set()\n\t\tfor j in S:\n\t\t\tF[j] = d\n\t\tfor j in S:\n\t\t\tfor q in M[j]:\n\t\t\t\tif F[q] == -1:\n\t\t\t\t\tT.add(q)\n\t\tS = T | set()\n\t\td += 1\n\tV = [-1] * n\n\t(S, d, ret) = (set([0]), 0, 0)\n\twhile len(S) > 0:\n\t\tT = set()\n\t\tfor j in S:\n\t\t\tV[j] = d\n\t\tfor j in S:\n\t\t\tfor q in M[j]:\n\t\t\t\tif V[q] == -1:\n\t\t\t\t\tif F[q] > d + 1:\n\t\t\t\t\t\tT.add(q)\n\t\t\t\t\telse:\n\t\t\t\t\t\tret += 1\n\t\tS = T | set()\n\t\td += 1\n\tM1 = []\n\tfor i in range(1, n):\n\t\tif len(M[i]) == 1:\n\t\t\tM1.append(i)\n\tbol = False\n\tfor i in M1:\n\t\tif F[i] > V[i] and V[i] != -1:\n\t\t\tbol = True\n\t\t\tbreak\n\tif bol:\n\t\tprint(-1)\n\telse:\n\t\tprint(ret)\n"
    },
    {
        "task_id": 33,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 4.2747721672058105,
        "fastest_time": 2.582439422607422,
        "fastest_solution": "import bisect\n(n, h) = map(int, input().split())\nstart = []\nend = []\nH = h\nstartpoints = []\nobs = []\npref = []\nfor _ in range(n):\n\t(x1, x2) = map(int, input().split())\n\tstart.append(x1)\n\tend.append(x2)\n\tstartpoints.append(x2 - x1)\nfor i in range(n - 1):\n\tobs.append(start[i + 1] - end[i])\n\tif i == 0:\n\t\tpref.append(obs[i])\n\telse:\n\t\tpref.append(pref[-1] + obs[i])\nprefstartpoints = [0]\nobs.append(100000000)\nfor i in range(n):\n\tprefstartpoints.append(startpoints[i] + prefstartpoints[-1])\nma = H\nfor i in range(n):\n\tres = 0\n\tc = bisect.bisect_left(pref, h)\n\tres = H + prefstartpoints[c + 1] - prefstartpoints[i]\n\tma = max(ma, res)\n\th = h + obs[i]\nprint(ma)\n",
        "slowest_solution": "(n, s) = map(int, input().split())\nmass = list()\narr = list()\npast = -1\nanswer = 0\nfor i in range(n):\n\t(l, r) = map(int, input().split())\n\tmass.append(r - l)\n\tif past != -1:\n\t\tarr.append(l - past)\n\tpast = r\nl2 = 0\nlocal = s\nq = mass[0] + s\nfor j in range(n - 1):\n\tlocal -= arr[j]\n\tif local <= 0:\n\t\tl2 = j\n\t\tbreak\n\tq += mass[j + 1]\nanswer = q\nif local <= 0:\n\tfor i in range(1, n):\n\t\tlocal += arr[i - 1]\n\t\tq -= mass[i - 1]\n\t\tif local > 0:\n\t\t\tlocal += arr[l2]\n\t\t\tfor j in range(l2, n - 1):\n\t\t\t\tlocal -= arr[j]\n\t\t\t\tif local <= 0:\n\t\t\t\t\tbreak\n\t\t\t\tl2 += 1\n\t\t\t\tq += mass[j + 1]\n\t\tif q > answer:\n\t\t\tanswer = q\n\t\tif local > 0:\n\t\t\tbreak\nprint(answer)\n"
    },
    {
        "task_id": 8,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 3.54451060295105,
        "fastest_time": 2.6431736946105957,
        "fastest_solution": "import sys\nT = int(input().strip())\nfor a0 in range(T):\n\tn = int(input().strip())\n\ta = [int(a_temp) for a_temp in input().strip().split(' ')]\n\ttxor_sums = [0, 0, 0]\n\tfor el in a:\n\t\tmod = el % 3\n\t\ttxor_sums[mod] += 1\n\tif txor_sums[1] % 2 == 0 and txor_sums[2] % 2 == 0:\n\t\tprint('Koca')\n\telse:\n\t\tprint('Balsa')\n",
        "slowest_solution": "import sys\nT = int(input().strip())\nfor a0 in range(T):\n\tn = int(input().strip())\n\ta = [int(a_temp) for a_temp in input().strip().split(' ')]\n\tx = [0, 0, 0]\n\tfor i in a:\n\t\tx[i % 3] += 1\n\tx[0] = x[0] & 1\n\tx[1] = x[1] & 1\n\tx[2] = x[2] & 1\n\tif x[0] == x[1] == x[2] == 0:\n\t\tprint('Koca')\n\telif x[0] == x[1] == 0:\n\t\tprint('Balsa')\n\telif x[0] == x[2] == 0:\n\t\tprint('Balsa')\n\telif x[1] == x[2] == 0:\n\t\tprint('Koca')\n\telif x[0] == x[1] == 1:\n\t\tprint('Balsa')\n\telif x[0] == x[2] == 1:\n\t\tprint('Balsa')\n\telif x[1] == x[2] == 1:\n\t\tprint('Balsa')\n\telse:\n\t\tprint('Balsa')\n"
    },
    {
        "task_id": 10,
        "slowest_solution_id": 3,
        "fastest_solution_id": 8,
        "slowest_time": 3.5198936462402344,
        "fastest_time": 2.657364845275879,
        "fastest_solution": "try:\n\tfrom sys import stdin as si, stdout as so\n\tfor _ in range(int(si.readline())):\n\t\t(n, k) = map(int, si.readline().split())\n\t\tb = list(map(int, si.readline().split()))\n\t\tm = max(b)\n\t\ts = sum(b)\n\t\tif s % k != 0:\n\t\t\tso.write('NO\\n')\n\t\telif m > s // k:\n\t\t\tso.write('NO\\n')\n\t\telse:\n\t\t\tso.write('YES\\n')\nexcept:\n\tpass\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\ts = sum(a)\n\tmaxi = max(a)\n\tif s % k == 0:\n\t\tr = s // k\n\t\tif r < maxi:\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 1,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 3.604658603668213,
        "fastest_time": 2.6051342487335205,
        "fastest_solution": "n = int(input())\nc = n // 1 * (n - 1) // 2 * (n - 2) // 3 * (n - 3) // 4 * (n - 4) // 5\nprint(c * c * 120)\n",
        "slowest_solution": "n = int(input())\ncn5 = n * (n - 1) // 2 * (n - 2) // 3 * (n - 3) // 4 * (n - 4) // 5\nan5 = n * (n - 1) * (n - 2) * (n - 3) * (n - 4)\nprint(cn5 * an5)\n"
    },
    {
        "task_id": 13,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 4.560771226882935,
        "fastest_time": 2.717168092727661,
        "fastest_solution": "(m, fac) = (10 ** 9 + 7, [1])\n[fac.append(fac[-1] * i % m) for i in range(1, 100001)]\n\ndef comb(n, r):\n\treturn fac[n] * pow(fac[r] * fac[n - r], m - 2, m) % m\nfor _ in range(int(input())):\n\t(u, v, k, p) = map(int, input().split())\n\tret = (comb(u * p, v * p) - comb(u, v)) * pow(p, m - 2, m) % m\n\tif k == 0:\n\t\tret += comb(u, v)\n\tprint(ret % m)\n",
        "slowest_solution": "(m, fac) = (10 ** 9 + 7, [1])\n[fac.append(fac[-1] * i % m) for i in range(1, 100001)]\n\ndef comb(n, r):\n\treturn fac[n] * pow(fac[r] * fac[n - r], m - 2, m) % m\nfor _ in range(int(input())):\n\t(u, v, k, p) = map(int, input().split())\n\tret = (comb(u * p, v * p) - comb(u, v)) * pow(p, m - 2, m) % m\n\tif k == 0:\n\t\tret += comb(u, v)\n\tprint(ret % m)\n"
    },
    {
        "task_id": 15,
        "slowest_solution_id": 4,
        "fastest_solution_id": 8,
        "slowest_time": 3.808107852935791,
        "fastest_time": 2.5986127853393555,
        "fastest_solution": "import math\nmod = 10 ** 9 + 7\n\ndef modInverse(b):\n\treturn pow(b, mod - 2, mod)\n\ndef modDivide(a, b):\n\ta = a % mod\n\tinv = modInverse(b)\n\treturn inv * a % mod\n\ndef solve():\n\tarr = list(map(int, list(input())))\n\tif len(arr) == 1:\n\t\tprint(0)\n\t\treturn 0\n\tt = 0\n\tl = len(arr)\n\tR = 0\n\tfor i in range(l - 2, -1, -1):\n\t\tR += pow(10, l - i - 1 - 1, mod) * (l - i - 1) % mod\n\t\tR %= mod\n\t\tt += arr[i] * R % mod\n\t\tt %= mod\n\tfor i in range(1, l):\n\t\tt += arr[i] * (i * (i + 1) // 2) % mod * pow(10, l - i - 1, mod) % mod\n\t\tt %= mod\n\tprint(int(t) % mod)\nsolve()\n",
        "slowest_solution": "import sys\nimport math as mt\nimport bisect\nt = 1\np = 10 ** 9 + 7\nfact = [0] * 300001\ninv = [0] * 300001\n\ndef ncr_util():\n\tinv[0] = inv[1] = 1\n\tfact[0] = fact[1] = 1\n\tfor i in range(2, 300001):\n\t\tinv[i] = inv[i % p] * (p - p // i) % p\n\tfor i in range(1, 300001):\n\t\tinv[i] = inv[i - 1] * inv[i] % p\n\t\tfact[i] = fact[i - 1] * i % p\nncr_util()\n\ndef ncr(n, r):\n\treturn fact[n] * inv[n - r] % p * (inv[r] % p) % p\n\ndef solve():\n\tans = 0\n\tp2 = [1] * (len(s) + 1)\n\tp10 = [1] * (len(s) + 1)\n\tp11 = [1] * (len(s) + 1)\n\tmul = 1\n\tfor i in range(1, len(s) + 1):\n\t\tp2[i] = p2[i - 1] * 2 % p\n\t\tp10[i] = p10[i - 1] * 10 % p\n\t\tp11[i] = p11[i - 1] * 10 % p\n\tpref = [0] * (len(s) + 1)\n\tmul = 1\n\tfor i in range(1, len(s) + 1):\n\t\tpref[i] = (pref[i - 1] + i * mul % p) % p\n\t\tmul = mul * 10 % p\n\tfor i in range(len(s)):\n\t\tx = int(s[i])\n\t\tx1 = i\n\t\tx1 = x1 * (x1 + 1) // 2\n\t\ty1 = x * pref[len(s) - i - 1] % p\n\t\tx1 = x * x1 % p * p10[len(s) - i - 1] % p\n\t\tans = (ans + x1 + y1) % p\n\treturn ans\nfor _ in range(t):\n\ts = input()\n\tprint(solve())\n"
    },
    {
        "task_id": 34,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 4.493668794631958,
        "fastest_time": 2.637634754180908,
        "fastest_solution": "M = int(input())\nwhile M > 0:\n\t(n, q) = map(int, input().split(' '))\n\ts = input()\n\tfreq = {}\n\tfor i in s:\n\t\tif i in freq:\n\t\t\tfreq[i] += 1\n\t\telse:\n\t\t\tfreq[i] = 1\n\tli = list(freq.values())\n\tmax1 = max(li)\n\tfor i in range(q):\n\t\tcount = 0\n\t\tc = int(input())\n\t\tfor j in li:\n\t\t\tif j > c:\n\t\t\t\tl = j - c\n\t\t\t\tcount += l\n\t\tprint(count)\n\tM = M - 1\n",
        "slowest_solution": "from collections import Counter\nfor _ in range(int(input())):\n\t(n, q) = map(int, input().split())\n\ts = input()\n\tdic = Counter(s)\n\tfor i in range(q):\n\t\tp = 0\n\t\tic = int(input())\n\t\tfor j in dic:\n\t\t\tif dic[j] > ic:\n\t\t\t\tp += dic[j] - ic\n\t\tprint(p)\n"
    },
    {
        "task_id": 21,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 3.851147174835205,
        "fastest_time": 2.5585861206054688,
        "fastest_solution": "def f(arr, m, n, mx, mi):\n\tmx[m][n] = mi[m][n] = arr[m][n]\n\tfor i in range(m - 1, -1, -1):\n\t\tmx[i][n] = mi[i][n] = arr[i][n] + mx[i + 1][n]\n\tfor i in range(n - 1, -1, -1):\n\t\tmx[m][i] = mi[m][i] = arr[m][i] + mx[m][i + 1]\n\tfor i in range(m - 1, -1, -1):\n\t\tfor j in range(n - 1, -1, -1):\n\t\t\tmx[i][j] = max(mx[i + 1][j], mx[i][j + 1]) + arr[i][j]\n\t\t\tmi[i][j] = min(mi[i + 1][j], mi[i][j + 1]) + arr[i][j]\n\treturn\nt = int(input())\nfor _ in range(t):\n\t(m, n) = map(int, input().split())\n\tarr = []\n\tans = True\n\tfor i in range(m):\n\t\tar = list(map(int, input().split()))\n\t\tarr.append(ar)\n\tif (m + n) % 2 == 0:\n\t\tans = False\n\telse:\n\t\tmx = [[-1 for i in range(n)] for j in range(m)]\n\t\tmi = [[-1 for i in range(n)] for j in range(m)]\n\t\tf(arr, m - 1, n - 1, mx, mi)\n\t\ta = mx[0][0]\n\t\tb = mi[0][0]\n\t\tif a < 0 or b > 0:\n\t\t\tans = False\n\tif ans:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "for case in range(int(input())):\n\t(n, m) = map(int, input().split())\n\ta = [list(map(int, input().split())) for _ in range(n)]\n\tif (n + m - 1) % 2:\n\t\tprint('NO')\n\t\tcontinue\n\tdp = [0] * (m + 1)\n\tfor i in range(n):\n\t\tdp[0] = int(not i)\n\t\tfor j in range(m):\n\t\t\tdp[j + 1] = (dp[j] | dp[j + 1]) << (a[i][j] == -1)\n\tif dp[-1] & 1 << (n + m - 1) // 2:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 30,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 4.0167906284332275,
        "fastest_time": 2.5428342819213867,
        "fastest_solution": "def count_r(x, a, b):\n\tx.sort()\n\toutput = [0] * len(x)\n\toutput2 = [0] * len(x)\n\t(i, j) = (0, len(x) - 1)\n\twhile i - j <= 0:\n\t\tif x[i] + x[j] >= a:\n\t\t\toutput[j] = i\n\t\t\tj -= 1\n\t\telse:\n\t\t\toutput[i] = j + 1\n\t\t\ti += 1\n\t(i, j) = (0, len(x) - 1)\n\twhile i - j <= 0:\n\t\tif x[i] + x[j] <= b:\n\t\t\toutput2[i] = j\n\t\t\ti += 1\n\t\telse:\n\t\t\toutput2[j] = i - 1\n\t\t\tj -= 1\n\tanswer = [o2 - o + 1 - (o <= i <= o2) for (i, (o, o2)) in enumerate(zip(output, output2))]\n\treturn sum(answer) // 2\nt = int(input())\nwhile t:\n\t(n, a, b) = map(int, input().split())\n\tli = list(map(int, input().split()))\n\tprint(count_r(li, a, b))\n\tt = t - 1\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\t(n, l, r) = map(int, input().split())\n\ta = sorted(list(map(int, input().split())))\n\tcount = 0\n\ti = 0\n\tj = 0\n\twhile i < n:\n\t\tn -= 1\n\t\twhile i < n and a[i] + a[n] < l:\n\t\t\ti += 1\n\t\twhile j < n and a[j] + a[n] <= r:\n\t\t\tj += 1\n\t\tcount += min(j, n) - i\n\tprint(count)\n"
    },
    {
        "task_id": 26,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 3.902979612350464,
        "fastest_time": 2.5871212482452393,
        "fastest_solution": "def formtri(x, y, z):\n\tif x + y >= z and y + z >= x and (z + x >= y):\n\t\treturn True\n\ndef check(A, B):\n\tif A[-1] != B[0] or A[-1] <= 0:\n\t\treturn 'No'\n\tif not A[0] == B[-1] == 0:\n\t\treturn 'No'\n\tfor i in range(1, len(A) - 1):\n\t\tif not (A[i] > 0 and B[i] > 0):\n\t\t\treturn 'No'\n\tmindist = A[-1]\n\tfor i in range(1, len(A) - 1):\n\t\tif not formtri(A[i], B[i], mindist):\n\t\t\treturn 'No'\n\treturn 'Yes'\nfor _ in range(int(input())):\n\tn = int(input())\n\tadis = list(map(int, input().split()))\n\tbdis = list(map(int, input().split()))\n\tprint(check(adis, bdis))\n",
        "slowest_solution": "for _ in range(int(input())):\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tB = list(map(int, input().split()))\n\tif A[0] != 0 or B[N - 1] != 0 or A[N - 1] != B[0]:\n\t\tprint('No')\n\t\tcontinue\n\tans = 'Yes'\n\tfor i in range(N):\n\t\tif i != 0 and A[i] == 0:\n\t\t\tans = 'No'\n\t\t\tbreak\n\t\tif i != N - 1 and B[i] == 0:\n\t\t\tans = 'No'\n\t\t\tbreak\n\t\tif A[i] + B[i] < B[0] or A[i] + B[0] < B[i] or B[i] + B[0] < A[i]:\n\t\t\tans = 'No'\n\t\t\tbreak\n\tprint(ans)\n"
    },
    {
        "task_id": 22,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 4.441426753997803,
        "fastest_time": 2.591063976287842,
        "fastest_solution": "import math\nimport heapq\n\ndef S():\n\treturn input()\n\ndef M():\n\treturn map(int, input().split())\n\ndef I():\n\treturn int(S())\n\ndef L():\n\treturn list(M())\nq = I()\na = []\ndi = {}\nm = 10000000\nk = 1\nt = 1\nar = []\nheapq.heapify(a)\nfor i in range(q):\n\tl = L()\n\tif len(l) == 2:\n\t\theapq.heappush(a, (m - l[1], l[1], k))\n\t\tdi[k] = 0\n\t\tk += 1\n\telif l[0] == 2:\n\t\twhile di.get(t, 0) == 1:\n\t\t\tt += 1\n\t\tar.append(t)\n\t\tdi[t] = 1\n\t\tt += 1\n\telse:\n\t\tp = heapq.heappop(a)\n\t\twhile di.get(p[2]) == 1:\n\t\t\tp = heapq.heappop(a)\n\t\tdi[p[2]] = 1\n\t\tar.append(p[2])\nprint(*ar)\n",
        "slowest_solution": "import heapq\n\ndef solution(n: int, arr: [[int]]) -> [int]:\n\tqueue = []\n\theap = []\n\tresult = []\n\tlastIndex = 0\n\tfor i in arr:\n\t\tif i[0] == 1:\n\t\t\tlastIndex += 1\n\t\t\telement = [-i[1], lastIndex, False]\n\t\t\tqueue.append(element)\n\t\t\theapq.heappush(heap, element)\n\t\tif i[0] == 2:\n\t\t\tcustomer = queue.pop(0)\n\t\t\twhile customer[2] == True:\n\t\t\t\tcustomer = queue.pop(0)\n\t\t\tcustomer[2] = True\n\t\t\tresult.append(customer[1])\n\t\tif i[0] == 3:\n\t\t\tcustomer = heapq.heappop(heap)\n\t\t\twhile customer[2] == True:\n\t\t\t\tcustomer = heapq.heappop(heap)\n\t\t\tcustomer[2] = True\n\t\t\tresult.append(customer[1])\n\treturn result\n\ndef main():\n\tn = int(input())\n\tarr = [[int(j) for j in input().split(' ')] for i in range(n)]\n\tprint(' '.join([str(i) for i in solution(n, arr)]))\nmain()\n"
    },
    {
        "task_id": 27,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 4.524386644363403,
        "fastest_time": 2.551952600479126,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tenemy = list(input().strip())\n\tfriend = list(input().strip())\n\tk = 0\n\tfor i in range(n):\n\t\tif friend[i] == '1':\n\t\t\tif enemy[i] != '1':\n\t\t\t\tk += 1\n\t\t\telif i != 0 and enemy[i - 1] == '1':\n\t\t\t\tenemy[i - 1] = '0'\n\t\t\t\tk += 1\n\t\t\telif i != n - 1 and enemy[i + 1] == '1':\n\t\t\t\tenemy[i + 1] = '0'\n\t\t\t\tk += 1\n\tprint(k)\n",
        "slowest_solution": "entrada = int(input())\nfor i in range(entrada):\n\tn = int(input())\n\ts = list(input())\n\tl = list(input())\n\tcount = 0\n\tfor i in range(n):\n\t\tif l[i] == '1':\n\t\t\tif s[i] == '0':\n\t\t\t\tcount += 1\n\t\t\telif i != 0 and s[i - 1] == '1':\n\t\t\t\ts[i - 1] = '0'\n\t\t\t\tcount += 1\n\t\t\telif i != n - 1 and s[i + 1] == '1':\n\t\t\t\ts[i + 1] = '0'\n\t\t\t\tcount += 1\n\tprint(count)\n"
    },
    {
        "task_id": 29,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 4.544184923171997,
        "fastest_time": 2.5458569526672363,
        "fastest_solution": "import math\nfor q in range(int(input())):\n\t(n, m, k) = list(map(int, input().split()))\n\tk -= 1\n\ttemp2 = n * (n - 1) // 2\n\ttemp = temp2 - m\n\ttemp = temp + 1 if m != n - 1 else n - 1\n\tif n == 1 and k > 0 and (m == 0):\n\t\tprint('YES')\n\telif m > temp2:\n\t\tprint('NO')\n\telif m == temp2 and k > 1:\n\t\tprint('YES')\n\telif m == n - 1 and k > 2:\n\t\tprint('YES')\n\telif m < n - 1:\n\t\tprint('NO')\n\telif 2 < k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "t = int(input())\nwhile t:\n\tt -= 1\n\t(n, m, k) = map(int, input().split())\n\tif m < n - 1 or m > n * (n - 1) // 2:\n\t\tprint('NO')\n\t\tcontinue\n\tif k > 3:\n\t\tprint('YES')\n\telif k == 3:\n\t\tif m == n * (n - 1) // 2:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telif k == 2:\n\t\tif n == 1 and m == 0:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 25,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 4.495655298233032,
        "fastest_time": 2.528561592102051,
        "fastest_solution": "print(input().swapcase())\n",
        "slowest_solution": "string_input = input()\nprint(string_input.swapcase())\n"
    },
    {
        "task_id": 77,
        "slowest_solution_id": 6,
        "fastest_solution_id": 3,
        "slowest_time": 0.044626474380493164,
        "fastest_time": 0.001007080078125,
        "fastest_solution": "def find(n, z):\n\tr = n + 1\n\tsumn = sumof(n)\n\twhile True:\n\t\tif sumof(r) > sumn + z:\n\t\t\treturn r\n\t\tr += 1\n\treturn 'Perhaps this is a different way to solve the kata, but it works ;-)(not cheat)'\n\ndef sumof(n):\n\tfm = [[], [], [], [22, 13, 4], [365, 167, 50, 14], [5415, 2130, 627, 177, 51], [75802, 27067, 7897, 2254, 661, 202], [123456, 123456, 123456, 123456, 123456, 123456, 123456]]\n\tl = 1 if n < 10 else 2 if n < 100 else 3 if n < 1000 else 4 if n < 10000 else 5 if n < 100000 else 6 if n < 1000000 else 7\n\t(a, i, r) = (fm[l], l - 1, 0)\n\twhile n > 0:\n\t\tt = n % 10\n\t\tn //= 10\n\t\tr += t * a[i]\n\t\ti -= 1\n\treturn r\n",
        "slowest_solution": "def get_partitionr(ss):\n\tout = []\n\tif len(ss) <= 1:\n\t\treturn [ss]\n\tfor i in range(2 ** len(ss) // 2):\n\t\tparts = [[], []]\n\t\tfor item in ss:\n\t\t\tparts[i & 1].append(item)\n\t\t\ti >>= 1\n\t\tbb = get_partitionr(parts[1])\n\t\tfor b in bb:\n\t\t\tout.append([parts[0]] + b)\n\treturn out\n\ndef add(parts):\n\ttotal = 0\n\tfor part in parts:\n\t\ttotal += sum((int(''.join(p)) if isinstance(p, list) else int(p) for p in part))\n\treturn total\n\ndef find(n, z):\n\tparts = get_partitionr(list(str(n)))[1:]\n\tadd_parts = add(parts)\n\ttarget = add_parts + z\n\twhile add_parts <= target:\n\t\tn += 1\n\t\tparts = get_partitionr(list(str(n)))[1:]\n\t\tadd_parts = add(parts)\n\treturn n\n"
    },
    {
        "task_id": 80,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 0.001039266586303711,
        "fastest_time": 0.0,
        "fastest_solution": "def mix(s1, s2):\n\thist = {}\n\tfor ch in 'abcdefghijklmnopqrstuvwxyz':\n\t\t(val1, val2) = (s1.count(ch), s2.count(ch))\n\t\tif max(val1, val2) > 1:\n\t\t\twhich = '1' if val1 > val2 else '2' if val2 > val1 else '='\n\t\t\thist[ch] = (-max(val1, val2), which + ':' + ch * max(val1, val2))\n\treturn '/'.join((hist[ch][1] for ch in sorted(hist, key=lambda x: hist[x])))\n",
        "slowest_solution": "def mix(s1, s2):\n\ts1 = {elem: '1:' + ''.join([x for x in s1 if x == elem]) for elem in s1 if s1.count(elem) > 1 and elem.islower()}\n\ts2 = {elem: '2:' + ''.join([x for x in s2 if x == elem]) for elem in s2 if s2.count(elem) > 1 and elem.islower()}\n\tfor elem in s2:\n\t\tif elem in s1:\n\t\t\tif len(s2.get(elem)) > len(s1.get(elem)):\n\t\t\t\ts1.update({elem: s2.get(elem)})\n\t\t\telif len(s2.get(elem)) == len(s1.get(elem)):\n\t\t\t\ts1.update({elem: '=:' + s2.get(elem)[2:]})\n\t\telse:\n\t\t\ts1.update({elem: s2.get(elem)})\n\ts2 = sorted([s1.get(elem) for elem in s1])\n\tprint(s2)\n\tfor i in range(len(s2)):\n\t\tfor j in range(len(s2)):\n\t\t\tif len(s2[i]) < len(s2[j]):\n\t\t\t\t(s2[i], s2[j]) = (s2[j], s2[i])\n\t\t\telif len(s2[i]) == len(s2[j]):\n\t\t\t\tif s2[i][0] == s2[j][0] and sorted([s2[i][2], s2[j][2]])[0] == s2[j][2] or (s2[i][0].isdigit() == False and s2[j][0].isdigit()) or (s2[i][0].isdigit() and s2[j][0].isdigit() and (int(s2[i][0]) > int(s2[j][0]))):\n\t\t\t\t\t(s2[i], s2[j]) = (s2[j], s2[i])\n\treturn '/'.join(reversed([x for x in s2]))\n"
    },
    {
        "task_id": 23,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 4.561589002609253,
        "fastest_time": 2.5898799896240234,
        "fastest_solution": "MOD = 998244353\n\ndef inv(x):\n\treturn pow(x, MOD - 2, MOD)\n(n, k) = list(map(int, input().split()))\nif k >= n:\n\tprint(0)\nelse:\n\tout = 0\n\tcol = n - k\n\tbinom = 1\n\tmult = 1\n\tfor i in range(n, col, -1):\n\t\tmult *= i\n\t\tmult *= inv(n + 1 - i)\n\t\tmult %= MOD\n\tfor i in range(col, 0, -1):\n\t\tout += binom * pow(i, n, MOD)\n\t\tout %= MOD\n\t\tbinom *= i\n\t\tbinom *= inv(col + 1 - i)\n\t\tbinom *= -1\n\t\tbinom %= MOD\n\tout *= mult\n\tif k > 0:\n\t\tout *= 2\n\tprint(out % MOD)\n",
        "slowest_solution": "(n, k) = map(int, input().split())\ntuk = n - k\nhell = 998244353\nif tuk <= 0:\n\tprint(0)\n\texit(0)\nfact = [1] * 200005\nfor i in range(2, 200005):\n\tfact[i] = i * fact[i - 1] % hell\n\ndef C(n, r):\n\tans = 1\n\tans = fact[r] * fact[n - r] % hell\n\tans = fact[n] * pow(ans, hell - 2, hell) % hell\n\treturn ans\nans = C(n, tuk)\nif k != 0:\n\tans *= 2\nres = 0\nfor i in range(tuk):\n\tt = C(tuk, i) * pow(tuk - i, n, hell) % hell\n\tif i % 2:\n\t\tres = (res - t + hell) % hell\n\telse:\n\t\tres = (res + t) % hell\nans = ans * res % hell\nprint(ans)\n"
    },
    {
        "task_id": 55,
        "slowest_solution_id": 1,
        "fastest_solution_id": 6,
        "slowest_time": 2.8306572437286377,
        "fastest_time": 2.467951774597168,
        "fastest_solution": "(a, b) = input().split()\ndiff = str(int(a) - int(b))\nout = ''\nfor x in range(0, len(diff)):\n\tif x == 0:\n\t\tif diff[0] != '1':\n\t\t\tout = out + '1'\n\t\telse:\n\t\t\tout = out + '2'\n\telse:\n\t\tout = out + diff[x]\nprint(out)\n",
        "slowest_solution": "(a, b) = map(int, input().split())\nif a < b:\n\t(a, b) = (b, a)\na = str(a - b)\nif len(a) == 1:\n\tif a == '1':\n\t\tprint(2)\n\telse:\n\t\tprint(1)\nelse:\n\tv = '1'\n\tif a[0] == '1':\n\t\tv = '2'\n\ta = v + a[1:]\n\tprint(int(a))\n"
    },
    {
        "task_id": 4,
        "slowest_solution_id": 9,
        "fastest_solution_id": 7,
        "slowest_time": 4.711703538894653,
        "fastest_time": 2.5708553791046143,
        "fastest_solution": "def combination(a, b):\n\tans = 0\n\tans += factorial(a) // factorial(b) ** 2\n\treturn ans\nM = 1000000007\nfrom math import factorial\nfor _ in range(int(input())):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tcount = l.count(max(l))\n\tif count & 1:\n\t\tprint(pow(2, n, M))\n\telse:\n\t\tways = pow(2, n - count, M) * combination(count, count // 2)\n\t\tx = pow(2, n, M)\n\t\tprint((x - ways) % M)\n",
        "slowest_solution": "mod = 10 ** 9 + 7\nN = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(mod):\n\tnaturalNumInverse[0] = naturalNumInverse[1] = 1\n\tfor i in range(2, N + 1, 1):\n\t\tnaturalNumInverse[i] = naturalNumInverse[mod % i] * (mod - int(mod / i)) % mod\n\ndef InverseofFactorial(mod):\n\tfactorialNumInverse[0] = factorialNumInverse[1] = 1\n\tfor i in range(2, N + 1):\n\t\tfactorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % mod\n\ndef factorial(mod):\n\tfact[0] = 1\n\tfor i in range(1, N + 1):\n\t\tfact[i] = fact[i - 1] * i % mod\n\ndef nCr(N, R, mod):\n\tans = fact[N] * factorialNumInverse[R] % mod * factorialNumInverse[N - R] % mod\n\treturn ans\n\ndef solve():\n\tn = int(input())\n\tli = list(map(int, input().split()))\n\tmaxNoF = li.count(max(li))\n\tif maxNoF % 2 == 1:\n\t\tprint(pow(2, n) % mod)\n\telse:\n\t\textevent = (pow(2, maxNoF) - nCr(maxNoF, maxNoF // 2, mod) + mod) % mod\n\t\tans = pow(2, n - maxNoF) * extevent % mod\n\t\tprint(ans)\nInverseofNumber(mod)\nInverseofFactorial(mod)\nfactorial(mod)\nfor test in range(int(input())):\n\tsolve()\n"
    },
    {
        "task_id": 16,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 4.1263954639434814,
        "fastest_time": 2.5341644287109375,
        "fastest_solution": "(a, x, y) = map(int, input().split())\nif y > 0:\n\tif y / a > y // a:\n\t\tif y // a == 0:\n\t\t\tif abs(x) < a / 2:\n\t\t\t\tprint(1)\n\t\t\t\texit()\n\t\telif y // a % 2 == 1:\n\t\t\tif abs(x) < a / 2:\n\t\t\t\tprint((y // a - 1) // 2 * 3 + 2)\n\t\t\t\texit()\n\t\telse:\n\t\t\tm = y // a * 3 / 2\n\t\t\tif 0 < x < a:\n\t\t\t\tprint(int(m + 1))\n\t\t\t\texit()\n\t\t\telif 0 > x > -a:\n\t\t\t\tprint(int(m))\n\t\t\t\texit()\nprint('-1')\n",
        "slowest_solution": "(a, x, y) = map(int, input().split())\nif x >= a or x <= -a or y == y // a * a or (y < 0):\n\tprint(-1)\n\texit(0)\nelif x == 0 and y // a % 2 == 0 and (y // a != 0):\n\tprint(-1)\n\texit(0)\nelif (x >= (a + 1) // 2 or -x >= (a + 1) // 2) and (y // a % 2 == 1 or y // a == 0):\n\tprint(-1)\n\texit(0)\nz = y // a\nif z == 0:\n\tprint(1)\nelif (z - 1) % 2 == 0:\n\tprint((z - 1) // 2 * 3 + 2)\nelif x < 0:\n\tprint((z - 1) // 2 * 3 + 3)\nelse:\n\tprint((z - 1) // 2 * 3 + 4)\n"
    },
    {
        "task_id": 39,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 3.625567674636841,
        "fastest_time": 2.5277693271636963,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n(N, K) = map(int, input().split())\ngraph = [[] for _ in range(N)]\nfor _ in range(N - 1):\n\t(a, b) = map(int, input().split())\n\tgraph[a - 1].append(b - 1)\n\tgraph[b - 1].append(a - 1)\nPar = [-1] * N\nque = []\nchilds = [0] * N\nstack = [0]\nInd = [0] * N\nD = [0] * N\nwhile stack:\n\tp = stack[-1]\n\tif Ind[p] == len(graph[p]):\n\t\tstack.pop()\n\t\tif stack:\n\t\t\tpar = stack[-1]\n\t\t\tPar[p] = par\n\t\t\tchilds[par] += childs[p] + 1\n\telif len(stack) > 1 and stack[-2] == graph[p][Ind[p]]:\n\t\tInd[p] += 1\n\telse:\n\t\tnp = graph[p][Ind[p]]\n\t\tD[np] = D[p] + 1\n\t\tInd[p] += 1\n\t\tstack.append(np)\nB = []\nfor n in range(N):\n\tB.append(D[n] - childs[n])\nB.sort(reverse=True)\nprint(sum(B[:K]))\n",
        "slowest_solution": "from collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nbuffer = []\n\ndef dfs(graph, n, p, level):\n\tpenalty = 1\n\tfor c in graph[n]:\n\t\tif c == p:\n\t\t\tcontinue\n\t\tpenalty += dfs(graph, c, n, level + 1)\n\tbuffer.append(level - penalty)\n\treturn penalty\n\ndef main():\n\t(n, k) = map(int, input().split())\n\tgraph = defaultdict(list)\n\tfor i in range(n - 1):\n\t\t(a, b) = map(int, input().split())\n\t\tgraph[a].append(b)\n\t\tgraph[b].append(a)\n\ttry:\n\t\tdfs(graph, 1, None, 1)\n\texcept Exception as e:\n\t\tprint(e)\n\tprint(sum(sorted(buffer, reverse=True)[:k]))\nt = threading.Thread(target=main)\nt.start()\nt.join()\n"
    },
    {
        "task_id": 74,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5843307971954346,
        "fastest_time": 2.5843307971954346,
        "fastest_solution": "from heapq import *\n(n, L) = [int(i) for i in input().split()]\ndots = [0, L]\n(tr, ind) = ({}, {})\nfor i in range(n):\n\t(x, d, t, p) = [int(i) for i in input().split()]\n\tif x - p < 0 or t >= d:\n\t\tcontinue\n\ttr.setdefault(x - p, [])\n\ttr[x - p].append((x + d, p + t, i))\n\tdots.append(x - p)\n\tdots.append(x + d)\ndots = [i for i in set(dots)]\ndots.sort()\ng = [[] for i in dots]\nfor i in range(1, len(dots) - 1):\n\tg[i].append((i - 1, dots[i] - dots[i - 1]))\n\tg[i].append((i + 1, dots[i + 1] - dots[i]))\ng[0].append((1, dots[1] - dots[0]))\ng[-1].append((len(dots) - 2, dots[-1] - dots[-2]))\nfor (i, x) in enumerate(dots):\n\tind[x] = i\nfor (i, x) in enumerate(dots):\n\tif not x in tr:\n\t\tcontinue\n\tfor j in tr[x]:\n\t\tg[i].append((ind[j[0]], j[1], j[2]))\n(d, p, val) = ([2000000000 for i in dots], [-1 for i in dots], [-1 for i in dots])\nd[0] = 0\nq = [(0, 0)]\nwhile len(q) > 0:\n\t(dist, v) = heappop(q)\n\tif dist > d[v]:\n\t\tcontinue\n\tfor e in g[v]:\n\t\tif d[e[0]] > d[v] + e[1]:\n\t\t\td[e[0]] = d[v] + e[1]\n\t\t\tp[e[0]] = v\n\t\t\tif len(e) > 2:\n\t\t\t\tval[e[0]] = e[2]\n\t\t\telse:\n\t\t\t\tval[e[0]] = -1\n\t\t\theappush(q, (d[e[0]], e[0]))\nprint(d[len(dots) - 1])\nv = len(dots) - 1\nans = []\nwhile v != 0:\n\tif val[v] != -1:\n\t\tans += [val[v]]\n\tv = p[v]\nans.reverse()\nans = [i + 1 for i in ans]\nprint(len(ans))\nprint(*ans)\n",
        "slowest_solution": "from heapq import *\n(n, L) = [int(i) for i in input().split()]\ndots = [0, L]\n(tr, ind) = ({}, {})\nfor i in range(n):\n\t(x, d, t, p) = [int(i) for i in input().split()]\n\tif x - p < 0 or t >= d:\n\t\tcontinue\n\ttr.setdefault(x - p, [])\n\ttr[x - p].append((x + d, p + t, i))\n\tdots.append(x - p)\n\tdots.append(x + d)\ndots = [i for i in set(dots)]\ndots.sort()\ng = [[] for i in dots]\nfor i in range(1, len(dots) - 1):\n\tg[i].append((i - 1, dots[i] - dots[i - 1]))\n\tg[i].append((i + 1, dots[i + 1] - dots[i]))\ng[0].append((1, dots[1] - dots[0]))\ng[-1].append((len(dots) - 2, dots[-1] - dots[-2]))\nfor (i, x) in enumerate(dots):\n\tind[x] = i\nfor (i, x) in enumerate(dots):\n\tif not x in tr:\n\t\tcontinue\n\tfor j in tr[x]:\n\t\tg[i].append((ind[j[0]], j[1], j[2]))\n(d, p, val) = ([2000000000 for i in dots], [-1 for i in dots], [-1 for i in dots])\nd[0] = 0\nq = [(0, 0)]\nwhile len(q) > 0:\n\t(dist, v) = heappop(q)\n\tif dist > d[v]:\n\t\tcontinue\n\tfor e in g[v]:\n\t\tif d[e[0]] > d[v] + e[1]:\n\t\t\td[e[0]] = d[v] + e[1]\n\t\t\tp[e[0]] = v\n\t\t\tif len(e) > 2:\n\t\t\t\tval[e[0]] = e[2]\n\t\t\telse:\n\t\t\t\tval[e[0]] = -1\n\t\t\theappush(q, (d[e[0]], e[0]))\nprint(d[len(dots) - 1])\nv = len(dots) - 1\nans = []\nwhile v != 0:\n\tif val[v] != -1:\n\t\tans += [val[v]]\n\tv = p[v]\nans.reverse()\nans = [i + 1 for i in ans]\nprint(len(ans))\nprint(*ans)\n"
    },
    {
        "task_id": 51,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 2.9362070560455322,
        "fastest_time": 2.557854175567627,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\ns = [[[0 for _ in range(m)] for _ in range(m)] for _ in range(m)]\nfor i in range(n):\n\tk = int(input())\n\tfor j in range(k):\n\t\t(l, r) = map(int, input().split())\n\t\tl -= 1\n\t\tr -= 1\n\t\tfor x in range(l, r + 1):\n\t\t\ts[l][r][x] += 1\nfor i in range(m):\n\tfor j in range(max(1, i), m):\n\t\tfor k in range(i, j + 1):\n\t\t\ts[i][j][k] += s[i][j - 1][k]\nfor i in range(m - 2, -1, -1):\n\tfor j in range(i, m):\n\t\tfor k in range(i, j + 1):\n\t\t\ts[i][j][k] += s[i + 1][j][k]\nf = [[0 for _ in range(m)] for _ in range(m)]\nfor i in range(m - 1, -1, -1):\n\tfor j in range(i, m):\n\t\tfor k in range(i, j + 1):\n\t\t\ta = f[i][k - 1] if i <= k - 1 else 0\n\t\t\tb = f[k + 1][j] if k + 1 <= j else 0\n\t\t\tf[i][j] = max(f[i][j], a + b + s[i][j][k] ** 2)\nprint(f[0][m - 1])\n",
        "slowest_solution": "from bisect import *\nimport sys\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n\treturn int(sys.stdin.readline())\n\ndef MI():\n\treturn map(int, sys.stdin.readline().split())\n\ndef LI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n\treturn [LI() for _ in range(rows_number)]\n\ndef SI():\n\treturn sys.stdin.readline()[:-1]\n\ndef solve():\n\tdp = [[0] * (w + 1) for _ in range(w + 1)]\n\tfor d in range(1, w + 1):\n\t\tfor l in range(w - d + 1):\n\t\t\tr = l + d\n\t\t\tcnt = [0] * (w + 1)\n\t\t\tfor i in range(h):\n\t\t\t\tsl = bisect_left(seg[i], l)\n\t\t\t\tsr = bisect_right(seg[i], r)\n\t\t\t\tif sl == sr:\n\t\t\t\t\tcontinue\n\t\t\t\tb = seg[i][sl]\n\t\t\t\te = seg[i][sr - 1]\n\t\t\t\tcnt[b] += 1\n\t\t\t\tcnt[e] -= 1\n\t\t\tfor j in range(l, r):\n\t\t\t\tcnt[j + 1] += cnt[j]\n\t\t\t\tif cnt[j] == 0:\n\t\t\t\t\tcontinue\n\t\t\t\tdp[l][r] = max(dp[l][r], cnt[j] ** 2 + dp[l][j] + dp[j + 1][r])\n\tprint(dp[0][w])\n(h, w) = MI()\nseg = [[0] for _ in range(h)]\nfor i in range(h):\n\tfor _ in range(II()):\n\t\t(l, r) = MI()\n\t\tseg[i].append(r)\nsolve()\n"
    },
    {
        "task_id": 84,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6453332901000977,
        "fastest_time": 2.6453332901000977,
        "fastest_solution": "s = list(map(int, input().split()))\nn = s[0]\nm = s[1]\nroads = []\nfor i in range(0, n + 1):\n\troads.append([])\nfor i in range(0, m):\n\ts = list(map(int, input().split()))\n\troads[s[0]].append([s[1], s[2]])\n\troads[s[1]].append([s[0], s[2]])\ncol = [-1] * (n + 1)\nbfs = True\nfor start in range(1, n + 1):\n\tif col.count(-1) == 1:\n\t\tbreak\n\tif col[start] == -1:\n\t\tQ = [start]\n\t\tcol[start] = 1\n\t\twhile len(Q) > 0 and bfs:\n\t\t\tcurr = Q.pop(0)\n\t\t\tfor e in roads[curr]:\n\t\t\t\tif col[e[0]] == -1:\n\t\t\t\t\tQ.append(e[0])\n\t\t\t\t\tif e[1]:\n\t\t\t\t\t\tcol[e[0]] = col[curr]\n\t\t\t\t\telse:\n\t\t\t\t\t\tcol[e[0]] = 1 - col[curr]\n\t\t\t\telif abs(col[e[0]] - col[curr]) != 1 - e[1]:\n\t\t\t\t\tbfs = False\n\t\t\t\t\tQ = []\n\t\t\t\t\tbreak\nif bfs:\n\tL = [j for j in range(1, n + 1) if col[j] == 1]\n\tprint(len(L))\n\tans = ''\n\tfor i in range(0, len(L)):\n\t\tans += str(L[i]) + ' '\n\tans = ans[:len(ans) - 1]\n\tprint(ans)\nelse:\n\tprint('Impossible')\n",
        "slowest_solution": "s = list(map(int, input().split()))\nn = s[0]\nm = s[1]\nroads = []\nfor i in range(0, n + 1):\n\troads.append([])\nfor i in range(0, m):\n\ts = list(map(int, input().split()))\n\troads[s[0]].append([s[1], s[2]])\n\troads[s[1]].append([s[0], s[2]])\ncol = [-1] * (n + 1)\nbfs = True\nfor start in range(1, n + 1):\n\tif col.count(-1) == 1:\n\t\tbreak\n\tif col[start] == -1:\n\t\tQ = [start]\n\t\tcol[start] = 1\n\t\twhile len(Q) > 0 and bfs:\n\t\t\tcurr = Q.pop(0)\n\t\t\tfor e in roads[curr]:\n\t\t\t\tif col[e[0]] == -1:\n\t\t\t\t\tQ.append(e[0])\n\t\t\t\t\tif e[1]:\n\t\t\t\t\t\tcol[e[0]] = col[curr]\n\t\t\t\t\telse:\n\t\t\t\t\t\tcol[e[0]] = 1 - col[curr]\n\t\t\t\telif abs(col[e[0]] - col[curr]) != 1 - e[1]:\n\t\t\t\t\tbfs = False\n\t\t\t\t\tQ = []\n\t\t\t\t\tbreak\nif bfs:\n\tL = [j for j in range(1, n + 1) if col[j] == 1]\n\tprint(len(L))\n\tans = ''\n\tfor i in range(0, len(L)):\n\t\tans += str(L[i]) + ' '\n\tans = ans[:len(ans) - 1]\n\tprint(ans)\nelse:\n\tprint('Impossible')\n"
    },
    {
        "task_id": 38,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 4.290674686431885,
        "fastest_time": 2.541224241256714,
        "fastest_solution": "import bisect\nt = int(input())\ntemp = {1: 1, 4: 2, 9: 3, 49: 4, 100: 5, 144: 6, 400: 7, 441: 8, 900: 9, 1444: 10, 4900: 11, 9409: 12, 10000: 13, 10404: 14, 11449: 15, 14400: 16, 19044: 17, 40000: 18, 40401: 19, 44100: 20, 44944: 21, 90000: 22, 144400: 23, 419904: 24, 490000: 25, 491401: 26, 904401: 27, 940900: 28, 994009: 29, 1000000: 30, 1004004: 31, 1014049: 32, 1040400: 33, 1100401: 34, 1144900: 35, 1440000: 36, 1904400: 37, 1940449: 38, 4000000: 39, 4004001: 40, 4040100: 41, 4410000: 42, 4494400: 43, 9000000: 44, 9909904: 45, 9941409: 46, 11909401: 47, 14010049: 48, 14040009: 49, 14440000: 50, 19909444: 51, 40411449: 52, 41990400: 53, 49000000: 54, 49014001: 55, 49140100: 56, 49999041: 57, 90440100: 58, 94090000: 59, 94109401: 60, 99400900: 61, 99940009: 62, 100000000: 63, 100040004: 64, 100140049: 65, 100400400: 66, 101404900: 67, 101949409: 68, 104040000: 69, 104919049: 70, 110040100: 71, 111049444: 72, 114041041: 73, 114490000: 74, 144000000: 75, 190440000: 76, 194044900: 77, 400000000: 78, 400040001: 79, 400400100: 80, 404010000: 81, 404090404: 82, 409941009: 83, 414000409: 84, 414041104: 85, 441000000: 86, 449440000: 87, 490091044: 88, 900000000: 89, 990990400: 90, 991494144: 91, 994140900: 92, 1190940100: 93, 1401004900: 94, 1404000900: 95, 1409101444: 96, 1444000000: 97, 1449401041: 98, 1490114404: 99, 1990944400: 100, 4014109449: 101, 4019940409: 102, 4041144900: 103, 4199040000: 104, 4900000000: 105, 4900140001: 106, 4901400100: 107, 4914010000: 108, 4914991449: 109, 4941949401: 110, 4999904100: 111, 9044010000: 112, 9409000000: 113, 9409194001: 114, 9410940100: 115, 9900449001: 116, 9940090000: 117, 9994000900: 118, 9999400009: 119, 10000000000: 120}\narr = [1, 4, 9, 49, 100, 144, 400, 441, 900, 1444, 4900, 9409, 10000, 10404, 11449, 14400, 19044, 40000, 40401, 44100, 44944, 90000, 144400, 419904, 490000, 491401, 904401, 940900, 994009, 1000000, 1004004, 1014049, 1040400, 1100401, 1144900, 1440000, 1904400, 1940449, 4000000, 4004001, 4040100, 4410000, 4494400, 9000000, 9909904, 9941409, 11909401, 14010049, 14040009, 14440000, 19909444, 40411449, 41990400, 49000000, 49014001, 49140100, 49999041, 90440100, 94090000, 94109401, 99400900, 99940009, 100000000, 100040004, 100140049, 100400400, 101404900, 101949409, 104040000, 104919049, 110040100, 111049444, 114041041, 114490000, 144000000, 190440000, 194044900, 400000000, 400040001, 400400100, 404010000, 404090404, 409941009, 414000409, 414041104, 441000000, 449440000, 490091044, 900000000, 990990400, 991494144, 994140900, 1190940100, 1401004900, 1404000900, 1409101444, 1444000000, 1449401041, 1490114404, 1990944400, 4014109449, 4019940409, 4041144900, 4199040000, 4900000000, 4900140001, 4901400100, 4914010000, 4914991449, 4941949401, 4999904100, 9044010000, 9409000000, 9409194001, 9410940100, 9900449001, 9940090000, 9994000900, 9999400009, 10000000000]\nfor _ in range(t):\n\t(a, b) = map(int, input().split())\n\tflag1 = 0\n\tflag2 = 0\n\tif a in temp and b in temp:\n\t\tans = temp[b] - temp[a]\n\telif a in temp:\n\t\tlb2 = arr[bisect.bisect_left(arr, b, 0, len(arr)) - 1]\n\t\tans = temp[lb2] - temp[a]\n\telif b in temp:\n\t\tlb1 = arr[bisect.bisect_left(arr, a, 0, len(arr))]\n\t\tans = temp[b] - temp[lb1]\n\telse:\n\t\tlb1 = arr[bisect.bisect_left(arr, a, 0, len(arr))]\n\t\tlb2 = arr[bisect.bisect_left(arr, b, 0, len(arr)) - 1]\n\t\tans = temp[lb2] - temp[lb1]\n\tans += 1\n\tprint(ans)\n",
        "slowest_solution": "from bisect import *\ntable = [0, 1, 4, 9, 49, 100, 144, 400, 441, 900, 1444, 4900, 9409, 10000, 10404, 11449, 14400, 19044, 40000, 40401, 44100, 44944, 90000, 144400, 419904, 490000, 491401, 904401, 940900, 994009, 1000000, 1004004, 1014049, 1040400, 1100401, 1144900, 1440000, 1904400, 1940449, 4000000, 4004001, 4040100, 4410000, 4494400, 9000000, 9909904, 9941409, 11909401, 14010049, 14040009, 14440000, 19909444, 40411449, 41990400, 49000000, 49014001, 49140100, 49999041, 90440100, 94090000, 94109401, 99400900, 99940009, 100000000, 100040004, 100140049, 100400400, 101404900, 101949409, 104040000, 104919049, 110040100, 111049444, 114041041, 114490000, 144000000, 190440000, 194044900, 400000000, 400040001, 400400100, 404010000, 404090404, 409941009, 414000409, 414041104, 441000000, 449440000, 490091044, 900000000, 990990400, 991494144, 994140900, 1190940100, 1401004900, 1404000900, 1409101444, 1444000000, 1449401041, 1490114404, 1990944400, 4014109449, 4019940409, 4041144900, 4199040000, 4900000000, 4900140001, 4901400100, 4914010000, 4914991449, 4941949401, 4999904100, 9044010000, 9409000000, 9409194001, 9410940100, 9900449001, 9940090000, 9994000900, 9999400009, 10000000000]\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\taa = bisect_left(table, a)\n\tbb = bisect_right(table, b)\n\tprint(bb - aa)\n"
    },
    {
        "task_id": 42,
        "slowest_solution_id": 1,
        "fastest_solution_id": 8,
        "slowest_time": 3.5444343090057373,
        "fastest_time": 2.4892358779907227,
        "fastest_solution": "tmp = input().split()\nn = int(tmp[0])\nk = int(tmp[1])\ntmp = input().split()\nsum = 0\nsum1 = 0\nsum2 = 0\nfor i in range(k):\n\tif int(tmp[i]) % 4 == 2:\n\t\tsum2 += 1\n\tsum += int(tmp[i])\n\tsum1 += int(tmp[i]) % 2\nif sum2 > 3 * n:\n\tif sum + sum1 + (sum2 - 3 * n) * 2 <= 8 * n:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nelif sum + sum1 <= 8 * n:\n\tprint('YES')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "(n, k) = map(int, input().split())\na = list(map(int, input().split()))\n(fours, twos, ones) = (n, 2 * n, 0)\nfor i in range(k):\n\twhile a[i] >= 4:\n\t\ta[i] -= 4\n\t\tif fours:\n\t\t\tfours -= 1\n\t\telif twos >= 2:\n\t\t\ttwos -= 2\n\t\telse:\n\t\t\tprint('NO')\n\t\t\texit()\nfor i in range(k):\n\tif a[i] == 3:\n\t\ta[i] = 0\n\t\tif fours:\n\t\t\tfours -= 1\n\t\telif twos >= 2:\n\t\t\ttwos -= 2\n\t\telse:\n\t\t\tprint('NO')\n\t\t\texit()\nfor i in range(k):\n\tif a[i] == 2:\n\t\ta[i] = 0\n\t\tif twos:\n\t\t\ttwos -= 1\n\t\telif fours:\n\t\t\tfours -= 1\n\t\t\tones += 1\n\t\telif ones >= 2:\n\t\t\tones -= 2\n\t\telse:\n\t\t\tprint('NO')\n\t\t\texit()\nones += 2 * fours + twos\nif a.count(1) > ones:\n\tprint('NO')\nelse:\n\tprint('YES')\n"
    },
    {
        "task_id": 45,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 3.2384285926818848,
        "fastest_time": 2.5797150135040283,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\n\ndef scanf(datatype=str):\n\treturn datatype(sys.stdin.readline().rstrip())\n\ndef printf(answer=''):\n\treturn sys.stdout.write(str(answer) + '\\n')\n\ndef prints(answer):\n\treturn sys.stdout.write(str(answer) + ' ')\n\ndef map_input(datatype=str):\n\treturn map(datatype, sys.stdin.readline().split())\n\ndef list_input(datatype=str):\n\treturn list(map(datatype, sys.stdin.readline().split()))\n\ndef testcase(number: int, solve_function):\n\tfor _ in range(number):\n\t\tprintf(solve_function())\n\ndef solve():\n\tn = scanf(int)\n\tarr = list_input(int)\n\tif n <= 2:\n\t\treturn 0\n\tarr.sort()\n\tprefix = [0] * n\n\tprefix[0] = arr[0]\n\tfor i in range(1, n):\n\t\tprefix[i] = prefix[i - 1] + arr[i]\n\tSum = 0\n\tmul = 1\n\tfor i in range(2, n):\n\t\tSum += arr[i] * mul - prefix[i - 2]\n\t\tmul += 1\n\tSum *= -1\n\treturn Sum\nt = scanf(int)\ntestcase(t, solve)\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\td = list(map(int, input().split()))\n\td = sorted(d)\n\tif n == 1:\n\t\tprint(d[n - 1])\n\t\tcontinue\n\tl = [0]\n\tfor i in range(n - 2, -1, -1):\n\t\tl.append(d[i] - d[n - 1])\n\tc = n - 1\n\tS = sum(l)\n\tans = S\n\tfor i in range(n - 2, 0, -1):\n\t\tdis = (d[i] - d[i + 1]) * c\n\t\tS -= dis\n\t\tans += S\n\t\tc -= 1\n\tfor i in range(1, n):\n\t\tans += d[i] - d[i - 1]\n\tprint(ans)\n"
    },
    {
        "task_id": 87,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7410497665405273,
        "fastest_time": 2.7410497665405273,
        "fastest_solution": "from sys import setrecursionlimit\nfrom collections import defaultdict, deque\n\n\ndef dfs(elem, visited, Graph):\n\tcola = deque(Graph[elem])\n\twhile cola:\n\t\telem = cola.pop()\n\t\tif visited[elem - 1]:\n\t\t\tcontinue\n\t\tvisited[elem - 1] = True\n\t\tcola += Graph[elem]\n\ndef solve():\n\tunequal = []\n\tpositions = {}\n\tGraph = defaultdict(list)\n\tN, K = list(map(int, input().strip().split()))\n\n\tfor i in range(K):\n\t\tx, o, y = input().strip().split()\n\t\tx = int(x)\n\t\ty = int(y)\n\n\t\tif o == \"=\":\n\t\t\tGraph[x].append(y)\n\t\t\tGraph[y].append(x)\n\t\telse:\n\t\t\tunequal.append((x, o, y))\n\n\tvisited = [False] * N\n\talready = set()\n\tstart = 1\n\tfor i in list(Graph.keys()):\n\t\tif visited[i-1]:\n\t\t\tcontinue\n\t\tvisited[i-1] = True\n\t\tdfs(i, visited, Graph)\n\t\tnodes = set([i+1 for i, j in enumerate(visited) if j]).difference(already)\n\t\tpositions.update({x: start for x in nodes})\n\t\tstart += 1\n\t\talready.update(nodes)\n\n\tfor i in unequal:\n\t\tx, o, y = i\n\t\tif x in positions and y in positions and positions[x] == positions[y]:\n\t\t\treturn False\n\n\treturn True\n\nT = eval(input())\nfor i in range(T):\n\tif solve():\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n",
        "slowest_solution": "from sys import setrecursionlimit\nfrom collections import defaultdict, deque\n\n\ndef dfs(elem, visited, Graph):\n\tcola = deque(Graph[elem])\n\twhile cola:\n\t\telem = cola.pop()\n\t\tif visited[elem - 1]:\n\t\t\tcontinue\n\t\tvisited[elem - 1] = True\n\t\tcola += Graph[elem]\n\ndef solve():\n\tunequal = []\n\tpositions = {}\n\tGraph = defaultdict(list)\n\tN, K = list(map(int, input().strip().split()))\n\n\tfor i in range(K):\n\t\tx, o, y = input().strip().split()\n\t\tx = int(x)\n\t\ty = int(y)\n\n\t\tif o == \"=\":\n\t\t\tGraph[x].append(y)\n\t\t\tGraph[y].append(x)\n\t\telse:\n\t\t\tunequal.append((x, o, y))\n\n\tvisited = [False] * N\n\talready = set()\n\tstart = 1\n\tfor i in list(Graph.keys()):\n\t\tif visited[i-1]:\n\t\t\tcontinue\n\t\tvisited[i-1] = True\n\t\tdfs(i, visited, Graph)\n\t\tnodes = set([i+1 for i, j in enumerate(visited) if j]).difference(already)\n\t\tpositions.update({x: start for x in nodes})\n\t\tstart += 1\n\t\talready.update(nodes)\n\n\tfor i in unequal:\n\t\tx, o, y = i\n\t\tif x in positions and y in positions and positions[x] == positions[y]:\n\t\t\treturn False\n\n\treturn True\n\nT = eval(input())\nfor i in range(T):\n\tif solve():\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
        "task_id": 59,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.9448132514953613,
        "fastest_time": 2.580392599105835,
        "fastest_solution": "def convertToParitys(s):\n\tkeys = '?abcdefghijklmnopqrstuvwxyz'\n\tparitys = {c: 0 for c in keys}\n\tfor c in s:\n\t\tparitys[c] += 1\n\tfor (c, v) in paritys.items():\n\t\tparitys[c] = v % 2\n\tout = 0\n\tbitValue = 1\n\tfor c in keys:\n\t\tif paritys[c]:\n\t\t\tout += bitValue\n\t\tbitValue *= 2\n\treturn out\n\ndef getSolutionBitMaps(s):\n\tout = []\n\tsP = convertToParitys(s)\n\tif sP % 2:\n\t\tsP -= 1\n\tout.append(sP)\n\tfor n in range(1, 27):\n\t\tout.append(sP ^ 1 + 2 ** n)\n\treturn out\n\ndef getLeadingSubStringBitMapCounts(s):\n\tout = {}\n\tbM = 0\n\tkeys = '?abcdefghijklmnopqrstuvwxyz'\n\tparitys = {c: 0 for c in keys}\n\tvalues = {c: 2 ** i for (i, c) in enumerate(keys)}\n\tout[bM] = out.setdefault(bM, 0) + 1\n\tbMis = []\n\ti = 0\n\tbMis = [0]\n\tfor c in s:\n\t\ti += 1\n\t\tif paritys[c]:\n\t\t\tparitys[c] = 0\n\t\t\tbM -= values[c]\n\t\telse:\n\t\t\tparitys[c] = 1\n\t\t\tbM += values[c]\n\t\tout[bM] = out.setdefault(bM, 0) + 1\n\t\tbMis.append(bM)\n\treturn (out, bMis)\n\ndef solve(s):\n\tout = 0\n\t(bMjCounts, bMis) = getLeadingSubStringBitMapCounts(s)\n\tsolutions = getSolutionBitMaps(s)\n\tfor bMi in bMis:\n\t\tfor bMs in solutions:\n\t\t\tif bMs ^ bMi in bMjCounts:\n\t\t\t\tout += bMjCounts[bMs ^ bMi]\n\tif 0 in solutions:\n\t\tout -= len(s)\n\tout //= 2\n\treturn out\nT = int(input())\nfor tc in range(T):\n\ts = input()\n\tprint(solve(s))\n",
        "slowest_solution": "from sys import stdin, stdout\ninput = stdin.readline\n\ndef val(i):\n\tif i == '?':\n\t\treturn 26\n\treturn ord(i) - 97\nt = int(input())\nfor _ in range(t):\n\ts = input()[:-1]\n\tans = 0\n\tmask = 0\n\tfor i in s:\n\t\tif i == '?':\n\t\t\tcontinue\n\t\tmask ^= 1 << val(i)\n\thash = {0: 1}\n\tpre = 0\n\tfor i in s:\n\t\tpre ^= 1 << val(i)\n\t\tans += hash.get(pre ^ mask, 0)\n\t\tx = mask ^ 1 << 26\n\t\tfor j in range(26):\n\t\t\tans += hash.get(pre ^ 1 << j ^ x, 0)\n\t\thash[pre] = hash.get(pre, 0) + 1\n\tstdout.write(str(ans) + '\\n')\n"
    },
    {
        "task_id": 93,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6591007709503174,
        "fastest_time": 2.6591007709503174,
        "fastest_solution": "import sys\nfrom collections import namedtuple\n\ndef readline():\n\treturn list(map(int, input().split()))\n\ndef readlines():\n\tfor line in sys.stdin.readlines():\n\t\tyield list(map(int, line.split()))\n\nclass State(namedtuple('State', 'payload time floor')):\n\n\tdef hook(self, pivot, a, b):\n\t\t(lo, up) = (min(pivot, a, self.floor), max(pivot, a, self.floor))\n\t\treturn (tuple((x for x in self.payload if x < lo or up < x)) + (b,), self.time + abs(self.floor - pivot) + abs(pivot - a))\n\n\tdef choices_to_take_next(self, a, b):\n\t\tfloor = self.floor\n\t\t(payload, time) = self.hook(floor, a, b)\n\t\tif len(payload) < 5:\n\t\t\tyield (payload, time)\n\t\t\tif floor > a:\n\t\t\t\tpivots = (x for x in self.payload if x > floor)\n\t\t\telif floor == a:\n\t\t\t\tpivots = ()\n\t\t\telse:\n\t\t\t\tpivots = (x for x in self.payload if x < floor)\n\t\telse:\n\t\t\tpivots = self.payload\n\t\tfor pivot in pivots:\n\t\t\tyield self.hook(pivot, a, b)\n\ndef time_to_get_free(payload, floor):\n\tif payload:\n\t\t(lo, up) = (min(payload), max(payload))\n\t\treturn abs(lo - up) + min(abs(floor - lo), abs(floor - up))\n\telse:\n\t\treturn 0\n\ndef main():\n\t(n,) = readline()\n\tfloor = 1\n\tpositions = {(): 0}\n\tfor (a, b) in readlines():\n\t\tmax_acceptable_time = min(positions.values()) + 16 - abs(floor - a)\n\t\tnew_positions = dict()\n\t\tfor (payload, time) in list(positions.items()):\n\t\t\tstate = State(payload, time, floor)\n\t\t\tfor (npayload, ntime) in state.choices_to_take_next(a, b):\n\t\t\t\tif ntime <= max_acceptable_time:\n\t\t\t\t\tnpayload = tuple(sorted(npayload))\n\t\t\t\t\tif new_positions.setdefault(npayload, ntime) > ntime:\n\t\t\t\t\t\tnew_positions[npayload] = ntime\n\t\tpositions = new_positions\n\t\tfloor = a\n\treturn min((t + time_to_get_free(p, floor) for (p, t) in list(positions.items()))) + 2 * n\nprint(main())\n",
        "slowest_solution": "import sys\nfrom collections import namedtuple\n\ndef readline():\n\treturn list(map(int, input().split()))\n\ndef readlines():\n\tfor line in sys.stdin.readlines():\n\t\tyield list(map(int, line.split()))\n\nclass State(namedtuple('State', 'payload time floor')):\n\n\tdef hook(self, pivot, a, b):\n\t\t(lo, up) = (min(pivot, a, self.floor), max(pivot, a, self.floor))\n\t\treturn (tuple((x for x in self.payload if x < lo or up < x)) + (b,), self.time + abs(self.floor - pivot) + abs(pivot - a))\n\n\tdef choices_to_take_next(self, a, b):\n\t\tfloor = self.floor\n\t\t(payload, time) = self.hook(floor, a, b)\n\t\tif len(payload) < 5:\n\t\t\tyield (payload, time)\n\t\t\tif floor > a:\n\t\t\t\tpivots = (x for x in self.payload if x > floor)\n\t\t\telif floor == a:\n\t\t\t\tpivots = ()\n\t\t\telse:\n\t\t\t\tpivots = (x for x in self.payload if x < floor)\n\t\telse:\n\t\t\tpivots = self.payload\n\t\tfor pivot in pivots:\n\t\t\tyield self.hook(pivot, a, b)\n\ndef time_to_get_free(payload, floor):\n\tif payload:\n\t\t(lo, up) = (min(payload), max(payload))\n\t\treturn abs(lo - up) + min(abs(floor - lo), abs(floor - up))\n\telse:\n\t\treturn 0\n\ndef main():\n\t(n,) = readline()\n\tfloor = 1\n\tpositions = {(): 0}\n\tfor (a, b) in readlines():\n\t\tmax_acceptable_time = min(positions.values()) + 16 - abs(floor - a)\n\t\tnew_positions = dict()\n\t\tfor (payload, time) in list(positions.items()):\n\t\t\tstate = State(payload, time, floor)\n\t\t\tfor (npayload, ntime) in state.choices_to_take_next(a, b):\n\t\t\t\tif ntime <= max_acceptable_time:\n\t\t\t\t\tnpayload = tuple(sorted(npayload))\n\t\t\t\t\tif new_positions.setdefault(npayload, ntime) > ntime:\n\t\t\t\t\t\tnew_positions[npayload] = ntime\n\t\tpositions = new_positions\n\t\tfloor = a\n\treturn min((t + time_to_get_free(p, floor) for (p, t) in list(positions.items()))) + 2 * n\nprint(main())\n"
    },
    {
        "task_id": 49,
        "slowest_solution_id": 9,
        "fastest_solution_id": 7,
        "slowest_time": 3.14363956451416,
        "fastest_time": 2.4412288665771484,
        "fastest_solution": "from math import sqrt\nn = int(input())\ns = 0\nf = 0\nwhile int(sqrt(n)) == sqrt(n) and n > 1:\n\tn = int(sqrt(n))\n\ts += 1\nfor i in range(int(sqrt(n)), 1, -1):\n\twhile n % (i * i) == 0:\n\t\ts += 1\n\t\tn //= i\n\t\tf = 1\nprint(n, s + f)\n",
        "slowest_solution": "import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\nN = int(input())\nfactors = collections.defaultdict(int)\nprimes = [True for _ in range(max(1 + N // 2, 10))]\nprimes[0] = primes[1] = False\nfor i in range(2, N // 2 + 1):\n\tif primes[i]:\n\t\tt = 2\n\t\twhile i * t <= N // 2:\n\t\t\tprimes[i * t] = False\n\t\t\tt += 1\nn = N\nfor i in range(2, N // 2 + 1):\n\tif not primes[i]:\n\t\tcontinue\n\twhile i <= n and n % i == 0:\n\t\tn //= i\n\t\tfactors[i] += 1\n\ndef dpow(x):\n\tu = int(math.log2(x))\n\tp = 1 << u\n\tif p < x:\n\t\treturn u + 1\n\telse:\n\t\treturn u\nvals = list(factors.values())\nU = [dpow(a) for a in vals]\nif not U:\n\tprint(N, 0)\nelse:\n\tans = 1\n\tfor v in factors.keys():\n\t\tans *= v\n\tu = max(U)\n\tif all((2 ** u == vals[i] for i in range(len(vals)))):\n\t\tprint(ans, u)\n\telse:\n\t\tprint(ans, u + 1)\n"
    },
    {
        "task_id": 82,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.693171501159668,
        "fastest_time": 2.6105148792266846,
        "fastest_solution": "import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\n(M, N) = map(int, input().split())\nwords = []\nfor i in range(M):\n\twords.append([int(x) for x in input().split()][1:])\nC = set()\nE = collections.defaultdict(list)\nfor i in range(M - 1):\n\tw1 = words[i]\n\tw2 = words[i + 1]\n\tif len(w1) > len(w2) and w1[:len(w2)] == w2:\n\t\tprint('No')\n\t\texit(0)\n\tfor j in range(min(len(w1), len(w2))):\n\t\tif w1[j] < w2[j]:\n\t\t\tE[w2[j]].append(w1[j])\n\t\t\tbreak\n\t\telif w1[j] > w2[j]:\n\t\t\tC.add(w1[j])\n\t\t\tbreak\nA = {u for u in C}\nwhile A:\n\tB = set(itertools.chain.from_iterable([E[u] for u in A]))\n\tA = B - C\n\tC |= B\nfor i in range(M - 1):\n\tw1 = words[i]\n\tw2 = words[i + 1]\n\tfor j in range(min(len(w1), len(w2))):\n\t\t(a, b) = (w1[j], w2[j])\n\t\td = [a in C, b in C]\n\t\tif a < b:\n\t\t\tif d == [False, True]:\n\t\t\t\tprint('No')\n\t\t\t\texit(0)\n\t\t\tbreak\n\t\telif a > b:\n\t\t\tif d != [True, False]:\n\t\t\t\tprint('No')\n\t\t\t\texit(0)\n\t\t\tbreak\nprint('Yes')\nprint(len(C))\nif C:\n\tprint(' '.join(map(str, sorted(C))))\n",
        "slowest_solution": "from collections import defaultdict, deque\n\ndef main():\n\t(n, m) = map(int, input().split())\n\tcap = [None] * (m + 1)\n\tsame_cap = defaultdict(list)\n\tq = deque()\n\n\tdef apply_cap(a, c):\n\t\tif cap[a] is not None:\n\t\t\treturn cap[a] == c\n\t\tq.append((a, c))\n\t\twhile q:\n\t\t\tb = q.pop()\n\t\t\tif b[1] == c:\n\t\t\t\tif cap[b[0]] is None:\n\t\t\t\t\tcap[b[0]] = c\n\t\t\t\t\tq.extend(same_cap[b[0]])\n\t\t\t\t\tsame_cap[b[0]] = []\n\t\t\t\telif cap[b[0]] != c:\n\t\t\t\t\treturn False\n\t\treturn True\n\n\tdef same(a, b):\n\t\tsame_cap[b].append((a, True))\n\t\tsame_cap[a].append((b, False))\n\t\tif cap[a] == False:\n\t\t\treturn apply_cap(b, False)\n\t\tif cap[b] == True:\n\t\t\treturn apply_cap(a, True)\n\t\treturn True\n\n\tdef process(p, c):\n\t\tlp = p[0]\n\t\tlc = c[0]\n\t\tfor i in range(1, min(lp, lc) + 1):\n\t\t\tif p[i] > c[i]:\n\t\t\t\treturn apply_cap(p[i], True) and apply_cap(c[i], False)\n\t\t\tif p[i] < c[i]:\n\t\t\t\treturn same(p[i], c[i])\n\t\treturn lp <= lc\n\tp = list(map(int, input().split()))\n\tfor i in range(n - 1):\n\t\tc = list(map(int, input().split()))\n\t\tif not process(p, c):\n\t\t\tprint('No')\n\t\t\tbreak\n\t\tp = c\n\telse:\n\t\tprint('Yes')\n\t\tres = []\n\t\tfor (i, b) in enumerate(cap):\n\t\t\tif b:\n\t\t\t\tres.append(i)\n\t\tprint(len(res))\n\t\tprint(' '.join(map(str, res)))\nmain()\n"
    },
    {
        "task_id": 91,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.587017774581909,
        "fastest_time": 2.550886392593384,
        "fastest_solution": "pow_2 = [1, 2, 4, 8, 16, 32, 64, 128, 256]\n\ndef solve(N, G, L):\n\tif not N in pow_2:\n\t\tprint(-1)\n\t\treturn\n\tV = [i for i in range(0, N)]\n\twhile len(V) > 1:\n\t\ti = 0\n\t\tC = []\n\t\twhile i < len(V) - 1:\n\t\t\tu = V[i]\n\t\t\tv = V[i + 1]\n\t\t\tif G[u][v] != 0:\n\t\t\t\tC.append(u)\n\t\t\t\tL.remove((u, v))\n\t\t\telse:\n\t\t\t\tC.append(v)\n\t\t\t\tL.remove((v, u))\n\t\t\ti += 2\n\t\tV = C\n\tprint(len(L))\n\tfor i in range(0, len(L) - 1):\n\t\tprint(G[L[i][0]][L[i][1]], end=' ')\n\tif len(L) != 0:\n\t\tprint(G[L[-1][0]][L[-1][1]])\n\telse:\n\t\tprint('')\nT = int(input())\nfor i in range(0, T):\n\tN = int(input())\n\tG = [[0 for j in range(0, N)] for i in range(0, N)]\n\tL = []\n\tfor i in range(0, N * (N - 1) // 2):\n\t\t(u, v) = [int(s) for s in input().split(' ') if s != '']\n\t\tG[u - 1][v - 1] = i + 1\n\t\tL.append((u - 1, v - 1))\n\tsolve(N, G, L)\n",
        "slowest_solution": "powers_of_two = [2 ** x for x in range(11)]\n\ndef power_root(l, r, adj_matrix, keep_edges):\n\tif l == r:\n\t\treturn l\n\tmid = (l + r) // 2\n\troot1 = power_root(l, mid, adj_matrix, keep_edges)\n\troot2 = power_root(mid + 1, r, adj_matrix, keep_edges)\n\tif adj_matrix[root1][root2] > 0:\n\t\tkeep_edges[root1][root2] = 1\n\t\tnew_root = root1\n\telse:\n\t\tkeep_edges[root2][root1] = 1\n\t\tnew_root = root2\n\treturn new_root\nT = int(input())\nfor t in range(T):\n\tn = int(input())\n\tadj_matrix = []\n\tfor i in range(n):\n\t\tadj_matrix.append([0] * n)\n\tkeep_edges = []\n\tfor i in range(n):\n\t\tkeep_edges.append([0] * n)\n\tfor i in range(1, n * (n - 1) // 2 + 1):\n\t\t(u, v) = [int(vert) for vert in input().split(' ')]\n\t\tadj_matrix[u - 1][v - 1] = i\n\tif not n in powers_of_two:\n\t\tprint(-1)\n\t\tcontinue\n\tpower_root(0, n - 1, adj_matrix, keep_edges)\n\tanswer = []\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif keep_edges[i][j] == 0 and adj_matrix[i][j] != 0:\n\t\t\t\tanswer.append(adj_matrix[i][j])\n\tprint(len(answer))\n\tif len(answer) > 0:\n\t\tprint(*answer)\n"
    },
    {
        "task_id": 52,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.932518482208252,
        "fastest_time": 2.544973850250244,
        "fastest_solution": "n = int(input())\na = [[] for i in range(n)]\ngen = []\nfor i in range(n):\n\tk = int(input())\n\tif k == -1:\n\t\tgen.append(i)\n\telse:\n\t\ta[k - 1].append(i)\n\ndef is_leaf(root):\n\tif a[root]:\n\t\treturn 0\n\telse:\n\t\treturn 1\n\ndef f(root):\n\tif is_leaf(root):\n\t\treturn 1\n\telse:\n\t\tret = 1\n\t\tfor v in a[root]:\n\t\t\tret = max(ret, f(v) + 1)\n\t\treturn ret\nif len(gen) == n:\n\tprint(1)\nelif len(gen) == n - 1:\n\tprint(2)\nelse:\n\tflag = 0\n\ttag = 0\n\ttag = f(flag)\n\tfor i in gen:\n\t\ts = f(i)\n\t\tif s > tag:\n\t\t\tflag = i\n\t\t\ttag = s\n\tprint(f(flag))\n",
        "slowest_solution": "n = int(input())\ngr = []\nst = []\nfor i in range(n + 1):\n\tgr.append([])\nfor i in range(n):\n\tx = int(input())\n\tif x != -1:\n\t\tgr[x].append(i + 1)\n\telse:\n\t\tst.append(i + 1)\n\ndef trav(a):\n\tdis = [-1 for x in range(n + 1)]\n\tq = []\n\tq.append(a)\n\tdis[a] = 0\n\twhile len(q) > 0:\n\t\tb = q[0]\n\t\tq.pop(0)\n\t\tfor i in range(len(gr[b])):\n\t\t\tz = gr[b][i]\n\t\t\tif dis[z] == -1:\n\t\t\t\tq.append(z)\n\t\t\t\tdis[z] = dis[b] + 1\n\tdis.sort()\n\treturn dis[len(dis) - 1]\nf = []\nfor i in range(len(st)):\n\tk = trav(st[i])\n\tf.append(k)\nf.sort(reverse=True)\nprint(f[0] + 1)\n"
    },
    {
        "task_id": 53,
        "slowest_solution_id": 1,
        "fastest_solution_id": 7,
        "slowest_time": 2.9800305366516113,
        "fastest_time": 2.582796812057495,
        "fastest_solution": "import sys\nnums = list(map(int, sys.stdin.read().split()))\nfor i in range(nums[0]):\n\tN = nums[i * 2 + 1]\n\tm = nums[i * 2 + 2]\n\ta = (N + 1) // m\n\tb = (N + 1) % m\n\tans = m * (m - 1) // 2 * a + b * (b - 1) // 2\n\tprint(ans)\n",
        "slowest_solution": "T = int(input())\nfor _ in range(T):\n\t(N, m) = [int(_) for _ in input().split()]\n\t(d, r) = divmod(N, m)\n\tprint((m - 1) * m // 2 * d + r * (r + 1) // 2)\n"
    },
    {
        "task_id": 54,
        "slowest_solution_id": 1,
        "fastest_solution_id": 6,
        "slowest_time": 2.7794315814971924,
        "fastest_time": 2.525350570678711,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tprint(pow(2, n + 1, 1000000007) + 2)\n",
        "slowest_solution": "t = int(input())\nbase = 1000000007\nwhile t > 0:\n\tt -= 1\n\tn = int(input())\n\tk = 1\n\tn += 1\n\ta = 2\n\twhile n > 0:\n\t\tif n % 2 == 1:\n\t\t\tk = k * a % base\n\t\tn //= 2\n\t\ta = a * a % base\n\tk = (k + 2) % base\n\tprint(k)\n"
    },
    {
        "task_id": 65,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.5845518112182617,
        "fastest_time": 2.5787391662597656,
        "fastest_solution": "def solve():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn = int(input())\n\t\ta = list(map(int, input().split()))\n\t\tbits = 32\n\t\tmask = 0\n\t\trearranged = []\n\t\tfor i in range(bits):\n\t\t\tbitmask = 1 << bits - 1 - i\n\t\t\tif mask & bitmask:\n\t\t\t\tcontinue\n\t\t\tbest = None\n\t\t\tfor (idx, v) in enumerate(a):\n\t\t\t\tif not v & bitmask:\n\t\t\t\t\tcontinue\n\t\t\t\tif best is None:\n\t\t\t\t\tbest = idx\n\t\t\t\t\tcontinue\n\t\t\t\tif v & (v ^ mask) > a[best] & (a[best] ^ mask):\n\t\t\t\t\tbest = idx\n\t\t\tif best is not None:\n\t\t\t\trearranged.append(a[best])\n\t\t\t\tmask |= a[best]\n\t\tfor r in rearranged:\n\t\t\ta.remove(r)\n\t\trearranged += a\n\t\tprint(' '.join(map(str, rearranged)))\nsolve()\n",
        "slowest_solution": "MAX_BITS = 32\n\ndef to_bin(dec_number):\n\treturn bin(dec_number).replace('0b', '')\n\ndef pick_best(dec_numbers, or_prefix_dec):\n\tbest_result = 0\n\tbest_dec_pick = None\n\tbest_pick_index = None\n\tfor (index, dec_number) in dec_numbers.items():\n\t\tresult = or_prefix_dec | dec_number\n\t\tif result > best_result:\n\t\t\tbest_result = result\n\t\t\tbest_dec_pick = dec_number\n\t\t\tbest_pick_index = index\n\treturn (best_dec_pick, best_pick_index)\n\ndef solve():\n\tt = int(input())\n\tfor _ in range(t):\n\t\t_ = int(input())\n\t\tdec_numbers = list(map(int, input().split()))\n\t\tdec_numbers = {index: number for (index, number) in enumerate(dec_numbers)}\n\t\tordered_numbers = list()\n\t\tor_prefix_dec = 0\n\t\tor_prefix_bin = to_bin(or_prefix_dec).zfill(MAX_BITS)\n\t\tbit_index = 0\n\t\twhile bit_index < MAX_BITS:\n\t\t\tif or_prefix_bin[bit_index] == '1':\n\t\t\t\tbit_index += 1\n\t\t\t\tcontinue\n\t\t\t(best_dec_pick, best_pick_index) = pick_best(dec_numbers, or_prefix_dec)\n\t\t\tif best_pick_index is not None:\n\t\t\t\tor_prefix_dec = or_prefix_dec | best_dec_pick\n\t\t\t\tor_prefix_bin = to_bin(or_prefix_dec).zfill(MAX_BITS)\n\t\t\t\tordered_numbers.append(best_dec_pick)\n\t\t\t\tdel dec_numbers[best_pick_index]\n\t\t\tbit_index += 1\n\t\tordered_numbers += list(dec_numbers.values())\n\t\tprint(' '.join([str(number) for number in ordered_numbers]))\nsolve()\n"
    },
    {
        "task_id": 97,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.598884344100952,
        "fastest_time": 2.598884344100952,
        "fastest_solution": "from random import randint\n\ndef solve_e(m, c, n, A):\n\tM = 998244353\n\n\tdef multiply(v):\n\t\tr = [0] * n\n\t\tfor i in range(n):\n\t\t\tfor j in range(n):\n\t\t\t\tr[i] += A[i][j] * v[j]\n\t\t\t\tr[i] %= M\n\t\treturn r\n\tv = [randint(0, M - 1) for _ in range(n)]\n\ttmp = [0 for _ in range(n)]\n\tfor i in range(m):\n\t\tfor j in range(n):\n\t\t\ttmp[j] += c[i] * v[j]\n\t\t\ttmp[j] %= M\n\t\tv = multiply(v)\n\tfor j in range(n):\n\t\tif tmp[j] != 0:\n\t\t\treturn 'NO'\n\treturn 'YES'\nT = int(input())\nif 1 <= T <= 2000:\n\tfor i in range(T):\n\t\tN = int(input())\n\t\tC = list(map(int, input().split(' ')))\n\t\tm = int(input())\n\t\tmatrix = [list(map(int, input().split(' '))) for j in range(m)]\n\t\tprint(solve_e(N, C, m, matrix))\n",
        "slowest_solution": "from random import randint\n\ndef solve_e(m, c, n, A):\n\tM = 998244353\n\n\tdef multiply(v):\n\t\tr = [0] * n\n\t\tfor i in range(n):\n\t\t\tfor j in range(n):\n\t\t\t\tr[i] += A[i][j] * v[j]\n\t\t\t\tr[i] %= M\n\t\treturn r\n\tv = [randint(0, M - 1) for _ in range(n)]\n\ttmp = [0 for _ in range(n)]\n\tfor i in range(m):\n\t\tfor j in range(n):\n\t\t\ttmp[j] += c[i] * v[j]\n\t\t\ttmp[j] %= M\n\t\tv = multiply(v)\n\tfor j in range(n):\n\t\tif tmp[j] != 0:\n\t\t\treturn 'NO'\n\treturn 'YES'\nT = int(input())\nif 1 <= T <= 2000:\n\tfor i in range(T):\n\t\tN = int(input())\n\t\tC = list(map(int, input().split(' ')))\n\t\tm = int(input())\n\t\tmatrix = [list(map(int, input().split(' '))) for j in range(m)]\n\t\tprint(solve_e(N, C, m, matrix))\n"
    },
    {
        "task_id": 98,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6109561920166016,
        "fastest_time": 2.6109561920166016,
        "fastest_solution": "def nextstate(q, x):\n\ti = 0\n\tfor i in range(len(q)):\n\t\tif q[i] & x > 0:\n\t\t\treturn q[:i] + (x,) + q[i + 1:]\n\treturn q + (x,)\nqs = [()]\ntrans = []\nptr = 0\nwhile ptr < len(qs):\n\tq = qs[ptr]\n\ttb = []\n\tfor x in range(1, 4):\n\t\tqn = nextstate(q, x)\n\t\tif qn not in qs:\n\t\t\tqs.append(qn)\n\t\ttb.append(qs.index(qn))\n\ttrans.append(tb)\n\tptr += 1\nn = int(input())\na = [int(x) for x in input().split(' ')]\ncnt = [0] * len(qs)\ncnt[0] = 1\nans = 0\nfor (i, ai) in enumerate(a):\n\tcnt2 = [0] * len(qs)\n\tcnt2[0] = 1\n\tif ai == 0:\n\t\tfor j in range(len(qs)):\n\t\t\tcnt2[j] += cnt[j]\n\t\tans += (i + 1) * (n - i)\n\telse:\n\t\tfor j in range(len(qs)):\n\t\t\tqn = trans[j][ai - 1]\n\t\t\tcnt2[qn] += cnt[j]\n\tfor j in range(len(qs)):\n\t\tans += cnt2[j] * len(qs[j])\n\tcnt = cnt2\nprint(ans)\n",
        "slowest_solution": "def nextstate(q, x):\n\ti = 0\n\tfor i in range(len(q)):\n\t\tif q[i] & x > 0:\n\t\t\treturn q[:i] + (x,) + q[i + 1:]\n\treturn q + (x,)\nqs = [()]\ntrans = []\nptr = 0\nwhile ptr < len(qs):\n\tq = qs[ptr]\n\ttb = []\n\tfor x in range(1, 4):\n\t\tqn = nextstate(q, x)\n\t\tif qn not in qs:\n\t\t\tqs.append(qn)\n\t\ttb.append(qs.index(qn))\n\ttrans.append(tb)\n\tptr += 1\nn = int(input())\na = [int(x) for x in input().split(' ')]\ncnt = [0] * len(qs)\ncnt[0] = 1\nans = 0\nfor (i, ai) in enumerate(a):\n\tcnt2 = [0] * len(qs)\n\tcnt2[0] = 1\n\tif ai == 0:\n\t\tfor j in range(len(qs)):\n\t\t\tcnt2[j] += cnt[j]\n\t\tans += (i + 1) * (n - i)\n\telse:\n\t\tfor j in range(len(qs)):\n\t\t\tqn = trans[j][ai - 1]\n\t\t\tcnt2[qn] += cnt[j]\n\tfor j in range(len(qs)):\n\t\tans += cnt2[j] * len(qs[j])\n\tcnt = cnt2\nprint(ans)\n"
    },
    {
        "task_id": 100,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6558613777160645,
        "fastest_time": 2.6558613777160645,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n\ndef main():\n\t(n, m) = map(int, input().split())\n\ta = list(map(int, input().split())) + [0] * 500000\n\tans_S = 0\n\ta[n] = a[0] + m\n\ts = [0] * 600600\n\tfor i in range(n):\n\t\ts[i] = a[i + 1] - a[i]\n\ts[n] = -1\n\tfor i in range(n):\n\t\ts[2 * n - i] = s[i]\n\tfor i in range(2 * n + 1, 3 * n + 1):\n\t\ts[i] = s[i - n]\n\t(l, r) = (0, 0)\n\tz = [0] * 600600\n\tfor i in range(1, 3 * n + 1):\n\t\tif i < r:\n\t\t\tz[i] = z[i - l]\n\t\twhile i + z[i] <= 3 * n and s[i + z[i]] == s[z[i]]:\n\t\t\tz[i] += 1\n\t\tif i + z[i] > r:\n\t\t\tl = i\n\t\t\tr = i + z[i]\n\tans = []\n\tfor i in range(n + 1, 2 * n + 1):\n\t\tif z[i] < n:\n\t\t\tcontinue\n\t\tans_S += 1\n\t\tans.append((a[0] + a[2 * n - i + 1]) % m)\n\tans.sort()\n\tprint(ans_S)\n\tprint(*ans)\n\treturn\nmain()\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef main():\n\t(n, m) = map(int, input().split())\n\ta = list(map(int, input().split())) + [0] * 500000\n\tans_S = 0\n\ta[n] = a[0] + m\n\ts = [0] * 600600\n\tfor i in range(n):\n\t\ts[i] = a[i + 1] - a[i]\n\ts[n] = -1\n\tfor i in range(n):\n\t\ts[2 * n - i] = s[i]\n\tfor i in range(2 * n + 1, 3 * n + 1):\n\t\ts[i] = s[i - n]\n\t(l, r) = (0, 0)\n\tz = [0] * 600600\n\tfor i in range(1, 3 * n + 1):\n\t\tif i < r:\n\t\t\tz[i] = z[i - l]\n\t\twhile i + z[i] <= 3 * n and s[i + z[i]] == s[z[i]]:\n\t\t\tz[i] += 1\n\t\tif i + z[i] > r:\n\t\t\tl = i\n\t\t\tr = i + z[i]\n\tans = []\n\tfor i in range(n + 1, 2 * n + 1):\n\t\tif z[i] < n:\n\t\t\tcontinue\n\t\tans_S += 1\n\t\tans.append((a[0] + a[2 * n - i + 1]) % m)\n\tans.sort()\n\tprint(ans_S)\n\tprint(*ans)\n\treturn\nmain()\n"
    },
    {
        "task_id": 58,
        "slowest_solution_id": 0,
        "fastest_solution_id": 4,
        "slowest_time": 2.7613494396209717,
        "fastest_time": 2.5751073360443115,
        "fastest_solution": "a = [input()[0] for x in range(3)]\nb = ['F', 'M', 'S']\nif a.count('r') == 1 and a.count('s') == 2 or (a.count('s') == 1 and a.count('p') == 2) or (a.count('p') == 1 and a.count('r') == 2):\n\tfor x in range(3):\n\t\tif a.count(a[x]) == 1:\n\t\t\tprint(b[x])\nelse:\n\tprint('?')\n",
        "slowest_solution": "I = lambda : int(input())\nIL = lambda : list(map(int, input().split()))\nL = [input()[0] for i in '123']\ngt = {'r': 'rp', 'p': 'ps', 's': 'sr'}\nprint('F' if L[1] not in gt[L[0]] and L[2] not in gt[L[0]] else 'M' if L[0] not in gt[L[1]] and L[2] not in gt[L[1]] else 'S' if L[0] not in gt[L[2]] and L[1] not in gt[L[2]] else '?')\n"
    },
    {
        "task_id": 105,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.6384451389312744,
        "fastest_time": 2.5932881832122803,
        "fastest_solution": "from bisect import *\nI = lambda : map(int, input().split())\nn = int(input())\na = sorted(I())\nb = sorted(I())\nsum = [0] * (n + 1)\nfor i in range(1, n + 1):\n\tsum[i] = sum[i - 1] + b[i - 1]\nans = 0\nfor i in range(n):\n\tj = bisect_right(b, a[i])\n\tans += j * a[i] - sum[j] + sum[n] - sum[j] - (n - j) * a[i] - (n - 1) * abs(a[i] - b[i])\nprint(ans)\n",
        "slowest_solution": "from bisect import *\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na.sort()\nb.sort()\nsum = [0] * (n + 1)\nfor i in range(1, n + 1):\n\tsum[i] = sum[i - 1] + b[i - 1]\nans = 0\nfor i in range(n):\n\tj = bisect_right(b, a[i])\n\tans += j * a[i] - sum[j]\n\tans += sum[n] - sum[j] - (n - j) * a[i]\n\tans -= (n - 1) * abs(a[i] - b[i])\nprint(ans)\n"
    },
    {
        "task_id": 66,
        "slowest_solution_id": 2,
        "fastest_solution_id": 1,
        "slowest_time": 6.511359691619873,
        "fastest_time": 5.83116888999939,
        "fastest_solution": "from collections import defaultdict\nimport sys\n\ndef f(n):\n\tout = 1\n\twhile n > 0:\n\t\tdigit = n % 10\n\t\tif digit != 0:\n\t\t\tout *= digit\n\t\tn = n // 10\n\treturn out\nmemorization = defaultdict(int)\n\ndef g(n):\n\tif n < 10:\n\t\treturn n\n\tf_n = f(n)\n\tif f_n in memorization:\n\t\treturn memorization[f_n]\n\telse:\n\t\tans = g(f_n)\n\t\tmemorization[f_n] = ans\n\t\treturn ans\n\ndef s(L, l, r, k):\n\tif l > r:\n\t\treturn l\n\tm = (l + r) // 2\n\tif L[m] == k:\n\t\treturn m\n\tif L[m] > k:\n\t\treturn s(L, l, m - 1, k)\n\telse:\n\t\treturn s(L, m + 1, r, k)\nans = {i: [1000001] for i in range(1, 10)}\nfor i in range(1, 1000001):\n\tg_i = g(i)\n\tif g_i != 0:\n\t\tans[g_i].append(i)\nfor i in ans:\n\tans[i].sort()\ninput = sys.stdin.readline\nn = int(input())\nfor i in range(n):\n\t(l, r, k) = [int(i) for i in input().split()]\n\t(l_idx, r_idx) = (s(ans[k], 0, len(ans[k]) - 1, l), s(ans[k], 0, len(ans[k]) - 1, r))\n\tif ans[k][l_idx] != l and ans[k][l_idx] < l and (ans[k][l_idx + 1] > l):\n\t\tl_idx += 1\n\tif ans[k][r_idx] != r and (not (ans[k][r_idx] < r and ans[k][r_idx + 1] > r)):\n\t\tr_idx -= 1\n\tprint(r_idx - l_idx + 1)\n",
        "slowest_solution": "import bisect as b\nfrom sys import stdin\ninp = stdin.readline\npre_calc = x = [[] for i in range(10)]\n\ndef get_g(num):\n\twhile num > 9:\n\t\tnew_num = 1\n\t\twhile num:\n\t\t\tdigit = num % 10\n\t\t\tif digit:\n\t\t\t\tnew_num *= digit\n\t\t\tnum //= 10\n\t\tnum = new_num\n\treturn num\nfor i in range(1, 10 ** 6 + 5):\n\tpre_calc[get_g(i)].append(i)\nq = int(inp())\nwhile q:\n\tq -= 1\n\t(l, r, x) = list(map(int, inp().split()))\n\tindex_l = b.bisect_left(pre_calc[x], l)\n\tif index_l < len(pre_calc[x]) and pre_calc[x][index_l] >= l:\n\t\tindex_l -= 1\n\tindex_r = b.bisect_left(pre_calc[x], r)\n\tif index_r < len(pre_calc[x]) and pre_calc[x][index_r] <= r:\n\t\tindex_r += 1\n\tprint(max(index_r - index_l - 1, 0))\n"
    },
    {
        "task_id": 81,
        "slowest_solution_id": 5,
        "fastest_solution_id": 3,
        "slowest_time": 2.8708369731903076,
        "fastest_time": 2.5809504985809326,
        "fastest_solution": "(a, b) = map(int, input().split(' '))\ndone = {a}\nc = 0\nwhile a != 0:\n\tc += 1\n\tif c > 2 * b:\n\t\tbreak\n\ta += a % b\n\tif a in done:\n\t\tprint('Yes')\n\t\texit()\n\tdone.add(a)\nprint('No')\n",
        "slowest_solution": "(a, m) = map(int, input().split())\nfor i in range(10 ** 6):\n\tif a % m == 0:\n\t\tprint('Yes')\n\t\texit(0)\n\telse:\n\t\ta += a % m\nprint('No')\n"
    },
    {
        "task_id": 62,
        "slowest_solution_id": 8,
        "fastest_solution_id": 4,
        "slowest_time": 2.7641570568084717,
        "fastest_time": 2.525764226913452,
        "fastest_solution": "T = int(input(''))\nwhile T > 0:\n\tN = int(input(''))\n\tno = map(int, input('').split())\n\tones = 0\n\ttwos = 0\n\trest = 0\n\tfor i in no:\n\t\tif i == 1:\n\t\t\tones += 1\n\t\telif i == 2:\n\t\t\ttwos += 1\n\t\telse:\n\t\t\trest += 1\n\tres = 0\n\tres = ones * (twos + rest) + ones * (ones - 1) + twos * (twos - 1) / 2\n\tprint(int(res))\n\tT -= 1\n",
        "slowest_solution": "t = int(input())\nfor t1 in range(t):\n\tn = int(input())\n\ta = [int(j) for j in input().strip().split()]\n\tsum = 0\n\tcount1 = 0\n\tcount2 = 0\n\tcount0 = 0\n\tfor e in a:\n\t\tif e == 1:\n\t\t\tcount1 += 1\n\t\telif e == 2:\n\t\t\tcount2 += 1\n\t\telse:\n\t\t\tcount0 += 1\n\tsum += count1 * (count1 - 1)\n\tsum += count1 * (count2 + count0)\n\tsum += count2 * (count2 - 1) // 2\n\tprint(sum)\n"
    },
    {
        "task_id": 107,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.7622783184051514,
        "fastest_time": 2.642812728881836,
        "fastest_solution": "def solve(S, A, m, n):\n\tS = list(S)\n\t(i, j) = (0, 0)\n\twhile i < m and j < n:\n\t\tif S[i] == A[j]:\n\t\t\tj += 1\n\t\telif S[i] == '?':\n\t\t\tif A[j] != 'a':\n\t\t\t\tS[i] = 'a'\n\t\t\telse:\n\t\t\t\tS[i] = 'e'\n\t\ti += 1\n\tif j < n:\n\t\treturn ''.join(S)\n\treturn -1\nt = int(input())\nfor i in range(t):\n\t(m, n) = map(int, input().split())\n\tS = input()\n\tA = input()\n\tprint(solve(S, A, m, n))\n",
        "slowest_solution": "T = int(input())\nfor _ in range(T):\n\t(m, n) = map(int, input().split())\n\ts1 = input()\n\ts2 = input()\n\ts1 = list(s1)\n\ti = 0\n\tj = 0\n\twhile i < m and j < n:\n\t\tif s1[i] == s2[j]:\n\t\t\ti += 1\n\t\t\tj += 1\n\t\telif s1[i] == '?':\n\t\t\tif s2[j] != 'a':\n\t\t\t\ts1[i] = 'a'\n\t\t\telse:\n\t\t\t\ts1[i] = 'e'\n\t\t\ti += 1\n\t\telse:\n\t\t\ti += 1\n\tif j < n:\n\t\tprint(''.join(s1))\n\telse:\n\t\tprint(-1)\n"
    },
    {
        "task_id": 63,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 2.7532615661621094,
        "fastest_time": 2.5182578563690186,
        "fastest_solution": "def Test(n, a, k):\n\tdp = [0] * n\n\tdp[0] = a[0]\n\tfor i in range(1, n):\n\t\tdp[i] = dp[i - 1] + a[i]\n\ts = [0] * k\n\tr = 0\n\tfor i in range(k):\n\t\ts[i] = dp[n - k + i] - r & 1\n\t\tr = dp[i]\n\treturn s.count(1)\nfor _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, [*input()]))\n\tprint(Test(n, a, k))\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ts = input()\n\tcount = 0\n\tif k == 1:\n\t\tcnt = s.count('1')\n\t\tif cnt % 2 == 0:\n\t\t\tprint('0')\n\t\telse:\n\t\t\tprint('1')\n\telse:\n\t\tfor i in range(n - k + 1):\n\t\t\tif s[i] == '1':\n\t\t\t\tcount += 1\n\t\tlst = []\n\t\tlst.append(count)\n\t\tp = n - k + 1\n\t\tstart = 0\n\t\twhile p < n:\n\t\t\tif s[start] == '1':\n\t\t\t\tcount = count - 1\n\t\t\tif s[p] == '1':\n\t\t\t\tcount = count + 1\n\t\t\tstart += 1\n\t\t\tp += 1\n\t\t\tlst.append(count)\n\t\tans = 0\n\t\tfor i in lst:\n\t\t\tif i % 2 != 0:\n\t\t\t\tans += 1\n\t\tprint(ans)\n"
    },
    {
        "task_id": 64,
        "slowest_solution_id": 6,
        "fastest_solution_id": 0,
        "slowest_time": 2.7401561737060547,
        "fastest_time": 2.55322265625,
        "fastest_solution": "(n, a) = (int(input()), [int(x) for x in input().split()])\nres = str('NO') if sum(a) % 2 == 1 or 2 * max(a) > sum(a) else str('YES')\nprint(res)\n",
        "slowest_solution": "import sys, os, io\n\ndef rs():\n\treturn sys.stdin.readline().rstrip()\n\ndef ri():\n\treturn int(sys.stdin.readline())\n\ndef ria():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef ws(s):\n\tsys.stdout.write(s + '\\n')\n\ndef wi(n):\n\tsys.stdout.write(str(n) + '\\n')\n\ndef wia(a):\n\tsys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math, datetime, functools, itertools, operator, bisect, fractions, statistics\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify, _heapify_max, _heappop_max\n\ndef main():\n\tstarttime = datetime.datetime.now()\n\tif os.path.exists('input.txt'):\n\t\tsys.stdin = open('input.txt', 'r')\n\t\tsys.stdout = open('output.txt', 'w')\n\tfor _ in range(1):\n\t\tn = ri()\n\t\ta = ria()\n\t\tc = sum(a)\n\t\tans = 'YES'\n\t\tfor i in a:\n\t\t\tif i > c // 2:\n\t\t\t\tans = 'NO'\n\t\t\t\tbreak\n\t\tif c % 2 == 1:\n\t\t\tans = 'NO'\n\t\tprint(ans)\n\tendtime = datetime.datetime.now()\n\ttime = (endtime - starttime).total_seconds() * 1000\n\tif os.path.exists('input.txt'):\n\t\tprint('Time:', time, 'ms')\n\nclass FastReader(io.IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, fd, chunk_size=1024 * 8):\n\t\tself._fd = fd\n\t\tself._chunk_size = chunk_size\n\t\tself.buffer = io.BytesIO()\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self, size=-1):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n\tdef __init__(self, fd):\n\t\tself._fd = fd\n\t\tself.buffer = io.BytesIO()\n\t\tself.write = self.buffer.write\n\n\tdef flush(self):\n\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass FastStdin(io.IOBase):\n\n\tdef __init__(self, fd=0):\n\t\tself.buffer = FastReader(fd)\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n\nclass FastStdout(io.IOBase):\n\n\tdef __init__(self, fd=1):\n\t\tself.buffer = FastWriter(fd)\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.flush = self.buffer.flush\nsys.stdin = FastStdin()\nsys.stdout = FastStdout()\nmain()\n"
    },
    {
        "task_id": 68,
        "slowest_solution_id": 9,
        "fastest_solution_id": 0,
        "slowest_time": 2.7762961387634277,
        "fastest_time": 2.5086324214935303,
        "fastest_solution": "import sys\nfrom collections import deque\nsys.setrecursionlimit(30000)\nsz = 3333\ncyclic = 0\nbegin = 0\nend = 0\ncycle = []\ngraph = []\nused = []\nparent = []\ndist = []\n\ndef dfs(current, prev):\n\tglobal graph, begin, end, used, parent\n\tused[current] = 1\n\tfor nxt in graph[current]:\n\t\tif used[nxt] != 2 and nxt != prev:\n\t\t\tif used[nxt] == 0:\n\t\t\t\tparent[current] = nxt\n\t\t\t\tif dfs(nxt, current):\n\t\t\t\t\treturn True\n\t\t\telif used[nxt] == 1:\n\t\t\t\tbegin = current\n\t\t\t\tend = nxt\n\t\t\t\treturn True\n\tused[current] = 2\n\treturn False\n\ndef other_dfs(graph, current, cycle_in, d):\n\tused[current] = 1\n\tglobal dist\n\tdist[current] = 0 if cycle_in[current] else d\n\td = dist[current]\n\tfor nxt in graph[current]:\n\t\tif not used[nxt]:\n\t\t\tother_dfs(graph, nxt, cycle_in, d + 1)\n\ndef main():\n\tn = int(input())\n\tglobal graph, used, parent, dist\n\tcycle = []\n\tgraph = [[] for i in range(sz)]\n\tused = [0 for i in range(sz)]\n\tparent = [0 for i in range(sz)]\n\tdist = [0 for i in range(sz)]\n\tfor i in range(n):\n\t\t(x, y) = [int(i) for i in input().split()]\n\t\tgraph[x - 1].append(y - 1)\n\t\tgraph[y - 1].append(x - 1)\n\tfor i in range(n):\n\t\tif not used[i]:\n\t\t\tif dfs(i, -1):\n\t\t\t\tbreak\n\tu = end\n\tparent[begin] = -1\n\twhile u != -1:\n\t\tcycle.append(u)\n\t\tu = parent[u]\n\tcycle_in = [False for i in range(n)]\n\tfor node in cycle:\n\t\tcycle_in[node] = True\n\tused = [0 for i in range(n)]\n\tother_dfs(graph, begin, cycle_in, 0)\n\tfor node in dist[:n]:\n\t\tprint(node, end=' ')\nmain()\n",
        "slowest_solution": "from collections import deque\n\ndef findCycle(grafo):\n\tn = len(grafo)\n\tdegree = dict()\n\tfor i in range(n):\n\t\tdegree[i] = len(grafo[i])\n\tvisited = [False for i in range(n)]\n\tq = deque()\n\twhile True:\n\t\tfor i in range(len(degree)):\n\t\t\tif degree[i] == 1 and visited[i] == False:\n\t\t\t\tq.append(i)\n\t\tif len(q) == 0:\n\t\t\tbreak\n\t\twhile q:\n\t\t\ttemp = q.popleft()\n\t\t\tvisited[temp] = True\n\t\t\tfor destino in grafo[temp]:\n\t\t\t\tdegree[destino] -= 1\n\tresult = []\n\tfor i in range(len(visited)):\n\t\tif visited[i] == False:\n\t\t\tresult.append(i)\n\treturn result\n\ndef distanciasAlCiclo(grafo, ciclo, numero_grande=float('inf')):\n\tdistancias = [numero_grande for i in range(n)]\n\tfor nodo in ciclo:\n\t\tdistancias[nodo] = 0\n\tcola = deque(ciclo)\n\twhile len(cola):\n\t\tnodo = cola.popleft()\n\t\tfor conectado in grafo[nodo]:\n\t\t\tif distancias[conectado] == numero_grande:\n\t\t\t\tdistancias[conectado] = distancias[nodo] + 1\n\t\t\t\tcola.append(conectado)\n\treturn distancias\nn = int(input())\ngrafo = [list() for i in range(n)]\nfor i in range(n):\n\t(x, y) = map(lambda z: int(z) - 1, input().split())\n\tgrafo[x].append(y)\n\tgrafo[y].append(x)\nnodos_ciclo = findCycle(grafo)\nprint(' '.join(map(str, distanciasAlCiclo(grafo, nodos_ciclo))))\n"
    },
    {
        "task_id": 70,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 2.783501148223877,
        "fastest_time": 2.545078754425049,
        "fastest_solution": "(N, L, R) = map(int, input().split())\nS = ''\nwhile N > 0:\n\tS = str(N % 2) + S\n\tN //= 2\nRAns = 0\nfor i in range(1, len(S) + 1):\n\tif R >= 2 ** (i - 1):\n\t\tRAns += 1 * int(S[i - 1])\n\t\tRAns += (R - 2 ** (i - 1)) // 2 ** i * int(S[i - 1])\nL -= 1\nLAns = 0\nfor i in range(1, len(S) + 1):\n\tif L >= 2 ** (i - 1):\n\t\tLAns += 1 * int(S[i - 1])\n\t\tLAns += (L - 2 ** (i - 1)) // 2 ** i * int(S[i - 1])\nprint(RAns - LAns)\n",
        "slowest_solution": "def cz(m):\n\tglobal ws, n\n\tif m % 2 == 1:\n\t\treturn 1\n\telse:\n\t\ts = 2\n\t\ti = 1\n\t\twhile m % (s * 2) == 0:\n\t\t\ts *= 2\n\t\t\ti += 1\n\t\ti = ws - i\n\t\tif n >> i & 1:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\nimport math\n(n, l, r) = map(int, input().split())\nif n == 0:\n\tprint(0)\nelse:\n\tws = int(math.log2(n))\n\tprint('%d' % sum((cz(i) for i in range(l, r + 1))))\n"
    },
    {
        "task_id": 69,
        "slowest_solution_id": 9,
        "fastest_solution_id": 5,
        "slowest_time": 2.8010082244873047,
        "fastest_time": 2.534097909927368,
        "fastest_solution": "p = [1000000000.0]\nd = k = v = 0\nfor i in range(int(input())):\n\ts = input()\n\tt = int(s[0])\n\tif t == 1:\n\t\tv = int(s[2:])\n\t\twhile p[-1] < v:\n\t\t\tp.pop()\n\t\t\tk += 1\n\tif t == 2:\n\t\t(k, d) = (k + d, 0)\n\tif t == 3:\n\t\tu = int(s[2:])\n\t\tif v > u:\n\t\t\tk += 1\n\t\telse:\n\t\t\tp += [u]\n\tif t == 4:\n\t\td = 0\n\tif t == 5:\n\t\tp = [1000000000.0]\n\tif t == 6:\n\t\td += 1\nprint(k)\n",
        "slowest_solution": "n = int(input())\ns = 0\nms = []\no = 1\nz = 0\nq = 0\nfor _ in range(n):\n\ta = list(map(int, input().split()))\n\tif a[0] == 1:\n\t\ts = a[1]\n\t\twhile len(ms) > 0 and ms[-1] < s:\n\t\t\tz += 1\n\t\t\tms.pop(-1)\n\telif a[0] == 2:\n\t\tif o != 1:\n\t\t\tz += 1 - o\n\t\t\to = 1\n\telif a[0] == 3:\n\t\tms.append(a[1])\n\t\twhile len(ms) > 0 and ms[-1] < s:\n\t\t\tz += 1\n\t\t\tms.pop(-1)\n\telif a[0] == 4:\n\t\to = 1\n\telif a[0] == 5:\n\t\tms = []\n\telif a[0] == 6:\n\t\to -= 1\nprint(z)\n"
    },
    {
        "task_id": 83,
        "slowest_solution_id": 8,
        "fastest_solution_id": 5,
        "slowest_time": 2.7857394218444824,
        "fastest_time": 2.5232763290405273,
        "fastest_solution": "import sys\n\ndef main():\n\tn = int(sys.stdin.readline())\n\tx = list(map(int, sys.stdin.readline().split()))\n\ty = [0] * n\n\tfor i in range(n):\n\t\ty[i] = x[i] - 1\n\tq = []\n\tq.append(0)\n\ti = 0\n\tres = [-1] * n\n\tres[0] = 0\n\twhile i < len(q):\n\t\tc = q[i]\n\t\ti += 1\n\t\tif c > 0 and res[c - 1] == -1:\n\t\t\tres[c - 1] = res[c] + 1\n\t\t\tq.append(c - 1)\n\t\tif c < n - 1 and res[c + 1] == -1:\n\t\t\tres[c + 1] = res[c] + 1\n\t\t\tq.append(c + 1)\n\t\tif res[y[c]] == -1:\n\t\t\tres[y[c]] = res[c] + 1\n\t\t\tq.append(y[c])\n\tprint(' '.join(map(str, res)))\nmain()\n",
        "slowest_solution": "from collections import Counter, OrderedDict\nfrom itertools import permutations as perm\nfrom fractions import Fraction\nfrom collections import deque\nfrom sys import stdin\nfrom bisect import *\nfrom heapq import *\nfrom math import *\ng = lambda : stdin.readline().strip()\ngl = lambda : g().split()\ngil = lambda : [int(var) for var in gl()]\ngfl = lambda : [float(var) for var in gl()]\ngcl = lambda : list(g())\ngbs = lambda : [int(var) for var in g()]\nmod = int(1000000000.0) + 7\ninf = float('inf')\n(n,) = gil()\nadj = [[] for _ in range(n + 1)]\nfor (start, end) in zip(range(1, n + 1), gil()):\n\tif end > start + 1:\n\t\tadj[start].append(end)\nfor start in range(1, n + 1):\n\tif start + 1 <= n:\n\t\tadj[start].append(start + 1)\n\tif start - 1:\n\t\tadj[start].append(start - 1)\nd = [inf] * (n + 1)\nd[1] = 0\nh = [(0, 1)]\nwhile h:\n\t(dist, node) = heappop(h)\n\tif dist != d[node]:\n\t\tcontinue\n\tfor c in adj[node]:\n\t\tif d[c] > dist + 1:\n\t\t\td[c] = dist + 1\n\t\t\theappush(h, (d[c], c))\nprint(*d[1:])\n"
    },
    {
        "task_id": 71,
        "slowest_solution_id": 7,
        "fastest_solution_id": 4,
        "slowest_time": 2.824733257293701,
        "fastest_time": 2.567643165588379,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tans = 0\n\thop = 2\n\twhile hop <= n:\n\t\tfor i in range(0, n, hop):\n\t\t\tv = arr[i] - arr[i + hop // 2]\n\t\t\tif abs(v) >= hop:\n\t\t\t\tans = -1\n\t\t\t\tbreak\n\t\t\telif v > 0:\n\t\t\t\tans += 1\n\t\thop *= 2\n\t\tif ans == -1:\n\t\t\tbreak\n\tprint(ans)\n",
        "slowest_solution": "from audioop import mul\nimport sys\n\ndef beat(arr):\n\tn_swap = 0\n\tmult = 2\n\twhile mult <= len(arr):\n\t\tfor i in range(0, len(arr), mult):\n\t\t\tif abs(arr[i] - arr[i + mult // 2]) < mult:\n\t\t\t\tif arr[i] > arr[i + mult // 2]:\n\t\t\t\t\tarr[i] = arr[i + mult // 2]\n\t\t\t\t\tn_swap += 1\n\t\t\telse:\n\t\t\t\treturn -1\n\t\tmult = mult * 2\n\treturn n_swap\nk = int(input())\nfor i in range(k):\n\tn = int(input())\n\tarr = [int(j) for j in input().split()]\n\tprint(beat(arr))\n"
    },
    {
        "task_id": 72,
        "slowest_solution_id": 7,
        "fastest_solution_id": 4,
        "slowest_time": 2.781986713409424,
        "fastest_time": 2.556710720062256,
        "fastest_solution": "a = []\nb = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\nm = 0\nn = 0\nfor i in range(3):\n\tdata = input()\n\tline = [data[0], data[1], data[2]]\n\tm += line.count('X')\n\tn += line.count('0')\n\ta.append(line)\n\tfor j in range(3):\n\t\tif a[i][j] == 'X':\n\t\t\tb[i][j] = 1\n\t\telif a[i][j] == '0':\n\t\t\tb[i][j] = -1\ntemp = []\nfor i in range(3):\n\ttemp.append(sum(b[i]))\nfor j in range(3):\n\ts = 0\n\tfor i in range(3):\n\t\ts += b[i][j]\n\ttemp.append(s)\ntemp.append(b[0][0] + b[1][1] + b[2][2])\ntemp.append(b[0][2] + b[1][1] + b[2][0])\nif m - n != 0 and m - n != 1:\n\tprint('illegal')\nelif 3 in temp and -3 in temp:\n\tprint('illegal')\nelif m - n == 0 and 3 in temp:\n\tprint('illegal')\nelif m - n == 1 and -3 in temp:\n\tprint('illegal')\nelif 3 in temp:\n\tprint('the first player won')\nelif -3 in temp:\n\tprint('the second player won')\nelif m - n == 0:\n\tprint('first')\nelif m - n == 1:\n\tif m + n == 9:\n\t\tprint('draw')\n\telse:\n\t\tprint('second')\n",
        "slowest_solution": "def has_three(x):\n\tif x[0] == x[1] == x[2]:\n\t\tif x[0] != '.':\n\t\t\treturn x[0]\n\treturn None\n\ndef count_all(a):\n\t(crosses, circles) = (0, 0)\n\tfor ai in a:\n\t\tfor aij in ai:\n\t\t\tif aij == 'X':\n\t\t\t\tcrosses += 1\n\t\t\telif aij == '0':\n\t\t\t\tcircles += 1\n\treturn (crosses, circles)\na = []\nfor i in range(3):\n\ta.append(list(input()))\n(crosses, circles) = count_all(a)\nif crosses == circles or crosses == circles + 1:\n\tto_check = [a[0], a[1], a[2], [ai[0] for ai in a], [ai[1] for ai in a], [ai[2] for ai in a], [ai[i] for (i, ai) in enumerate(a)], [ai[2 - i] for (i, ai) in enumerate(a)]]\n\tresults = [has_three(x) for x in to_check]\n\t(cnt_x, cnt_o) = (results.count('X'), results.count('0'))\n\tif cnt_x >= 1 and cnt_o == 0:\n\t\tif crosses != circles + 1:\n\t\t\tprint('illegal')\n\t\telse:\n\t\t\tprint('the first player won')\n\telif cnt_o == 1 and cnt_x == 0:\n\t\tif crosses != circles:\n\t\t\tprint('illegal')\n\t\telse:\n\t\t\tprint('the second player won')\n\telif cnt_x != 0 or cnt_o != 0:\n\t\tprint('illegal')\n\telif crosses == circles:\n\t\tprint('first')\n\telif crosses == circles + 1:\n\t\tif crosses == 5:\n\t\t\tprint('draw')\n\t\telse:\n\t\t\tprint('second')\nelse:\n\tprint('illegal')\n"
    },
    {
        "task_id": 73,
        "slowest_solution_id": 6,
        "fastest_solution_id": 0,
        "slowest_time": 2.7472128868103027,
        "fastest_time": 2.571728229522705,
        "fastest_solution": "import sys, os, io\nimport bisect\nfor _ in range(int(input())):\n\tinput()\n\t(n, m) = [int(i) for i in input().split()]\n\tu = []\n\td = []\n\ta = []\n\tfor i in range(m):\n\t\t(x, y) = [int(i) for i in input().split()]\n\t\ta.append([y, x])\n\ta.sort()\n\ttemp = 0\n\tflag = 0\n\tprev = 0\n\tprevi = 0\n\tif m % 2 == 1:\n\t\tprint('NO')\n\telse:\n\t\tfor i in range(len(a)):\n\t\t\tif temp == 0:\n\t\t\t\tprev = a[i][0]\n\t\t\t\tprevi = a[i][1]\n\t\t\t\ttemp = 1\n\t\t\telse:\n\t\t\t\tif i != len(a) - 1:\n\t\t\t\t\tif a[i][0] == a[i + 1][0]:\n\t\t\t\t\t\tflag = 1\n\t\t\t\t\t\tbreak\n\t\t\t\tif previ == a[i][1]:\n\t\t\t\t\tif (a[i][0] - prev) % 2 == 0:\n\t\t\t\t\t\tflag = 1\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\ttemp = 0\n\t\t\t\telif (a[i][0] - prev) % 2 == 1:\n\t\t\t\t\tflag = 1\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\ttemp = 0\n\t\tif flag:\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint('YES')\n",
        "slowest_solution": "ans = []\n\ndef read():\n\treturn int(input())\n\ndef readline():\n\treturn list(map(int, input().split()))\n\ndef readmore():\n\treturn map(int, input().split())\nx_test = 1\nif x_test == 0:\n\tx_test = 1\nelse:\n\tx_test = int(input())\nfor _ in range(x_test):\n\temptyline = input()\n\t(n, m) = readmore()\n\tif m % 2:\n\t\tprint('NO')\n\t\tfor i in range(m):\n\t\t\tinput()\n\t\tcontinue\n\tL = []\n\tfor i in range(m):\n\t\t(y, x) = readmore()\n\t\tL.append([x, y])\n\tL.sort()\n\tresult = 'YES'\n\tk = 1\n\tfor i in range(1, m):\n\t\tif k == 0:\n\t\t\tk = 1\n\t\t\tcontinue\n\t\tdx = L[i][0] - L[i - 1][0]\n\t\tdy = L[i][1] - L[i - 1][1]\n\t\tc1 = dx % 2\n\t\tc2 = dy % 2\n\t\tif c1 ^ c2:\n\t\t\tif i + 1 < m and L[i + 1][0] == L[i][0]:\n\t\t\t\tresult = 'NO'\n\t\t\t\tbreak\n\t\t\tk = 0\n\t\telse:\n\t\t\tresult = 'NO'\n\t\t\tbreak\n\tif k:\n\t\tresult = 'NO'\n\tprint(result)\nans = str(ans)\nlls = len(ans)\n_ans = ans[1:lls - 1].replace(', ', '\\n')\nprint(_ans)\n"
    },
    {
        "task_id": 75,
        "slowest_solution_id": 9,
        "fastest_solution_id": 4,
        "slowest_time": 2.9087753295898438,
        "fastest_time": 2.5257134437561035,
        "fastest_solution": "import sys\nn = int(input())\nc = 0\ne = 1\ns = []\nfor _ in range(2 * n):\n\tx = sys.stdin.readline().split()\n\tif len(x) == 1:\n\t\tif s:\n\t\t\tif s[-1] == e:\n\t\t\t\ts.pop()\n\t\t\telse:\n\t\t\t\tc += 1\n\t\t\t\ts = []\n\t\te += 1\n\telse:\n\t\ts += [int(x[1])]\nprint(c)\n",
        "slowest_solution": "t = int(input())\nans = 0\ncurr = 1\nlst = []\nfor i in range(2 * t):\n\ts = input().split()\n\tif s[0] == 'add':\n\t\tn = int(s[1])\n\t\tlst.append(n)\n\telse:\n\t\tif lst != []:\n\t\t\tif lst[-1] == curr:\n\t\t\t\tlst.pop()\n\t\t\telse:\n\t\t\t\tlst = []\n\t\t\t\tans += 1\n\t\tcurr += 1\nprint(ans)\n"
    },
    {
        "task_id": 109,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.8009161949157715,
        "fastest_time": 2.8009161949157715,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n(l, r) = map(int, input().split())\ndif = r - l + 1\nprint('YES')\nn = 2\nwhile 2 ** (n - 2) < dif:\n\tn += 1\nedges = []\nfor i in range(n - 2):\n\tfor j in range(i + 1, n - 1):\n\t\tif i == 0:\n\t\t\tedges.append([1, j + 1, 1])\n\t\telse:\n\t\t\tedges.append([i + 1, j + 1, 2 ** (i - 1)])\nmx = l - 1\ni = 1\nif mx == 0 or dif == 2 ** (n - 2):\n\tedges.append([1, n, mx + 1])\n\tmx += 1\n\tdif -= 1\nwhile dif:\n\tif dif % 2:\n\t\tedges.append([i + 1, n, mx])\n\t\tmx += 2 ** (i - 1)\n\tdif //= 2\n\ti += 1\nprint(n, len(edges))\nfor e in edges:\n\tprint(*e)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n(l, r) = map(int, input().split())\ndif = r - l + 1\nprint('YES')\nn = 2\nwhile 2 ** (n - 2) < dif:\n\tn += 1\nedges = []\nfor i in range(n - 2):\n\tfor j in range(i + 1, n - 1):\n\t\tif i == 0:\n\t\t\tedges.append([1, j + 1, 1])\n\t\telse:\n\t\t\tedges.append([i + 1, j + 1, 2 ** (i - 1)])\nmx = l - 1\ni = 1\nif mx == 0 or dif == 2 ** (n - 2):\n\tedges.append([1, n, mx + 1])\n\tmx += 1\n\tdif -= 1\nwhile dif:\n\tif dif % 2:\n\t\tedges.append([i + 1, n, mx])\n\t\tmx += 2 ** (i - 1)\n\tdif //= 2\n\ti += 1\nprint(n, len(edges))\nfor e in edges:\n\tprint(*e)\n"
    },
    {
        "task_id": 89,
        "slowest_solution_id": 7,
        "fastest_solution_id": 3,
        "slowest_time": 2.7055060863494873,
        "fastest_time": 2.5602738857269287,
        "fastest_solution": "T = int(input())\n\ndef main(r, c):\n\td = []\n\tfor i in range(1, r + 1):\n\t\tfor k in range(1, c + 1):\n\t\t\td.append(max(abs(i - 1) + abs(k - 1), abs(i - 1) + abs(k - c), abs(i - r) + abs(k - 1), abs(i - r) + abs(k - c)))\n\td.sort()\n\toutput = ''\n\tfor i in d:\n\t\toutput += str(i) + ' '\n\treturn output[:-1]\n\nclass case:\n\n\tdef __init__(self, Line):\n\t\ttemp = Line.split()\n\t\tself.rows = int(temp[0])\n\t\tself.col = int(temp[1])\ncases = []\nfor i in range(T):\n\tline = input()\n\tcases.append(case(line))\nfor i in range(T):\n\tprint(main(cases[i].rows, cases[i].col))\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n\t(num_rows, num_cols) = [int(x) for x in input().split()]\n\ti_center = (num_rows - 1) / 2\n\tj_center = (num_cols - 1) / 2\n\toffset = i_center + j_center\n\tdistances = [int(abs(i - i_center) + abs(j - j_center) + offset) for i in range(num_rows) for j in range(num_cols)]\n\tdistances.sort()\n\tprint(*distances)\n"
    },
    {
        "task_id": 76,
        "slowest_solution_id": 9,
        "fastest_solution_id": 4,
        "slowest_time": 2.9857630729675293,
        "fastest_time": 2.5721287727355957,
        "fastest_solution": "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tb = set()\n\tl.sort()\n\tfor i in range(len(l)):\n\t\tfor j in range(i + 1, len(l)):\n\t\t\tb.add(l[j] - l[i])\n\tprint(len(b))\n",
        "slowest_solution": "t = int(input())\nfor _ in range(0, t):\n\tn = int(input())\n\tlist1 = [int(num) for num in input().split()]\n\tc = 0\n\tbases = []\n\tfor i in range(0, len(list1) - 1):\n\t\tfor j in range(i + 1, len(list1)):\n\t\t\tdiff = list1[j] - list1[i]\n\t\t\tif diff not in bases:\n\t\t\t\tbases.append(diff)\n\t\t\t\tc += 1\n\tprint(c)\n"
    },
    {
        "task_id": 79,
        "slowest_solution_id": 9,
        "fastest_solution_id": 3,
        "slowest_time": 2.909388780593872,
        "fastest_time": 2.5483877658843994,
        "fastest_solution": "def find_boasting_students(n, scores):\n\tcount = 0\n\tfor i in range(n):\n\t\tnum_greater = 0\n\t\tnum_less_equal = 0\n\t\tfor j in range(n):\n\t\t\tif scores[j] > scores[i]:\n\t\t\t\tnum_greater += 1\n\t\t\telif scores[j] <= scores[i]:\n\t\t\t\tnum_less_equal += 1\n\t\tif num_less_equal > num_greater:\n\t\t\tcount += 1\n\treturn count\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tscores = list(map(int, input().split()))\n\tcount = find_boasting_students(n, scores)\n\tprint(count)\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tc = 0\n\tfor j in l:\n\t\ts = 0\n\t\tk = 0\n\t\tfor z in l:\n\t\t\tif z <= j:\n\t\t\t\ts += 1\n\t\t\telif z > j:\n\t\t\t\tk += 1\n\t\tif s > k:\n\t\t\tc += 1\n\tprint(c)\n"
    },
    {
        "task_id": 125,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "from math import ceil\n\ndef branch(n):\n\tif n == 1:\n\t\treturn 0\n\tl = int(ceil(n ** 0.5)) // 2\n\tn -= (2 * l - 1) ** 2 + 1\n\treturn n // (2 * l or 1)\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 110,
        "slowest_solution_id": 2,
        "fastest_solution_id": 3,
        "slowest_time": 2.760164737701416,
        "fastest_time": 2.6318633556365967,
        "fastest_solution": "from time import time\nstartTime = time()\nT = int(input())\nfor _ in range(T):\n\t(H, W) = [int(x) for x in input().split()]\n\tA = [[int(x) for x in input().split()] for row in range(H)]\n\tpeaksChosen = 0\n\tpeaksToCheck = []\n\ttilesLeft = H * W\n\twhile tilesLeft > 0:\n\t\tif len(peaksToCheck) == 0:\n\t\t\t(bestPeakHeight, bestPeakLocation) = (-1, (None, None))\n\t\t\tfor R in range(H):\n\t\t\t\tif max(A[R]) > bestPeakHeight:\n\t\t\t\t\t(bestPeakHeight, bestPeakLocation) = (max(A[R]), (R, A[R].index(max(A[R]))))\n\t\t\tpeaksToCheck.append((bestPeakLocation[0], bestPeakLocation[1], bestPeakHeight))\n\t\t\tpeaksChosen += 1\n\t\t\tA[bestPeakLocation[0]][bestPeakLocation[1]] = 0\n\t\t\ttilesLeft -= 1\n\t\twhile len(peaksToCheck) > 0:\n\t\t\t(R, C, V) = peaksToCheck.pop(0)\n\t\t\tif R != 0 and V >= A[R - 1][C] > 0:\n\t\t\t\tpeaksToCheck.append((R - 1, C, A[R - 1][C]))\n\t\t\t\tA[R - 1][C] = 0\n\t\t\t\ttilesLeft -= 1\n\t\t\tif C != W - 1 and V >= A[R][C + 1] > 0:\n\t\t\t\tpeaksToCheck.append((R, C + 1, A[R][C + 1]))\n\t\t\t\tA[R][C + 1] = 0\n\t\t\t\ttilesLeft -= 1\n\t\t\tif R != H - 1 and V >= A[R + 1][C] > 0:\n\t\t\t\tpeaksToCheck.append((R + 1, C, A[R + 1][C]))\n\t\t\t\tA[R + 1][C] = 0\n\t\t\t\ttilesLeft -= 1\n\t\t\tif C != 0 and V >= A[R][C - 1] > 0:\n\t\t\t\tpeaksToCheck.append((R, C - 1, A[R][C - 1]))\n\t\t\t\tA[R][C - 1] = 0\n\t\t\t\ttilesLeft -= 1\n\tprint(peaksChosen)\n",
        "slowest_solution": "T = int(input())\nmove = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nfor _ in range(T):\n\t(N, M) = [int(c) for c in input().strip().split()]\n\tS = []\n\tfor i in range(N):\n\t\trow = [int(c) for c in input().strip().split()]\n\t\tS.append(row)\n\tvisited = []\n\tfor i in range(N):\n\t\tvisited.append([0] * M)\n\tnbSol = 0\n\twhile True:\n\t\tmaxindex = []\n\t\tmaxrow = []\n\t\tfor i in range(N):\n\t\t\tm = max(S[i])\n\t\t\tmaxrow.append(m)\n\t\t\tmaxindex.append(S[i].index(m))\n\t\tm = max(maxrow)\n\t\tr = maxrow.index(m)\n\t\tc = maxindex[r]\n\t\tif m == -1:\n\t\t\tbreak\n\t\ttovisit = []\n\t\ttovisit.append([r, c])\n\t\twhile len(tovisit) != 0:\n\t\t\t(x, y) = tovisit.pop(0)\n\t\t\th = S[x][y]\n\t\t\tS[x][y] = -1\n\t\t\tfor (ix, iy) in move:\n\t\t\t\tnx = x + ix\n\t\t\t\tny = y + iy\n\t\t\t\tif nx >= 0 and nx < N and (ny >= 0) and (ny < M) and (visited[nx][ny] == 0) and (S[nx][ny] <= h):\n\t\t\t\t\tvisited[nx][ny] = 1\n\t\t\t\t\ttovisit.append([nx, ny])\n\t\tnbSol = nbSol + 1\n\tprint(nbSol)\n"
    },
    {
        "task_id": 85,
        "slowest_solution_id": 9,
        "fastest_solution_id": 4,
        "slowest_time": 2.8984644412994385,
        "fastest_time": 2.546226978302002,
        "fastest_solution": "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\ndict = {}\nm = 0\nfor i in arr:\n\tif i in dict:\n\t\tdict[i] += 1\n\telse:\n\t\tdict[i] = 1\n\t\tm += 1\nif m < k:\n\tprint('{0} {1}'.format(-1, -1))\nelse:\n\tr = n - 1\n\tfor i in range(n - 1, -1, -1):\n\t\tif m == k:\n\t\t\tif dict[arr[i]] == 1:\n\t\t\t\tr = i\n\t\t\t\tbreak\n\t\tif arr[i] in dict:\n\t\t\tdict[arr[i]] -= 1\n\t\t\tif dict[arr[i]] == 0:\n\t\t\t\tm -= 1\n\tl = 0\n\tfor i in range(n):\n\t\tif dict[arr[i]] == 1:\n\t\t\tl = i\n\t\t\tbreak\n\t\telse:\n\t\t\tdict[arr[i]] -= 1\n\tprint('{0} {1}'.format(l + 1, r + 1))\n",
        "slowest_solution": "def fastio():\n\timport sys\n\tfrom io import StringIO\n\tfrom atexit import register\n\tglobal input\n\tsys.stdin = StringIO(sys.stdin.read())\n\tinput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\tsys.stdout = StringIO()\n\tregister(lambda : sys.__stdout__.write(sys.stdout.getvalue()))\nfastio()\nimport sys\nsys.setrecursionlimit(5000)\nMOD = 10 ** 9 + 7\nI = lambda : list(map(int, input().split()))\n(n, k) = I()\na = I()\ns = set()\ni = 0\ns.add(a[i])\nl = 0\nr = 1\nv = [0] * 100001\nv[a[0]] += 1\nwhile r < n and len(s) < k:\n\tv[a[r]] += 1\n\ts.add(a[r])\n\tr += 1\nt = l\nwhile (v[a[t]] > 1 or a[l] != a[t]) and v[a[l]] > 1 and (l < r):\n\tv[a[l]] -= 1\n\tl += 1\nif len(s) < k:\n\tprint(-1, -1)\nelse:\n\tprint(l + 1, r)\n"
    },
    {
        "task_id": 133,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "BINGO = {ord(c) - 64 for c in 'BINGO'}\n\ndef bingo(lst):\n\treturn 'WIN' if set(lst) >= BINGO else 'LOSE'\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 86,
        "slowest_solution_id": 8,
        "fastest_solution_id": 9,
        "slowest_time": 2.821063995361328,
        "fastest_time": 2.461641311645508,
        "fastest_solution": "import numpy as np\nfor _ in range(int(input())):\n\tn = int(input()) - 1\n\tsoldiers = [int(j) for j in input().split()]\n\tforce = int(input())\n\tattacks = np.zeros(2 * n, dtype=int)\n\tattacks[:n] = np.array(soldiers)\n\tattacks[n:2 * n] = attacks[:n]\n\tshield = [0 for _ in range(n)]\n\tpow_of_2 = 1\n\twhile n // pow_of_2 > 0:\n\t\tpow_of_2 *= 2\n\tsoldier_of_attack = (2 * n - pow_of_2) % n\n\tpow_of_2 = attacks[soldier_of_attack] > force\n\tfor i in range(n):\n\t\tif attacks[i] > force:\n\t\t\tshield[i] = 10 ** 11\n\t\telif n == 1:\n\t\t\tshield[i] = force\n\t\telif pow_of_2:\n\t\t\tshield[i] = force\n\t\t\tnum_of_survivors = n\n\t\t\tsoldiers = list(attacks[i:i + n])\n\t\t\tstarting_soldier = (n - i) % n\n\t\t\tif (num_of_survivors - starting_soldier) % 2 == 1:\n\t\t\t\tshield[i] += soldiers[-1]\n\t\t\tsoldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n\t\t\tnum_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n\t\t\tif num_of_survivors > 1:\n\t\t\t\tpow_2 = 1\n\t\t\t\twhile True:\n\t\t\t\t\tattacker = num_of_survivors - num_of_survivors % pow_2\n\t\t\t\t\tpow_2 *= 2\n\t\t\t\t\tif attacker == 0:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif attacker % pow_2 == 0:\n\t\t\t\t\t\tshield[i] += soldiers[attacker]\n\t\telif i == soldier_of_attack:\n\t\t\tshield[i] = force\n\t\telse:\n\t\t\tshield[i] = force + 1\n\tshield_needed = min(shield)\n\tif shield_needed == 10 ** 11:\n\t\tprint('impossible')\n\telse:\n\t\tprint('possible')\n\t\tfor i in range(n):\n\t\t\tif shield[i] == shield_needed:\n\t\t\t\tprint(str(i + 1) + ' ' + str(shield_needed))\n\t\t\t\tbreak\n",
        "slowest_solution": "def main():\n\tfor _ in range(int(input())):\n\t\tn = int(input())\n\t\ta = list(map(int, input().split()))\n\t\tf = int(input())\n\t\tidxs = []\n\t\ti = 0\n\t\twhile i < n - 1:\n\t\t\tif a[i] <= f:\n\t\t\t\tidxs.append(i)\n\t\t\ti += 1\n\t\tif len(idxs) == 0:\n\t\t\tprint('impossible')\n\t\t\tcontinue\n\t\tmn = 1000000000\n\t\tfor k in idxs:\n\t\t\tleft = k\n\t\t\tpts = 0\n\t\t\telm = left - 1\n\t\t\tright = n - 1 - left\n\t\t\tlast = n - 2\n\t\t\tsub = a[elm]\n\t\t\tsleft = 1\n\t\t\tslast = 1\n\t\t\twhile left > 0:\n\t\t\t\tif left % 2 == 0:\n\t\t\t\t\telm -= sleft\n\t\t\t\t\tsub = a[elm]\n\t\t\t\t\tleft = left // 2\n\t\t\t\t\tsleft *= 2\n\t\t\t\telse:\n\t\t\t\t\tpts += a[elm]\n\t\t\t\t\tleft = (left + 1) // 2\n\t\t\t\t\tsleft *= 2\n\t\t\t\tif right % 2 == 0:\n\t\t\t\t\tlast -= slast\n\t\t\t\t\tright //= 2\n\t\t\t\t\tslast *= 2\n\t\t\t\telse:\n\t\t\t\t\tslast *= 2\n\t\t\t\t\tleft -= 1\n\t\t\t\t\tright = (right + 1) // 2\n\t\t\twhile right > 2:\n\t\t\t\tif right % 2 == 0:\n\t\t\t\t\tlast -= slast\n\t\t\t\t\tsub = a[last]\n\t\t\t\t\tright = right // 2\n\t\t\t\t\tslast *= 2\n\t\t\t\telse:\n\t\t\t\t\tslast *= 2\n\t\t\t\t\tsub = a[last]\n\t\t\t\t\tpts += sub\n\t\t\t\t\tright = (right + 1) // 2\n\t\t\tif mn > pts:\n\t\t\t\tmn = pts\n\t\t\t\tidx = k\n\t\t\t\tif pts == 0:\n\t\t\t\t\tbreak\n\t\tprint('possible')\n\t\tprint(idx + 1, mn + f)\nmain()\n"
    },
    {
        "task_id": 88,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 2.882998466491699,
        "fastest_time": 2.5760715007781982,
        "fastest_solution": "def lis(arr):\n\tif len(arr) == 0:\n\t\treturn 0\n\tl = [arr[0]]\n\tfor element in arr[1:]:\n\t\t(left, right) = (-1, len(l))\n\t\twhile right - left > 1:\n\t\t\tmid = (left + right) // 2\n\t\t\tif k * l[mid] + b <= element:\n\t\t\t\tleft = mid\n\t\t\telse:\n\t\t\t\tright = mid\n\t\tif right == len(l):\n\t\t\tl.append(element)\n\t\telse:\n\t\t\tl[right] = min(l[right], element)\n\treturn len(l)\nfor _ in range(int(input())):\n\t(N, k, b) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\ta.sort()\n\tprint(lis(a))\n",
        "slowest_solution": "for i in range(int(input())):\n\t(n, k, b) = map(int, input().split())\n\tA = list(map(int, input().split()))\n\tA.sort()\n\tc = k * A[0] + b\n\tx = 1\n\tfor i in range(1, n):\n\t\tif A[i] >= c:\n\t\t\tx += 1\n\t\t\tc = k * A[i] + b\n\tprint(x)\n"
    },
    {
        "task_id": 90,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 2.798766851425171,
        "fastest_time": 2.49043345451355,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nn = int(input())\np = list(map(int, input().split()))\nflag = [1] * n\nr = n - 1\ncnt = 0\nprint(1, end=' ')\nfor i in range(n - 1):\n\tflag[p[i] - 1] = 0\n\twhile flag[r] == 0:\n\t\tr -= 1\n\t\tcnt += 1\n\tprint(i + 2 - cnt, end=' ')\nprint(1)\n",
        "slowest_solution": "n = int(input())\nl = [int(i) for i in input().split()]\nprint(1, end=' ')\nl1 = []\nend = n - 1\nfor i in range(n):\n\tl1.append(0)\nans = 1\nfor i in range(n - 1):\n\tl1[l[i] - 1] = 1\n\tif l[i] - 1 != end:\n\t\tans += 1\n\t\tprint(ans, end=' ')\n\telse:\n\t\tfor j in range(l[i] - 2, -1, -1):\n\t\t\tif l1[j] != 1:\n\t\t\t\tans -= end - j - 1\n\t\t\t\tend = j\n\t\t\t\tbreak\n\t\tprint(ans, end=' ')\nprint(1)\n"
    },
    {
        "task_id": 117,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.7952611446380615,
        "fastest_time": 2.6778807640075684,
        "fastest_solution": "from bisect import *\nfrom math import *\nn = int(input())\n(a, b, c, d) = list(map(int, input().replace('/', ' ').split()))\nalpha = atan2(c, d) - atan2(a, b)\ntan_alpha = tan(alpha)\nlis = []\nfor (x, y) in sorted(((y / tan_alpha - x, y) for (x, y) in [(x, y) for (x, y) in [(b * x + a * y, -a * x + b * y) for (x, y) in [list(map(int, input().split())) for _ in range(n)] if a * x - b * y <= 0 and d * y - c * x <= 0]])):\n\tpos = bisect_left(lis, -y)\n\tif pos == len(lis):\n\t\tlis.append(-y)\n\telse:\n\t\tlis[pos] = -y\nprint(len(lis))\n",
        "slowest_solution": "import bisect\n\ndef INPUT():\n\tglobal n, a, b, c, d\n\tn = int(input())\n\t(a, b, c, d) = [int(j) for i in input().split() for j in i.split('/')]\n\tglobal y_alpha\n\ty_alpha = []\n\tfor _ in range(n):\n\t\t(x, y) = [int(x) for x in input().split()]\n\t\ty_alpha.append((b * y - a * x, c * x - d * y))\nINPUT()\ny_alpha = sorted([(x, y) for (x, y) in y_alpha if x > 0 and y > 0], key=lambda x: (x[0], -x[1]))\ndp = []\nfor (x, y) in y_alpha:\n\ti = bisect.bisect_left(dp, y)\n\tif i == len(dp):\n\t\tdp.append(y)\n\telse:\n\t\tdp[i] = y\nprint(len(dp))\n"
    },
    {
        "task_id": 92,
        "slowest_solution_id": 8,
        "fastest_solution_id": 2,
        "slowest_time": 2.912626028060913,
        "fastest_time": 2.580109119415283,
        "fastest_solution": "from collections import defaultdict\n\ndef solve(tree):\n\tsummation = 1\n\tto_count = [1]\n\twhile to_count != []:\n\t\ttemp = []\n\t\tfor i in to_count:\n\t\t\ttemp += tree[i]\n\t\tsummation += len(temp) % 2\n\t\tto_count = temp\n\treturn summation\nnum = int(input().strip())\ntree = defaultdict(list)\nfor (index, parent) in enumerate(input().strip().split(), 2):\n\ttree[int(parent)].append(index)\nprint(solve(tree))\n",
        "slowest_solution": "n = int(input())\nle = [0] * (n + 1)\nle[1] = 1\nl = [int(x) for x in input().split()]\nfor i in range(len(l)):\n\tle[i + 2] = le[l[i]] + 1\nf = [0] * (n + 1)\nfor ele in le:\n\tf[ele] += 1\nans = 0\nfor ele in f:\n\tif ele % 2 == 1:\n\t\tans += 1\nprint(ans - 1)\n"
    },
    {
        "task_id": 94,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 2.936415433883667,
        "fastest_time": 2.5404181480407715,
        "fastest_solution": "import sys\nimport collections\nimport bisect\nimport math\nfrom functools import lru_cache\nsys.setrecursionlimit(10 ** 6)\n\ndef helper(arr, n, k):\n\tmydict = dict()\n\tsum = 0\n\tmaxLen = 0\n\tfor i in range(n):\n\t\tsum += arr[i]\n\t\tif sum == k:\n\t\t\tmaxLen = i + 1\n\t\telif sum - k in mydict:\n\t\t\tmaxLen = max(maxLen, i - mydict[sum - k])\n\t\tif sum not in mydict:\n\t\t\tmydict[sum] = i\n\treturn maxLen\nfor _ in range(int(input())):\n\t(n, k) = list(map(int, sys.stdin.readline().split()))\n\tarr = list(map(int, sys.stdin.readline().split()))\n\ts = sum(arr)\n\tif s < k:\n\t\tprint(-1)\n\telif s == k:\n\t\tprint(0)\n\telse:\n\t\tmaxLen = helper(arr, n, k)\n\t\tprint(n - maxLen)\n",
        "slowest_solution": "def solve():\n\t(n, s) = map(int, input().split())\n\tlis = list(map(int, input().split()))\n\tans = -1\n\tstart = 0\n\tsum = 0\n\tfor i in range(n):\n\t\tsum += lis[i]\n\t\twhile sum > s:\n\t\t\tsum -= lis[start]\n\t\t\tstart += 1\n\t\tif sum == s:\n\t\t\tans = max(ans, i - start + 1)\n\tprint(ans if ans == -1 else n - ans)\nfor _ in range(int(input())):\n\tsolve()\n"
    },
    {
        "task_id": 135,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7720415592193604,
        "fastest_time": 2.7720415592193604,
        "fastest_solution": "import bisect\nimport itertools\n\nclass Main:\n\n\tdef __init__(self):\n\t\titerable = self.__standard()\n\t\tself.__solution(iterable)\n\n\tdef __solution(self, iterable):\n\t\t(cases,) = map(int, next(iterable).split())\n\t\tfor _test in range(cases):\n\t\t\t(total,) = map(int, next(iterable).split())\n\t\t\tgirl = map(int, next(iterable).split())\n\t\t\tboy = map(int, next(iterable).split())\n\t\t\tkisses = self.__kisses(girl, boy)\n\t\t\tprint('{:.6f}'.format(kisses / total))\n\n\tdef __kisses(self, girl, boy):\n\t\tgirl = sorted(girl)\n\t\tboy = sorted(boy)\n\t\tkisses = 0\n\t\tfor (x, group) in itertools.groupby(girl):\n\t\t\tcount = 0\n\t\t\tfor _item in group:\n\t\t\t\tcount += 1\n\t\t\tcurrent = 0\n\t\t\tif x == 1:\n\t\t\t\tpass\n\t\t\telif x == 2:\n\t\t\t\tcurrent += bisect.bisect_right(boy, 1)\n\t\t\t\tcurrent += len(boy) - bisect.bisect_left(boy, 5)\n\t\t\telif x == 3:\n\t\t\t\tcurrent += bisect.bisect_right(boy, 2)\n\t\t\t\tcurrent += len(boy) - bisect.bisect_left(boy, 4)\n\t\t\telse:\n\t\t\t\tcurrent += bisect.bisect_right(boy, 1)\n\t\t\t\tcurrent += len(boy) - bisect.bisect_right(boy, x)\n\t\t\tkisses += count * current\n\t\treturn kisses\n\n\tdef __test(self):\n\t\tyield '3'\n\t\tyield '1'\n\t\tyield '3'\n\t\tyield '4'\n\t\tyield '2'\n\t\tyield '2 3'\n\t\tyield '1 4'\n\t\tyield '2'\n\t\tyield '2 4'\n\t\tyield '2 2'\n\n\tdef __standard(self):\n\t\ttry:\n\t\t\twhile True:\n\t\t\t\tyield input()\n\t\texcept EOFError:\n\t\t\tpass\nMain()\n",
        "slowest_solution": "import bisect\nimport itertools\n\nclass Main:\n\n\tdef __init__(self):\n\t\titerable = self.__standard()\n\t\tself.__solution(iterable)\n\n\tdef __solution(self, iterable):\n\t\t(cases,) = map(int, next(iterable).split())\n\t\tfor _test in range(cases):\n\t\t\t(total,) = map(int, next(iterable).split())\n\t\t\tgirl = map(int, next(iterable).split())\n\t\t\tboy = map(int, next(iterable).split())\n\t\t\tkisses = self.__kisses(girl, boy)\n\t\t\tprint('{:.6f}'.format(kisses / total))\n\n\tdef __kisses(self, girl, boy):\n\t\tgirl = sorted(girl)\n\t\tboy = sorted(boy)\n\t\tkisses = 0\n\t\tfor (x, group) in itertools.groupby(girl):\n\t\t\tcount = 0\n\t\t\tfor _item in group:\n\t\t\t\tcount += 1\n\t\t\tcurrent = 0\n\t\t\tif x == 1:\n\t\t\t\tpass\n\t\t\telif x == 2:\n\t\t\t\tcurrent += bisect.bisect_right(boy, 1)\n\t\t\t\tcurrent += len(boy) - bisect.bisect_left(boy, 5)\n\t\t\telif x == 3:\n\t\t\t\tcurrent += bisect.bisect_right(boy, 2)\n\t\t\t\tcurrent += len(boy) - bisect.bisect_left(boy, 4)\n\t\t\telse:\n\t\t\t\tcurrent += bisect.bisect_right(boy, 1)\n\t\t\t\tcurrent += len(boy) - bisect.bisect_right(boy, x)\n\t\t\tkisses += count * current\n\t\treturn kisses\n\n\tdef __test(self):\n\t\tyield '3'\n\t\tyield '1'\n\t\tyield '3'\n\t\tyield '4'\n\t\tyield '2'\n\t\tyield '2 3'\n\t\tyield '1 4'\n\t\tyield '2'\n\t\tyield '2 4'\n\t\tyield '2 2'\n\n\tdef __standard(self):\n\t\ttry:\n\t\t\twhile True:\n\t\t\t\tyield input()\n\t\texcept EOFError:\n\t\t\tpass\nMain()\n"
    },
    {
        "task_id": 96,
        "slowest_solution_id": 8,
        "fastest_solution_id": 7,
        "slowest_time": 3.0817666053771973,
        "fastest_time": 2.4865992069244385,
        "fastest_solution": "import bisect\n\nclass BIT:\n\n\tdef __init__(self, node_size):\n\t\tself._node = node_size + 1\n\t\tself.bit = [0] * self._node\n\n\tdef add(self, index, add_val):\n\t\twhile index < self._node:\n\t\t\tself.bit[index] += add_val\n\t\t\tindex += index & -index\n\n\tdef sum(self, index):\n\t\tres = 0\n\t\twhile index > 0:\n\t\t\tres += self.bit[index]\n\t\t\tindex -= index & -index\n\t\treturn res\n(n, t) = map(int, input().split())\na = list(map(int, input().split()))\nru = [0] * (n + 1)\nans = 0\nfor i in range(1, n + 1):\n\tru[i] = ru[i - 1] + a[i - 1]\nrus = sorted(ru)\nbit = BIT(n + 2)\nfor i in range(n + 1):\n\tru[i] = bisect.bisect_left(rus, ru[i])\nfor i in range(n + 1):\n\tind = bisect.bisect_left(rus, rus[ru[i]] - t + 1)\n\tans += bit.sum(n + 2) - bit.sum(ind)\n\tbit.add(ru[i] + 1, 1)\nprint(ans)\n",
        "slowest_solution": "class segmentTree:\n\tinitValue = 0\n\tdat = []\n\tlenTreeLeaf = -1\n\tdepthTreeList = 0\n\tlenOriginalList = -1\n\tfunc = None\n\tfuncPropagateToChild = None\n\tlazy = None\n\tN = -1\n\n\tdef load(self, l):\n\t\tself.N = len(l)\n\t\tself.lenOriginalList = self.N\n\t\tself.depthTreeList = (self.N - 1).bit_length()\n\t\tself.lenTreeLeaf = 2 ** self.depthTreeList\n\t\tself.dat = [self.initValue] * (self.lenTreeLeaf * 2)\n\t\tself.lazy = [self.initValue] * (self.lenTreeLeaf * 2)\n\t\tfor i in range(len(l)):\n\t\t\tself.dat[self.lenTreeLeaf - 1 + i] = l[i]\n\t\tself.build()\n\n\tdef build(self):\n\t\tfor i in range(self.lenTreeLeaf - 2, -1, -1):\n\t\t\tself.dat[i] = self.func(self.dat[2 * i + 1], self.dat[2 * i + 2])\n\n\tdef addValue(self, ind, value):\n\t\tnodeId = self.lenTreeLeaf - 1 + ind\n\t\tself.dat[nodeId] += value\n\t\tself.setValue(ind, self.dat[nodeId])\n\n\tdef setValue(self, ind, value):\n\t\tnodeId = self.lenTreeLeaf - 1 + ind\n\t\tself.dat[nodeId] = value\n\t\twhile nodeId != 0:\n\t\t\tnodeId = (nodeId - 1) // 2\n\t\t\tself.dat[nodeId] = self.func(self.dat[nodeId * 2 + 1], self.dat[nodeId * 2 + 2])\n\n\tdef nodelistFromLR(self, l, r, withchild=False):\n\t\tL = l + self.lenTreeLeaf >> 1\n\t\tR = r + self.lenTreeLeaf >> 1\n\t\tlc = 0 if l & 1 else (L & -L).bit_length()\n\t\trc = 0 if r & 1 else (R & -R).bit_length()\n\t\tres = []\n\t\tfor i in range(self.depthTreeList + (1 if withchild else 0)):\n\t\t\tif rc <= i:\n\t\t\t\tres.append(R - 1)\n\t\t\tif L < R and lc <= i:\n\t\t\t\tres.append(L - 1)\n\t\t\tL = L >> 1\n\t\t\tR = R >> 1\n\t\treturn res\n\n\tdef rangeAdd(self, l, r, x):\n\t\tplist = self.nodelistFromLR(l, r)\n\t\tself.propagete(plist)\n\t\tL = self.lenTreeLeaf + l\n\t\tR = self.lenTreeLeaf + r\n\t\tvalue = x\n\t\twhile L < R:\n\t\t\tif R & 1:\n\t\t\t\tR -= 1\n\t\t\t\tself.lazy[R - 1] = self.func(self.lazy[R - 1], value)\n\t\t\t\tself.dat[R - 1] = self.func(self.dat[R - 1], value)\n\t\t\tif L & 1:\n\t\t\t\tself.lazy[L - 1] = self.func(self.lazy[L - 1], value)\n\t\t\t\tself.dat[L - 1] = self.func(self.dat[L - 1], value)\n\t\t\t\tL += 1\n\t\t\tL = L >> 1\n\t\t\tR = R >> 1\n\t\t\tvalue = self.funcRangePropagetToParent(value)\n\t\tfor node in plist:\n\t\t\tself.dat[node] = self.func(self.dat[2 * node + 1], self.dat[2 * node + 2])\n\n\tdef propagete(self, plist):\n\t\tfor nodeId in plist[::-1]:\n\t\t\tif self.lazy[nodeId] == self.initValue:\n\t\t\t\tcontinue\n\t\t\tif nodeId < self.lenTreeLeaf - 1:\n\t\t\t\tpropageteValue = self.funcPropagateToChild(self.lazy[nodeId])\n\t\t\t\tself.lazy[2 * nodeId + 1] = self.func(self.lazy[2 * nodeId + 1], propageteValue)\n\t\t\t\tself.lazy[2 * nodeId + 2] = self.func(self.lazy[2 * nodeId + 2], propageteValue)\n\t\t\t\tself.dat[2 * nodeId + 1] = self.func(self.dat[2 * nodeId + 1], propageteValue)\n\t\t\t\tself.dat[2 * nodeId + 2] = self.func(self.dat[2 * nodeId + 2], propageteValue)\n\t\t\telse:\n\t\t\t\tpass\n\t\t\tself.lazy[nodeId] = self.initValue\n\n\tdef query(self, l, r):\n\t\tplist = self.nodelistFromLR(l, r)\n\t\tself.propagete(plist)\n\t\tL = self.lenTreeLeaf + l\n\t\tR = self.lenTreeLeaf + r\n\t\tview = []\n\t\tres = self.initValue\n\t\twhile L < R:\n\t\t\tif R & 1:\n\t\t\t\tR -= 1\n\t\t\t\tres = self.func(res, self.dat[R - 1])\n\t\t\tif L & 1:\n\t\t\t\tres = self.func(res, self.dat[L - 1])\n\t\t\t\tL += 1\n\t\t\tL = L >> 1\n\t\t\tR = R >> 1\n\t\treturn res\n\n\tdef findNthValueSub(self, x, nodeId):\n\t\tif self.dat[nodeId] < x:\n\t\t\treturn (None, x - self.dat[nodeId])\n\t\tif nodeId >= self.lenTreeLeaf - 1:\n\t\t\treturn (True, nodeId - (self.lenTreeLeaf - 1))\n\t\tresLeft = self.findNthValueSub(x, 2 * nodeId + 1)\n\t\tif resLeft[0] != None:\n\t\t\treturn (True, resLeft[1])\n\t\tresRight = self.findNthValueSub(resLeft[1], 2 * nodeId + 2)\n\t\treturn resRight\n\n\tdef findNthValue(self, x):\n\t\treturn self.findNthValueSub(x, 0)[1]\n\nclass segmentTreeSum(segmentTree):\n\n\tdef __init__(self):\n\t\tself.func = lambda x, y: x + y\n\t\tself.funcPropagateToChild = lambda parentValue: parentValue >> 1\n\t\tself.funcRangePropagetToParent = lambda currentValue: currentValue << 1\n\t\tself.initValue = 0\n\nclass segmentTreeMin(segmentTree):\n\n\tdef __init__(self):\n\t\tself.func = lambda x, y: min(x, y)\n\t\tself.funcPropagateToChild = lambda parentValue: parentValue\n\t\tself.funcRangePropagetToParent = lambda currentValue: currentValue\n\t\tself.initValue = 2 * 10 ** 9\nimport sys\nimport sys\n\ndef do():\n\tst = segmentTreeSum()\n\t(n, t) = map(int, input().split())\n\tdat = list(map(int, input().split()))\n\tdattotal = []\n\ttotal = 0\n\tsegtreeList = [0] * (200000 + 10)\n\tzatsu = set()\n\tfor x in dat:\n\t\ttotal += x\n\t\tdattotal.append(total)\n\t\tzatsu.add(total)\n\tzatsu = list(zatsu)\n\tzatsu.sort()\n\tzatsuTable = dict()\n\tzatsuTableRev = dict()\n\tfor (ind, val) in enumerate(zatsu):\n\t\tzatsuTable[val] = ind\n\t\tzatsuTableRev[ind] = val\n\tbuf = []\n\tfor x in dattotal:\n\t\tbuf.append(zatsuTable[x])\n\t\tsegtreeList[zatsuTable[x]] += 1\n\tst.load(segtreeList)\n\tfrom bisect import bisect_left, bisect_right\n\toffset = 0\n\tres = 0\n\tfor i in range(n):\n\t\tx = dattotal[i]\n\t\tcurvalind = zatsuTable[x]\n\t\ttargetval = t + offset\n\t\ttargetind = bisect_left(zatsu, targetval)\n\t\tcnt = st.query(0, targetind)\n\t\tres += cnt\n\t\tst.addValue(curvalind, -1)\n\t\toffset += dat[i]\n\tprint(res)\ndo()\n"
    },
    {
        "task_id": 101,
        "slowest_solution_id": 5,
        "fastest_solution_id": 1,
        "slowest_time": 2.7658543586730957,
        "fastest_time": 2.523808479309082,
        "fastest_solution": "def main():\n\tread = lambda : map(int, input().split())\n\t(n, m, k) = read()\n\t(x, s) = read()\n\ta = list(read())\n\tb = list(read())\n\tc = list(read())\n\td = list(read())\n\tans = n * x\n\tif min(b) <= s:\n\t\tMin2 = min((a[i] for i in range(m) if b[i] <= s))\n\t\tans = min(ans, n * Min2)\n\tb = sorted([(b[i], i) for i in range(m)])\n\tj = 0\n\tMin = x\n\tfor i in range(k - 1, -1, -1):\n\t\twhile j < m and b[j][0] + d[i] <= s:\n\t\t\tMin = min(Min, a[b[j][1]])\n\t\t\tj += 1\n\t\tif d[i] > s:\n\t\t\tcontinue\n\t\tcur = (n - c[i]) * Min\n\t\tans = min(ans, cur)\n\tprint(ans)\nmain()\n",
        "slowest_solution": "import bisect\n(n, m, k) = map(int, input().split(' '))\n(x, s) = map(int, input().split(' '))\na = list(map(int, input().split(' ')))\nb = list(map(int, input().split(' ')))\nc = list(map(int, input().split(' ')))\nd = list(map(int, input().split(' ')))\na.append(x)\nb.append(0)\nans = n * x\nfor i in range(m + 1):\n\tif b[i] <= s:\n\t\tj = bisect.bisect_right(d, s - b[i])\n\t\tif j > 0:\n\t\t\tj -= 1\n\t\t\tans = min(ans, (n - c[j]) * a[i])\n\t\telse:\n\t\t\tans = min(ans, n * a[i])\nprint(ans)\n"
    },
    {
        "task_id": 108,
        "slowest_solution_id": 7,
        "fastest_solution_id": 8,
        "slowest_time": 2.8361685276031494,
        "fastest_time": 2.6122376918792725,
        "fastest_solution": "import os\nimport sys\nfrom math import ceil, pow\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef main():\n\tfor _ in range(int(input())):\n\t\t(a, b) = map(int, input().split())\n\t\tif a * b == ceil(pow(a * b, 1 / 3)) ** 3:\n\t\t\ttemp = ceil(pow(a * b, 1 / 3))\n\t\t\tif a % temp == b % temp == 0:\n\t\t\t\tprint('Yes')\n\t\t\t\tcontinue\n\t\tprint('No')\nmain()\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef RL():\n\treturn map(int, sys.stdin.readline().rstrip().split())\n\ndef RLL():\n\treturn list(map(int, sys.stdin.readline().rstrip().split()))\n\ndef N():\n\treturn int(input())\n\ndef comb(n, m):\n\treturn factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\n\ndef perm(n, m):\n\treturn factorial(n) // factorial(n - m) if n >= m else 0\n\ndef mdis(x1, y1, x2, y2):\n\treturn abs(x1 - x2) + abs(y1 - y2)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\nfrom math import pow\n\ndef main():\n\tfor _ in range(N()):\n\t\t(a, b) = RL()\n\t\tmt = a * b\n\t\tres = round(pow(mt, 1 / 3))\n\t\tif res ** 3 == mt and a % res == 0 and (b % res == 0):\n\t\t\tprint('Yes')\n\t\telse:\n\t\t\tprint('No')\nmain()\n"
    },
    {
        "task_id": 102,
        "slowest_solution_id": 6,
        "fastest_solution_id": 0,
        "slowest_time": 2.8257253170013428,
        "fastest_time": 2.563082218170166,
        "fastest_solution": "from math import gcd\nT = int(input())\nfor i in range(T):\n\tn = int(input())\n\tg = [set() for _ in range(n)]\n\tfor j in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tu -= 1\n\t\tv -= 1\n\t\tg[u].add(v)\n\t\tg[v].add(u)\n\tweight = list(map(int, input().split()))\n\tmod = list(map(int, input().split()))\n\tans = [None] * n\n\n\tdef dfs(node, v, p=None):\n\t\tf = 0\n\t\tfor i in g[node]:\n\t\t\tif i != p:\n\t\t\t\tdfs(i, gcd(v, weight[i]), node)\n\t\t\t\tf = 1\n\t\tif f == 0:\n\t\t\tans[node] = mod[node] - gcd(v, mod[node])\n\tdfs(0, weight[0])\n\tprint(' '.join(map(str, [i for i in ans if i != None])))\n",
        "slowest_solution": "import sys\nsys.setrecursionlimit(10 ** 8)\nmod = 1000000007\nget_arr = lambda : list(map(int, input().split()))\nget_int = lambda : int(input())\nget_ints = lambda : map(int, input().split())\nget_str = lambda : input()\nget_strs = lambda : input().split()\nfrom math import gcd\n\ndef fn(root, leafs, d, vis, g):\n\tvis[root] = True\n\tisLeaf = True\n\tfor i in d[root]:\n\t\tif vis[i] == False:\n\t\t\tisLeaf = False\n\t\t\tif g == None:\n\t\t\t\tfn(i, leafs, d, vis, A[root])\n\t\t\telse:\n\t\t\t\tfn(i, leafs, d, vis, gcd(g, A[root]))\n\tif isLeaf:\n\t\tleafs.append([root, gcd(g, A[root])])\nfor _ in range(get_int()):\n\tn = get_int()\n\td = {}\n\tfor i in range(1, n + 1):\n\t\td[i] = []\n\tfor i in range(n - 1):\n\t\t(u, v) = get_ints()\n\t\td[u] += [v]\n\t\td[v] += [u]\n\tA = [None] + get_arr()\n\tmods = [None] + get_arr()\n\tvis = [False] * (n + 1)\n\tleafs = []\n\tfn(1, leafs, d, vis, None)\n\tleafs = sorted(leafs)\n\tfor i in leafs:\n\t\t(a, b) = (i[1], mods[i[0]])\n\t\tx = gcd(a, b)\n\t\tprint((b // x - 1) * x, end=' ')\n\tprint()\n"
    },
    {
        "task_id": 103,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 2.9467732906341553,
        "fastest_time": 2.5117080211639404,
        "fastest_solution": "R = lambda : list(map(int, input().split()))\n\ndef dfs(a):\n\tcnt = 0\n\tn = len(a)\n\ta.append(10000000)\n\tfor i in range(1, n):\n\t\tif a[i] != a[i - 1]:\n\t\t\tcnt = 0\n\t\telse:\n\t\t\tcnt += 1\n\t\tif cnt >= 2:\n\t\t\tj = i\n\t\t\twhile a[j] == a[i]:\n\t\t\t\tj += 1\n\t\t\treturn j - i + 2 + dfs(a[:i - 2] + a[j:n])\n\treturn 0\n(n, k, x) = R()\na = R()\nans = 1\nfor i in range(n + 1):\n\tans = max(ans, dfs(a[:i] + [x] + a[i:]))\nprint(ans - 1)\n",
        "slowest_solution": "(n, k, x) = list(map(int, input().split()))\nl = list(map(int, input().split()))\nintervals = []\nsums = [0]\n\ndef countballs(array):\n\tj = 0\n\tcount = 0\n\th = 0\n\tif array == []:\n\t\treturn 0\n\twhile h < len(array):\n\t\tif array[h] == array[j]:\n\t\t\tcount += 1\n\t\t\th += 1\n\t\telse:\n\t\t\tif count > 2:\n\t\t\t\treturn count + countballs(array[:j] + array[h:])\n\t\t\tj = h\n\t\t\tcount = 0\n\tif count < 3:\n\t\treturn 0\n\telse:\n\t\treturn count + countballs(array[:j] + array[h - 1:])\ni = 0\nwhile i < n - 1:\n\tif l[i] == l[i + 1]:\n\t\tif l[i] == x:\n\t\t\tintervals.append([i, i + 1])\n\t\ti += 2\n\telse:\n\t\ti += 1\nfor inte in intervals:\n\tsums.append(countballs(l[:inte[0]] + [x] + l[inte[0]:]))\nif max(sums) > 0:\n\tprint(max(sums) - 1)\nelse:\n\tprint(0)\n"
    },
    {
        "task_id": 104,
        "slowest_solution_id": 6,
        "fastest_solution_id": 8,
        "slowest_time": 3.042215585708618,
        "fastest_time": 2.5383236408233643,
        "fastest_solution": "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\ta = [int(x) for x in input().split()]\n\ta.sort()\n\ts = 0\n\twhile len(a):\n\t\tm = 1\n\t\tx = a.pop()\n\t\twhile len(a) and x == a[len(a) - 1]:\n\t\t\ta.pop()\n\t\t\tm += 1\n\t\ts += m * (n + 1) / (n - len(a) + 1)\n\tprint('%0.02f' % s)\n",
        "slowest_solution": "T = int(input())\nfor t in range(T):\n\tN = int(input())\n\tY = list(sorted(map(int, input().split())))\n\n\tdef get_e(smaller):\n\t\treturn (N + 1) / (N - smaller + 1)\n\tans = 0\n\tneq_idx = None\n\tfor (i, n) in enumerate(Y):\n\t\tif neq_idx == None or Y[neq_idx] != n:\n\t\t\tneq_idx = i\n\t\tans += get_e(neq_idx)\n\tprint('{0:.2f}'.format(ans))\n"
    },
    {
        "task_id": 106,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.7822349071502686,
        "fastest_time": 2.505013942718506,
        "fastest_solution": "try:\n\twhile True:\n\t\tgoals = input()\n\t\tteam_a = 0\n\t\tteam_b = 0\n\t\tfor (i, goal) in enumerate(goals):\n\t\t\tif i < 10:\n\t\t\t\tif i % 2 == 0:\n\t\t\t\t\tteam_a += int(goal)\n\t\t\t\telse:\n\t\t\t\t\tteam_b += int(goal)\n\t\t\t\tif team_b - team_a > 5 - (i + 2) // 2:\n\t\t\t\t\tprint('TEAM-B', i + 1)\n\t\t\t\t\tbreak\n\t\t\t\telif team_a - team_b > 5 - (i + 1) // 2:\n\t\t\t\t\tprint('TEAM-A', i + 1)\n\t\t\t\t\tbreak\n\t\t\telif i % 2 == 0:\n\t\t\t\tlast = int(goal)\n\t\t\telse:\n\t\t\t\tcurrent = int(goal)\n\t\t\t\tif last == current:\n\t\t\t\t\tpass\n\t\t\t\telif last > current:\n\t\t\t\t\tprint('TEAM-A', i + 1)\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tprint('TEAM-B', i + 1)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tprint('TIE')\nexcept:\n\tpass\n",
        "slowest_solution": "def soln():\n\ts = list(map(int, list(input())))\n\ta_score = b_score = 0\n\ta_rem = b_rem = 5\n\tfor i in range(10):\n\t\tif i & 1:\n\t\t\tb_score += s[i]\n\t\t\tb_rem -= 1\n\t\telse:\n\t\t\ta_score += s[i]\n\t\t\ta_rem -= 1\n\t\tif a_score - b_score > b_rem:\n\t\t\treturn f'TEAM-A {i + 1}'\n\t\tif b_score - a_score > a_rem:\n\t\t\treturn f'TEAM-B {i + 1}'\n\tif a_score > b_score:\n\t\treturn f'TEAM-A {10}'\n\telif b_score > a_score:\n\t\treturn f'TEAM-B {10}'\n\tfor i in range(10, 20, 2):\n\t\ta_score += s[i]\n\t\tb_score += s[i + 1]\n\t\tif a_score > b_score:\n\t\t\treturn f'TEAM-A {i + 2}'\n\t\tif a_score < b_score:\n\t\t\treturn f'TEAM-B {i + 2}'\n\treturn 'TIE'\ntry:\n\twhile True:\n\t\tprint(soln())\nexcept:\n\tpass\n"
    },
    {
        "task_id": 146,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.681427001953125,
        "fastest_time": 2.579014778137207,
        "fastest_solution": "from math import gcd\n\ndef PRINT(a, b):\n\tprint(str(int(a)) + '/' + str(int(b)))\n\ndef solve(n):\n\tpre = 0\n\twhile n > 1 and n % 2 == 0:\n\t\tpre = pre + 1\n\t\tn = n // 2\n\tif n == 1:\n\t\tPRINT(pre, 1)\n\t\treturn\n\tarr = []\n\trem = 1\n\twhile True:\n\t\trem = rem * 2\n\t\tarr.append(int(rem // n))\n\t\trem = rem % n\n\t\tif rem == 1:\n\t\t\tbreak\n\tk = len(arr)\n\tans = 0\n\tfor i in range(0, k):\n\t\tif arr[i] == 1:\n\t\t\tans = ans + 2 ** (k - 1 - i) * (i + 1)\n\tans = ans * n + k\n\tA = ans\n\tB = 2 ** k - 1\n\tG = gcd(A, B)\n\tA = A // G\n\tB = B // G\n\tPRINT(A + B * pre, B)\nn = int(input())\nsolve(n)\n",
        "slowest_solution": "from fractions import *\n(n, L) = (int(input()), 0)\nwhile n % 2 == 0:\n\t(n, L) = (n // 2, L + 1)\nif n == 1:\n\tprint('%d/1' % L)\nelse:\n\t(s, t) = (1, 1)\n\tfor i in range(n):\n\t\t(t, s) = (t * 2 % n, s * 2)\n\t\tif t == 1:\n\t\t\tm = i + 1\n\t\t\tbreak\n\t(r, t, i, ans) = (s, s * n, L, 0)\n\twhile r > 1:\n\t\t(i, t) = (i + 1, t // 2)\n\t\tif r - t > 0:\n\t\t\t(r, ans) = (r - t, ans + i * t)\n\tprint(Fraction(ans + m, s - 1))\n"
    },
    {
        "task_id": 137,
        "slowest_solution_id": 9,
        "fastest_solution_id": 0,
        "slowest_time": 2.8044638633728027,
        "fastest_time": 2.659750461578369,
        "fastest_solution": "import sys\nreadline = sys.stdin.readline\n\ndef i1():\n\treturn int(readline())\n\ndef nl():\n\treturn [int(s) for s in readline().split()]\n\ndef nn(n):\n\treturn [int(readline()) for i in range(n)]\n\ndef nnp(n, x):\n\treturn [int(readline()) + x for i in range(n)]\n\ndef nmp(n, x):\n\treturn (int(readline()) + x for i in range(n))\n\ndef nlp(x):\n\treturn [int(s) + x for s in readline().split()]\n\ndef nll(n):\n\treturn [[int(s) for s in readline().split()] for i in range(n)]\n\ndef mll(n):\n\treturn ([int(s) for s in readline().split()] for i in range(n))\n\ndef s1():\n\treturn readline().rstrip()\n\ndef sl():\n\treturn [s for s in readline().split()]\n\ndef sn(n):\n\treturn [readline().rstrip() for i in range(n)]\n\ndef sm(n):\n\treturn (readline().rstrip() for i in range(n))\n\ndef redir(s):\n\tglobal readline\n\timport os\n\tfn = sys.argv[0] + f'/../in-{s}.txt'\n\treadline = open(fn).readline if os.path.exists(fn) else readline\nredir('b')\nn = i1()\narr = nn(n - 1)\ncnt = [0] * (n + 1)\nleaf = [True] * (n + 1)\ni = n\narr.reverse()\nok = True\nfor p in arr:\n\tif leaf[i]:\n\t\tcnt[p] += 1\n\telif cnt[i] < 3:\n\t\tok = False\n\t\tbreak\n\tleaf[p] = False\n\ti -= 1\nprint('YES' if ok and cnt[1] >= 3 else 'NO')\n",
        "slowest_solution": "def dfs(x):\n\tcnt = 0\n\tglobal flag\n\tfor v in child[x]:\n\t\tif len(child[v]):\n\t\t\tdfs(v)\n\t\telse:\n\t\t\tcnt += 1\n\tif cnt < 3:\n\t\tflag = False\nn = int(input())\nflag = True\nchild = [[] for i in range(n + 1)]\nfor i in range(2, n + 1):\n\ta = int(input())\n\tchild[a].append(i)\ndfs(1)\nprint(('NO', 'YES')[flag])\n"
    },
    {
        "task_id": 140,
        "slowest_solution_id": 3,
        "fastest_solution_id": 2,
        "slowest_time": 2.8378729820251465,
        "fastest_time": 2.5939576625823975,
        "fastest_solution": "def main():\n\n\tdef computeR():\n\t\tr = [0] * n\n\t\tfor (i, x) in enumerate(p):\n\t\t\tr[x] = i\n\t\treturn r\n\n\tdef computeA():\n\t\ta = [0] * n\n\t\tfor i in range(n):\n\t\t\tj = i\n\t\t\tfor _ in range(base):\n\t\t\t\tj = p[j]\n\t\t\ta[i] = j\n\t\treturn a\n\n\tdef update(x, y):\n\t\ttemp = p[x]\n\t\tp[x] = p[y]\n\t\tp[y] = temp\n\t\ttemp = r[p[x]]\n\t\tr[p[x]] = r[p[y]]\n\t\tr[p[y]] = temp\n\t\tfor z in (x, y):\n\t\t\tfor _ in range(base):\n\t\t\t\tz = r[z]\n\t\t\tz2 = z\n\t\t\tfor _ in range(base):\n\t\t\t\tz2 = p[z2]\n\t\t\tfor _ in range(base + 1):\n\t\t\t\ta[z] = z2\n\t\t\t\tz = p[z]\n\t\t\t\tz2 = p[z2]\n\n\tdef query(x, k):\n\t\twhile k >= base:\n\t\t\tk -= base\n\t\t\tx = a[x]\n\t\twhile k >= 1:\n\t\t\tk -= 1\n\t\t\tx = p[x]\n\t\treturn x + 1\n\t(n, m) = readIntArr()\n\tp = readIntArr()\n\tfor i in range(n):\n\t\tp[i] -= 1\n\tbase = int(n ** 0.5 + 1)\n\tr = computeR()\n\ta = computeA()\n\tallans = []\n\tfor _ in range(m):\n\t\t(aa, bb, cc) = readIntArr()\n\t\tif aa == 1:\n\t\t\tupdate(bb - 1, cc - 1)\n\t\telse:\n\t\t\tallans.append(query(bb - 1, cc))\n\tmultiLineArrayPrint(allans)\n\treturn\nimport sys\ninput = sys.stdin.buffer.readline\n\ndef oneLineArrayPrint(arr):\n\tprint(' '.join([str(x) for x in arr]))\n\ndef multiLineArrayPrint(arr):\n\tprint('\\n'.join([str(x) for x in arr]))\n\ndef multiLineArrayOfArraysPrint(arr):\n\tprint('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n\ndef readIntArr():\n\treturn [int(x) for x in input().split()]\n\ndef makeArr(defaultValFactory, dimensionArr):\n\tdv = defaultValFactory\n\tda = dimensionArr\n\tif len(da) == 1:\n\t\treturn [dv() for _ in range(da[0])]\n\telse:\n\t\treturn [makeArr(dv, da[1:]) for _ in range(da[0])]\n\ndef queryInteractive(a, b, c):\n\tprint('? {} {} {}'.format(a, b, c))\n\tsys.stdout.flush()\n\treturn int(input())\n\ndef answerInteractive(ansArr):\n\tprint('! {}'.format(' '.join([str(x) for x in ansArr])))\n\tsys.stdout.flush()\ninf = float('inf')\nfrom math import gcd, floor, ceil\nimport math\nfor _abc in range(1):\n\tmain()\n",
        "slowest_solution": "import io, os\nimport sys\nfrom sys import stdin\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict, deque, namedtuple\nfrom heapq import heappush, heappop\nfrom math import gcd, ceil, floor, factorial, sqrt\nfrom itertools import combinations, permutations\ninput = sys.stdin.buffer.readline\n\ndef work():\n\tans = 0\n\treturn\n\ndef main():\n\ttest = 1\n\tfor idt in range(test):\n\t\t(n, q) = map(int, input().split())\n\t\tp = list(map(int, input().split()))\n\t\tfor i in range(n):\n\t\t\tp[i] -= 1\n\t\tr = [0] * n\n\t\tfor i in range(n):\n\t\t\tr[p[i]] = i\n\t\ta = [0] * n\n\t\tQ = 100\n\t\tfor i in range(n):\n\t\t\tx = i\n\t\t\tfor j in range(Q):\n\t\t\t\tx = p[x]\n\t\t\ta[i] = x\n\t\tfor _ in range(q):\n\t\t\t(t, x, y) = map(int, input().split())\n\t\t\tif t == 2:\n\t\t\t\tx -= 1\n\t\t\t\twhile y >= Q:\n\t\t\t\t\ty -= Q\n\t\t\t\t\tx = a[x]\n\t\t\t\twhile y:\n\t\t\t\t\tx = p[x]\n\t\t\t\t\ty -= 1\n\t\t\t\tprint(x + 1)\n\t\t\telse:\n\t\t\t\t(x, y) = (x - 1, y - 1)\n\t\t\t\t(r[p[x]], r[p[y]]) = (r[p[y]], r[p[x]])\n\t\t\t\t(p[x], p[y]) = (p[y], p[x])\n\t\t\t\tax = x\n\t\t\t\tfor i in range(Q):\n\t\t\t\t\tax = p[ax]\n\t\t\t\tx2 = x\n\t\t\t\tfor i in range(Q):\n\t\t\t\t\ta[x] = ax\n\t\t\t\t\tx = r[x]\n\t\t\t\t\tax = r[ax]\n\t\t\t\t(x, y) = (y, x)\n\t\t\t\tax = x\n\t\t\t\tfor i in range(Q):\n\t\t\t\t\tax = p[ax]\n\t\t\t\tx2 = x\n\t\t\t\tfor i in range(Q):\n\t\t\t\t\ta[x] = ax\n\t\t\t\t\tx = r[x]\n\t\t\t\t\tax = r[ax]\n\treturn\nmain()\n"
    },
    {
        "task_id": 145,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.8264400959014893,
        "fastest_time": 2.4994120597839355,
        "fastest_solution": "mod = 1000000007\n\ndef integer_list():\n\treturn list(map(int, input().split()))\n\ndef string_list():\n\treturn list(map(str, input().split()))\n\ndef hetro_list():\n\treturn list(input().split())\nimport math\nimport sys\nfrom collections import Counter, defaultdict\n\ndef main():\n\toccur = Counter(lst)\n\ts_e_lst = []\n\tfor ele in occur:\n\t\tif occur[ele] == 1:\n\t\t\ts_e_lst.append(ele)\n\t(s, e) = (s_e_lst[0], s_e_lst[1])\n\tif e in dct:\n\t\t(s, e) = (e, s)\n\tans = []\n\twhile True:\n\t\tif s == e:\n\t\t\tbreak\n\t\t(end, cost) = dct[s]\n\t\tans.append([s, end, cost])\n\t\ts = end\n\tfor ele in ans:\n\t\tprint(*ele)\n\tprint(f'{total_cost}' + ext)\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tdct = defaultdict(list)\n\ttotal_cost = 0\n\tlst = []\n\text = ''\n\tfor i in range(n - 1):\n\t\t(a, b, cost) = hetro_list()\n\t\tlst.append(a)\n\t\tlst.append(b)\n\t\ttotal_cost += int(cost[:-1])\n\t\text = cost[-1:]\n\t\tdct[a].extend([b, cost])\n\tmain()\n",
        "slowest_solution": "def hetro_list():\n\treturn list(input().split())\nfrom collections import Counter, defaultdict\n\ndef main():\n\toccur = Counter(lst)\n\ts_e_lst = []\n\tfor ele in occur:\n\t\tif occur[ele] == 1:\n\t\t\ts_e_lst.append(ele)\n\t(s, e) = (s_e_lst[0], s_e_lst[1])\n\tif e in dct:\n\t\t(s, e) = (e, s)\n\tans = []\n\twhile True:\n\t\tif s == e:\n\t\t\tbreak\n\t\t(end, cost) = dct[s]\n\t\tans.append([s, end, cost])\n\t\ts = end\n\tfor ele in ans:\n\t\tprint(*ele)\n\tprint(f'{total_cost}' + ext)\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tdct = defaultdict(list)\n\ttotal_cost = 0\n\tlst = []\n\text = ''\n\tfor i in range(n - 1):\n\t\t(a, b, cost) = hetro_list()\n\t\tlst.extend([a, b])\n\t\ttotal_cost += int(cost[:-1])\n\t\text = cost[-1:]\n\t\tdct[a].extend([b, cost])\n\tmain()\n"
    },
    {
        "task_id": 134,
        "slowest_solution_id": 5,
        "fastest_solution_id": 1,
        "slowest_time": 2.8716611862182617,
        "fastest_time": 2.6206893920898438,
        "fastest_solution": "import sys\nsys.setrecursionlimit(100000)\n\ndef _r():\n\treturn sys.stdin.buffer.readline()\n\ndef rs():\n\treturn _r().decode('ascii').strip()\n\ndef rn():\n\treturn int(_r())\n\ndef rnt():\n\treturn map(int, _r().split())\n\ndef rnl():\n\treturn list(rnt())\n\ndef solve(n, m, k, mat, q):\n\t(sol, cache) = ([], [0] * m)\n\tfor c in q:\n\t\tcc = c - 1\n\t\tif cache[cc] == 0:\n\t\t\t(r, c, alldown) = (0, c - 1, True)\n\t\t\twhile r < n:\n\t\t\t\tif mat[r][c] == 2:\n\t\t\t\t\tr += 1\n\t\t\t\telse:\n\t\t\t\t\talldown = False\n\t\t\t\t\t(mat[r][c], c) = (2, c + 2 - mat[r][c])\n\t\t\tif alldown:\n\t\t\t\tcache[cc] = c + 1\n\t\t\tsol.append(c + 1)\n\t\telse:\n\t\t\tsol.append(cache[cc])\n\treturn sol\n(n, m, k) = rnt()\nmat = []\nfor _ in range(n):\n\tmat.append(rnl())\nq = rnl()\nprint(' '.join(map(str, solve(n, m, k, mat, q))))\n",
        "slowest_solution": "import os, sys\nfrom io import BytesIO, FileIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ntry:\n\t(sys.stdin, sys.stdout) = (open('in.txt', 'r'), open('out.txt', 'w'))\nexcept:\n\tpass\nii1 = lambda : int(sys.stdin.readline().strip())\nis1 = lambda : sys.stdin.readline().strip()\niia = lambda : list(map(int, sys.stdin.readline().strip().split()))\nisa = lambda : sys.stdin.readline().strip().split()\nmod = int(1000000000.0 + 7)\nfrom collections import defaultdict as dd\n\ndef main(t):\n\t(n, m, k) = iia()\n\tarr = []\n\tfor i in range(n):\n\t\tarr.append(iia())\n\tK = iia()\n\tdic = dd(int)\n\tres = []\n\tfor q in range(k):\n\t\tstart = K[q] - 1\n\t\tshift = 0\n\t\tif start in dic:\n\t\t\tres.append(dic[start])\n\t\t\tcontinue\n\t\tj = 0\n\t\twhile j < n:\n\t\t\tif 0 <= start < m:\n\t\t\t\tif arr[j][start] == 1:\n\t\t\t\t\tarr[j][start] = 2\n\t\t\t\t\tstart += 1\n\t\t\t\t\tshift += 1\n\t\t\t\telif arr[j][start] == 3:\n\t\t\t\t\tarr[j][start] = 2\n\t\t\t\t\tstart -= 1\n\t\t\t\t\tshift += 1\n\t\t\t\telse:\n\t\t\t\t\tj += 1\n\t\t\telse:\n\t\t\t\tbreak\n\t\tif shift == 0:\n\t\t\tdic[K[q] - 1] = start + 1\n\t\tres.append(start + 1)\n\tprint(*res)\nt = 1\nfor _ in range(t):\n\tmain(_)\n"
    },
    {
        "task_id": 119,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 3.1956493854522705,
        "fastest_time": 2.572845458984375,
        "fastest_solution": "from collections import deque\nn = int(input())\na = [0] + list(map(int, input().split()))\ne = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n\t(u, v) = list(map(int, input().split()))\n\te[u].append(v)\n\te[v].append(u)\nisp = [1] * 501\nprime = []\nfor i in range(2, 501):\n\tif isp[i]:\n\t\tprime.append(i)\n\tfor p in prime:\n\t\tif i * p > 500:\n\t\t\tbreak\n\t\tisp[i * p] = 0\n\t\tif i % p == 0:\n\t\t\tbreak\nlp = len(prime)\n\ndef diam(gr, n):\n\tvis = [0] * (n + 1)\n\tlvl = [-1] * (n + 1)\n\tmaxlvl = 0\n\tfor i in range(1, n + 1):\n\t\tif not vis[i]:\n\t\t\tq = deque([i])\n\t\t\tstart = i\n\t\t\twhile q:\n\t\t\t\tstart = q.popleft()\n\t\t\t\tfor to in gr[start]:\n\t\t\t\t\tif not vis[to]:\n\t\t\t\t\t\tvis[to] = 1\n\t\t\t\t\t\tq.append(to)\n\t\t\tq.append(start)\n\t\t\tlvl[start] = 0\n\t\t\ttmplvl = 0\n\t\t\twhile q:\n\t\t\t\tcur = q.popleft()\n\t\t\t\tfor to in gr[cur]:\n\t\t\t\t\tif lvl[to] == -1:\n\t\t\t\t\t\tlvl[to] = lvl[cur] + 1\n\t\t\t\t\t\tq.append(to)\n\t\t\t\t\t\ttmplvl = lvl[to]\n\t\t\tmaxlvl = max(maxlvl, tmplvl)\n\treturn maxlvl + 1\nnewn = [0] * (n + 1)\nv = [[] for i in range(lp)]\nother = {}\nfor i in range(1, n + 1):\n\tl = a[i]\n\tfor j in range(lp):\n\t\tr = prime[j]\n\t\tif l % r == 0:\n\t\t\tv[j].append(i)\n\t\t\twhile l % r == 0:\n\t\t\t\tl //= r\n\tif l != 1:\n\t\tif l in other:\n\t\t\tother[l].append(i)\n\t\telse:\n\t\t\tother[l] = [i]\nfor val in list(other.values()):\n\tv.append(val)\nans = 0\nfor i in range(len(v)):\n\tcount = 1\n\tfor node in v[i]:\n\t\tnewn[node] = count\n\t\tcount += 1\n\tif count == 1:\n\t\tcontinue\n\tg = [[] for i in range(count)]\n\tfor node in v[i]:\n\t\tfor to in e[node]:\n\t\t\tif newn[to]:\n\t\t\t\tg[newn[node]].append(newn[to])\n\tans = max(ans, diam(g, count - 1))\n\tfor node in v[i]:\n\t\tnewn[node] = 0\nprint(ans)\n",
        "slowest_solution": "from sys import stdin, stdout\nfrom math import *\nfrom heapq import *\nfrom collections import *\ndv = list(range(200002))\nfor i in range(2, 200002):\n\tif i * i >= 200002:\n\t\tbreak\n\tif dv[i] == i:\n\t\tj = i\n\t\twhile i * j < 200002:\n\t\t\tdv[i * j] = i\n\t\t\tj = j + 1\n\ndef loPr(x):\n\tglobal dv\n\tif x <= 1:\n\t\treturn []\n\tret = []\n\twhile x > 1:\n\t\td = dv[x]\n\t\tret.append(d)\n\t\twhile x % d == 0:\n\t\t\tx = trunc(x / d)\n\treturn ret\n\ndef main():\n\tglobal dv\n\tn = int(stdin.readline())\n\ta = [0] + [int(x) for x in stdin.readline().split()]\n\te = []\n\tfor _ in range(n + 2):\n\t\te.append([])\n\tfor _ in range(n - 1):\n\t\t(u, v) = [int(x) for x in stdin.readline().split()]\n\t\te[u].append(v)\n\t\te[v].append(u)\n\tpre = [0] * (n + 2)\n\tq = [1]\n\td = [False] * (n + 2)\n\td[1] = True\n\tpre[1] = 1\n\ti = 0\n\twhile i < len(q):\n\t\tu = q[i]\n\t\tfor v in e[u]:\n\t\t\tif d[v] == False:\n\t\t\t\td[v] = True\n\t\t\t\tpre[v] = u\n\t\t\t\tq.append(v)\n\t\ti = i + 1\n\tf = [dict()]\n\tfor _ in range(n + 2):\n\t\tf.append(dict())\n\tb = [[]]\n\tfor i in range(1, n + 1):\n\t\tb.append(loPr(a[i]))\n\t\tfor p in b[i]:\n\t\t\tf[i][p] = [1]\n\tq.reverse()\n\tres = 0\n\tfor u in q:\n\t\tnxt = pre[u]\n\t\tfor p in b[u]:\n\t\t\tfp = f[u].get(p, [1])\n\t\t\tfp.sort()\n\t\t\tres = max(res, fp[-1])\n\t\t\tif len(fp) >= 2:\n\t\t\t\tres = max(res, fp[-1] + fp[-2] - 1)\n\t\t\tfnxt = f[nxt].get(p, None)\n\t\t\tif fnxt != None:\n\t\t\t\tfnxt.append(max(1, fp[-1]) + 1)\n\tstdout.write(str(res))\n\treturn 0\nmain()\n"
    },
    {
        "task_id": 111,
        "slowest_solution_id": 8,
        "fastest_solution_id": 3,
        "slowest_time": 2.823507785797119,
        "fastest_time": 2.4596240520477295,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nfor f in range(int(input())):\n\t(a, b, c, d) = map(int, input().split())\n\tif d >= c:\n\t\tif a > b * c:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(a)\n\telif a > b * c:\n\t\tprint(-1)\n\telif a < b * d:\n\t\tprint(a)\n\telse:\n\t\tk = a // (b * d)\n\t\tprint((k + 1) * a - k * (k + 1) * b * d // 2)\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n\tfor _ in range(int(input())):\n\t\t(a, b, c, d) = map(int, input().split())\n\t\tif a > b * c:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tn = a // (b * d) + 1\n\t\t\tprint(n * a - n * (n - 1) * b * d // 2)\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n"
    },
    {
        "task_id": 149,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 3.297919988632202,
        "fastest_time": 2.671725273132324,
        "fastest_solution": "import sys\nfrom array import array\nimport typing as Tp\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\n\ndef main():\n\t(l, r, k) = map(int, input().split())\n\t(valid_bits, is_valid_bits) = ([], [0] * 1024)\n\tfor bit in range(1024):\n\t\tif bin(bit).count('1') <= k:\n\t\t\tvalid_bits.append(bit)\n\t\t\tis_valid_bits[bit] = 1\n\tmod = 998244353\n\n\tdef solve(ub):\n\t\tdp = array('i', [0]) * 1024\n\t\tdp_cnt = array('i', [0]) * 1024\n\t\tnext_dp = array('i', [0]) * 1024\n\t\tnext_dp_cnt = array('i', [0]) * 1024\n\t\t(boundary_dp, b_bit) = (0, 0)\n\t\tfor (e, digit) in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))):\n\t\t\tbase = pow(10, e, mod)\n\t\t\tfor bit in valid_bits:\n\t\t\t\tfor d in range(10):\n\t\t\t\t\tnextbit = bit | 1 << d\n\t\t\t\t\tif is_valid_bits[nextbit]:\n\t\t\t\t\t\tnext_dp[nextbit] = (next_dp[nextbit] + dp[bit] + base * d * dp_cnt[bit]) % mod\n\t\t\t\t\t\tnext_dp_cnt[nextbit] += dp_cnt[bit]\n\t\t\t\t\t\tif next_dp_cnt[nextbit] >= mod:\n\t\t\t\t\t\t\tnext_dp_cnt[nextbit] -= mod\n\t\t\tfor d in range(digit):\n\t\t\t\tnextbit = b_bit | 1 << d\n\t\t\t\tif is_valid_bits[nextbit]:\n\t\t\t\t\tnext_dp[nextbit] = (next_dp[nextbit] + boundary_dp + base * d) % mod\n\t\t\t\t\tnext_dp_cnt[nextbit] += 1\n\t\t\tb_bit |= 1 << digit\n\t\t\tboundary_dp = (boundary_dp + base * digit) % mod\n\t\t\tfor i in valid_bits:\n\t\t\t\tdp[i] = next_dp[i]\n\t\t\t\tdp_cnt[i] = next_dp_cnt[i]\n\t\t\t\tnext_dp[i] = next_dp_cnt[i] = 0\n\t\t\t(dp[0], dp_cnt[0]) = (0, 1)\n\t\t\tdp[1] = dp_cnt[1] = 0\n\t\treturn (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod\n\tprint((solve(r) - solve(l - 1)) % mod)\nmain()\n",
        "slowest_solution": "MOD = 998244353\n\ndef pop_count(x):\n\tans = 0\n\twhile x > 0:\n\t\tans = ans + x % 2\n\t\tx = x // 2\n\treturn ans\n\ndef check(x, k):\n\tmask = 0\n\tnx = int(x)\n\twhile nx > 0:\n\t\tmask = mask | 1 << nx % 10\n\t\tnx = nx // 10\n\tif pop_count(mask) <= k:\n\t\treturn x\n\treturn 0\npop = []\np10 = []\nf = [[0 for j in range(1 << 10)] for i in range(20)]\nw = [[0 for j in range(1 << 10)] for i in range(20)]\n\ndef prepare():\n\tp10.append(1)\n\tfor i in range(20):\n\t\tp10.append(p10[i] * 10 % MOD)\n\tfor i in range(1 << 10):\n\t\tpop.append(pop_count(i))\n\tw[0][0] = 1\n\tfor i in range(1, 20):\n\t\tfor j in range(1 << 10):\n\t\t\tfor use in range(10):\n\t\t\t\tw[i][j | 1 << use] = (w[i][j | 1 << use] + w[i - 1][j]) % MOD\n\t\t\t\tf[i][j | 1 << use] = (f[i][j | 1 << use] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD\n\ndef solve(x, k):\n\tsx = [int(d) for d in str(x)]\n\tn = len(sx)\n\tans = 0\n\tfor i in range(1, n):\n\t\tfor use in range(1, 10):\n\t\t\tfor mask in range(1 << 10):\n\t\t\t\tif pop[1 << use | mask] <= k:\n\t\t\t\t\tans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD\n\tcmask = 0\n\tcsum = 0\n\tfor i in range(n):\n\t\tcdig = sx[i]\n\t\tfor use in range(cdig):\n\t\t\tif i == 0 and use == 0:\n\t\t\t\tcontinue\n\t\t\tnmask = cmask | 1 << use\n\t\t\tfor mask in range(1 << 10):\n\t\t\t\tif pop[nmask | mask] <= k:\n\t\t\t\t\tans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD\n\t\tcmask |= 1 << cdig\n\t\tcsum = (10 * csum + cdig) % MOD\n\treturn ans\nprepare()\n(l, r, k) = list(map(int, input().split()))\nans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD\nprint(ans)\n"
    },
    {
        "task_id": 153,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.8139312267303467,
        "fastest_time": 2.4255409240722656,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef RL():\n\treturn map(int, sys.stdin.readline().rstrip().split())\n\ndef RLL():\n\treturn list(map(int, sys.stdin.readline().rstrip().split()))\n\ndef N():\n\treturn int(input())\n\ndef print_list(l):\n\tprint(' '.join(map(str, l)))\nfrom collections import defaultdict as dc\n\ndef judge(last, key, d1, d2):\n\tif key > last:\n\t\tfor (a, b, c) in data:\n\t\t\tif last < c <= key:\n\t\t\t\td1[a].add(b)\n\t\t\t\td2[b].add(a)\n\telse:\n\t\tfor (a, b, c) in data:\n\t\t\tif key < c <= last:\n\t\t\t\td1[a].remove(b)\n\t\t\t\tif not d1[a]:\n\t\t\t\t\tdel d1[a]\n\t\t\t\td2[b].remove(a)\n\t\t\t\tif not d2[b]:\n\t\t\t\t\tdel d2[b]\n\tif len(d1.keys()) < n or len(d2.keys()) < n:\n\t\treturn False\n\tfor a in d1:\n\t\tlone = 0\n\t\tfor b in d1[a]:\n\t\t\tif len(d2[b]) == 1:\n\t\t\t\tlone += 1\n\t\t\t\tif lone > 1:\n\t\t\t\t\treturn False\n\tfor b in d2:\n\t\tlone = 0\n\t\tfor a in d2[b]:\n\t\t\tif len(d1[a]) == 1:\n\t\t\t\tlone += 1\n\t\t\t\tif lone > 1:\n\t\t\t\t\treturn False\n\tused = set()\n\tfor a in d1:\n\t\tif a not in used:\n\t\t\t(s1, s2, now) = ({a}, d1[a].copy(), d1[a].copy())\n\t\t\twhile now:\n\t\t\t\tb = now.pop()\n\t\t\t\tda = d2[b] - s1\n\t\t\t\ts1 |= da\n\t\t\t\tfor aa in da:\n\t\t\t\t\tdb = d1[aa] - s2\n\t\t\t\t\tnow |= db\n\t\t\t\t\ts2 |= db\n\t\t\tif len(s1) != len(s2):\n\t\t\t\treturn False\n\t\t\tused |= s1\n\treturn True\n(n, m) = RL()\ndata = []\nfor _ in range(m):\n\tdata.append(tuple(map(int, sys.stdin.readline().split())))\n(l, r) = (min((a[2] for a in data)), max((a[2] for a in data)) + 1)\nmd = r\nlast = 0\ndu = dc(set)\ndv = dc(set)\nwhile l < r:\n\tkey = l + r >> 1\n\tif judge(last, key, du, dv):\n\t\tr = key\n\telse:\n\t\tl = key + 1\n\tlast = key\nif l >= md:\n\tprint(-1)\nelse:\n\tprint(l)\n",
        "slowest_solution": "def hopcroft_karp(graph, n, m):\n\tassert n == len(graph)\n\tmatch1 = [-1] * n\n\tmatch2 = [-1] * m\n\tfor node in range(n):\n\t\tfor nei in graph[node]:\n\t\t\tif match2[nei] == -1:\n\t\t\t\tmatch1[node] = nei\n\t\t\t\tmatch2[nei] = node\n\t\t\t\tbreak\n\twhile 1:\n\t\tbfs = [node for node in range(n) if match1[node] == -1]\n\t\tdepth = [-1] * n\n\t\tfor node in bfs:\n\t\t\tdepth[node] = 0\n\t\tfor node in bfs:\n\t\t\tfor nei in graph[node]:\n\t\t\t\tnext_node = match2[nei]\n\t\t\t\tif next_node == -1:\n\t\t\t\t\tbreak\n\t\t\t\tif depth[next_node] == -1:\n\t\t\t\t\tdepth[next_node] = depth[node] + 1\n\t\t\t\t\tbfs.append(next_node)\n\t\t\telse:\n\t\t\t\tcontinue\n\t\t\tbreak\n\t\telse:\n\t\t\tbreak\n\t\tpointer = [len(c) for c in graph]\n\t\tdfs = [node for node in range(n) if depth[node] == 0]\n\t\twhile dfs:\n\t\t\tnode = dfs[-1]\n\t\t\twhile pointer[node]:\n\t\t\t\tpointer[node] -= 1\n\t\t\t\tnei = graph[node][pointer[node]]\n\t\t\t\tnext_node = match2[nei]\n\t\t\t\tif next_node == -1:\n\t\t\t\t\twhile nei != -1:\n\t\t\t\t\t\tnode = dfs.pop()\n\t\t\t\t\t\t(match2[nei], match1[node], nei) = (node, nei, match1[node])\n\t\t\t\t\tbreak\n\t\t\t\telif depth[node] + 1 == depth[next_node]:\n\t\t\t\t\tdfs.append(next_node)\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tdfs.pop()\n\treturn (match1, match2)\n\ndef getMatchCounts(roads, days, n):\n\tadj = [[] for _ in range(n)]\n\tfor (u, v, d) in roads:\n\t\tif d <= days:\n\t\t\tadj[u].append(v)\n\tmatchCounts = n - hopcroft_karp(adj, n, n)[0].count(-1)\n\treturn matchCounts\n\ndef main():\n\t(n, m) = readIntArr()\n\troads = []\n\tfor _ in range(m):\n\t\t(u, v, d) = readIntArr()\n\t\tu -= 1\n\t\tv -= 1\n\t\troads.append([u, v, d])\n\tif getMatchCounts(roads, 1000000000.0 + 1, n) < n:\n\t\tprint(-1)\n\telse:\n\t\tdays = 0\n\t\tb = 1000000000\n\t\twhile b > 0:\n\t\t\twhile getMatchCounts(roads, days + b, n) < n:\n\t\t\t\tdays += b\n\t\t\tb //= 2\n\t\tdays += 1\n\t\tprint(days)\n\treturn\nimport sys\ninput = sys.stdin.buffer.readline\n\ndef oneLineArrayPrint(arr):\n\tprint(' '.join([str(x) for x in arr]))\n\ndef multiLineArrayPrint(arr):\n\tprint('\\n'.join([str(x) for x in arr]))\n\ndef multiLineArrayOfArraysPrint(arr):\n\tprint('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n\ndef readIntArr():\n\treturn [int(x) for x in input().split()]\n\ndef makeArr(defaultValFactory, dimensionArr):\n\tdv = defaultValFactory\n\tda = dimensionArr\n\tif len(da) == 1:\n\t\treturn [dv() for _ in range(da[0])]\n\telse:\n\t\treturn [makeArr(dv, da[1:]) for _ in range(da[0])]\n\ndef queryInteractive(i, j):\n\tprint('? {} {}'.format(i, j))\n\tsys.stdout.flush()\n\treturn int(input())\n\ndef answerInteractive(ans):\n\tprint('! {}'.format(' '.join([str(x) for x in ans])))\n\tsys.stdout.flush()\ninf = float('inf')\nMOD = 10 ** 9 + 7\nfor _abc in range(1):\n\tmain()\n"
    },
    {
        "task_id": 113,
        "slowest_solution_id": 9,
        "fastest_solution_id": 1,
        "slowest_time": 3.023326873779297,
        "fastest_time": 2.513817548751831,
        "fastest_solution": "memo = {}\n\ndef equivalent(a, b):\n\tlength = len(a)\n\tif (a, b) in memo:\n\t\treturn memo[a, b]\n\tif a == b:\n\t\tmemo[a, b] = True\n\t\treturn True\n\telif length % 2 != 0:\n\t\tmemo[a, b] = False\n\t\treturn False\n\telif equivalent(a[:length // 2], b[:length // 2]) and equivalent(a[length // 2:], b[length // 2:]) or (equivalent(a[:length // 2], b[length // 2:]) and equivalent(a[length // 2:], b[:length // 2])):\n\t\tmemo[a, b] = True\n\t\treturn True\nA = input()\nB = input()\nif equivalent(A, B):\n\tprint('YES')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "def si(a, b):\n\tif a == b:\n\t\treturn True\n\tlongitud = max(len(a), len(b))\n\tif longitud % 2 == 1:\n\t\tif a == b:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\tmedia = longitud // 2\n\tif si(a[0:media], b[0:media]) and si(a[media:], b[media:]):\n\t\treturn True\n\tif si(a[media:], b[0:media]) and si(a[0:media], b[media:]):\n\t\treturn True\n\treturn False\nprimero = input()\nsegundo = input()\nif si(primero, segundo):\n\tprint('YES')\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 115,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.9218902587890625,
        "fastest_time": 2.567275285720825,
        "fastest_solution": "from sys import stdin, stdout\n\ndef find(node):\n\tx = []\n\twhile dsu[node] > 0:\n\t\tx.append(node)\n\t\tnode = dsu[node]\n\tfor i in x:\n\t\tdsu[i] = node\n\treturn node\n\ndef union(node1, node2):\n\tif node1 != node2:\n\t\tif dsu[node1] > dsu[node2]:\n\t\t\t(node1, node2) = (node2, node1)\n\t\tdsu[node1] += dsu[node2]\n\t\tdsu[node2] = node1\nn = int(stdin.readline().strip())\ndsu = [-1] * (n + 1)\nm = int(stdin.readline().strip())\nfor __ in range(m):\n\t(a, b) = map(int, stdin.readline().strip().split())\n\tunion(find(a), find(b))\nk = int(stdin.readline().strip())\nfor __ in range(k):\n\t(a, b) = map(int, stdin.readline().strip().split())\n\tp_a = find(a)\n\tp_b = find(b)\n\tif p_a == p_b:\n\t\tdsu[p_a] = 0\nmaxm = 0\nfor i in range(1, n + 1):\n\tif dsu[i] < 0:\n\t\tmaxm = max(maxm, abs(dsu[i]))\nstdout.write(f'{maxm}')\n",
        "slowest_solution": "n = int(input())\nparents = [i for i in range(n + 1)]\nranks = [1 for i in range(n + 1)]\n\ndef find(x):\n\tif parents[x] != x:\n\t\tparents[x] = find(parents[x])\n\treturn parents[x]\n\ndef union(x, y):\n\txs = find(x)\n\tys = find(y)\n\tif xs == ys:\n\t\treturn\n\tif ranks[xs] > ranks[ys]:\n\t\tparents[ys] = xs\n\telif ranks[ys] > ranks[xs]:\n\t\tparents[xs] = ys\n\telse:\n\t\tparents[ys] = xs\n\t\tranks[xs] += 1\nfor _ in range(int(input())):\n\t(u, v) = map(int, input().split())\n\tunion(u, v)\nrejects = set([])\nfor _ in range(int(input())):\n\t(p, q) = map(int, input().split())\n\tps = find(p)\n\tqs = find(q)\n\tif ps == qs:\n\t\trejects.add(ps)\nps = {}\nfor i in range(1, n + 1):\n\tp = find(i)\n\tif p not in rejects:\n\t\tif p in ps:\n\t\t\tps[p] += 1\n\t\telse:\n\t\t\tps[p] = 1\nans = 0\nfor i in ps:\n\tans = max(ans, ps[i])\nprint(ans)\n"
    },
    {
        "task_id": 156,
        "slowest_solution_id": 2,
        "fastest_solution_id": 3,
        "slowest_time": 2.8024375438690186,
        "fastest_time": 2.605565071105957,
        "fastest_solution": "from sys import stdin\nfrom sys import stdout\nn = int(stdin.readline())\nd = [0] + list(map(int, stdin.readline().split()))\ne = []\nfor i in range(1, n + 1):\n\tfor u in range(d[i - 1] + 1, d[i] + 1):\n\t\tfor v in range(u + 1, d[n - i + 1] + 2):\n\t\t\te.append([u, v])\nstdout.write('{}\\n'.format(len(e)))\nfor ei in e:\n\tstdout.write('{} {}\\n'.format(ei[0], ei[1]))\n",
        "slowest_solution": "import sys\nline = lambda : sys.stdin.buffer.readline()\nn = int(line())\nd = [0] + list(map(int, line().split()))\ns = []\nfor i in range(1, n + 1):\n\tfor u in range(d[i - 1] + 1, d[i] + 1):\n\t\tfor v in range(u + 1, d[n - i + 1] + 2):\n\t\t\ts.append((u, v))\nprint(len(s))\nfor t in s:\n\tprint(*t)\n"
    },
    {
        "task_id": 114,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.967811346054077,
        "fastest_time": 2.5904886722564697,
        "fastest_solution": "for rpt in range(int(input())):\n\t(n, m) = [int(x) for x in input().split()]\n\tnumbers = [int(x) for x in input().split()]\n\tremains = [0 for x in range(m)]\n\tfor i in numbers:\n\t\tremains[i % m] += 1\n\tres = 0\n\tfor i in range(m // 2 + 1):\n\t\tif remains[i] > 0 or remains[(m - i) % m] > 0:\n\t\t\tsmaller = min(remains[i], remains[(m - i) % m])\n\t\t\tbigger = max(remains[i], remains[(m - i) % m])\n\t\t\tif bigger - smaller <= 1:\n\t\t\t\tres += 1\n\t\t\telse:\n\t\t\t\tres += bigger - smaller - 1 + 1\n\tprint(res)\n",
        "slowest_solution": "from collections import Counter\nt = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\tali = list(map(int, input().split()))\n\tq = Counter()\n\tcnt = 0\n\tfor i in range(n):\n\t\tw = ali[i] % m\n\t\tq[w] += 1\n\tif m % 2 == 0:\n\t\te = m // 2\n\telse:\n\t\te = m // 2 + 1\n\tfor i in range(1, m // 2 + 1):\n\t\ta = abs(m - i)\n\t\tz = q[a]\n\t\tx = q[i]\n\t\tif z != 0 and x != 0 and (i != a):\n\t\t\tif z == x:\n\t\t\t\tcnt += 1\n\t\t\telif z < x:\n\t\t\t\tx = x - (z + 1)\n\t\t\t\tcnt += x\n\t\t\t\tcnt += 1\n\t\t\telse:\n\t\t\t\tz = z - (x + 1)\n\t\t\t\tcnt += 1\n\t\t\t\tcnt += z\n\t\telif i == a and q[i] > 0:\n\t\t\tif i + i == m:\n\t\t\t\tcnt += 1\n\t\telse:\n\t\t\tcnt += x\n\t\t\tcnt += z\n\tv = q[0]\n\tif v > 0:\n\t\tcnt += 1\n\tprint(cnt)\n"
    },
    {
        "task_id": 152,
        "slowest_solution_id": 1,
        "fastest_solution_id": 3,
        "slowest_time": 2.8287885189056396,
        "fastest_time": 2.702191114425659,
        "fastest_solution": "(N, K) = list(map(int, input().split()))\nS = input().strip()\nS = [-1 if _ == '?' else ord(_) - ord('a') for _ in S]\n\ndef check(x):\n\tp = [[N for i in range(N + 1)] for k in range(K)]\n\tfor k in range(K):\n\t\tkeep = 0\n\t\tfor i in range(N - 1, -1, -1):\n\t\t\tkeep += 1\n\t\t\tif S[i] != -1 and S[i] != k:\n\t\t\t\tkeep = 0\n\t\t\tp[k][i] = p[k][i + 1]\n\t\t\tif keep >= x:\n\t\t\t\tp[k][i] = i + x - 1\n\td = [N for s in range(1 << K)]\n\td[0] = -1\n\tfor s in range(1, 1 << K):\n\t\tfor k in range(K):\n\t\t\tif s & 1 << k and d[s ^ 1 << k] < N:\n\t\t\t\td[s] = min(d[s], p[k][d[s ^ 1 << k] + 1])\n\treturn d[(1 << K) - 1] < N\n(l, r) = (0, N // K)\nwhile l < r:\n\tmid = (l + r + 1) // 2\n\tif check(mid):\n\t\tl = mid\n\telse:\n\t\tr = mid - 1\nprint(l)\n",
        "slowest_solution": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\n(N, K) = map(int, input().split())\nS = [-1 if a == '?' else ord(a) - 97 for a in input()]\nII = {1 << i: i for i in range(20)}\n\ndef calc(mmm):\n\tinf = 300000\n\tX = [[0] * N for _ in range(K)]\n\tfor k in range(K):\n\t\tXk = X[k]\n\t\tmi = inf\n\t\tr = 0\n\t\tfor i in range(N)[::-1]:\n\t\t\tif S[i] < 0 or S[i] == k:\n\t\t\t\tr += 1\n\t\t\telse:\n\t\t\t\tr = 0\n\t\t\tif r >= mmm:\n\t\t\t\tmi = min(mi, i + mmm)\n\t\t\tXk[i] = mi\n\tY = [0] * (1 << K)\n\tfor i in range(1, 1 << K):\n\t\tmi = inf\n\t\tfor j in range(K):\n\t\t\tif i >> j & 1:\n\t\t\t\tii = i ^ 1 << j\n\t\t\t\tif Y[ii] < N:\n\t\t\t\t\tmi = min(mi, X[j][Y[ii]])\n\t\tY[i] = mi\n\treturn 1 if Y[-1] < inf else 0\n(l, r) = (0, N // K + 1)\nwhile r - l > 1:\n\tm = l + r >> 1\n\tif calc(m):\n\t\tl = m\n\telse:\n\t\tr = m\nprint(l)\n"
    },
    {
        "task_id": 164,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.999485969543457,
        "fastest_time": 2.999485969543457,
        "fastest_solution": "N = 10 ** 5 + 10\n\nclass Bit:\n\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.arr = [0] * (n + 1)\n\n\tdef update(self, i, v):\n\t\ti += 1\n\t\twhile i <= self.n:\n\t\t\tself.arr[i] += v\n\t\t\ti += i & -i\n\n\tdef getsum(self, i):\n\t\ts = 0\n\t\ti = i + 1\n\t\twhile i > 0:\n\t\t\ts += self.arr[i]\n\t\t\ti -= i & -i\n\t\treturn s\n\n\tdef print(self):\n\t\tprint(self.arr)\n\ndef horizontal(x1, y1, x2, y2):\n\treturn y1 == y2\n\ndef main():\n\ttc = int(input())\n\tallowed = []\n\tblocked = []\n\thevents = []\n\tvevents = []\n\thendpoints = {}\n\tvendpoints = {}\n\tans = [-1] * tc\n\tfor t in range(tc):\n\t\t(x1, y1, x2, y2) = tuple(map(int, input().split()))\n\t\tif horizontal(x1, y1, x2, y2):\n\t\t\tif x1 > x2:\n\t\t\t\t(x1, x2) = (x2, x1)\n\t\t\tvevents.append((y1, (x1, x2), 'Q', t))\n\t\t\thevents.append((x1, y1, 'A'))\n\t\t\thevents.append((x2, y2, 'S'))\n\t\t\thendpoints[x1, y1] = 1\n\t\t\thendpoints[x2, y2] = 1\n\t\telse:\n\t\t\tif y1 > y2:\n\t\t\t\t(y1, y2) = (y2, y1)\n\t\t\thevents.append((x1, (y1, y2), 'Q', t))\n\t\t\tvevents.append((y1, x1, 'A'))\n\t\t\tvevents.append((y2, x2, 'S'))\n\t\t\tvendpoints[y1, x1] = 1\n\t\t\tvendpoints[y2, x2] = 1\n\thevents.sort(key=lambda x: (x[0], x[2]))\n\tvevents.sort(key=lambda x: (x[0], x[2]))\n\tbh = Bit(N)\n\tfor e in hevents:\n\t\tif e[2] == 'A':\n\t\t\tbh.update(e[1], 1)\n\t\tif e[2] == 'Q':\n\t\t\tstart = e[1][0] - 1\n\t\t\tend = e[1][1]\n\t\t\tif (e[0], start + 1) in hendpoints:\n\t\t\t\tstart += 1\n\t\t\tif (e[0], end) in hendpoints:\n\t\t\t\tend -= 1\n\t\t\tsum1 = bh.getsum(end)\n\t\t\tsum2 = bh.getsum(start)\n\t\t\tans[e[3]] = sum1 - sum2\n\t\tif e[2] == 'S':\n\t\t\tbh.update(e[1], -1)\n\tbv = Bit(N)\n\tfor e in vevents:\n\t\tif e[2] == 'A':\n\t\t\tbv.update(e[1], 1)\n\t\tif e[2] == 'Q':\n\t\t\tstart = e[1][0] - 1\n\t\t\tend = e[1][1]\n\t\t\tif (e[0], start + 1) in vendpoints:\n\t\t\t\tstart += 1\n\t\t\tif (e[0], end) in vendpoints:\n\t\t\t\tend -= 1\n\t\t\tsum1 = bv.getsum(end)\n\t\t\tsum2 = bv.getsum(start)\n\t\t\tans[e[3]] = sum1 - sum2\n\t\tif e[2] == 'S':\n\t\t\tbv.update(e[1], -1)\n\ttotal = sum(ans) // 2\n\tprint(total)\n\tprint(*ans, sep=' ')\nmain()\n",
        "slowest_solution": "N = 10 ** 5 + 10\n\nclass Bit:\n\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.arr = [0] * (n + 1)\n\n\tdef update(self, i, v):\n\t\ti += 1\n\t\twhile i <= self.n:\n\t\t\tself.arr[i] += v\n\t\t\ti += i & -i\n\n\tdef getsum(self, i):\n\t\ts = 0\n\t\ti = i + 1\n\t\twhile i > 0:\n\t\t\ts += self.arr[i]\n\t\t\ti -= i & -i\n\t\treturn s\n\n\tdef print(self):\n\t\tprint(self.arr)\n\ndef horizontal(x1, y1, x2, y2):\n\treturn y1 == y2\n\ndef main():\n\ttc = int(input())\n\tallowed = []\n\tblocked = []\n\thevents = []\n\tvevents = []\n\thendpoints = {}\n\tvendpoints = {}\n\tans = [-1] * tc\n\tfor t in range(tc):\n\t\t(x1, y1, x2, y2) = tuple(map(int, input().split()))\n\t\tif horizontal(x1, y1, x2, y2):\n\t\t\tif x1 > x2:\n\t\t\t\t(x1, x2) = (x2, x1)\n\t\t\tvevents.append((y1, (x1, x2), 'Q', t))\n\t\t\thevents.append((x1, y1, 'A'))\n\t\t\thevents.append((x2, y2, 'S'))\n\t\t\thendpoints[x1, y1] = 1\n\t\t\thendpoints[x2, y2] = 1\n\t\telse:\n\t\t\tif y1 > y2:\n\t\t\t\t(y1, y2) = (y2, y1)\n\t\t\thevents.append((x1, (y1, y2), 'Q', t))\n\t\t\tvevents.append((y1, x1, 'A'))\n\t\t\tvevents.append((y2, x2, 'S'))\n\t\t\tvendpoints[y1, x1] = 1\n\t\t\tvendpoints[y2, x2] = 1\n\thevents.sort(key=lambda x: (x[0], x[2]))\n\tvevents.sort(key=lambda x: (x[0], x[2]))\n\tbh = Bit(N)\n\tfor e in hevents:\n\t\tif e[2] == 'A':\n\t\t\tbh.update(e[1], 1)\n\t\tif e[2] == 'Q':\n\t\t\tstart = e[1][0] - 1\n\t\t\tend = e[1][1]\n\t\t\tif (e[0], start + 1) in hendpoints:\n\t\t\t\tstart += 1\n\t\t\tif (e[0], end) in hendpoints:\n\t\t\t\tend -= 1\n\t\t\tsum1 = bh.getsum(end)\n\t\t\tsum2 = bh.getsum(start)\n\t\t\tans[e[3]] = sum1 - sum2\n\t\tif e[2] == 'S':\n\t\t\tbh.update(e[1], -1)\n\tbv = Bit(N)\n\tfor e in vevents:\n\t\tif e[2] == 'A':\n\t\t\tbv.update(e[1], 1)\n\t\tif e[2] == 'Q':\n\t\t\tstart = e[1][0] - 1\n\t\t\tend = e[1][1]\n\t\t\tif (e[0], start + 1) in vendpoints:\n\t\t\t\tstart += 1\n\t\t\tif (e[0], end) in vendpoints:\n\t\t\t\tend -= 1\n\t\t\tsum1 = bv.getsum(end)\n\t\t\tsum2 = bv.getsum(start)\n\t\t\tans[e[3]] = sum1 - sum2\n\t\tif e[2] == 'S':\n\t\t\tbv.update(e[1], -1)\n\ttotal = sum(ans) // 2\n\tprint(total)\n\tprint(*ans, sep=' ')\nmain()\n"
    },
    {
        "task_id": 161,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 3.481999158859253,
        "fastest_time": 2.916111469268799,
        "fastest_solution": "t = int(input())\nM = 1000000007\nmul = [1]\nfor i in range(4 * 100000):\n\tmul.append(mul[-1] * 101 % M)\nwhile t:\n\tt -= 1\n\ta = input()\n\tn = len(a)\n\ta += a\n\tpre = [0]\n\tfor i in range(1, 2 * n + 1):\n\t\tpre.append((pre[-1] + ord(a[i - 1]) * mul[i - 1] % M) % M)\n\tsuf = [0]\n\tfor i in range(2 * n, 0, -1):\n\t\tsuf.append((suf[-1] + ord(a[i - 1]) * mul[2 * n - i] % M) % M)\n\tans = 0\n\tfor i in range(n):\n\t\tif (pre[n + i] - pre[i] + M) % M * mul[n - i] % M == (suf[2 * n - i] - suf[n - i] + M) % M * mul[i] % M:\n\t\t\tans += 1\n\tprint(ans)\n",
        "slowest_solution": "m = 1000000007\nt = int(input())\np2 = []\np2.append(1)\nfor i in range(400000):\n\tp2.append(p2[i] * 31 % m)\nfor h in range(t):\n\ts = input()\n\tn = len(s)\n\ts2 = s[::-1]\n\thash1 = 0\n\thash2 = 0\n\tfor i in range(n):\n\t\thash1 += p2[i] * (ord(s[i]) - ord('a'))\n\t\thash1 %= m\n\t\thash2 += p2[i] * (ord(s2[i]) - ord('a'))\n\t\thash2 %= m\n\tans = 0\n\tfor i in range(n):\n\t\thash1 -= p2[i] * (ord(s[i]) - ord('a'))\n\t\thash1 += p2[i + n] * (ord(s[i]) - ord('a'))\n\t\thash1 %= m\n\t\tif hash1 < 0:\n\t\t\thash1 += m\n\t\thash2 *= p2[2]\n\t\thash2 %= m\n\t\thash2 -= p2[n + 1 + i] * (ord(s2[n - 1 - i]) - ord('a'))\n\t\thash2 += p2[i + 1] * (ord(s2[n - 1 - i]) - ord('a'))\n\t\thash2 %= m\n\t\tif hash2 < 0:\n\t\t\thash2 += m\n\t\tif hash1 == hash2:\n\t\t\tans += 1\n\tprint(ans)\n"
    },
    {
        "task_id": 122,
        "slowest_solution_id": 8,
        "fastest_solution_id": 2,
        "slowest_time": 3.0468406677246094,
        "fastest_time": 2.5161635875701904,
        "fastest_solution": "t = int(input())\nfor i in range(t):\n\t(n, k) = map(int, input().split())\n\tl = list(map(int, input().split()))\n\tdict = {i: l.count(i) for i in range(1, n + 1)}\n\tc = 0\n\ty = 1\n\tfor j in dict.values():\n\t\tif j >= k and l[y - 1] != y:\n\t\t\tc += 1\n\t\ty += 1\n\tprint(c)\n",
        "slowest_solution": "from collections import Counter\nfor _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tarr = tuple(map(int, input().split()))\n\t(counts, count) = (Counter(arr), 0)\n\tfor i in range(n):\n\t\tif arr[i] == i + 1:\n\t\t\tcounts[arr[i]] = 0\n\tfor x in counts:\n\t\tif counts[x] >= k:\n\t\t\tcount += 1\n\tprint(count)\n"
    },
    {
        "task_id": 130,
        "slowest_solution_id": 6,
        "fastest_solution_id": 1,
        "slowest_time": 2.9659512042999268,
        "fastest_time": 2.609996795654297,
        "fastest_solution": "n = int(input())\nr = n\nMAX = 998244353\narr = [0] * (n + 1)\nfor i in range(n - 1):\n\t(a, b) = map(int, input().split())\n\tarr[a] += 1\n\tarr[b] += 1\n\tr *= arr[a] * arr[b]\n\tr %= MAX\nprint(r)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nMOD = 998244353\nfa = [1]\nfor i in range(1, 2 * 10 ** 5 + 10):\n\tfa.append(fa[-1] * i % MOD)\nN = int(input())\nX = [[] for i in range(N)]\nfor i in range(N - 1):\n\t(x, y) = map(int, input().split())\n\tX[x - 1].append(y - 1)\n\tX[y - 1].append(x - 1)\nP = [-1] * N\nQ = [0]\nwhile Q:\n\ti = Q.pop()\n\tfor a in X[i]:\n\t\tif a != P[i]:\n\t\t\tP[a] = i\n\t\t\tX[a].remove(i)\n\t\t\tQ.append(a)\nans = N\nfor i in range(len(X)):\n\tans = ans * fa[len(X[i]) + (1 if i else 0)] % MOD\nprint(ans)\n"
    },
    {
        "task_id": 131,
        "slowest_solution_id": 7,
        "fastest_solution_id": 2,
        "slowest_time": 2.8159990310668945,
        "fastest_time": 2.5580673217773438,
        "fastest_solution": "for s in [*open(0)][2::2]:\n\t(x, *a) = map(int, s.split())\n\tprint(('Bob', 'Alice')[x > min(a)])\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef solution(items: list, n: int):\n\tmin_idx = 1\n\tfor i in range(2, n):\n\t\tif items[i] < items[min_idx]:\n\t\t\tmin_idx = i\n\treturn 'Alice' if items[min_idx] < items[0] else 'Bob'\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\titems = list(map(int, input().split()))\n\tprint(solution(items, n))\n"
    },
    {
        "task_id": 123,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 3.0310046672821045,
        "fastest_time": 2.5551702976226807,
        "fastest_solution": "t = int(input())\nwhile t > 0:\n\t(n, k, l) = map(int, input().split())\n\tarr = list(map(int, input().split()))\n\tif n == 1:\n\t\tprint('Yes')\n\telse:\n\t\tsp = arr[len(arr) - 1]\n\t\tdel arr[len(arr) - 1]\n\t\tmx = max(arr)\n\t\tif mx < sp:\n\t\t\tprint('Yes')\n\t\telif k <= 0 and mx >= sp:\n\t\t\tprint('No')\n\t\telse:\n\t\t\tsp += (l - 1) * k\n\t\t\tif mx < sp:\n\t\t\t\tprint('Yes')\n\t\t\telse:\n\t\t\t\tprint('No')\n\tt -= 1\n",
        "slowest_solution": "for i in range(int(input())):\n\t(n, k, l) = map(int, input().split())\n\tspeeds = list(map(int, input().split()))\n\tif max(speeds) == speeds[-1]:\n\t\tprint('Yes')\n\telif k <= 0 and max(speeds) != speeds[-1]:\n\t\tprint('No')\n\telif int((max(speeds) - speeds[-1]) / k) + 1 >= l:\n\t\tprint('No')\n\telse:\n\t\tprint('Yes')\n"
    },
    {
        "task_id": 124,
        "slowest_solution_id": 8,
        "fastest_solution_id": 3,
        "slowest_time": 3.089301109313965,
        "fastest_time": 2.5208308696746826,
        "fastest_solution": "try:\n\n\tdef nextPowerOf2(n):\n\t\tcount = 0\n\t\tif n and (not n & n - 1):\n\t\t\treturn n\n\t\twhile n != 0:\n\t\t\tn >>= 1\n\t\t\tcount += 1\n\t\treturn 1 << count\n\tfor t in range(int(input())):\n\t\tN = int(input())\n\t\tif N == 1:\n\t\t\tprint('Alice')\n\t\telif N == 2:\n\t\t\tprint('Bob')\n\t\telif N == 3:\n\t\t\tprint('Alice')\n\t\telif N == 4:\n\t\t\tprint('Alice')\n\t\telse:\n\t\t\ttemp = nextPowerOf2(N) - N\n\t\t\tif temp <= 3:\n\t\t\t\tif temp == 0 or temp == 1:\n\t\t\t\t\tprint('Alice')\n\t\t\t\telif temp == 2 or temp == 3:\n\t\t\t\t\tprint('Bob')\n\t\t\telif N % 2 == 0:\n\t\t\t\tprint('Alice')\n\t\t\telse:\n\t\t\t\tprint('Bob')\nexcept:\n\tpass\n",
        "slowest_solution": "def po(n):\n\tif n != 0 and n & n - 1 == 0:\n\t\treturn True\n\telse:\n\t\treturn False\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tif n == 2:\n\t\tprint('Bob')\n\telif n == 1:\n\t\tprint('Alice')\n\telif n % 2 == 0:\n\t\tif po(n + 2) == True:\n\t\t\tprint('Bob')\n\t\telse:\n\t\t\tprint('Alice')\n\telif n % 2 != 0:\n\t\tif po(n + 1) == True:\n\t\t\tprint('Alice')\n\t\telse:\n\t\t\tprint('Bob')\n"
    },
    {
        "task_id": 129,
        "slowest_solution_id": 8,
        "fastest_solution_id": 1,
        "slowest_time": 2.9439408779144287,
        "fastest_time": 2.4622116088867188,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\targs = [int(x) for x in input().split()]\n\t(n, k) = (args[0], args[1])\n\tnums = []\n\tfor __ in range(n):\n\t\tnums.extend([int(x) for x in input().split()])\n\tnums.sort()\n\tmin_goodness = 0\n\tfor i in range(n):\n\t\tmin_goodness += nums[(i + 1) * (n // 2)]\n\tif min_goodness > k:\n\t\tprint(-1)\n\t\tcontinue\n\t(lo, hi) = (n // 2, n * n - 1)\n\tgoodness = -1\n\twhile lo <= hi:\n\t\tmid = (lo + hi) // 2\n\t\ttaken = 0\n\t\trlim = n * n\n\t\tless = mid\n\t\ti = mid\n\t\tcost = 0\n\t\twhile taken <= n and i < rlim:\n\t\t\tif less >= n // 2:\n\t\t\t\tcost += nums[i]\n\t\t\t\tless -= n // 2\n\t\t\t\trlim -= n - n // 2 - 1\n\t\t\t\tif rlim <= i:\n\t\t\t\t\tbreak\n\t\t\t\ttaken += 1\n\t\t\telse:\n\t\t\t\tless += 1\n\t\t\ti += 1\n\t\tif taken == n and cost <= k:\n\t\t\tlo = mid + 1\n\t\t\tgoodness = nums[mid]\n\t\telse:\n\t\t\thi = mid - 1\n\tprint(goodness)\n",
        "slowest_solution": "for T in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tarr = []\n\tfor i in range(n):\n\t\tarr.append([int(i) for i in input().split()])\n\tar = []\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tar.append(arr[i][j])\n\tar.sort()\n\tleftcount = n // 2\n\trightcount = n - leftcount - 1\n\trighttotal = rightcount * n\n\tans = -1\n\tl = leftcount\n\tr = n * n - righttotal - (n - 1) - 1\n\twhile l <= r:\n\t\tmid = (l + r) // 2\n\t\tsum = 0\n\t\tcnt = 0\n\t\ttot = 0\n\t\tx = 0\n\t\ty = mid\n\t\tvis = [0] * (n * n)\n\t\twhile tot != n:\n\t\t\tif cnt == leftcount:\n\t\t\t\tif vis[y] == 0:\n\t\t\t\t\tvis[y] = 1\n\t\t\t\t\tsum += ar[y]\n\t\t\t\t\ty += 1\n\t\t\t\t\ttot += 1\n\t\t\t\t\tcnt = 0\n\t\t\t\telse:\n\t\t\t\t\ty += 1\n\t\t\telif vis[x] == 0:\n\t\t\t\tvis[x] = 1\n\t\t\t\tx += 1\n\t\t\t\tcnt += 1\n\t\t\telse:\n\t\t\t\tx += 1\n\t\tif sum <= k:\n\t\t\tans = mid\n\t\t\tl = mid + 1\n\t\telse:\n\t\t\tr = mid - 1\n\tif ans == -1:\n\t\tprint(ans)\n\telse:\n\t\tprint(ar[ans])\n"
    },
    {
        "task_id": 128,
        "slowest_solution_id": 0,
        "fastest_solution_id": 4,
        "slowest_time": 3.100611925125122,
        "fastest_time": 2.596597671508789,
        "fastest_solution": "T = int(input())\nans = [0] * T\nfor t in range(T):\n\t(X, Y) = ([0] * 4, [0] * 4)\n\tA = [0] * 4\n\tfor i in range(4):\n\t\t(X[i], Y[i]) = map(int, input().split())\n\t\tA[i] = [X[i], Y[i]]\n\tX.sort()\n\tY.sort()\n\tA.sort()\n\tcnt = 0\n\tfor i in range(2):\n\t\trank = 1\n\t\tfor j in range(4):\n\t\t\tif A[i][1] < A[j][1]:\n\t\t\t\trank += 1\n\t\tif rank <= 2:\n\t\t\tcnt += 1\n\tif cnt != 1:\n\t\tans[t] += min(Y[2] - Y[1], X[2] - X[1]) * 2\n\tx_min = X[2] - X[1]\n\tx_max = X[3] - X[0]\n\ty_min = Y[2] - Y[1]\n\ty_max = Y[3] - Y[0]\n\tif x_max < y_min:\n\t\tans[t] += X[3] - X[2] + (X[1] - X[0])\n\t\tans[t] += Y[3] - Y[2] + (Y[1] - Y[0]) + 2 * (y_min - x_max)\n\telif y_max < x_min:\n\t\tans[t] += X[3] - X[2] + (X[1] - X[0]) + 2 * (x_min - y_max)\n\t\tans[t] += Y[3] - Y[2] + (Y[1] - Y[0])\n\telse:\n\t\tans[t] += X[3] - X[2] + (X[1] - X[0])\n\t\tans[t] += Y[3] - Y[2] + (Y[1] - Y[0])\nprint(*ans, sep='\\n')\n",
        "slowest_solution": "t = int(input())\n\ndef solvePerm(points):\n\tx1 = [points[0][0], points[1][0]]\n\tsegX1 = (min(*x1), max(*x1))\n\tx2 = [points[2][0], points[3][0]]\n\tsegX2 = (min(*x2), max(*x2))\n\txRange = (max(0, min(*segX2) - max(*segX1)), max(*segX2) - min(*segX1))\n\tif xRange[1] < xRange[0]:\n\t\treturn 10 ** 20\n\ty1 = [points[1][1], points[2][1]]\n\tsegY1 = (min(*y1), max(*y1))\n\ty2 = [points[3][1], points[0][1]]\n\tsegY2 = (min(*y2), max(*y2))\n\tyRange = (max(0, min(*segY2) - max(*segY1)), max(*segY2) - min(*segY1))\n\tif yRange[1] < yRange[0]:\n\t\treturn 10 ** 20\n\ts = segX1[1] - segX1[0] + (segX2[1] - segX2[0])\n\ts += segY1[1] - segY1[0] + (segY2[1] - segY2[0])\n\tif yRange[0] <= xRange[1] and xRange[0] <= yRange[1]:\n\t\tpass\n\telse:\n\t\td = max(yRange[0] - xRange[1], xRange[0] - yRange[1])\n\t\ts += 2 * d\n\treturn s\nfrom itertools import permutations\nfor _ in range(t):\n\tpoints = [tuple(map(int, input().split())) for _ in range(4)]\n\tmi = 10 ** 20\n\tfor p in permutations(points):\n\t\tmi = min(mi, solvePerm(p))\n\tprint(mi)\n"
    },
    {
        "task_id": 127,
        "slowest_solution_id": 8,
        "fastest_solution_id": 3,
        "slowest_time": 2.9916911125183105,
        "fastest_time": 2.6012539863586426,
        "fastest_solution": "t = int(input())\nanswers = []\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\t(n_, m_) = (n, m)\n\t(two, five) = (0, 0)\n\twhile n_ % 2 == 0:\n\t\tn_ //= 2\n\t\ttwo += 1\n\twhile n_ % 5 == 0:\n\t\tn_ //= 5\n\t\tfive += 1\n\ttmp = 1\n\tif two > five:\n\t\tfor i in range(two - five):\n\t\t\tif m_ < 5:\n\t\t\t\tbreak\n\t\t\tm_ //= 5\n\t\t\ttmp *= 5\n\telse:\n\t\tfor i in range(five - two):\n\t\t\tif m_ < 2:\n\t\t\t\tbreak\n\t\t\tm_ //= 2\n\t\t\ttmp *= 2\n\tk = int(str(m_)[0]) * 10 ** (len(str(m_)) - 1) * tmp\n\tanswers.append(n * k)\nfor answer in answers:\n\tprint(answer)\n",
        "slowest_solution": "K = lambda : [*map(int, input().split())]\nfor _ in ' ' * K()[0]:\n\t(n, m) = K()\n\tN = n\n\twhile n % 10 == 0:\n\t\tn //= 10\n\tc = 1\n\twhile n % 2 == 0 and c * 5 <= m:\n\t\tc *= 5\n\t\tn //= 2\n\twhile n % 5 == 0 and c * 2 <= m:\n\t\tc *= 2\n\t\tn //= 5\n\twhile c * 10 <= m:\n\t\tc *= 10\n\tprint(N * c * (m // c))\n"
    },
    {
        "task_id": 141,
        "slowest_solution_id": 6,
        "fastest_solution_id": 9,
        "slowest_time": 2.9301276206970215,
        "fastest_time": 2.5568792819976807,
        "fastest_solution": "class Solver(object):\n\n\tdef read_input(self):\n\t\tn = int(input())\n\t\tgrid = []\n\t\tfor i in range(n):\n\t\t\tl = list(input())\n\t\t\tgrid.append(l)\n\t\tself.n = n\n\t\tself.grid = grid\n\n\tdef solve_line(self):\n\t\tpos = []\n\t\tfor i in range(self.n):\n\t\t\tres = False\n\t\t\tfor j in range(self.n):\n\t\t\t\tif self.grid[i][j] == '.':\n\t\t\t\t\tres = True\n\t\t\t\t\tpos.append((i, j))\n\t\t\t\tif res == True:\n\t\t\t\t\tbreak\n\t\t\tif res == True:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tpos = -1\n\t\t\t\tbreak\n\t\tself.pos = pos\n\t\treturn pos\n\n\tdef solve_column(self):\n\t\tpos = []\n\t\tfor j in range(self.n):\n\t\t\tres = False\n\t\t\tfor i in range(self.n):\n\t\t\t\tif self.grid[i][j] == '.':\n\t\t\t\t\tres = True\n\t\t\t\t\tpos.append((i, j))\n\t\t\t\tif res == True:\n\t\t\t\t\tbreak\n\t\t\tif res == True:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tpos = -1\n\t\t\t\tbreak\n\t\tself.pos = pos\n\t\treturn pos\n\n\tdef print_solution(self):\n\t\tfor (i, j) in self.pos:\n\t\t\tprint(i + 1, j + 1)\n\n\tdef solve(self):\n\t\tlines = self.solve_line()\n\t\tif lines != -1:\n\t\t\tself.print_solution()\n\t\telse:\n\t\t\tcols = self.solve_column()\n\t\t\tif cols == -1:\n\t\t\t\tprint(-1)\n\t\t\telse:\n\t\t\t\tself.print_solution()\nS = Solver()\nS.read_input()\nS.solve()\n",
        "slowest_solution": "n = int(input())\ngrid = [input() for line in range(n)]\ntotal = sum([ln.count('.') for ln in grid])\nrowsWSpcN = len([True for ln in grid if '.' in ln])\ncolsWSpcN = len([True for col in range(n) if '.' in [ln[col] for ln in grid]])\nrowsWSpc = [ln.count('.') for ln in grid]\ncolsWSpc = [[ln[col] for ln in grid].count('.') for col in range(n)]\nused = 0\nif 0 in rowsWSpc and 0 in colsWSpc:\n\tprint(-1)\nelif 0 not in rowsWSpc:\n\tfor row in range(n):\n\t\tprint(row + 1, grid[row].index('.') + 1)\nelse:\n\tfor col in range(n):\n\t\tprint([grid[row][col] for row in range(n)].index('.') + 1, col + 1)\n"
    },
    {
        "task_id": 136,
        "slowest_solution_id": 2,
        "fastest_solution_id": 6,
        "slowest_time": 3.2020297050476074,
        "fastest_time": 2.438082218170166,
        "fastest_solution": "for T in range(int(input())):\n\tn = int(input())\n\tmenu = list(map(int, input().split()))\n\ttmp = {}\n\tfor Q in range(int(input())):\n\t\t(p, k) = map(int, input().split())\n\t\tL = []\n\t\tif p not in tmp:\n\t\t\tfor (i, num) in enumerate(menu):\n\t\t\t\tif num % p == 0:\n\t\t\t\t\tL.append(num)\n\t\t\tL.sort()\n\t\t\tsumL = []\n\t\t\tsum = 0\n\t\t\tfor i in range(n):\n\t\t\t\tif menu[i] % p != 0:\n\t\t\t\t\tsum += menu[i]\n\t\t\t\telse:\n\t\t\t\t\tsum += L.pop()\n\t\t\t\tsumL.append(sum)\n\t\t\ttmp[p] = sumL\n\t\tprint(tmp[p][k - 1])\n",
        "slowest_solution": "def get_factors(n):\n\tarr = [[i, []] for i in range(1, n + 1)]\n\tfor j in range(1, len(arr)):\n\t\t(k, factors) = arr[j]\n\t\tif len(factors) > 0:\n\t\t\tcontinue\n\t\tfor z in range(j, len(arr), k):\n\t\t\tarr[z][1].append(k)\n\treturn arr\nlimit = 100000\nfactors = get_factors(limit)\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tvalues = [int(el) for el in input().split(' ')]\n\tnum_queries = int(input())\n\toriginal_queries = []\n\tfor query in range(num_queries):\n\t\t(p, k) = [int(el) for el in input().split(' ')]\n\t\toriginal_queries.append((p, k))\n\tsorted_values = sorted(values)\n\tprimes = {}\n\tfor n in sorted_values:\n\t\tps = factors[n - 1][1]\n\t\tfor p in ps:\n\t\t\tif p in primes:\n\t\t\t\tprimes[p].append(primes[p][-1] + n)\n\t\t\telse:\n\t\t\t\tprimes[p] = [n]\n\tzq = enumerate(original_queries)\n\tqueries = [(i, p, k) for (i, (p, k)) in zq]\n\tqueries.sort(key=lambda t: t[2])\n\tq = 0\n\tvisited_primes = {}\n\ttotal = 0\n\tres = [0] * len(queries)\n\tfor (i, v) in enumerate(values):\n\t\ttotal += v\n\t\tfs = factors[v - 1][1]\n\t\tfor f in fs:\n\t\t\tif f in visited_primes:\n\t\t\t\tvisited_primes[f][0] += 1\n\t\t\t\tvisited_primes[f][1] += v\n\t\t\telse:\n\t\t\t\tvisited_primes[f] = [1, v]\n\t\twhile q < len(queries) and queries[q][2] == i + 1:\n\t\t\t(original_index, p, k) = queries[q]\n\t\t\tq += 1\n\t\t\tif p not in visited_primes or visited_primes[p][0] == len(primes[p]):\n\t\t\t\tres[original_index] = total\n\t\t\telse:\n\t\t\t\tres[original_index] = total - visited_primes[p][1] + primes[p][-1] - primes[p][len(primes[p]) - visited_primes[p][0] - 1]\n\tfor r in res:\n\t\tprint(r)\n"
    },
    {
        "task_id": 139,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 2.819040536880493,
        "fastest_time": 2.5976204872131348,
        "fastest_solution": "from functools import reduce\nimport operator\nn = int(input())\na = list(map(int, input().split()))\ngr = reduce(operator.xor, a)\nans = sum((1 for _ in filter(lambda x: x ^ gr < x, a)))\nprint(ans)\n",
        "slowest_solution": "from functools import reduce\nN = int(input())\nheaps = list(map(int, input().strip().split()))\nnim = reduce(lambda x, y: x ^ y, heaps)\nif nim == 0:\n\tnum = 0\nelse:\n\tnum = 0\n\tfor n in heaps:\n\t\tif n ^ nim < n:\n\t\t\tnum = num + 1\nprint(num)\n"
    },
    {
        "task_id": 165,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.7084336280822754,
        "fastest_time": 2.4988577365875244,
        "fastest_solution": "import sys, collections\ninput = sys.stdin.readline\n\ndef main1():\n\tT = int(input())\n\tfor _ in range(T):\n\t\t(N, K) = map(int, input().split())\n\t\tTree = {}\n\t\tfor j in range(N):\n\t\t\tTree[j] = []\n\t\tfor i in range(N - 1):\n\t\t\t(u, v) = map(int, input().split())\n\t\t\tTree[u - 1].append(v - 1)\n\t\t\tTree[v - 1].append(u - 1)\n\t\tA = list(map(int, input().split()))\n\t\tvis = [0 for i in range(N)]\n\t\tmaxval = [[0, 0] for i in range(N)]\n\t\tminval = [0 for i in range(N)]\n\t\tlfnode = []\n\t\tvis[0] = 1\n\t\tQ = collections.deque([0])\n\t\t(maxval[0][0], maxval[0][1]) = (A[0], 1)\n\t\tminval[0] = A[0]\n\t\twhile len(Q) != 0:\n\t\t\ta = Q.pop()\n\t\t\tmv1 = maxval[a][0]\n\t\t\tmv2 = minval[a]\n\t\t\tflag = 0\n\t\t\tfor i in Tree[a]:\n\t\t\t\tif vis[i] == 0:\n\t\t\t\t\tvis[i] = 1\n\t\t\t\t\tflag = 1\n\t\t\t\t\tv = A[i]\n\t\t\t\t\tQ.append(i)\n\t\t\t\t\tif mv1 < v:\n\t\t\t\t\t\t(maxval[i][0], maxval[i][1]) = (v, 1)\n\t\t\t\t\telif mv1 == v:\n\t\t\t\t\t\t(maxval[i][0], maxval[i][1]) = (mv1, maxval[a][1] + 1)\n\t\t\t\t\telse:\n\t\t\t\t\t\t(maxval[i][0], maxval[i][1]) = (maxval[a][0], maxval[a][1])\n\t\t\t\t\tif mv2 > v:\n\t\t\t\t\t\tminval[i] = v\n\t\t\t\t\telif v == mv2:\n\t\t\t\t\t\tminval[i] = mv2\n\t\t\t\t\telse:\n\t\t\t\t\t\tminval[i] = minval[a]\n\t\t\tif flag == 0:\n\t\t\t\tlfnode.append(a)\n\t\tflag = 0\n\t\tK1 = len(bin(K)) - 2\n\t\tfor i in lfnode:\n\t\t\t(v1, v2) = (maxval[i][0], maxval[i][1])\n\t\t\tif v1 > K1 and v2 % 2 == 0:\n\t\t\t\tflag = 1\n\t\t\telif v1 == K1 and v2 % 2 == 1:\n\t\t\t\tflag = 1\n\t\t\tv11 = minval[i]\n\t\t\tif v11 > K1 and v11 != v1:\n\t\t\t\tflag = 1\n\t\t\telif v11 == K1:\n\t\t\t\tflag = 1\n\t\t\tif flag == 1:\n\t\t\t\tbreak\n\t\tif flag == 1:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\nmain1()\n",
        "slowest_solution": "import sys\nimport math\nfrom collections import defaultdict, Counter\nimport threading\ninput = sys.stdin.readline\n\ndef print(x):\n\tsys.stdout.write(str(x) + '\\n')\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\n\n@bootstrap\ndef find(u, g, e, g2, e2, le):\n\tvisit[u - 1] = 1\n\tif a[u - 1] > g:\n\t\tg = a[u - 1]\n\t\te = 1\n\telif a[u - 1] == g:\n\t\te += 1\n\tif a[u - 1] < g2:\n\t\tg2 = a[u - 1]\n\t\te2 = 1\n\telif a[u - 1] == g2:\n\t\te2 += 1\n\tfor j in l[u]:\n\t\tif visit[j - 1] == 0:\n\t\t\tflag = (yield find(j, g, e, g2, e2, le))\n\t\t\tif flag:\n\t\t\t\tyield 1\n\t\telif len(l[u]) == 1:\n\t\t\tif g == le and e & 1 or (g > le and e % 2 == 0) or g2 == le or (g2 > le and g > g2):\n\t\t\t\tyield 1\n\tyield 0\n\ndef add(a, b):\n\tl[a].append(b)\n\tl[b].append(a)\nt = int(input())\nfor i in range(t):\n\t(n, k) = map(int, input().split())\n\tl = defaultdict(list)\n\tfor j in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tadd(u, v)\n\ta = list(map(int, input().split()))\n\tvisit = [0] * n\n\tle = len(bin(k)) - 2\n\tif find(1, 0, 0, 100, 0, le):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nsys.setrecursionlimit(10 ** 5)\n"
    },
    {
        "task_id": 154,
        "slowest_solution_id": 6,
        "fastest_solution_id": 8,
        "slowest_time": 4.217325925827026,
        "fastest_time": 2.5296783447265625,
        "fastest_solution": "import math\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = [int(_) for _ in input().split()]\ntotal = sum(a)\ncurrent = 2\nfactors = []\nwhile current * current <= total:\n\tcnt = 0\n\twhile total % current == 0:\n\t\ttotal = total // current\n\t\tcnt = cnt + 1\n\tif cnt > 0:\n\t\tfactors.append(current)\n\tcurrent = current + 1\nif total > 1:\n\tfactors.append(total)\nans = sum(a) * n * n\nfor i in factors:\n\t(total, moves) = (0, 0)\n\tfor j in a:\n\t\ttotal += j\n\t\tmoves += min(total % i, i - total % i)\n\tans = min(ans, moves)\nif len(factors) == 0:\n\tans = -1\nprint(ans)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.buffer.readline\nn = int(input())\na = list(map(int, input().split()))\nif sum(a) == 1:\n\tprint(-1)\n\texit()\nsm = sum(a)\nnmax = 10 ** 6 + 10\neratos = [0 for i in range(nmax + 1)]\nprime = []\ncnt = 2\nwhile True:\n\twhile cnt <= nmax and eratos[cnt]:\n\t\tcnt += 1\n\tif cnt > nmax:\n\t\tbreak\n\teratos[cnt] = 1\n\tprime.append(cnt)\n\tfor i in range(cnt ** 2, nmax + 1, cnt):\n\t\teratos[i] = 1\ndvls = set()\nfor i in prime:\n\twhile sm % i == 0:\n\t\tdvls.add(i)\n\t\tsm //= i\nif sm != 1:\n\tdvls.add(sm)\nansls = []\nls = []\nfor dv in dvls:\n\tcnti = 0\n\tans = 0\n\tif dv == 2:\n\t\tfor i in range(n):\n\t\t\tif a[i] % 2:\n\t\t\t\tcnti += 1\n\t\t\t\tif cnti % 2:\n\t\t\t\t\tpivot = i\n\t\t\t\telse:\n\t\t\t\t\tans += i - pivot\n\telse:\n\t\tflg = 0\n\t\tfor (i, ai) in enumerate(a):\n\t\t\trai = ai % dv\n\t\t\tif rai:\n\t\t\t\tcnti += rai\n\t\t\t\tif 1 <= cnti <= dv // 2:\n\t\t\t\t\tls.append((i, rai))\n\t\t\t\telif not flg:\n\t\t\t\t\tpivot = i\n\t\t\t\t\twhile ls:\n\t\t\t\t\t\t(j, num) = ls.pop()\n\t\t\t\t\t\tans += (pivot - j) * num\n\t\t\t\t\tif cnti < dv:\n\t\t\t\t\t\tflg = 1\n\t\t\t\t\t\tneed = dv - cnti\n\t\t\t\t\telse:\n\t\t\t\t\t\tcnti -= dv\n\t\t\t\t\t\tls.append((pivot, cnti))\n\t\t\t\telif cnti >= dv:\n\t\t\t\t\tans += need * (i - pivot)\n\t\t\t\t\tcnti -= dv\n\t\t\t\t\tif cnti <= dv // 2:\n\t\t\t\t\t\tflg = 0\n\t\t\t\t\t\tif rai - need:\n\t\t\t\t\t\t\tls.append((i, rai - need))\n\t\t\t\t\telse:\n\t\t\t\t\t\tpivot = i\n\t\t\t\t\t\tneed = dv - cnti\n\t\t\t\telse:\n\t\t\t\t\tans += rai * (i - pivot)\n\t\t\t\t\tneed -= rai\n\tansls.append(ans)\nprint(min(ansls))\n"
    },
    {
        "task_id": 99,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 6.291903972625732,
        "fastest_time": 3.864703416824341,
        "fastest_solution": "counter = int(input())\n\n\ndef bit_xor(tmp):\n\tnum2 = 0\n\tcount = 0\n\tfor num1 in range(1, (tmp + 1)):\n\t\tfor num2 in range(num1 + 1, tmp + 1):\n\t\t\tif num1 ^ num2 <= tmp:\n\t\t\t\tcount += 1\n\tprint(count)\n\n\nfor n in range(counter):\n\ttmp = int(input())\n\tbit_xor(tmp)\n",
        "slowest_solution": "r=int(input(\"\"))\nl=[]\n\nfor i in range(r):\n\tq= int(input(\"\"))\n\tl.append(q)\nfor n in l:\n  s=0\n\n  for i in range(1,n):\n   k=i\n   while(k!=n):\n   \tk=k+1\n   \tif i^k<=n:\n   \t\ts=s+1\n  print(s)\n\n\n   \n   \n   \n\n  \t\n   \t\n\t\n"
    },
    {
        "task_id": 175,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.81567120552063,
        "fastest_time": 2.733583450317383,
        "fastest_solution": "N=int(input())\nscores=[int(input()) for x in range(N)]\n\ntablet=[0]*N\n\ntablet[0]=1\n\nfor i in range(1,N):\n\tif scores[i]>scores[i-1]:\n\t\ttablet[i]=tablet[i-1]+1\n\n\telse:\n\t\ttablet[i]=1\n\n\n\nfor i in range(N-2,-1,-1):\n\n\tif scores[i]>scores[i+1] and tablet[i]<=tablet[i+1]:\n\t\ttablet[i]=tablet[i+1]+1\n\n\n\nprint(sum(tablet))\n\n\n\n",
        "slowest_solution": "n=int(input())\nval=1\nlis=[]\nlol=[1]\nlol1=[1]\nfor i in range(n):\n\tlis.append(int(input()))\nfor i in range(1,n):\n\tif lis[i]>lis[i-1]:\n\t\tlol.append(lol[-1]+1)\n\telse:\n\t\tlol.append(1)\n#print lol\nfor i in range(n-2,-1,-1):\n\tif lis[i]>lis[i+1]:\n\t\tlol1.append(lol1[-1]+1)\n\telse:\n\t\tlol1.append(1)\nlol1=lol1[::-1]\n#print lol1\nfor i in range(n):\n\tlol[i]=max(lol[i],lol1[i])\nprint(sum(lol))\n"
    },
    {
        "task_id": 143,
        "slowest_solution_id": 5,
        "fastest_solution_id": 8,
        "slowest_time": 3.0014617443084717,
        "fastest_time": 2.451803684234619,
        "fastest_solution": "def minVal(x, y):\n\tif x > y:\n\t\treturn y\n\telse:\n\t\treturn x\n\ndef build_min(arr, st_min, ss, se, si):\n\tif ss == se:\n\t\tst_min[si] = arr[ss]\n\t\treturn\n\tmid = ss + (se - ss) // 2\n\tbuild_min(arr, st_min, ss, mid, 2 * si + 1)\n\tbuild_min(arr, st_min, mid + 1, se, 2 * si + 2)\n\tst_min[si] = minVal(st_min[si * 2 + 1], st_min[si * 2 + 2])\n\treturn\n\ndef build_max(arr, st_max, ss, se, si):\n\tif ss == se:\n\t\tst_max[si] = arr[ss]\n\t\treturn\n\tmid = ss + (se - ss) // 2\n\tbuild_max(arr, st_max, ss, mid, 2 * si + 1)\n\tbuild_max(arr, st_max, mid + 1, se, 2 * si + 2)\n\tst_max[si] = max(st_max[si * 2 + 1], st_max[si * 2 + 2])\n\treturn\n\ndef getMin(arr, st_min, ss, se, qs, qe, si):\n\tif qs <= ss and qe >= se:\n\t\treturn st_min[si]\n\tif qs > se or qe < ss:\n\t\treturn 10000000000000000000000000\n\tmid = ss + (se - ss) // 2\n\treturn minVal(getMin(arr, st_min, ss, mid, qs, qe, 2 * si + 1), getMin(arr, st_min, mid + 1, se, qs, qe, 2 * si + 2))\n\ndef getMax(arr, st_max, ss, se, qs, qe, si):\n\tif qs <= ss and qe >= se:\n\t\treturn st_max[si]\n\tif qs > se or qe < ss:\n\t\treturn 0\n\tmid = ss + (se - ss) // 2\n\treturn max(getMax(arr, st_max, ss, mid, qs, qe, 2 * si + 1), getMax(arr, st_max, mid + 1, se, qs, qe, 2 * si + 2))\nn = int(input())\narr = list(map(int, input().split()))\nst_min = [0] * (4 * n)\nst_max = [0] * (4 * n)\nbuild_min(arr, st_min, 0, n - 1, 0)\nbuild_max(arr, st_max, 0, n - 1, 0)\nq = int(input())\nwhile q:\n\t(L, R) = map(int, input().split())\n\tmaxx = getMax(arr, st_max, 0, n - 1, L, R, 0)\n\tminn = getMin(arr, st_min, 0, n - 1, L, R, 0)\n\ttotal = 0\n\tif maxx == st_max[0]:\n\t\tval1 = maxx - minn\n\t\tval1 = val1 / 2\n\t\ttotal = minn + val1\n\t\tnew_max = max(getMax(arr, st_max, 0, n - 1, 0, L - 1, 0), getMax(arr, st_max, 0, n - 1, R + 1, n - 1, 0))\n\t\tnew_max = new_max + minn\n\t\tif new_max >= total:\n\t\t\tprint(float(new_max))\n\t\telse:\n\t\t\tprint(float(total))\n\telse:\n\t\tnum = st_max[0] + minn\n\t\tprint(float(num))\n\tq = q - 1\n",
        "slowest_solution": "from math import log2, floor\nn = int(input())\nb = list(map(int, input().split()))\nk = floor(log2(n))\ntb1 = [[0] * (k + 1) for _ in range(n)]\ntb2 = [[0] * (k + 1) for _ in range(n)]\nfor i in range(n):\n\ttb1[i][0] = b[i]\n\ttb2[i][0] = b[i]\nfor j in range(1, k + 1):\n\tfor i in range(n - (1 << j) + 1):\n\t\ttb1[i][j] = max(tb1[i][j - 1], tb1[i + (1 << j - 1)][j - 1])\n\t\ttb2[i][j] = min(tb2[i][j - 1], tb2[i + (1 << j - 1)][j - 1])\n\ndef maxquery(l, r):\n\tk = floor(log2(r - l + 1))\n\treturn max(tb1[l][k], tb1[r - (1 << k) + 1][k])\n\ndef minquery(l, r):\n\tk = floor(log2(r - l + 1))\n\treturn min(tb2[l][k], tb2[r - (1 << k) + 1][k])\n\ndef query(l, r):\n\tm = minquery(l, r)\n\tM = maxquery(l, r)\n\ty = max(maxquery(0, l - 1) if l > 0 else 0, maxquery(r + 1, n - 1) if r < n - 1 else 0)\n\treturn m + max((M - m) / 2, y)\nq = int(input())\nfor _ in range(q):\n\t(l, r) = map(int, input().split())\n\tprint('{:.1f}'.format(query(l, r)))\n"
    },
    {
        "task_id": 150,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.833326578140259,
        "fastest_time": 2.5349106788635254,
        "fastest_solution": "import math, queue, heapq\nimport sys\nsys.setrecursionlimit(10 ** 6)\nfastinput = sys.stdin.readline\nfastout = sys.stdout.write\nt = int(fastinput())\nwhile t:\n\tt -= 1\n\t(n, k) = map(int, fastinput().split())\n\ts = input()\n\tcount1 = [0] * k\n\tcount2 = [0] * k\n\tcount0 = 0\n\tcount4 = 0\n\tcount3 = 0\n\tans = True\n\tfor j in range(k):\n\t\tv = 0\n\t\tfor i in range(j, n, k):\n\t\t\tv += 1\n\t\t\tif s[i] == '0':\n\t\t\t\tcount1[j] += 1\n\t\t\telif s[i] == '?':\n\t\t\t\tcount2[j] += 1\n\t\tif count2[j] == v:\n\t\t\tcount3 += 1\n\t\telif count1[j] > 0 and count1[j] + count2[j] == v:\n\t\t\tcount0 += 1\n\t\telif count1[j] > 0:\n\t\t\tans = False\n\t\t\tbreak\n\t\telse:\n\t\t\tcount4 += 1\n\tif not ans:\n\t\tprint('NO')\n\telif count0 + count3 + count4 == k and count0 <= k // 2 and (count4 <= k // 2):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "def check(s, k):\n\tcount = {'0': 0, '1': 0, '?': 0}\n\tfor i in range(k):\n\t\tval = '?'\n\t\tfor j in range(i, len(s), k):\n\t\t\tif s[j] == '?':\n\t\t\t\tcontinue\n\t\t\tif val == '?':\n\t\t\t\tval = s[j]\n\t\t\t\tcontinue\n\t\t\tif val != s[j]:\n\t\t\t\treturn False\n\t\tcount[val] += 1\n\tdiff = abs(count['0'] - count['1'])\n\tmarks = count['?'] - diff\n\tif marks < 0:\n\t\treturn False\n\treturn marks % 2 == 0\nT = int(input())\nfor t in range(T):\n\t(n, k) = [int(i) for i in input().split(' ')]\n\ts = input()\n\tans = check(s, k)\n\tif ans == True:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 147,
        "slowest_solution_id": 3,
        "fastest_solution_id": 9,
        "slowest_time": 2.804569721221924,
        "fastest_time": 2.5497663021087646,
        "fastest_solution": "from sys import *\n(n, q) = list(map(int, input().strip().split(' ')))\nans = 1000000007\nleaves = 2 ** n\nedges = (2 ** (n + 1) - 2) % ans\nheight = n + 1\nop = []\nroot = 1\nfor i in range(q):\n\ts = str(input().strip())\n\tif s[0] == '2':\n\t\top.append('disp')\n\telse:\n\t\tk = list(map(int, s.split()))\n\t\top.append(k[1])\nfor j in op:\n\tif j == 'disp':\n\t\tprint(edges)\n\telif j == 1 or j == 2:\n\t\tedges = (2 * edges + height) % ans\n\t\tleaves = 2 * leaves % ans\n\t\troot = root * 2 % ans\n\telif j == 4:\n\t\tedges = (2 * edges + leaves) % ans\n\t\tleaves = root\n\t\theight = 2 * height % ans\n\telse:\n\t\tedges = (2 * edges + root) % ans\n\t\troot = leaves\n\t\theight = 2 * height % ans\n",
        "slowest_solution": "mod = 10 ** 9 + 7\n(n, q) = map(int, input().split())\ntop = 1\nbottom = 2 ** n % mod\nleft = (n + 1) % mod\nright = (n + 1) % mod\nedges = (2 ** n - 1) * 2 % mod\nfor _ in range(q):\n\ts = input()\n\tif int(s[0]) == 1:\n\t\tif int(s[2]) == 1:\n\t\t\tedges = (2 * edges % mod + right) % mod\n\t\t\ttop = top * 2 % mod\n\t\t\tbottom = bottom * 2 % mod\n\t\telif int(s[2]) == 2:\n\t\t\tedges = (2 * edges % mod + left) % mod\n\t\t\ttop = top * 2 % mod\n\t\t\tbottom = bottom * 2 % mod\n\t\telif int(s[2]) == 3:\n\t\t\tedges = (2 * edges % mod + top) % mod\n\t\t\ttop = bottom\n\t\t\tleft = 2 * left % mod\n\t\t\tright = 2 * right % mod\n\t\telse:\n\t\t\tedges = (2 * edges % mod + bottom) % mod\n\t\t\tbottom = top\n\t\t\tleft = left * 2 % mod\n\t\t\tright = right * 2 % mod\n\telse:\n\t\tprint(edges)\n"
    },
    {
        "task_id": 192,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 0.003325939178466797,
        "fastest_time": 0.0,
        "fastest_solution": "def vector_length(vector):\n\t((x1, y1), (x2, y2)) = vector\n\treturn ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n",
        "slowest_solution": "import numpy as np\n\ndef vector_length(vector):\n\t(P1, P2) = map(np.array, vector)\n\treturn np.linalg.norm(P1 - P2)\n"
    },
    {
        "task_id": 148,
        "slowest_solution_id": 3,
        "fastest_solution_id": 9,
        "slowest_time": 2.8238348960876465,
        "fastest_time": 2.539210557937622,
        "fastest_solution": "def solve():\n\tfrom math import factorial\n\ts1 = input()\n\ts2 = input()\n\t(cs1, cs2) = (0, 0)\n\tc2 = 0\n\tfor i in s1:\n\t\tif i == '+':\n\t\t\tcs1 += 1\n\t\telse:\n\t\t\tcs1 -= 1\n\tfor i in s2:\n\t\tif i == '+':\n\t\t\tcs2 += 1\n\t\telif i == '-':\n\t\t\tcs2 -= 1\n\t\telse:\n\t\t\tc2 += 1\n\tif c2 == 0:\n\t\tif cs1 == cs2:\n\t\t\tprint(float(1))\n\t\telse:\n\t\t\tprint(float(0))\n\telse:\n\t\tl = []\n\t\tx = c2\n\t\ty = -1 * c2\n\t\twhile x >= y:\n\t\t\tl.append(x)\n\t\t\tx -= 2\n\t\tif cs1 - cs2 in l:\n\t\t\tz = l.index(cs1 - cs2)\n\t\t\tpu = factorial(c2) // (factorial(z) * factorial(c2 - z))\n\t\t\tpd = 2 ** c2\n\t\t\tp = pu / pd\n\t\t\tprint(p)\n\t\telse:\n\t\t\tprint(float(0))\nsolve()\n",
        "slowest_solution": "import sys\nfrom collections import Counter\nfrom math import factorial\ninput = sys.stdin\noutput = sys.stdout\ncombinations_dynamic = dict()\n\ndef combinations(n, k):\n\tif k > n - k:\n\t\tk = n - k\n\tif k < 0:\n\t\treturn 0\n\tif n < 1:\n\t\treturn 0\n\tif k == 0:\n\t\treturn 1\n\tif k == 1:\n\t\treturn n\n\tquestion = tuple((n, k))\n\tif question not in combinations_dynamic:\n\t\tcombinations_dynamic[question] = combinations(n - 1, k - 1) + combinations(n - 1, k)\n\treturn combinations_dynamic[question]\n\ndef read_int():\n\treturn [int(x) for x in input.readline().rstrip().split()]\ncommands = input.readline().rstrip()\nreceived = input.readline().rstrip()\ntarget = 0\nfor c in commands:\n\tif c == '+':\n\t\ttarget += 1\n\telse:\n\t\ttarget -= 1\n(position, drop) = (0, 0)\nfor c in received:\n\tif c == '+':\n\t\tposition += 1\n\telif c == '-':\n\t\tposition -= 1\n\telse:\n\t\tdrop += 1\nanswer = 1.0 if target == position else 0.0\nif drop > 0:\n\tneed = abs(target - position)\n\tif drop < need:\n\t\tanswer = 0.0\n\telse:\n\t\tplus = need\n\t\tif (drop - plus) % 2 != 0:\n\t\t\tanswer = 0.0\n\t\telse:\n\t\t\tplus += (drop - plus) // 2\n\t\t\tanswer = combinations(drop, plus) / 2 ** drop\noutput.write('%.12f\\n' % answer)\n"
    },
    {
        "task_id": 162,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 2.7836461067199707,
        "fastest_time": 2.575222969055176,
        "fastest_solution": "import math\nfrom decimal import *\nimport random\nimport math\nfrom decimal import *\nimport random\nfor _ in range(int(input())):\n\ts = str(input())\n\ts1 = ''\n\tn = len(s)\n\tp1 = 0\n\tpos = len(s) - 1\n\t(pre, suf) = ('', '')\n\tlongest = ''\n\tcont = True\n\tfor i in range(n):\n\t\tif s[i:] == s[i:][::-1]:\n\t\t\tif len(s[i:]) > len(longest):\n\t\t\t\tlongest = s[i:]\n\t\tif s[:i + 1] == s[:i + 1][::-1]:\n\t\t\tif len(s[:i + 1]) > len(longest):\n\t\t\t\tlongest = s[:i + 1]\n\twhile p1 <= pos:\n\t\tif p1 == pos:\n\t\t\tpre += s[p1]\n\t\telse:\n\t\t\tpre += s[p1]\n\t\t\tif s[pos] == s[p1] and cont:\n\t\t\t\tsuf = s[pos] + suf\n\t\t\t\tpos -= 1\n\t\t\telse:\n\t\t\t\tcont = False\n\t\tcomp = pre + suf\n\t\tif comp == comp[::-1]:\n\t\t\tif len(comp) > len(longest):\n\t\t\t\tlongest = comp\n\t\tp1 += 1\n\t(p1, p2) = (0, len(s) - 1)\n\t(pre, suf) = ('', '')\n\tcont = True\n\twhile p2 >= p1:\n\t\tif p2 == p1:\n\t\t\tsuf = s[p1] + suf\n\t\telse:\n\t\t\tsuf = s[p2] + suf\n\t\t\tif s[p1] == s[p2] and cont:\n\t\t\t\tpre += s[p1]\n\t\t\t\tp1 += 1\n\t\t\telse:\n\t\t\t\tcont = False\n\t\tcomp = pre + suf\n\t\tif comp == comp[::-1]:\n\t\t\tif len(comp) > len(longest):\n\t\t\t\tlongest = comp\n\t\tp2 -= 1\n\tprint(longest)\n",
        "slowest_solution": "temp = ''\n\ndef is_palindrome(a, b):\n\twhile a <= b:\n\t\tif temp[a] != temp[b]:\n\t\t\treturn 0\n\t\ta += 1\n\t\tb -= 1\n\treturn i + 1\nt = int(input())\nfor _ in range(t):\n\ts = input()\n\tn = len(s)\n\tans = 0\n\ta = 0\n\tb = n - 1\n\twhile a < b:\n\t\tif s[a] != s[b]:\n\t\t\tbreak\n\t\ta += 1\n\t\tb -= 1\n\tans = max(ans, a + n - 1 - b)\n\toc = ans\n\tp = s[a:b + 1]\n\ttoprint = ''\n\ttemp = ''\n\tfor i in range(len(p)):\n\t\ttemp += p[i]\n\t\tif oc + is_palindrome(0, i) > ans:\n\t\t\tans = oc + is_palindrome(0, i)\n\t\t\ttoprint = temp\n\ttemp = ''\n\tp = p[::-1]\n\tfor i in range(len(p)):\n\t\ttemp += p[i]\n\t\tif oc + is_palindrome(0, i) > ans:\n\t\t\tans = oc + is_palindrome(0, i)\n\t\t\ttoprint = temp\n\tprint(s[0:a] + toprint + s[0:a][::-1])\n"
    },
    {
        "task_id": 151,
        "slowest_solution_id": 1,
        "fastest_solution_id": 7,
        "slowest_time": 2.8355553150177,
        "fastest_time": 2.525935649871826,
        "fastest_solution": "def gcd(x, y):\n\twhile y:\n\t\t(x, y) = (y, x % y)\n\treturn x\n\ndef solution():\n\t(n, m) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\ta.sort()\n\tif len(a) == 1:\n\t\tfor j in range(m):\n\t\t\tprint(a[0] + b[j], end=' ')\n\t\tprint()\n\telse:\n\t\tif len(a) == 2:\n\t\t\tans = a[1] - a[0]\n\t\telse:\n\t\t\tans = gcd(a[1] - a[0], a[2] - a[0])\n\t\t\tfor i in range(3, n):\n\t\t\t\tans = gcd(ans, a[i] - a[0])\n\t\tfor j in range(m):\n\t\t\tprint(gcd(a[0] + b[j], ans), end=' ')\n\t\tprint()\nsolution()\n",
        "slowest_solution": "import math\n(n, m) = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\na1 = a[0]\nwithout_a1 = [a_i - a[0] for a_i in a[1:]]\ncommon_gcd = without_a1[0] if without_a1 else 0\nfor a_i in without_a1[1:]:\n\tcommon_gcd = math.gcd(common_gcd, a_i)\nprint(*[math.gcd(common_gcd, b_i + a1) for b_i in b], sep=' ')\n"
    },
    {
        "task_id": 190,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.739229440689087,
        "fastest_time": 2.654547929763794,
        "fastest_solution": "t = int(input())\nwhile t > 0:\n\t(n, q, m) = [int(i) for i in input().split()]\n\tarr = [int(i) for i in input().split()]\n\tfrom collections import defaultdict\n\td = defaultdict(int)\n\tdp = defaultdict(int)\n\tarrr = [0] * (m + 2)\n\tmmx = 0\n\tfor i in range(q):\n\t\t(l, r) = [int(i) for i in input().split()]\n\t\tl -= 1\n\t\tr -= 1\n\t\tdp[l, r] += 1\n\t\tmmx = max(mmx, arr[r])\n\tans = 0\n\tfor (i, j) in dp.items():\n\t\tl = min(i)\n\t\tr = max(i)\n\t\tx = arr[r]\n\t\ty = arr[l]\n\t\txx = arr[l] + 1\n\t\twhile True:\n\t\t\tif y > m or y > mmx + 1000:\n\t\t\t\tbreak\n\t\t\tarrr[y] += j\n\t\t\tif y + x > m:\n\t\t\t\tbreak\n\t\t\tarrr[y + x] -= j\n\t\t\ty += x + xx - 1\n\tfor i in range(1, m + 2):\n\t\tarrr[i] += arrr[i - 1]\n\t\tans = max(ans, arrr[i])\n\tprint(ans)\n\tt -= 1\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nimport numpy as np\nimport math\n\ndef solution(N, Q, M, A, queries):\n\tsol = 0\n\tlcm_ = A[0]\n\tminus_ = {}\n\tplus_ = {}\n\tfor [i, j] in queries:\n\t\tlcm_ = lcm_ * (A[i - 1] + A[j - 1]) // math.gcd(lcm_, A[i - 1] + A[j - 1])\n\t\tif lcm_ > M:\n\t\t\tbreak\n\tif lcm_ < M:\n\t\tM = lcm_\n\tdiffs = np.array([0 for _ in range(M + 1)])\n\tfor [i, j] in queries:\n\t\tminus_[A[i - 1] + A[j - 1]] = minus_.get(A[i - 1] + A[j - 1], 0) + 1\n\tfor [i, j] in queries:\n\t\tplus_[A[i - 1], A[i - 1] + A[j - 1]] = plus_.get((A[i - 1], A[i - 1] + A[j - 1]), 0) + 1\n\tfor (val, count) in minus_.items():\n\t\tdiffs[val:M + 1:val] -= count\n\tfor ((s, b), count) in plus_.items():\n\t\tdiffs[s:M + 1:b] += count\n\tcur = 0\n\tfor diff in diffs[1:]:\n\t\tcur += diff\n\t\tsol = max(sol, cur)\n\tprint(sol)\nT = int(input())\nfor t in range(T):\n\t(N, Q, M) = map(int, input().split())\n\tA = list(map(int, input().split()))\n\tqueries = [list(map(int, input().split())) for _ in range(Q)]\n\tsolution(N, Q, M, A, queries)\n"
    },
    {
        "task_id": 180,
        "slowest_solution_id": 6,
        "fastest_solution_id": 2,
        "slowest_time": 2.682629108428955,
        "fastest_time": 2.5512301921844482,
        "fastest_solution": "(n, k, p, x, y) = map(int, input().split())\na = list(map(int, input().split()))\nt = 0\nfor i in a:\n\tif i < y:\n\t\tt += 1\nm = (n + 1) // 2\nif t >= m:\n\tprint(-1)\nelse:\n\tans = []\n\tans += [y] * max(0, m - (k - t))\n\tk += max(0, m - (k - t))\n\tans += [1] * max(0, n - k)\n\tif sum(ans) + sum(a) <= x:\n\t\tfor i in ans[:-1]:\n\t\t\tprint(i, end=' ')\n\t\tprint(ans[-1])\n\telse:\n\t\tprint(-1)\n",
        "slowest_solution": "(n, k, p, x, y) = map(int, input().split())\nA = list(map(int, input().split()))\ncnt = n // 2 + 1\nfor i in A:\n\tif i >= y:\n\t\tcnt -= 1\ncnt = max(cnt, 0)\nif n - k < cnt:\n\tprint(-1)\nelse:\n\tB = [y] * cnt + [1] * (n - k - cnt)\n\tif sum(A) + sum(B) > x:\n\t\tprint(-1)\n\telse:\n\t\tfor i in B:\n\t\t\tprint(i, end=' ')\n"
    },
    {
        "task_id": 160,
        "slowest_solution_id": 1,
        "fastest_solution_id": 4,
        "slowest_time": 2.940311908721924,
        "fastest_time": 2.5048468112945557,
        "fastest_solution": "def divisors(M):\n\td = []\n\ti = 1\n\twhile M >= i ** 2:\n\t\tif M % i == 0:\n\t\t\td.append(i)\n\t\t\tif i ** 2 != M:\n\t\t\t\td.append(M // i)\n\t\ti = i + 1\n\treturn d\n\ndef popcount(x):\n\tx = x - (x >> 1 & 1431655765)\n\tx = (x & 858993459) + (x >> 2 & 858993459)\n\tx = x + (x >> 4) & 252645135\n\tx = x + (x >> 8)\n\tx = x + (x >> 16)\n\treturn x & 127\n\ndef eratosthenes(n):\n\tres = [0 for i in range(n + 1)]\n\tprime = set([])\n\tfor i in range(2, n + 1):\n\t\tif not res[i]:\n\t\t\tprime.add(i)\n\t\t\tfor j in range(1, n // i + 1):\n\t\t\t\tres[i * j] = 1\n\treturn prime\n\ndef factorization(n):\n\tres = []\n\tfor p in prime:\n\t\tif n % p == 0:\n\t\t\twhile n % p == 0:\n\t\t\t\tn //= p\n\t\t\tres.append(p)\n\tif n != 1:\n\t\tres.append(n)\n\treturn res\n\ndef euler_phi(n):\n\tres = n\n\tfor x in range(2, n + 1):\n\t\tif x ** 2 > n:\n\t\t\tbreak\n\t\tif n % x == 0:\n\t\t\tres = res // x * (x - 1)\n\t\t\twhile n % x == 0:\n\t\t\t\tn //= x\n\tif n != 1:\n\t\tres = res // n * (n - 1)\n\treturn res\n\ndef ind(b, n):\n\tres = 0\n\twhile n % b == 0:\n\t\tres += 1\n\t\tn //= b\n\treturn res\n\ndef isPrimeMR(n):\n\td = n - 1\n\td = d // (d & -d)\n\tL = [2, 3, 5, 7, 11, 13, 17]\n\tfor a in L:\n\t\tt = d\n\t\ty = pow(a, t, n)\n\t\tif y == 1:\n\t\t\tcontinue\n\t\twhile y != n - 1:\n\t\t\ty = y * y % n\n\t\t\tif y == 1 or t == n - 1:\n\t\t\t\treturn 0\n\t\t\tt <<= 1\n\treturn 1\n\ndef findFactorRho(n):\n\tfrom math import gcd\n\tm = 1 << n.bit_length() // 8\n\tfor c in range(1, 99):\n\t\tf = lambda x: (x * x + c) % n\n\t\t(y, r, q, g) = (2, 1, 1, 1)\n\t\twhile g == 1:\n\t\t\tx = y\n\t\t\tfor i in range(r):\n\t\t\t\ty = f(y)\n\t\t\tk = 0\n\t\t\twhile k < r and g == 1:\n\t\t\t\tys = y\n\t\t\t\tfor i in range(min(m, r - k)):\n\t\t\t\t\ty = f(y)\n\t\t\t\t\tq = q * abs(x - y) % n\n\t\t\t\tg = gcd(q, n)\n\t\t\t\tk += m\n\t\t\tr <<= 1\n\t\tif g == n:\n\t\t\tg = 1\n\t\t\twhile g == 1:\n\t\t\t\tys = f(ys)\n\t\t\t\tg = gcd(abs(x - ys), n)\n\t\tif g < n:\n\t\t\tif isPrimeMR(g):\n\t\t\t\treturn g\n\t\t\telif isPrimeMR(n // g):\n\t\t\t\treturn n // g\n\t\t\treturn findFactorRho(g)\n\ndef primeFactor(n):\n\ti = 2\n\tret = {}\n\trhoFlg = 0\n\twhile i * i <= n:\n\t\tk = 0\n\t\twhile n % i == 0:\n\t\t\tn //= i\n\t\t\tk += 1\n\t\tif k:\n\t\t\tret[i] = k\n\t\ti += 1 + i % 2\n\t\tif i == 101 and n >= 2 ** 20:\n\t\t\twhile n > 1:\n\t\t\t\tif isPrimeMR(n):\n\t\t\t\t\t(ret[n], n) = (1, 1)\n\t\t\t\telse:\n\t\t\t\t\trhoFlg = 1\n\t\t\t\t\tj = findFactorRho(n)\n\t\t\t\t\tk = 0\n\t\t\t\t\twhile n % j == 0:\n\t\t\t\t\t\tn //= j\n\t\t\t\t\t\tk += 1\n\t\t\t\t\tret[j] = k\n\tif n > 1:\n\t\tret[n] = 1\n\tif rhoFlg:\n\t\tret = {x: ret[x] for x in sorted(ret)}\n\treturn ret\n\ndef divisors(n):\n\tres = [1]\n\tprime = primeFactor(n)\n\tfor p in prime:\n\t\tnewres = []\n\t\tfor d in res:\n\t\t\tfor j in range(prime[p] + 1):\n\t\t\t\tnewres.append(d * p ** j)\n\t\tres = newres\n\tres.sort()\n\treturn res\n\ndef xorfactorial(num):\n\tif num == 0:\n\t\treturn 0\n\telif num == 1:\n\t\treturn 1\n\telif num == 2:\n\t\treturn 3\n\telif num == 3:\n\t\treturn 0\n\telse:\n\t\tx = baseorder(num)\n\t\treturn 2 ** x * ((num - 2 ** x + 1) % 2) + function(num - 2 ** x)\n\ndef xorconv(n, X, Y):\n\tif n == 0:\n\t\tres = [X[0] * Y[0] % mod]\n\t\treturn res\n\tx = [X[i] + X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\ty = [Y[i] + Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\tz = [X[i] - X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\tw = [Y[i] - Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\tres1 = xorconv(n - 1, x, y)\n\tres2 = xorconv(n - 1, z, w)\n\tformer = [(res1[i] + res2[i]) * inv for i in range(2 ** (n - 1))]\n\tlatter = [(res1[i] - res2[i]) * inv for i in range(2 ** (n - 1))]\n\tformer = list(map(lambda x: x % mod, former))\n\tlatter = list(map(lambda x: x % mod, latter))\n\treturn former + latter\n\ndef merge_sort(A, B):\n\t(pos_A, pos_B) = (0, 0)\n\t(n, m) = (len(A), len(B))\n\tres = []\n\twhile pos_A < n and pos_B < m:\n\t\t(a, b) = (A[pos_A], B[pos_B])\n\t\tif a < b:\n\t\t\tres.append(a)\n\t\t\tpos_A += 1\n\t\telse:\n\t\t\tres.append(b)\n\t\t\tpos_B += 1\n\tres += A[pos_A:]\n\tres += B[pos_B:]\n\treturn res\n\nclass UnionFindVerSize:\n\n\tdef __init__(self, N):\n\t\tself._parent = [n for n in range(0, N)]\n\t\tself._size = [1] * N\n\t\tself.group = N\n\n\tdef find_root(self, x):\n\t\tif self._parent[x] == x:\n\t\t\treturn x\n\t\tself._parent[x] = self.find_root(self._parent[x])\n\t\tstack = [x]\n\t\twhile self._parent[stack[-1]] != stack[-1]:\n\t\t\tstack.append(self._parent[stack[-1]])\n\t\tfor v in stack:\n\t\t\tself._parent[v] = stack[-1]\n\t\treturn self._parent[x]\n\n\tdef unite(self, x, y):\n\t\tgx = self.find_root(x)\n\t\tgy = self.find_root(y)\n\t\tif gx == gy:\n\t\t\treturn\n\t\tself.group -= 1\n\t\tif self._size[gx] < self._size[gy]:\n\t\t\tself._parent[gx] = gy\n\t\t\tself._size[gy] += self._size[gx]\n\t\telse:\n\t\t\tself._parent[gy] = gx\n\t\t\tself._size[gx] += self._size[gy]\n\n\tdef get_size(self, x):\n\t\treturn self._size[self.find_root(x)]\n\n\tdef is_same_group(self, x, y):\n\t\treturn self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind:\n\n\tdef __init__(self, N):\n\t\tself.parent = [i for i in range(N)]\n\t\tself.size = [1 for i in range(N)]\n\t\tself.val = [0 for i in range(N)]\n\t\tself.flag = True\n\t\tself.edge = [[] for i in range(N)]\n\n\tdef dfs(self, v, pv):\n\t\tstack = [(v, pv)]\n\t\tnew_parent = self.parent[pv]\n\t\twhile stack:\n\t\t\t(v, pv) = stack.pop()\n\t\t\tself.parent[v] = new_parent\n\t\t\tfor (nv, w) in self.edge[v]:\n\t\t\t\tif nv != pv:\n\t\t\t\t\tself.val[nv] = self.val[v] + w\n\t\t\t\t\tstack.append((nv, v))\n\n\tdef unite(self, x, y, w):\n\t\tif not self.flag:\n\t\t\treturn\n\t\tif self.parent[x] == self.parent[y]:\n\t\t\tself.flag = self.val[x] - self.val[y] == w\n\t\t\treturn\n\t\tif self.size[self.parent[x]] > self.size[self.parent[y]]:\n\t\t\tself.edge[x].append((y, -w))\n\t\t\tself.edge[y].append((x, w))\n\t\t\tself.size[x] += self.size[y]\n\t\t\tself.val[y] = self.val[x] - w\n\t\t\tself.dfs(y, x)\n\t\telse:\n\t\t\tself.edge[x].append((y, -w))\n\t\t\tself.edge[y].append((x, w))\n\t\t\tself.size[y] += self.size[x]\n\t\t\tself.val[x] = self.val[y] + w\n\t\t\tself.dfs(x, y)\n\nclass Dijkstra:\n\n\tclass Edge:\n\n\t\tdef __init__(self, _to, _cost):\n\t\t\tself.to = _to\n\t\t\tself.cost = _cost\n\n\tdef __init__(self, V):\n\t\tself.G = [[] for i in range(V)]\n\t\tself._E = 0\n\t\tself._V = V\n\n\t@property\n\tdef E(self):\n\t\treturn self._E\n\n\t@property\n\tdef V(self):\n\t\treturn self._V\n\n\tdef add_edge(self, _from, _to, _cost):\n\t\tself.G[_from].append(self.Edge(_to, _cost))\n\t\tself._E += 1\n\n\tdef shortest_path(self, s):\n\t\timport heapq\n\t\tque = []\n\t\td = [10 ** 15] * self.V\n\t\td[s] = 0\n\t\theapq.heappush(que, (0, s))\n\t\twhile len(que) != 0:\n\t\t\t(cost, v) = heapq.heappop(que)\n\t\t\tif d[v] < cost:\n\t\t\t\tcontinue\n\t\t\tfor i in range(len(self.G[v])):\n\t\t\t\te = self.G[v][i]\n\t\t\t\tif d[e.to] > d[v] + e.cost:\n\t\t\t\t\td[e.to] = d[v] + e.cost\n\t\t\t\t\theapq.heappush(que, (d[e.to], e.to))\n\t\treturn d\n\ndef Z_algorithm(s):\n\tN = len(s)\n\tZ_alg = [0] * N\n\tZ_alg[0] = N\n\ti = 1\n\tj = 0\n\twhile i < N:\n\t\twhile i + j < N and s[j] == s[i + j]:\n\t\t\tj += 1\n\t\tZ_alg[i] = j\n\t\tif j == 0:\n\t\t\ti += 1\n\t\t\tcontinue\n\t\tk = 1\n\t\twhile i + k < N and k + Z_alg[k] < j:\n\t\t\tZ_alg[i + k] = Z_alg[k]\n\t\t\tk += 1\n\t\ti += k\n\t\tj -= k\n\treturn Z_alg\n\nclass BIT:\n\n\tdef __init__(self, n, mod=0):\n\t\tself.BIT = [0] * (n + 1)\n\t\tself.num = n\n\t\tself.mod = mod\n\n\tdef query(self, idx):\n\t\tres_sum = 0\n\t\tmod = self.mod\n\t\twhile idx > 0:\n\t\t\tres_sum += self.BIT[idx]\n\t\t\tif mod:\n\t\t\t\tres_sum %= mod\n\t\t\tidx -= idx & -idx\n\t\treturn res_sum\n\n\tdef update(self, idx, x):\n\t\tmod = self.mod\n\t\twhile idx <= self.num:\n\t\t\tself.BIT[idx] += x\n\t\t\tif mod:\n\t\t\t\tself.BIT[idx] %= mod\n\t\t\tidx += idx & -idx\n\t\treturn\n\nclass dancinglink:\n\n\tdef __init__(self, n, debug=False):\n\t\tself.n = n\n\t\tself.debug = debug\n\t\tself._left = [i - 1 for i in range(n)]\n\t\tself._right = [i + 1 for i in range(n)]\n\t\tself.exist = [True for i in range(n)]\n\n\tdef pop(self, k):\n\t\tif self.debug:\n\t\t\tassert self.exist[k]\n\t\tL = self._left[k]\n\t\tR = self._right[k]\n\t\tif L != -1:\n\t\t\tif R != self.n:\n\t\t\t\t(self._right[L], self._left[R]) = (R, L)\n\t\t\telse:\n\t\t\t\tself._right[L] = self.n\n\t\telif R != self.n:\n\t\t\tself._left[R] = -1\n\t\tself.exist[k] = False\n\n\tdef left(self, idx, k=1):\n\t\tif self.debug:\n\t\t\tassert self.exist[idx]\n\t\tres = idx\n\t\twhile k:\n\t\t\tres = self._left[res]\n\t\t\tif res == -1:\n\t\t\t\tbreak\n\t\t\tk -= 1\n\t\treturn res\n\n\tdef right(self, idx, k=1):\n\t\tif self.debug:\n\t\t\tassert self.exist[idx]\n\t\tres = idx\n\t\twhile k:\n\t\t\tres = self._right[res]\n\t\t\tif res == self.n:\n\t\t\t\tbreak\n\t\t\tk -= 1\n\t\treturn res\n\nclass SparseTable:\n\n\tdef __init__(self, A, merge_func, ide_ele):\n\t\tN = len(A)\n\t\tn = N.bit_length()\n\t\tself.table = [[ide_ele for i in range(n)] for i in range(N)]\n\t\tself.merge_func = merge_func\n\t\tfor i in range(N):\n\t\t\tself.table[i][0] = A[i]\n\t\tfor j in range(1, n):\n\t\t\tfor i in range(0, N - 2 ** j + 1):\n\t\t\t\tf = self.table[i][j - 1]\n\t\t\t\ts = self.table[i + 2 ** (j - 1)][j - 1]\n\t\t\t\tself.table[i][j] = self.merge_func(f, s)\n\n\tdef query(self, s, t):\n\t\tb = t - s + 1\n\t\tm = b.bit_length() - 1\n\t\treturn self.merge_func(self.table[s][m], self.table[t - 2 ** m + 1][m])\n\nclass BinaryTrie:\n\n\tclass node:\n\n\t\tdef __init__(self, val):\n\t\t\tself.left = None\n\t\t\tself.right = None\n\t\t\tself.max = val\n\n\tdef __init__(self):\n\t\tself.root = self.node(-10 ** 15)\n\n\tdef append(self, key, val):\n\t\tpos = self.root\n\t\tfor i in range(29, -1, -1):\n\t\t\tpos.max = max(pos.max, val)\n\t\t\tif key >> i & 1:\n\t\t\t\tif pos.right is None:\n\t\t\t\t\tpos.right = self.node(val)\n\t\t\t\t\tpos = pos.right\n\t\t\t\telse:\n\t\t\t\t\tpos = pos.right\n\t\t\telif pos.left is None:\n\t\t\t\tpos.left = self.node(val)\n\t\t\t\tpos = pos.left\n\t\t\telse:\n\t\t\t\tpos = pos.left\n\t\tpos.max = max(pos.max, val)\n\n\tdef search(self, M, xor):\n\t\tres = -10 ** 15\n\t\tpos = self.root\n\t\tfor i in range(29, -1, -1):\n\t\t\tif pos is None:\n\t\t\t\tbreak\n\t\t\tif M >> i & 1:\n\t\t\t\tif xor >> i & 1:\n\t\t\t\t\tif pos.right:\n\t\t\t\t\t\tres = max(res, pos.right.max)\n\t\t\t\t\tpos = pos.left\n\t\t\t\telse:\n\t\t\t\t\tif pos.left:\n\t\t\t\t\t\tres = max(res, pos.left.max)\n\t\t\t\t\tpos = pos.right\n\t\t\telif xor >> i & 1:\n\t\t\t\tpos = pos.right\n\t\t\telse:\n\t\t\t\tpos = pos.left\n\t\tif pos:\n\t\t\tres = max(res, pos.max)\n\t\treturn res\n\ndef solveequation(edge, ans, n, m):\n\tx = [0] * m\n\tused = [False] * n\n\tfor v in range(n):\n\t\tif used[v]:\n\t\t\tcontinue\n\t\ty = dfs(v)\n\t\tif y != 0:\n\t\t\treturn False\n\treturn x\n\n\tdef dfs(v):\n\t\tused[v] = True\n\t\tr = ans[v]\n\t\tfor (to, dire, id) in edge[v]:\n\t\t\tif used[to]:\n\t\t\t\tcontinue\n\t\t\ty = dfs(to)\n\t\t\tif dire == -1:\n\t\t\t\tx[id] = y\n\t\t\telse:\n\t\t\t\tx[id] = -y\n\t\t\tr += y\n\t\treturn r\n\nclass SegmentTree:\n\n\tdef __init__(self, init_val, segfunc, ide_ele):\n\t\tn = len(init_val)\n\t\tself.segfunc = segfunc\n\t\tself.ide_ele = ide_ele\n\t\tself.num = 1 << (n - 1).bit_length()\n\t\tself.tree = [ide_ele] * 2 * self.num\n\t\tself.size = n\n\t\tfor i in range(n):\n\t\t\tself.tree[self.num + i] = init_val[i]\n\t\tfor i in range(self.num - 1, 0, -1):\n\t\t\tself.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n\tdef update(self, k, x):\n\t\tk += self.num\n\t\tself.tree[k] = x\n\t\twhile k > 1:\n\t\t\tself.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n\t\t\tk >>= 1\n\n\tdef query(self, l, r):\n\t\tif r == self.size:\n\t\t\tr = self.num\n\t\tres = self.ide_ele\n\t\tl += self.num\n\t\tr += self.num\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tres = self.segfunc(res, self.tree[l])\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tres = self.segfunc(res, self.tree[r - 1])\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\treturn res\n\n\tdef bisect_l(self, l, r, x):\n\t\tl += self.num\n\t\tr += self.num\n\t\tLmin = -1\n\t\tRmin = -1\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tif self.tree[l] <= x and Lmin == -1:\n\t\t\t\t\tLmin = l\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tif self.tree[r - 1] <= x:\n\t\t\t\t\tRmin = r - 1\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\tif Lmin != -1:\n\t\t\tpos = Lmin\n\t\t\twhile pos < self.num:\n\t\t\t\tif self.tree[2 * pos] <= x:\n\t\t\t\t\tpos = 2 * pos\n\t\t\t\telse:\n\t\t\t\t\tpos = 2 * pos + 1\n\t\t\treturn pos - self.num\n\t\telif Rmin != -1:\n\t\t\tpos = Rmin\n\t\t\twhile pos < self.num:\n\t\t\t\tif self.tree[2 * pos] <= x:\n\t\t\t\t\tpos = 2 * pos\n\t\t\t\telse:\n\t\t\t\t\tpos = 2 * pos + 1\n\t\t\treturn pos - self.num\n\t\telse:\n\t\t\treturn -1\nimport sys, random, bisect\nfrom collections import deque, defaultdict\nfrom heapq import heapify, heappop, heappush\nfrom itertools import permutations\nfrom math import gcd, log\ninput = lambda : sys.stdin.buffer.readline()\nmi = lambda : map(int, input().split())\nli = lambda : list(mi())\nn = int(input())\nxy = [mi() for i in range(n)]\nfor i in range(n):\n\t(x, y) = xy[i]\n\txy[i] = (x // 2, y // 2)\nparity = [0 for i in range(4)]\nfor (x, y) in xy:\n\tp = 2 * (x & 1) + (y & 1)\n\tparity[p] += 1\nres = 0\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\t(x0, y0) = xy[i]\n\t\t(x1, y1) = xy[j]\n\t\tif x0 - x1 & 1 == 0 and y0 - y1 & 1 == 0:\n\t\t\tt = 0\n\t\telse:\n\t\t\tt = 1\n\t\tfor p in range(4):\n\t\t\tx2 = p >> 1 & 1\n\t\t\ty2 = p & 1\n\t\t\ttmp = t\n\t\t\tif x0 - x2 & 1 or y0 - y2 & 1:\n\t\t\t\ttmp += 1\n\t\t\tif x1 - x2 & 1 or y1 - y2 & 1:\n\t\t\t\ttmp += 1\n\t\t\tif tmp & 1 == 0:\n\t\t\t\tplus = parity[p]\n\t\t\t\tif 2 * (x0 & 1) + (y0 & 1) == p:\n\t\t\t\t\tplus -= 1\n\t\t\t\tif 2 * (x1 & 1) + (y1 & 1) == p:\n\t\t\t\t\tplus -= 1\n\t\t\t\tres += plus\nprint(res // 3)\n",
        "slowest_solution": "n = int(input())\nnum = [0, 0, 0, 0]\nfor _ in range(n):\n\t(x, y) = map(int, input().split())\n\tnum[bool(x & 2) + (y & 2)] += 1\nprint(n * (n - 1) * (n - 2) // 6 - num[0] * num[1] * num[2] - num[0] * num[1] * num[3] - num[0] * num[2] * num[3] - num[1] * num[2] * num[3])\n"
    },
    {
        "task_id": 179,
        "slowest_solution_id": 3,
        "fastest_solution_id": 1,
        "slowest_time": 2.712515354156494,
        "fastest_time": 2.4805641174316406,
        "fastest_solution": "def seating_arrangement(T):\n\tmax_people = []\n\tfor i in range(T):\n\t\t(N, M, Z, L, R, B) = map(int, input().strip().split())\n\t\tmax_people.append(min(N * M, L + R + Z + min(B, N * (M + 1) - L - R >> 1, N * (M + 1 >> 1))))\n\treturn max_people\nT = int(input())\nfor i in seating_arrangement(T):\n\tprint(i)\n",
        "slowest_solution": "import math\ncases = []\nfor i in range(int(input())):\n\tcases.append(input().split())\nfor case in cases:\n\tN = int(case[0])\n\tM = int(case[1])\n\tZ = int(case[2])\n\tL = int(case[3])\n\tR = int(case[4])\n\tB = int(case[5])\n\tif L + R + Z >= M * N:\n\t\tprint(M * N)\n\telse:\n\t\tarr1 = math.floor((N * (M + 1) - L - R) / 2)\n\t\tarr2 = math.ceil(M / 2) * N\n\t\tarr3 = M * N - L - R - Z\n\t\tprint(Z + L + R + min(B, arr1, arr2, arr3))\n"
    },
    {
        "task_id": 155,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 2.7761025428771973,
        "fastest_time": 2.507145404815674,
        "fastest_solution": "import sys\nt = int(input())\n\ndef find(x):\n\tx.sort()\n\treturn x[len(x) // 2] - x[(len(x) - 1) // 2] + 1\nfor _ in range(t):\n\tn = int(input())\n\tx = list()\n\ty = list()\n\tfor _ in range(n):\n\t\t(x1, y1) = map(int, input().split())\n\t\tx.append(x1)\n\t\ty.append(y1)\n\tx = sorted(x)\n\ty = sorted(y)\n\tprint(find(x) * find(y))\n",
        "slowest_solution": "import math as m\n\ndef count(zoz, x, y):\n\tpoc = 0\n\tfor i in zoz:\n\t\tpoc += abs(x - i[0])\n\t\tpoc += abs(y - i[1])\n\treturn poc\nres = []\nfor _ in range(int(input())):\n\tn = int(input())\n\txes = []\n\tyes = []\n\tfor i in range(n):\n\t\tsur = [int(x) for x in input().split()]\n\t\txes.append(sur[0])\n\t\tyes.append(sur[1])\n\txes.sort()\n\tyes.sort()\n\tx = xes[int(len(xes) / 2)] - xes[int((len(xes) - 1) / 2)] + 1\n\ty = yes[int(len(yes) / 2)] - yes[int((len(yes) - 1) / 2)] + 1\n\tres.append(x * y)\nfor i in res:\n\tprint(i)\n"
    },
    {
        "task_id": 168,
        "slowest_solution_id": 0,
        "fastest_solution_id": 4,
        "slowest_time": 2.746692657470703,
        "fastest_time": 2.5771937370300293,
        "fastest_solution": "n = int(input())\nl = input().split()\nfor i in range(n):\n\tl[i] = int(l[i])\n\twhile l[i] % 2 == 0:\n\t\tl[i] /= 2\n\twhile l[i] % 3 == 0:\n\t\tl[i] /= 3\nflag = 1\nfor i in range(n):\n\tif l[i] != l[0]:\n\t\tprint('No')\n\t\tflag = 0\n\t\tbreak\nif flag:\n\tprint('Yes')\n",
        "slowest_solution": "n = int(input())\narr = list(map(int, input().split()))\nl = []\nfor i in arr:\n\tx = i\n\twhile x % 2 == 0:\n\t\tx /= 2\n\twhile x % 3 == 0:\n\t\tx /= 3\n\tl.append(x)\nif len(set(l)) == 1:\n\tprint('Yes')\nelse:\n\tprint('No')\n"
    },
    {
        "task_id": 159,
        "slowest_solution_id": 1,
        "fastest_solution_id": 8,
        "slowest_time": 2.968789577484131,
        "fastest_time": 2.53315806388855,
        "fastest_solution": "for _ in range(int(input())):\n\t(N, M) = list(map(int, input().split()))\n\tmod = 1000000007\n\tx = 111111112\n\ty = 1000000006\n\t(p, q) = [[[2, 1, -1, -2, -1, 1][N % 6] + pow(2, N, mod), [-1, 1, 2, 1, -1, -2][N % 6] + pow(2, N, mod), [-1, -2, -1, 1, 2, 1][N % 6] + pow(2, N, mod)], [[2, 1, -1, -2, -1, 1][M % 6] + pow(2, M, mod), [-1, 1, 2, 1, -1, -2][M % 6] + pow(2, M, mod), [-1, -2, -1, 1, 2, 1][M % 6] + pow(2, M, mod)]]\n\tprint(((p[0] * q[0] + p[1] * q[1] + p[2] * q[2]) * x + y) % mod)\n",
        "slowest_solution": "def power(b, n):\n\ts = 1\n\twhile n:\n\t\tif n % 2 == 1:\n\t\t\ts = s * b % MOD\n\t\tb = b * b % MOD\n\t\tn //= 2\n\treturn s\n\ndef Inv(x):\n\treturn power(x, MOD - 2)\nMOD = 1000000007\nfor _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\ta = [0, 0, 0]\n\tb = [0, 0, 0]\n\ta[0] = ([2, 1, -1, -2, -1, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n\ta[1] = ([-1, 1, 2, 1, -1, -2][n % 6] + power(2, n)) * Inv(3) % MOD\n\ta[2] = ([-1, -2, -1, 1, 2, 1][n % 6] + power(2, n)) * Inv(3) % MOD\n\tb[0] = ([2, 1, -1, -2, -1, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n\tb[1] = ([-1, 1, 2, 1, -1, -2][m % 6] + power(2, m)) * Inv(3) % MOD\n\tb[2] = ([-1, -2, -1, 1, 2, 1][m % 6] + power(2, m)) * Inv(3) % MOD\n\tprint(((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) % MOD + MOD - 1) % MOD)\n"
    },
    {
        "task_id": 197,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.718299388885498,
        "fastest_time": 2.6111743450164795,
        "fastest_solution": "def powm(x, y):\n\tif y == 1:\n\t\treturn x\n\telif y == 0:\n\t\treturn 1\n\telif y % 2 == 0:\n\t\tans = powm(x, y // 2)\n\t\tans *= ans\n\t\tans %= 1000000007\n\t\treturn ans\n\telse:\n\t\treturn powm(x, y - 1) * x % 1000000007\n\ndef findMulInv(n):\n\tnowCheck = 1000000007 + 1\n\twhile nowCheck % n != 0:\n\t\tnowCheck += 1000000007\n\treturn nowCheck // n\n\ndef solve():\n\tstr = input().split()\n\tn = int(str[0])\n\tk = int(str[1])\n\tans = 0\n\tif k != 1:\n\t\tmuli = findMulInv(k - 1)\n\t\tans += k * (-2 * (2 * n * n + 2 * n + 1) * powm(k, n + 1) + n * (2 * n + 1) * powm(k, n + 2) + (4 * n + 3) * powm(k, 2 * n + 1) - (4 * n + 1) * powm(k, 2 * n + 2) + powm(k, 3 * n + 2) + (2 * n * n + 3 * n + 1) * powm(k, n) - k - 1)\n\t\tans -= powm(k, n + 1) * (-2 * n * powm(k, n + 1) - powm(k, n + 1) + 2 * n * powm(k, n + 2) - powm(k, n + 2) - k * k * n * n + k * k + 2 * k * n * n + k - n * n)\n\t\tans -= k * ((2 * n + 1) * powm(k, n + 1) + n * powm(k, n + 2) - 2 * powm(k, 2 * n + 1) - (3 * n + 1) * powm(k, n) + k + 1)\n\t\tans %= 1000000007\n\t\tans *= muli ** 3\n\tans %= 1000000007\n\tprint(int(ans))\nfor tc in range(int(input())):\n\tsolve()\n",
        "slowest_solution": "from itertools import *\nMOD = 10 ** 9 + 7\n\ndef isPrefix(a, b):\n\tif len(a) > len(b):\n\t\treturn False\n\tif a == b[:len(a)]:\n\t\treturn True\n\treturn False\n\ndef bruteforce(N, K):\n\tS = []\n\tfor i in range(1, N + 1):\n\t\tfor p in product(range(K), repeat=i):\n\t\t\ts = ''.join((chr(j + ord('a')) for j in p))\n\t\t\tS.append(s)\n\tans = 0\n\tfor a in S:\n\t\tfor b in S:\n\t\t\tif isPrefix(a, b) or isPrefix(b, a):\n\t\t\t\tcontinue\n\t\t\tfor c in S:\n\t\t\t\tif isPrefix(a, c) or isPrefix(c, a):\n\t\t\t\t\tcontinue\n\t\t\t\tif isPrefix(b, c) or isPrefix(c, b):\n\t\t\t\t\tcontinue\n\t\t\t\tprint(a, b, c)\n\t\t\t\tans += 1\n\tprint(ans)\n\treturn ans\n\ndef countPrefixesFor2(n, k):\n\tmodinv = pow(k - 1, MOD - 2, MOD)\n\ttmp1 = modinv * k * (pow(k, n, MOD) + MOD - 1)\n\ttmp2 = modinv * n * (pow(k, n + 1, MOD) + MOD - 1)\n\ttmp3 = (modinv * (pow(k, n + 2, MOD) + MOD - 1) + MOD - (n + 1 + k) % MOD) * modinv\n\ttmp2 = tmp2 + MOD - tmp3\n\treturn (tmp1 + 2 * tmp2) % MOD\n\ndef countPrefixesFor3(n, k):\n\tmodinv = pow(k - 1, MOD - 2, MOD)\n\tans = k * (pow(k, n, MOD) + MOD - 1) * modinv\n\ttmp01 = n * (pow(k, n + 1, MOD) + MOD - 1) * modinv\n\ttmp02 = modinv * ((pow(k, n + 2, MOD) + MOD - 1) * modinv + (2 * MOD - n - 1 - k))\n\ttmp02 %= MOD\n\ttmp0 = tmp01 + (MOD - tmp02)\n\tans = (ans + 3 * tmp0) % MOD\n\ttmp1 = modinv * (pow(k, 2 * n, MOD) + MOD - pow(k, n + 1, MOD))\n\ttmp2 = MOD - 2 * (n - 1) * pow(k, n, MOD) % MOD\n\ttmp3 = k * (pow(k, n - 1, MOD) + MOD - 1) * modinv\n\ttmp4 = (tmp1 + tmp2 + tmp3) * k * k * modinv * modinv\n\tans += 3 * tmp4\n\tans %= MOD\n\treturn ans\n\ndef bruteforce2(N, K):\n\tS = []\n\tfor i in range(1, N + 1):\n\t\tfor p in product(range(K), repeat=i):\n\t\t\ts = ''.join((chr(j + ord('a')) for j in p))\n\t\t\tS.append(s)\n\tans = 0\n\tfor a in S:\n\t\tfor b in S:\n\t\t\tif isPrefix(a, b) or isPrefix(b, a):\n\t\t\t\tans += 1\n\tprint(ans, countPrefixesFor2(N, K))\n\ndef computeAns2(n, k):\n\tans2 = 0\n\tfor i in range(3, n + 1):\n\t\ttmp = (i - 2) * (i - 1) // 2 * k ** i\n\t\tans2 += tmp\n\treturn 6 * ans2\ndp_fastAns2 = [[]]\n\ndef computeFastAns2():\n\tfor k in range(1, 26 + 1):\n\t\trow = [0, 0, 0]\n\t\ttmp = k ** 2\n\t\tfor n in range(3, 10 ** 5 + 1):\n\t\t\ttmp = tmp * k % MOD\n\t\t\ttmp2 = (n - 2) * (n - 1) // 2\n\t\t\trow.append((row[-1] + tmp * tmp2) % MOD)\n\t\tdp_fastAns2.append(row)\n\ndef computeAns2Fastest(n, k):\n\tmodinv = pow(2, MOD - 2, MOD)\n\ttmp0 = modinv * zz(n, k)\n\ttmp1 = MOD - 3 * modinv * y(n, k) % MOD\n\tinv2 = pow(k - 1, MOD - 2, MOD)\n\ttmp3 = k * inv2 * (pow(k, n, MOD) + MOD - 1)\n\treturn (tmp0 + tmp1 + tmp3) % MOD\n\ndef y(n, k):\n\tmodinv = pow(k - 1, MOD - 2, MOD)\n\tans = modinv ** 2 * k\n\ttmp = ((k - 1) * n + MOD - 1) * pow(k, n, MOD) + 1\n\tans = ans * tmp % MOD\n\treturn ans\n\tans = 0\n\tfor i in range(1, n + 1):\n\t\tans += i * k ** i\n\treturn ans\n\ndef z(n, k):\n\tans = 0\n\tfor i in range(1, n + 1):\n\t\tans += i ** 2 * k ** i\n\treturn ans / k\n\ndef zz(n, k):\n\tmodinv = pow(k - 1, MOD - 2, MOD)\n\tans = k * pow(modinv, 3, MOD)\n\ttmp1 = n ** 2 * pow(k, n + 2, MOD)\n\ttmp2 = MOD - (2 * n * (n + 1) - 1) * pow(k, n + 1, MOD) % MOD\n\ttmp3 = (n + 1) ** 2 * pow(k, n, MOD) + (MOD - k - 1)\n\tans *= (tmp1 + tmp2 + tmp3) % MOD\n\tans %= MOD\n\treturn ans\n\ttmp = k * (n ** 2 * k ** (n + 2) - (2 * n * (n + 1) - 1) * k ** (n + 1) + (n + 1) ** 2 * k ** n - k - 1) // (k - 1) ** 3\n\treturn tmp % MOD\n\ndef bruteforce3(n, k):\n\tS = []\n\tfor i in range(1, n + 1):\n\t\tfor p in product(range(k), repeat=i):\n\t\t\ts = ''.join((chr(j + ord('a')) for j in p))\n\t\t\tS.append(s)\n\tans = 0\n\tans2 = 0\n\tans3 = 0\n\tfor a in S:\n\t\tfor b in S:\n\t\t\tfor c in S:\n\t\t\t\ttmp = 0\n\t\t\t\tif isPrefix(a, b) or isPrefix(b, a):\n\t\t\t\t\ttmp += 1\n\t\t\t\tif isPrefix(a, c) or isPrefix(c, a):\n\t\t\t\t\ttmp += 1\n\t\t\t\tif isPrefix(b, c) or isPrefix(c, b):\n\t\t\t\t\ttmp += 1\n\t\t\t\tif tmp == 3:\n\t\t\t\t\tif a == b and a == c and (b == c):\n\t\t\t\t\t\tans3 += 1\n\t\t\t\t\telif a == b and a != c or (a == c and a != b) or (b == c and b != a):\n\t\t\t\t\t\tans3 += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint(a, b, c)\n\t\t\t\t\t\tans2 += 1\n\t\t\t\tif not (isPrefix(a, b) or isPrefix(b, a) or isPrefix(a, c) or isPrefix(c, a) or isPrefix(b, c) or isPrefix(c, b)):\n\t\t\t\t\tans += 1\n\tprint(ans, f(n, k) + ans2)\n\tprint('ans2:', ans2, ans2 / 6)\n\tprint('cans2:', computeAns2(n, k))\n\ndef f(n, k):\n\tmodinv = pow(k - 1, MOD - 2, MOD)\n\ttmp = k * (pow(k, n, MOD) + MOD - 1) * modinv\n\tans = pow(tmp, 3, MOD)\n\tCOUNT2 = countPrefixesFor2(n, k)\n\ttmp0 = 3 * COUNT2 * tmp % MOD\n\tans = ans + MOD - tmp0\n\tans += countPrefixesFor3(n, k)\n\tans += 3 * COUNT2\n\tans = ans + MOD - 2 * tmp % MOD\n\tans += 6 * computeAns2Fastest(n, k)\n\tans %= MOD\n\treturn ans\n\ndef main():\n\tT = int(input())\n\tfor t in range(T):\n\t\t(n, k) = [int(x) for x in input().split()]\n\t\tif k == 1:\n\t\t\tprint(0)\n\t\telse:\n\t\t\tprint(f(n, k))\nmain()\n"
    },
    {
        "task_id": 170,
        "slowest_solution_id": 5,
        "fastest_solution_id": 1,
        "slowest_time": 2.7009191513061523,
        "fastest_time": 2.5081872940063477,
        "fastest_solution": "from collections import deque\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\ngrid = [[0 for x in range(55)] for y in range(55)]\nDX = [0, 1, 0, -1]\nDY = [1, 0, -1, 0]\n\ndef bfs(n, m, badGuy, goodGuy):\n\tvisited = [[0 for x in range(m)] for y in range(n)]\n\tq = deque([[n - 1, m - 1]])\n\tvisited[n - 1][m - 1] = 1\n\twhile len(q):\n\t\t(x, y) = q.popleft()\n\t\tif badGuy and grid[x][y] == 'B':\n\t\t\treturn 'No'\n\t\tif goodGuy and grid[x][y] == 'G':\n\t\t\tgrid[x][y] = '.'\n\t\tfor (dx, dy) in zip(DX, DY):\n\t\t\tif 0 <= x + dx < n and 0 <= y + dy < m:\n\t\t\t\tif grid[x + dx][y + dy] != '#' and (not visited[x + dx][y + dy]):\n\t\t\t\t\tvisited[x + dx][y + dy] = True\n\t\t\t\t\tq.append([x + dx, y + dy])\n\tfor x in range(n):\n\t\tfor y in range(m):\n\t\t\tif grid[x][y] == 'G':\n\t\t\t\treturn 'No'\n\treturn 'Yes'\n\ndef solve(n, m):\n\tbadGuy = False\n\tgoodGuy = False\n\tfor x in range(n):\n\t\tfor y in range(m):\n\t\t\tif grid[x][y] == 'B':\n\t\t\t\tbadGuy = True\n\t\t\t\tfor (dx, dy) in zip(DX, DY):\n\t\t\t\t\tif 0 <= x + dx < n and 0 <= y + dy < m:\n\t\t\t\t\t\tif grid[x + dx][y + dy] == 'G':\n\t\t\t\t\t\t\treturn 'No'\n\t\t\t\t\t\tif grid[x + dx][y + dy] == '.':\n\t\t\t\t\t\t\tgrid[x + dx][y + dy] = '#'\n\t\t\tif grid[x][y] == 'G':\n\t\t\t\tgoodGuy = True\n\tif not goodGuy:\n\t\treturn 'Yes'\n\treturn bfs(n, m, badGuy, goodGuy)\nt = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\tfor x in range(n):\n\t\ttemp = input()\n\t\tfor y in range(m):\n\t\t\tgrid[x][y] = temp[y]\n\tprint(solve(n, m))\n",
        "slowest_solution": "import math\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass Graph:\n\n\tdef __init__(self):\n\t\tself.graph = defaultdict(list)\n\n\tdef addEdge(self, u, v):\n\t\tself.graph[u].append(v)\n\n\tdef BFS(self, a):\n\t\tvisited = [False] * (n * m + 1)\n\t\tqueue = []\n\t\tqueue.append(n * m)\n\t\tvisited[n * m] = True\n\t\twhile queue:\n\t\t\ts = queue.pop(0)\n\t\t\tfor i in self.graph[s]:\n\t\t\t\tif visited[i] == False:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tvisited[i] = True\n\t\tfor i in range(len(a)):\n\t\t\tif visited[a[i]] == False:\n\t\t\t\treturn False\n\t\treturn True\n\ndef isSafe(i, j, matrix):\n\tif i >= 0 and i < len(matrix) and (j >= 0) and (j < len(matrix[0])) and (matrix[i][j] != '#'):\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef findPath(M):\n\tN = len(M)\n\tm = len(M[0])\n\tg = Graph()\n\tk = 1\n\ta = []\n\tfor i in range(N):\n\t\tfor j in range(m):\n\t\t\tif M[i][j] != '#':\n\t\t\t\tif isSafe(i, j + 1, M):\n\t\t\t\t\tg.addEdge(k, k + 1)\n\t\t\t\tif isSafe(i, j - 1, M):\n\t\t\t\t\tg.addEdge(k, k - 1)\n\t\t\t\tif isSafe(i + 1, j, M):\n\t\t\t\t\tg.addEdge(k, k + m)\n\t\t\t\tif isSafe(i - 1, j, M):\n\t\t\t\t\tg.addEdge(k, k - m)\n\t\t\t\tif M[i][j] == 'G':\n\t\t\t\t\ta.append(k)\n\t\t\tk += 1\n\treturn g.BFS(a)\nfor i in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tmatrix = [[0 for i in range(m)] for j in range(n)]\n\tfrom collections import defaultdict\n\ts = []\n\tc = 0\n\tf = 0\n\tc1 = 0\n\tw = []\n\tfor j in range(n):\n\t\ts.append(list(input()))\n\t\tc += s[-1].count('G')\n\tif c == 0:\n\t\tprint('Yes')\n\t\tcontinue\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif s[i][j] == 'B':\n\t\t\t\tw.append((i, j))\n\tfor y in w:\n\t\ti = y[0]\n\t\tj = y[1]\n\t\tif i > 0:\n\t\t\tif s[i - 1][j] == 'G':\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\t\ts[i - 1][j] = '#'\n\t\tif j > 0:\n\t\t\tif s[i][j - 1] == 'G':\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\t\ts[i][j - 1] = '#'\n\t\tif i < n - 1:\n\t\t\tif s[i + 1][j] == 'G':\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\t\ts[i + 1][j] = '#'\n\t\tif j < m - 1:\n\t\t\tif s[i][j + 1] == 'G':\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\t\ts[i][j + 1] = '#'\n\te = []\n\tif f == 1:\n\t\tprint('No')\n\t\tcontinue\n\telif findPath(s) == True:\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')\n"
    },
    {
        "task_id": 207,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5922060012817383,
        "fastest_time": 2.5922060012817383,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nclass FenwickTree:\n\n\tdef __init__(self, x):\n\t\tself.bit = x\n\t\tfor i in range(len(x)):\n\t\t\tj = i | i + 1\n\t\t\tif j < len(x):\n\t\t\t\tx[j] += x[i]\n\n\tdef update(self, idx, x):\n\t\twhile idx < len(self.bit):\n\t\t\tself.bit[idx] += x\n\t\t\tidx |= idx + 1\n\n\tdef query(self, end):\n\t\tx = 0\n\t\twhile end:\n\t\t\tx += self.bit[end - 1]\n\t\t\tend &= end - 1\n\t\treturn x\n\n\tdef findkth(self, k):\n\t\tidx = -1\n\t\tfor d in reversed(range(len(self.bit).bit_length())):\n\t\t\tright_idx = idx + (1 << d)\n\t\t\tif right_idx < len(self.bit) and k >= self.bit[right_idx]:\n\t\t\t\tidx = right_idx\n\t\t\t\tk -= self.bit[idx]\n\t\treturn idx + 1\n\ndef lb(a, x):\n\t(l, r) = (-1, len(a))\n\twhile r - l > 1:\n\t\tm = (l + r) // 2\n\t\tif a[m] < x:\n\t\t\tl = m\n\t\telse:\n\t\t\tr = m\n\treturn r\n\ndef main():\n\t(n, m) = map(int, input().split())\n\ts = input()\n\ta = [[] for _ in range(256)]\n\tb = FenwickTree([1] * len(s))\n\tfor (i, x) in enumerate(s):\n\t\ta[ord(x)].append(i + 1)\n\tfor _ in range(m):\n\t\t(l, r, c) = input().split()\n\t\t(l, r) = map(int, [l, r])\n\t\t(l, r) = (b.findkth(l), b.findkth(r))\n\t\tc = ord(c)\n\t\tl = lb(a[c], l)\n\t\tr = lb(a[c], r + 1)\n\t\tfor j in range(l, r):\n\t\t\tb.update(a[c][j], -1)\n\t\t\tn -= 1\n\t\ta[c] = a[c][:l] + a[c][r:]\n\tb = [x for x in map(b.findkth, range(1, n + 1))]\n\tprint(''.join((s[x - 1] for x in b)))\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nclass FenwickTree:\n\n\tdef __init__(self, x):\n\t\tself.bit = x\n\t\tfor i in range(len(x)):\n\t\t\tj = i | i + 1\n\t\t\tif j < len(x):\n\t\t\t\tx[j] += x[i]\n\n\tdef update(self, idx, x):\n\t\twhile idx < len(self.bit):\n\t\t\tself.bit[idx] += x\n\t\t\tidx |= idx + 1\n\n\tdef query(self, end):\n\t\tx = 0\n\t\twhile end:\n\t\t\tx += self.bit[end - 1]\n\t\t\tend &= end - 1\n\t\treturn x\n\n\tdef findkth(self, k):\n\t\tidx = -1\n\t\tfor d in reversed(range(len(self.bit).bit_length())):\n\t\t\tright_idx = idx + (1 << d)\n\t\t\tif right_idx < len(self.bit) and k >= self.bit[right_idx]:\n\t\t\t\tidx = right_idx\n\t\t\t\tk -= self.bit[idx]\n\t\treturn idx + 1\n\ndef lb(a, x):\n\t(l, r) = (-1, len(a))\n\twhile r - l > 1:\n\t\tm = (l + r) // 2\n\t\tif a[m] < x:\n\t\t\tl = m\n\t\telse:\n\t\t\tr = m\n\treturn r\n\ndef main():\n\t(n, m) = map(int, input().split())\n\ts = input()\n\ta = [[] for _ in range(256)]\n\tb = FenwickTree([1] * len(s))\n\tfor (i, x) in enumerate(s):\n\t\ta[ord(x)].append(i + 1)\n\tfor _ in range(m):\n\t\t(l, r, c) = input().split()\n\t\t(l, r) = map(int, [l, r])\n\t\t(l, r) = (b.findkth(l), b.findkth(r))\n\t\tc = ord(c)\n\t\tl = lb(a[c], l)\n\t\tr = lb(a[c], r + 1)\n\t\tfor j in range(l, r):\n\t\t\tb.update(a[c][j], -1)\n\t\t\tn -= 1\n\t\ta[c] = a[c][:l] + a[c][r:]\n\tb = [x for x in map(b.findkth, range(1, n + 1))]\n\tprint(''.join((s[x - 1] for x in b)))\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n"
    },
    {
        "task_id": 202,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.6271369457244873,
        "fastest_time": 2.6206905841827393,
        "fastest_solution": "memoization_table = {}\n\ndef compute_count(previous_max, rest):\n\tglobal memoization_table\n\toriginal_rest = rest\n\tif (previous_max, rest) in memoization_table:\n\t\treturn memoization_table[previous_max, rest]\n\tnum_digits = len(str(rest))\n\tif num_digits == 1:\n\t\tmemoization_table[previous_max, original_rest] = (1, min(0, rest - previous_max))\n\t\treturn (1, min(0, rest - previous_max))\n\tsum_count = 0\n\twhile rest > 0:\n\t\ts = str(rest).zfill(num_digits)\n\t\tnew_max = max(previous_max, int(s[0]))\n\t\tnew_rest = int(s[1:])\n\t\t(count, leftover) = compute_count(new_max, new_rest)\n\t\tsum_count += count\n\t\trest -= new_rest\n\t\trest += leftover\n\tmemoization_table[previous_max, original_rest] = (sum_count, rest)\n\treturn (sum_count, rest)\nn = int(input())\nans = 0\nif n != 0:\n\t(ans, not_ans) = compute_count(0, n)\nprint(ans)\n",
        "slowest_solution": "c = '0123456789'\nF = {c[a] + c[b]: (c[10 - a + b], 1) if a > b else (c[10 - a], 2) for a in range(1, 10) for b in range(10)}\nfor b in range(1, 10):\n\tF['0' + c[b]] = ('0', 1)\nF['00'] = ('0', 0)\n\ndef f(x):\n\tglobal F\n\tif x in F:\n\t\treturn F[x]\n\t(a, b, y, s) = (int(x[0]), int(x[1]), x[2:], 0)\n\tfor i in range(b, a, -1):\n\t\t(y, d) = f(c[i] + y)\n\t\ts += d\n\tfor i in range(min(a, b) + 1):\n\t\t(y, d) = f(x[0] + y)\n\t\ts += d\n\tF[x] = ('9' + y, s)\n\treturn F[x]\nprint(f('0' + input())[1])\n"
    },
    {
        "task_id": 213,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 0.0009992122650146484,
        "fastest_time": 0.0,
        "fastest_solution": "from functools import reduce\n\ndef get_chance(n, x, a):\n\treturn round(reduce(lambda m, b: m * (1 - x / (n - b)), range(a), 1), 2)\n",
        "slowest_solution": "def get_chance(n, x, a):\n\tp = 1\n\tfor i in range(a):\n\t\tp = p * (n - x - i) / (n - i)\n\treturn float('{:.2f}'.format(p) if p < 1 else 0.0)\n"
    },
    {
        "task_id": 172,
        "slowest_solution_id": 5,
        "fastest_solution_id": 6,
        "slowest_time": 2.7699761390686035,
        "fastest_time": 2.481581211090088,
        "fastest_solution": "from sys import stdin\n\ndef comparar(lista1, lista2):\n\tlista1.sort()\n\tfor i in range(len(lista2)):\n\t\tlista2[i].append(i)\n\tlista2 = sorted(lista2, key=lambda lista2: lista2[0])\n\tcont1 = 0\n\twhile cont1 < len(lista2):\n\t\tif lista2[cont1][0] >= lista1[-1]:\n\t\t\tlista2[cont1].append(len(lista1))\n\t\telif cont1 == 0:\n\t\t\tfor i in range(len(lista1)):\n\t\t\t\tif lista1[i] > lista2[cont1][0]:\n\t\t\t\t\tlista2[cont1].append(i)\n\t\t\t\t\tbreak\n\t\telif lista2[cont1][0] == lista2[cont1 - 1][0]:\n\t\t\tlista2[cont1].append(lista2[cont1 - 1][2])\n\t\telse:\n\t\t\tfor i in range(lista2[cont1 - 1][2], len(lista1)):\n\t\t\t\tif lista1[i] > lista2[cont1][0]:\n\t\t\t\t\tlista2[cont1].append(i)\n\t\t\t\t\tbreak\n\t\tcont1 += 1\n\tlista2 = sorted(lista2, key=lambda lista2: lista2[1])\n\trta = ''\n\tfor i in range(len(lista2)):\n\t\tif i != len(lista2) - 1:\n\t\t\trta += str(lista2[i][2]) + ' '\n\t\telse:\n\t\t\trta += str(lista2[i][2])\n\treturn rta\n\ndef main():\n\t(n1, n2) = stdin.readline().strip().split()\n\tarr1 = [int(x) for x in stdin.readline().strip().split()]\n\tarr2 = [[int(x)] for x in stdin.readline().strip().split()]\n\tprint(comparar(arr1, arr2))\nmain()\n",
        "slowest_solution": "import bisect\n(n, m) = map(int, input().strip().split())\na = sorted(map(int, input().strip().split()))\nb = list(map(int, input().strip().split()))\nanswer = []\nfor i in b:\n\tanswer.append(bisect.bisect_right(a, i))\nprint(*answer)\n"
    },
    {
        "task_id": 208,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6160593032836914,
        "fastest_time": 2.6160593032836914,
        "fastest_solution": "def main():\n\tt = int(input())\n\tfor i in range(0, t):\n\t\t(n, q) = map(int, input().split())\n\t\tarr = list(map(int, input().split()))\n\t\tsum1 = []\n\t\tsqr = []\n\t\tsix = []\n\t\ts1 = 0\n\t\ts2 = 0\n\t\ts3 = 0\n\t\tfor j in range(0, len(arr)):\n\t\t\ts1 += arr[j]\n\t\t\ts2 += arr[j] ** 2\n\t\t\ts3 += arr[j] ** 6\n\t\t\tsum1.append(s1)\n\t\t\tsqr.append(s2)\n\t\t\tsix.append(s3)\n\t\tfor k in range(0, q):\n\t\t\t(a, b, c, d) = map(int, input().split())\n\t\t\ta -= 1\n\t\t\tb -= 1\n\t\t\tc -= 1\n\t\t\td -= 1\n\t\t\tflagres = 0\n\t\t\tif a > 0:\n\t\t\t\tif c > 0:\n\t\t\t\t\tcv1 = -sum1[a - 1] - (sum1[d] - sum1[c - 1]) + sum1[b]\n\t\t\t\t\tcv2 = -sqr[a - 1] - (sqr[d] - sqr[c - 1]) + sqr[b]\n\t\t\t\t\tcv3 = -six[a - 1] - (six[d] - six[c - 1]) + six[b]\n\t\t\t\telif c == 0:\n\t\t\t\t\tcv1 = -sum1[a - 1] - sum1[d] + sum1[b]\n\t\t\t\t\tcv2 = -sqr[a - 1] - sqr[d] + sqr[b]\n\t\t\t\t\tcv3 = -six[a - 1] - sqr[d] + six[b]\n\t\t\telif a == 0:\n\t\t\t\tif c > 0:\n\t\t\t\t\tcv1 = -(sum1[d] - sum1[c - 1]) + sum1[b]\n\t\t\t\t\tcv2 = -(sqr[d] - sqr[c - 1]) + sqr[b]\n\t\t\t\t\tcv3 = -(six[d] - six[c - 1]) + six[b]\n\t\t\t\telif c == 0:\n\t\t\t\t\tcv1 = -sum1[d] + sum1[b]\n\t\t\t\t\tcv2 = -sum1[d] + sqr[b]\n\t\t\t\t\tcv3 = -sum1[d] + six[b]\n\t\t\tif cv1 == 0:\n\t\t\t\tif cv2 == 0 and abs(cv3) < 0.01:\n\t\t\t\t\tflagres = 0\n\t\t\t\telse:\n\t\t\t\t\tflagres = 1\n\t\t\telif cv2 % cv1 == 0:\n\t\t\t\tquo = cv2 // cv1\n\t\t\t\tx = (quo + cv1) // 2\n\t\t\t\ty = (quo - cv1) // 2\n\t\t\t\tif (quo + cv1) % 2 == 0 and (quo - cv1) % 2 == 0:\n\t\t\t\t\tif x >= 1 and y >= 1:\n\t\t\t\t\t\tif abs(x ** 6 - y ** 6 - cv3) < 0.01:\n\t\t\t\t\t\t\tta = 0\n\t\t\t\t\t\t\ttaa = -1\n\t\t\t\t\t\t\ttb = 0\n\t\t\t\t\t\t\ttbb = -1\n\t\t\t\t\t\t\tfor vb in range(a, b + 1):\n\t\t\t\t\t\t\t\tif arr[vb] > x:\n\t\t\t\t\t\t\t\t\tta = ta + 1\n\t\t\t\t\t\t\t\telif arr[vb] == x:\n\t\t\t\t\t\t\t\t\ttaa = taa + 1\n\t\t\t\t\t\t\tfor vb1 in range(c, d + 1):\n\t\t\t\t\t\t\t\tif arr[vb1] > y:\n\t\t\t\t\t\t\t\t\ttb = tb + 1\n\t\t\t\t\t\t\t\telif arr[vb1] == y:\n\t\t\t\t\t\t\t\t\ttbb = tbb + 1\n\t\t\t\t\t\t\tif ta == tb:\n\t\t\t\t\t\t\t\tflagres = 0\n\t\t\t\t\t\t\telif ta + taa == tb or tb + tbb == ta:\n\t\t\t\t\t\t\t\tflagres = 0\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tflagres = 1\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tflagres = 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tflagres = 1\n\t\t\t\telse:\n\t\t\t\t\tflagres = 1\n\t\t\telse:\n\t\t\t\tflagres = 1\n\t\t\tif flagres == 0:\n\t\t\t\tprint('YES')\n\t\t\telse:\n\t\t\t\tprint('NO')\nmain()\n",
        "slowest_solution": "def main():\n\tt = int(input())\n\tfor i in range(0, t):\n\t\t(n, q) = map(int, input().split())\n\t\tarr = list(map(int, input().split()))\n\t\tsum1 = []\n\t\tsqr = []\n\t\tsix = []\n\t\ts1 = 0\n\t\ts2 = 0\n\t\ts3 = 0\n\t\tfor j in range(0, len(arr)):\n\t\t\ts1 += arr[j]\n\t\t\ts2 += arr[j] ** 2\n\t\t\ts3 += arr[j] ** 6\n\t\t\tsum1.append(s1)\n\t\t\tsqr.append(s2)\n\t\t\tsix.append(s3)\n\t\tfor k in range(0, q):\n\t\t\t(a, b, c, d) = map(int, input().split())\n\t\t\ta -= 1\n\t\t\tb -= 1\n\t\t\tc -= 1\n\t\t\td -= 1\n\t\t\tflagres = 0\n\t\t\tif a > 0:\n\t\t\t\tif c > 0:\n\t\t\t\t\tcv1 = -sum1[a - 1] - (sum1[d] - sum1[c - 1]) + sum1[b]\n\t\t\t\t\tcv2 = -sqr[a - 1] - (sqr[d] - sqr[c - 1]) + sqr[b]\n\t\t\t\t\tcv3 = -six[a - 1] - (six[d] - six[c - 1]) + six[b]\n\t\t\t\telif c == 0:\n\t\t\t\t\tcv1 = -sum1[a - 1] - sum1[d] + sum1[b]\n\t\t\t\t\tcv2 = -sqr[a - 1] - sqr[d] + sqr[b]\n\t\t\t\t\tcv3 = -six[a - 1] - sqr[d] + six[b]\n\t\t\telif a == 0:\n\t\t\t\tif c > 0:\n\t\t\t\t\tcv1 = -(sum1[d] - sum1[c - 1]) + sum1[b]\n\t\t\t\t\tcv2 = -(sqr[d] - sqr[c - 1]) + sqr[b]\n\t\t\t\t\tcv3 = -(six[d] - six[c - 1]) + six[b]\n\t\t\t\telif c == 0:\n\t\t\t\t\tcv1 = -sum1[d] + sum1[b]\n\t\t\t\t\tcv2 = -sum1[d] + sqr[b]\n\t\t\t\t\tcv3 = -sum1[d] + six[b]\n\t\t\tif cv1 == 0:\n\t\t\t\tif cv2 == 0 and abs(cv3) < 0.01:\n\t\t\t\t\tflagres = 0\n\t\t\t\telse:\n\t\t\t\t\tflagres = 1\n\t\t\telif cv2 % cv1 == 0:\n\t\t\t\tquo = cv2 // cv1\n\t\t\t\tx = (quo + cv1) // 2\n\t\t\t\ty = (quo - cv1) // 2\n\t\t\t\tif (quo + cv1) % 2 == 0 and (quo - cv1) % 2 == 0:\n\t\t\t\t\tif x >= 1 and y >= 1:\n\t\t\t\t\t\tif abs(x ** 6 - y ** 6 - cv3) < 0.01:\n\t\t\t\t\t\t\tta = 0\n\t\t\t\t\t\t\ttaa = -1\n\t\t\t\t\t\t\ttb = 0\n\t\t\t\t\t\t\ttbb = -1\n\t\t\t\t\t\t\tfor vb in range(a, b + 1):\n\t\t\t\t\t\t\t\tif arr[vb] > x:\n\t\t\t\t\t\t\t\t\tta = ta + 1\n\t\t\t\t\t\t\t\telif arr[vb] == x:\n\t\t\t\t\t\t\t\t\ttaa = taa + 1\n\t\t\t\t\t\t\tfor vb1 in range(c, d + 1):\n\t\t\t\t\t\t\t\tif arr[vb1] > y:\n\t\t\t\t\t\t\t\t\ttb = tb + 1\n\t\t\t\t\t\t\t\telif arr[vb1] == y:\n\t\t\t\t\t\t\t\t\ttbb = tbb + 1\n\t\t\t\t\t\t\tif ta == tb:\n\t\t\t\t\t\t\t\tflagres = 0\n\t\t\t\t\t\t\telif ta + taa == tb or tb + tbb == ta:\n\t\t\t\t\t\t\t\tflagres = 0\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tflagres = 1\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tflagres = 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tflagres = 1\n\t\t\t\telse:\n\t\t\t\t\tflagres = 1\n\t\t\telse:\n\t\t\t\tflagres = 1\n\t\t\tif flagres == 0:\n\t\t\t\tprint('YES')\n\t\t\telse:\n\t\t\t\tprint('NO')\nmain()\n"
    },
    {
        "task_id": 174,
        "slowest_solution_id": 7,
        "fastest_solution_id": 8,
        "slowest_time": 2.7220346927642822,
        "fastest_time": 2.5524139404296875,
        "fastest_solution": "from collections import Counter\nfor _ in range(int(input())):\n\tt = input()\n\tm = n = len(set(t))\n\tans2 = ''\n\tfor i in t[::-1]:\n\t\tif i not in ans2:\n\t\t\tans2 += i\n\tc = Counter(t)\n\tcount = 0\n\tfor i in ans2:\n\t\tcount += c[i] // n\n\t\tn -= 1\n\ttest = t[:count]\n\ttemp1 = test\n\tans2 = ans2[::-1]\n\tfor i in range(m):\n\t\ttemp = ''\n\t\tfor j in temp1:\n\t\t\tif j != ans2[i]:\n\t\t\t\ttemp += j\n\t\ttest += temp\n\t\ttemp1 = temp\n\tif test == t:\n\t\tprint(t[:count], ans2)\n\telse:\n\t\tprint(-1)\n",
        "slowest_solution": "for _ in range(int(input())):\n\tt = input()\n\tl = sorted(set(t), key=t.rindex)\n\tc = 0\n\tfor i in set(t):\n\t\tif t.count(i) % (l.index(i) + 1):\n\t\t\tprint(-1)\n\t\t\tbreak\n\t\tc += t.count(i) // (l.index(i) + 1)\n\telse:\n\t\ts = t[:c]\n\t\tu = s\n\t\tfor i in l:\n\t\t\ts = ''.join((j for j in s if j != i))\n\t\t\tu += s\n\t\tif u != t:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(t[:c], ''.join(l))\n"
    },
    {
        "task_id": 199,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 2.656975269317627,
        "fastest_time": 2.537811040878296,
        "fastest_solution": "from math import sin, cos, tan, atan, pi\n\ndef main():\n\t(w, h, a) = map(int, input().split())\n\ta = min(a, 180 - a) * pi / 180\n\tif h > w:\n\t\t(h, w) = (w, h)\n\tif h * (1 + cos(a)) < w * sin(a):\n\t\tres = h * h / sin(a)\n\telse:\n\t\tres = h * w - ((w - h * tan(a / 2)) ** 2 * tan(a) + (h - w * tan(a / 2)) ** 2 * tan(a)) / 4\n\tprint('{:.9f}'.format(res))\nmain()\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\n\ndef main():\n\tpass\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef binary(n):\n\treturn bin(n).replace('0b', '')\n\ndef decimal(s):\n\treturn int(s, 2)\n\ndef pow2(n):\n\tp = 0\n\twhile n > 1:\n\t\tn //= 2\n\t\tp += 1\n\treturn p\n\ndef primeFactors(n):\n\tl = []\n\twhile n % 2 == 0:\n\t\tl.append(2)\n\t\tn = n / 2\n\tfor i in range(3, int(math.sqrt(n)) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tl.append(i)\n\t\t\tn = n / i\n\tif n > 2:\n\t\tl.append(int(n))\n\treturn l\n\ndef isPrime(n):\n\tif n == 1:\n\t\treturn False\n\telse:\n\t\troot = int(n ** 0.5)\n\t\troot += 1\n\t\tfor i in range(2, root):\n\t\t\tif n % i == 0:\n\t\t\t\treturn False\n\t\treturn True\n\ndef maxPrimeFactors(n):\n\tmaxPrime = -1\n\twhile n % 2 == 0:\n\t\tmaxPrime = 2\n\t\tn >>= 1\n\tfor i in range(3, int(math.sqrt(n)) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tmaxPrime = i\n\t\t\tn = n / i\n\tif n > 2:\n\t\tmaxPrime = n\n\treturn int(maxPrime)\n(w, h, a) = map(int, input().split())\nif a == 0 or a == 180:\n\tprint(w * h)\nelse:\n\t(w, h) = (max(w, h), min(w, h))\n\tif a > 90:\n\t\ta = 180 - a\n\ta = a * math.pi / 180\n\tif h * (1 + math.cos(a)) < w * math.sin(a):\n\t\tprint(pow(h, 2) / math.sin(a))\n\telse:\n\t\tx = h - w * ((math.cos(a) + 1) / math.sin(a))\n\t\tt = math.tan(a) - (math.cos(a) + 1) * (math.cos(a) + 1) / (math.cos(a) * math.sin(a))\n\t\tx = x / t\n\t\tx = abs(x)\n\t\tb2 = w - x - x / math.cos(a)\n\t\tb2 = abs(b2)\n\t\th2 = b2 / math.tan(a)\n\t\th2 = abs(h2)\n\t\th1 = h - h2 - h2 / math.cos(a)\n\t\th1 = abs(h1)\n\t\ttbm = x * h1 + b2 * h2\n\t\tprint(h * w - tbm)\n"
    },
    {
        "task_id": 215,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5574498176574707,
        "fastest_time": 2.5574498176574707,
        "fastest_solution": "P = 998244353\n(N, M) = map(int, input().split())\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nli = sum([A[i] * B[i] for i in range(N)])\ndi = sum([(A[i] ^ 1) * B[i] for i in range(N)])\nX = [1]\nSU = li + di\nPO = [0] * (5 * M + 10)\nfor i in range(-M - 5, 2 * M + 5):\n\tPO[i] = pow((SU + i) % P, P - 2, P)\n\ndef calc(L):\n\tsu = sum(L)\n\tpl = 0\n\tpd = 0\n\tRE = []\n\tfor i in range(len(L)):\n\t\ta = li + i\n\t\tb = di - (len(L) - 1 - i)\n\t\tpd = b * L[i] * PO[a + b - SU]\n\t\tRE.append((pl + pd) % P)\n\t\tpl = a * L[i] * PO[a + b - SU]\n\tRE.append(pl % P)\n\treturn RE\nfor i in range(M):\n\tX = calc(X)\nne = 0\npo = 0\nfor i in range(M + 1):\n\tpo = (po + X[i] * (li + i)) % P\n\tne = (ne + X[i] * (di - M + i)) % P\ninvli = pow(li, P - 2, P)\ninvdi = pow(di, P - 2, P)\nfor i in range(N):\n\tprint(po * B[i] * invli % P if A[i] else ne * B[i] * invdi % P)\n",
        "slowest_solution": "P = 998244353\n(N, M) = map(int, input().split())\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nli = sum([A[i] * B[i] for i in range(N)])\ndi = sum([(A[i] ^ 1) * B[i] for i in range(N)])\nX = [1]\nSU = li + di\nPO = [0] * (5 * M + 10)\nfor i in range(-M - 5, 2 * M + 5):\n\tPO[i] = pow((SU + i) % P, P - 2, P)\n\ndef calc(L):\n\tsu = sum(L)\n\tpl = 0\n\tpd = 0\n\tRE = []\n\tfor i in range(len(L)):\n\t\ta = li + i\n\t\tb = di - (len(L) - 1 - i)\n\t\tpd = b * L[i] * PO[a + b - SU]\n\t\tRE.append((pl + pd) % P)\n\t\tpl = a * L[i] * PO[a + b - SU]\n\tRE.append(pl % P)\n\treturn RE\nfor i in range(M):\n\tX = calc(X)\nne = 0\npo = 0\nfor i in range(M + 1):\n\tpo = (po + X[i] * (li + i)) % P\n\tne = (ne + X[i] * (di - M + i)) % P\ninvli = pow(li, P - 2, P)\ninvdi = pow(di, P - 2, P)\nfor i in range(N):\n\tprint(po * B[i] * invli % P if A[i] else ne * B[i] * invdi % P)\n"
    },
    {
        "task_id": 169,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.7883853912353516,
        "fastest_time": 2.4746742248535156,
        "fastest_solution": "def scanf(obj=list, type=int, sep=' '):\n\treturn obj(map(type, input().split(sep)))\n(n,) = scanf()\n(m,) = scanf()\na = scanf()\nb = scanf()\nif a.count(1) or b.count(1):\n\tprint(-1)\n\tquit()\n(l, r) = (0, 10 ** 9)\n\ndef f(x):\n\tfor (ai, bi) in zip(a, b):\n\t\tif ai * x < m + x:\n\t\t\treturn False\n\t\tx -= (m + x) / ai\n\t\tif bi * x < m + x:\n\t\t\treturn False\n\t\tx -= (m + x) / bi\n\treturn True\nwhile r - l > 1e-06:\n\ttemp = (r + l) / 2\n\tif f(temp):\n\t\tr = temp\n\telse:\n\t\tl = temp\nprint(r)\n",
        "slowest_solution": "def f(a, b, n, m, t):\n\tfor i in range(n):\n\t\tt -= (m + t) / a[i]\n\t\tif t < 0:\n\t\t\treturn False\n\t\tt -= (m + t) / b[i]\n\t\tif t < 0:\n\t\t\treturn False\n\treturn True\nn = int(input())\nm = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nl = 0\nr = 1000000001\nfor i in range(1000):\n\tt = (l + r) / 2\n\tif f(a, b, n, m, t):\n\t\tr = t + 0\n\telse:\n\t\tl = t + 0\nif r == 1000000001:\n\tprint(-1)\nelse:\n\tprint(r)\n"
    },
    {
        "task_id": 219,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 0.0010025501251220703,
        "fastest_time": 0.0,
        "fastest_solution": "def reg_sum_hits(dices, sides=6):\n\t(d, s) = (sides * [1], sides - 1)\n\tfor i in range(dices - 1):\n\t\tt = s * [0] + d + s * [0]\n\t\td = [sum(t[i:i + sides]) for i in range(len(t) - s)]\n\treturn [[i + dices, prob] for (i, prob) in enumerate(d)]\n",
        "slowest_solution": "from itertools import product\n\ndef reg_sum_hits(n, s):\n\tpairs = [[i, 0] for i in range(n, n * s + 1)]\n\tfor i in product(range(1, s + 1), repeat=n):\n\t\tsum = 0\n\t\tfor j in i:\n\t\t\tsum += j\n\t\tindex = sum - n\n\t\tpairs[index][1] += 1\n\treturn pairs\n"
    },
    {
        "task_id": 171,
        "slowest_solution_id": 6,
        "fastest_solution_id": 9,
        "slowest_time": 2.7200253009796143,
        "fastest_time": 2.4101970195770264,
        "fastest_solution": "def median(n, l):\n\tl.sort()\n\treturn l[n // 2]\na = int(input())\nb = input().strip().split(' ')\nc = []\nfor x in b:\n\tc.append(int(x))\nprint(median(a, c))\n",
        "slowest_solution": "n = int(input())\na = sorted(map(int, input().split()))\nprint(a[n // 2])\n"
    },
    {
        "task_id": 201,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 11.069468259811401,
        "fastest_time": 11.069468259811401,
        "fastest_solution": "MOD = 10 ** 9 + 7\nMAXN = 3 * 10 ** 5\n\ndef modpow(base, exp, mod):\n\tresult = 1\n\twhile exp:\n\t\tif exp & 1:\n\t\t\tresult = result * base % mod\n\t\tbase = base * base % mod\n\t\texp >>= 1\n\treturn result\n\ndef modinv(base, mod):\n\treturn modpow(base, mod - 2, mod)\nFACT = [1] * (MAXN + 1)\nFACTINV = [1] * (MAXN + 1)\nPOW2 = [1] * (MAXN + 1)\nPOW2_1INV = [1] * (MAXN + 1)\nfor n in range(1, MAXN + 1):\n\tFACT[n] = n * FACT[n - 1] % MOD\n\tFACTINV[n] = modinv(FACT[n], MOD)\n\tPOW2[n] = 2 * POW2[n - 1] % MOD\n\tPOW2_1INV[n] = modinv(POW2[n] - 1, MOD)\n\ndef binomial(N, K):\n\treturn FACT[N] * FACTINV[K] * FACTINV[N - K]\n\ndef main(N):\n\texpect = 0\n\tfor K in range(1, N + 1):\n\t\texpect = (expect - (-1) ** K * binomial(N, K) * POW2[K] * POW2_1INV[K]) % MOD\n\treturn expect\nT = int(input().strip())\nfor _ in range(T):\n\tN = int(input().strip())\n\tprint(main(N))\n",
        "slowest_solution": "MOD = 10 ** 9 + 7\nMAXN = 3 * 10 ** 5\n\ndef modpow(base, exp, mod):\n\tresult = 1\n\twhile exp:\n\t\tif exp & 1:\n\t\t\tresult = result * base % mod\n\t\tbase = base * base % mod\n\t\texp >>= 1\n\treturn result\n\ndef modinv(base, mod):\n\treturn modpow(base, mod - 2, mod)\nFACT = [1] * (MAXN + 1)\nFACTINV = [1] * (MAXN + 1)\nPOW2 = [1] * (MAXN + 1)\nPOW2_1INV = [1] * (MAXN + 1)\nfor n in range(1, MAXN + 1):\n\tFACT[n] = n * FACT[n - 1] % MOD\n\tFACTINV[n] = modinv(FACT[n], MOD)\n\tPOW2[n] = 2 * POW2[n - 1] % MOD\n\tPOW2_1INV[n] = modinv(POW2[n] - 1, MOD)\n\ndef binomial(N, K):\n\treturn FACT[N] * FACTINV[K] * FACTINV[N - K]\n\ndef main(N):\n\texpect = 0\n\tfor K in range(1, N + 1):\n\t\texpect = (expect - (-1) ** K * binomial(N, K) * POW2[K] * POW2_1INV[K]) % MOD\n\treturn expect\nT = int(input().strip())\nfor _ in range(T):\n\tN = int(input().strip())\n\tprint(main(N))\n"
    },
    {
        "task_id": 166,
        "slowest_solution_id": 5,
        "fastest_solution_id": 2,
        "slowest_time": 3.8918440341949463,
        "fastest_time": 2.4840307235717773,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\n\ndef factorial(n):\n\tans = 1\n\tfor i in range(2, n + 1):\n\t\tans = ans * i % mod\n\treturn ans\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tminn = min(a)\n\t(cnt, flag) = (0, 1)\n\tfor i in a:\n\t\tif i == minn:\n\t\t\tcnt += 1\n\t\tif i & minn != minn:\n\t\t\tflag = 0\n\tans = 0\n\tif flag:\n\t\tans = cnt * (cnt - 1) * factorial(n - 2) % mod\n\tprint(ans)\n",
        "slowest_solution": "N = 1000005\nmod = 10 ** 9 + 7\nfac = [1, 1]\nfor i in range(2, N):\n\tfac.append(fac[i - 1] * i % mod)\nfor tt in range(int(input())):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tl.sort()\n\tcnt = 0\n\tfor i in range(n):\n\t\tif l[i] == l[0]:\n\t\t\tcnt += 1\n\t\tif l[i] & l[0] != l[0]:\n\t\t\tprint(0)\n\t\t\tbreak\n\telse:\n\t\tprint(fac[n - 2] * cnt * (cnt - 1) % mod)\n"
    },
    {
        "task_id": 176,
        "slowest_solution_id": 4,
        "fastest_solution_id": 5,
        "slowest_time": 2.8096823692321777,
        "fastest_time": 2.4838624000549316,
        "fastest_solution": "movList = []\n\ndef coordtotuple(s):\n\tss = s[0]\n\tif ss == 'a':\n\t\txxx = 1\n\telif ss == 'b':\n\t\txxx = 2\n\telif ss == 'c':\n\t\txxx = 3\n\telif ss == 'd':\n\t\txxx = 4\n\telif ss == 'e':\n\t\txxx = 5\n\telif ss == 'f':\n\t\txxx = 6\n\telif ss == 'g':\n\t\txxx = 7\n\telif ss == 'h':\n\t\txxx = 8\n\treturn [xxx, int(s[1])]\n\ndef move():\n\tif x == xx:\n\t\tif y < yy:\n\t\t\tmovList.append('U')\n\t\t\treturn [0, 1]\n\t\telif y > yy:\n\t\t\tmovList.append('D')\n\t\t\treturn [0, -1]\n\telif y == yy:\n\t\tif x < xx:\n\t\t\tmovList.append('R')\n\t\t\treturn [1, 0]\n\t\telif x > xx:\n\t\t\tmovList.append('L')\n\t\t\treturn [-1, 0]\n\telif x < xx and y < yy:\n\t\tmovList.append('RU')\n\t\treturn [1, 1]\n\telif x < xx and y > yy:\n\t\tmovList.append('RD')\n\t\treturn [1, -1]\n\telif x > xx and y < yy:\n\t\tmovList.append('LU')\n\t\treturn [-1, 1]\n\telif x > xx and y > yy:\n\t\tmovList.append('LD')\n\t\treturn [-1, -1]\n\ndef printres():\n\tprint(len(movList))\n\tfor i in movList:\n\t\tprint(i)\ninn = input()\nx = coordtotuple(inn)[0]\ny = coordtotuple(inn)[1]\ninn = input()\nxx = coordtotuple(inn)[0]\nyy = coordtotuple(inn)[1]\nwhile x != xx or y != yy:\n\tp = move()\n\tx += p[0]\n\ty += p[1]\nprintres()\n",
        "slowest_solution": "(start_x, start_y) = map(str, input())\n(end_x, end_y) = map(str, input())\nd = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nmoves = ['', '', '', '', '', '', '', '']\nif d[end_x] > d[start_x]:\n\tfor i in range(d[end_x] - d[start_x]):\n\t\tmoves[i] = moves[i] + 'R'\nelif d[end_x] < d[start_x]:\n\tfor i in range(d[start_x] - d[end_x]):\n\t\tmoves[i] = moves[i] + 'L'\nelse:\n\tpass\nif int(end_y) > int(start_y):\n\tfor i in range(int(end_y) - int(start_y)):\n\t\tmoves[i] = moves[i] + 'U'\nelif int(end_y) < int(start_y):\n\tfor i in range(int(start_y) - int(end_y)):\n\t\tmoves[i] = moves[i] + 'D'\nelse:\n\tpass\ni = 0\nwhile i in range(len(moves)):\n\tif moves[i] == '':\n\t\tmoves.pop(i)\n\t\ti -= 1\n\ti += 1\nprint(len(moves))\nprint('\\n'.join(moves))\n"
    },
    {
        "task_id": 178,
        "slowest_solution_id": 9,
        "fastest_solution_id": 1,
        "slowest_time": 3.0396902561187744,
        "fastest_time": 2.477313756942749,
        "fastest_solution": "def change(grid, n, m):\n\tfor i in range(m):\n\t\tb = n - 1\n\t\ts = n\n\t\twhile b >= 0:\n\t\t\tif grid[b][i] == '*':\n\t\t\t\tgrid[b][i] = '.'\n\t\t\t\tgrid[s - 1][i] = '*'\n\t\t\t\ts -= 1\n\t\t\telif grid[b][i] == 'o':\n\t\t\t\ts = b\n\t\t\tb -= 1\nt = int(input())\nfor _ in range(t):\n\t(n, m) = [int(i) for i in input().split(' ')]\n\tgrid = []\n\tfor i in range(n):\n\t\tgrid.append(list(input()))\n\tchange(grid, n, m)\n\tfor i in range(n):\n\t\tprint(''.join(grid[i]))\n",
        "slowest_solution": "def solve():\n\t(n, m) = map(int, input().split())\n\tg = [[c for c in input().strip()] for _ in range(n)]\n\tfor j in range(m):\n\t\tlast = n - 1\n\t\tfor i in range(n - 1, -1, -1):\n\t\t\tif g[i][j] == 'o':\n\t\t\t\tlast = i - 1\n\t\t\telif g[i][j] == '*':\n\t\t\t\t(g[i][j], g[last][j]) = (g[last][j], g[i][j])\n\t\t\t\tlast -= 1\n\tfor i in range(n):\n\t\tprint(''.join(g[i]))\ntt = int(input())\nfor i in range(1, tt + 1):\n\tsolve()\n"
    },
    {
        "task_id": 177,
        "slowest_solution_id": 9,
        "fastest_solution_id": 1,
        "slowest_time": 3.052135467529297,
        "fastest_time": 2.4870524406433105,
        "fastest_solution": "def check_zero(left, right, bit_r, l):\n\tfor i in range(l):\n\t\tif len(bit_r) - 1 - i > 1:\n\t\t\tif bit_r[len(bit_r) - 1 - i] == '0':\n\t\t\t\tleft[l - 1 - i] = 0\n\t\t\t\tright[l - 1 - i] = 0\n\t\telse:\n\t\t\tleft[l - 1 - i] = 0\n\t\t\tright[l - 1 - i] = 0\n\ndef check_one(left, right, bit_r, l):\n\tfor i in range(l):\n\t\tif left[l - 1 - i] + right[l - 1 - i] == -1:\n\t\t\tif (len(bit_r) - 1 - i > 1) & (bit_r[len(bit_r) - 1 - i] == '1'):\n\t\t\t\tif left[l - 1 - i] == -1:\n\t\t\t\t\tleft[l - 1 - i] = 1\n\t\t\t\tif right[l - 1 - i] == -1:\n\t\t\t\t\tright[l - 1 - i] = 1\n\t\tif left[l - 1 - i] + right[l - 1 - i] == 0:\n\t\t\tif (len(bit_r) - 1 - i > 1) & (bit_r[len(bit_r) - 1 - i] == '1'):\n\t\t\t\treturn False\n\treturn True\nt = int(input())\nfor i in range(t):\n\t(P, Q, R) = map(int, input().split())\n\tbit_P = bin(P)\n\tbit_Q = bin(Q)\n\tbit_R = bin(R)\n\tl = max(len(bit_P), len(bit_Q), len(bit_R)) - 2\n\tlist_A = list((-1 for i in range(l)))\n\tlist_B = list_A.copy()\n\tlist_C = list_A.copy()\n\tcheck_zero(list_A, list_B, bit_P, l)\n\tcheck_zero(list_C, list_B, bit_Q, l)\n\tcheck_zero(list_A, list_C, bit_R, l)\n\tresult = 0\n\tif all([check_one(list_A, list_B, bit_P, l), check_one(list_C, list_B, bit_Q, l), check_one(list_A, list_C, bit_R, l)]):\n\t\tresult = 1\n\t\tfor i in range(l):\n\t\t\tif all(list((clist[i] == -1 for clist in [list_A, list_B, list_C]))):\n\t\t\t\tresult = result * 4\n\tprint(result)\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(P, Q, R) = list(map(int, input().split()))\n\tp = str(bin(P))[2:]\n\tq = str(bin(Q))[2:]\n\tr = str(bin(R))[2:]\n\tpl = len(p)\n\tql = len(q)\n\trl = len(r)\n\tml = max(pl, ql, rl)\n\tp = '0' * (ml - pl) + p\n\tr = '0' * (ml - rl) + r\n\tq = '0' * (ml - ql) + q\n\tans = 1\n\tflag = True\n\tfor i in range(ml):\n\t\tif int(p[i]) + int(q[i]) + int(r[i]) == 1:\n\t\t\tflag = False\n\t\t\tbreak\n\t\telif int(p[i]) + int(q[i]) + int(r[i]) == 3:\n\t\t\tans *= 4\n\tif flag:\n\t\tprint(ans)\n\telse:\n\t\tprint(0)\n"
    },
    {
        "task_id": 228,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 0.001001119613647461,
        "fastest_time": 0.0,
        "fastest_solution": "def binary_to_string(binary):\n\treturn ''.join([chr(int(binary[i:i + 8], 2)) for i in range(0, len(binary), 8)])\n",
        "slowest_solution": "import re\n\ndef binary_to_string(binary):\n\treturn re.sub('[01]{8}', lambda x: chr(int(x.group(), 2)), binary)\n"
    },
    {
        "task_id": 181,
        "slowest_solution_id": 9,
        "fastest_solution_id": 1,
        "slowest_time": 2.7287962436676025,
        "fastest_time": 2.499315023422241,
        "fastest_solution": "def get_winner(a, b):\n\tif a % 2 and b % 2:\n\t\treturn 'Vanka'\n\treturn 'Tuzik'\nfor _ in range(int(input())):\n\t(A, B) = map(int, input().split())\n\tprint(get_winner(A, B))\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\t(a, b) = map(int, input().split())\n\tif a % 2 == 1 and b % 2 == 1:\n\t\tprint('Vanka')\n\telse:\n\t\tprint('Tuzik')\n"
    },
    {
        "task_id": 182,
        "slowest_solution_id": 5,
        "fastest_solution_id": 8,
        "slowest_time": 3.227182388305664,
        "fastest_time": 2.6427559852600098,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nimport math\nimport bisect\nmod = 998244353\nfrom collections import Counter\nimport bisect\nfrom heapq import *\nfrom collections import defaultdict\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\nmod = 998244353\n\ndef power(base, exp):\n\tbase %= mod\n\tif exp < 3:\n\t\treturn base ** exp % mod\n\thalf = power(base * base, exp // 2)\n\treturn half * base % mod if exp % 2 == 1 else half % mod\n\ndef solve():\n\t(n, m) = map(int, input().split())\n\tgraph = [[] for _ in range(n + 1)]\n\t(count, visited) = ([0, 0], [-1 for _ in range(n + 1)])\n\tfor _ in range(m):\n\t\t(u, v) = map(int, input().split())\n\t\tgraph[u].append(v)\n\t\tgraph[v].append(u)\n\t(possible, ans) = (True, 1)\n\n\t@bootstrap\n\tdef dfs(node, par, parity):\n\t\tnonlocal possible, visited, graph, count\n\t\tif visited[node] != -1:\n\t\t\tpossible = False if visited[node] != parity else possible\n\t\t\tyield None\n\t\tvisited[node] = parity\n\t\tcount[parity] += 1\n\t\tfor child in graph[node]:\n\t\t\tif child != par:\n\t\t\t\tyield dfs(child, node, 1 - parity)\n\t\tyield\n\tfor i in range(1, n + 1):\n\t\tif visited[i] == -1:\n\t\t\tcount = [0, 0]\n\t\t\tdfs(i, -1, 1)\n\t\t\tans *= (power(2, count[0]) + power(2, count[1])) % mod\n\t\t\tans %= mod\n\tsys.stdout.write(str(ans) if possible else '0')\n\tsys.stdout.write('\\n')\n\ndef main():\n\ttests = 1\n\ttests = int(input().strip())\n\tfor test in range(tests):\n\t\tsolve()\nmain()\n",
        "slowest_solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\ngraph = defaultdict(list)\ncolor = [0] * (3 * 10 ** 5 + 1000)\nbipertite = True\nMOD = 998244353\nresult = 1\ncolor_count = [0] * 2\npow_value = []\nt = int(input())\npow_value.append(1)\nfor i in range(1, 3 * 10 ** 5 + 1000):\n\tnext_value = pow_value[i - 1] * 2 % MOD\n\tpow_value.append(next_value)\nwhile t:\n\t(n, m) = map(int, input().split())\n\tif m == 0:\n\t\tprint(pow(3, n, MOD))\n\t\tt -= 1\n\t\tcontinue\n\tgraph.clear()\n\tbipertite = True\n\tresult = 1\n\tfor node in range(0, n + 1):\n\t\tcolor[node] = -1\n\twhile m:\n\t\t(u, v) = map(int, input().split())\n\t\tgraph[u].append(v)\n\t\tgraph[v].append(u)\n\t\tm -= 1\n\tfor i in range(1, n + 1):\n\t\tif color[i] != -1:\n\t\t\tcontinue\n\t\tbipertite = True\n\t\tcolor_count[0] = color_count[1] = 0\n\t\tqueue = []\n\t\tqueue.append(i)\n\t\tcolor[i] = 0\n\t\tcolor_count[0] += 1\n\t\twhile queue:\n\t\t\tif bipertite == False:\n\t\t\t\tbreak\n\t\t\tfront_node = queue.pop()\n\t\t\tfor child_node in range(0, len(graph[front_node])):\n\t\t\t\tif color[graph[front_node][child_node]] == -1:\n\t\t\t\t\tcolor[graph[front_node][child_node]] = 1 - color[front_node]\n\t\t\t\t\tqueue.append(graph[front_node][child_node])\n\t\t\t\t\tcolor_count[color[graph[front_node][child_node]]] += 1\n\t\t\t\telif color[front_node] == color[graph[front_node][child_node]]:\n\t\t\t\t\tbipertite = False\n\t\t\t\t\tbreak\n\t\tif bipertite == False:\n\t\t\tprint(0)\n\t\t\tbreak\n\t\tcurrent = (pow_value[color_count[0]] + pow_value[color_count[1]]) % MOD\n\t\tresult = result * current % MOD\n\tif bipertite:\n\t\tprint(result)\n\tt -= 1\n"
    },
    {
        "task_id": 183,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 3.0265371799468994,
        "fastest_time": 2.569164514541626,
        "fastest_solution": "import sys\n\ndef N():\n\treturn int(sys.stdin.readline())\n\ndef S():\n\treturn sys.stdin.readline().rstrip()\n\ndef L():\n\treturn sorted(map(int, sys.stdin.readline().split()))\n\ndef M():\n\treturn map(int, sys.stdin.readline().split())\nfor _ in range(N()):\n\t(n, m) = M()\n\tsubsegment = list(range(1, n + 1))\n\tfor _ in range(m):\n\t\t(x, y) = M()\n\t\tmini = min(x, y) - 1\n\t\tmaxi = max(x, y) - 1\n\t\tsubsegment[maxi] = min(maxi - mini, subsegment[maxi])\n\tfor i in range(1, n):\n\t\tif subsegment[i] > subsegment[i - 1] + 1:\n\t\t\tsubsegment[i] = subsegment[i - 1] + 1\n\tprint(sum(subsegment))\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\td = dict()\n\tfor i in range(m):\n\t\ta = list(map(int, input().split()))\n\t\ta.sort()\n\t\tif a[1] in d:\n\t\t\td[a[1]] = max(d[a[1]], a[0])\n\t\telse:\n\t\t\td[a[1]] = a[0]\n\tans = 0\n\tc = 1\n\tm = -1\n\tfor i in range(1, n + 1):\n\t\tif i in d and m < d[i]:\n\t\t\tc = i - d[i]\n\t\t\tm = d[i]\n\t\tans += c\n\t\tc += 1\n\tprint(ans)\n"
    },
    {
        "task_id": 220,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 5.4657018184661865,
        "fastest_time": 5.4657018184661865,
        "fastest_solution": "from collections import defaultdict\nimport sys\ninf = sys.maxsize\nT = int(input())\nfor l in range(T):\n\tN,M   = [int(x) for x in input().split()]\n\tdicti = defaultdict(lambda : inf)\n\tD     = [[inf]*(N+1) for x in range(N+1)]\n\tfor i in range(1,N+1):\n\t\tD[i][i]=0\n\n\n\t\n\tfor i in range(M):\n\t\tu,v,c = [int(x) for x in input().split()]\n\t\tif D[u][v] >c:\n\t\t\tD[u][v]=c\n\t\t\tD[v][u]=c\n\t\t\n\tfor key,value in dicti.items():\n\t\tD[key[0]][key[1]] = value\n\t\n\n\t'''\n\tfor i in range(1,N+1):\n\t\tprint D[i]\n\t'''\n\n\tfor k in range(1,N+1):\n\t\tfor i in range(1,N+1):\n\t\t\tfor j in range(1,N+1):\n\t\t\t\tif D[i][k] == inf or D[k][j] == inf:\n\t\t\t\t\tcontinue\n\t\t\t\telif D[i][j] > D[i][k]+D[k][j]:\n\t\t\t\t\tD[i][j] = D[i][k]+D[k][j]\n\n\tS,A,H = [int(x) for x in input().split()]\n\tdist = [-1]*(N+1) \n\tfor k in range(1,N+1):\n\t\tif k!=S and k!=A and k!=H:\n\t\t\tdist[k] = D[S][k]+2*D[k][A]+D[k][H]\n\tans = max(dist)\n\tprint(ans)\n\t\t\n\t\t\n\n\n\t   \n\t\n",
        "slowest_solution": "from collections import defaultdict\nimport sys\ninf = sys.maxsize\nT = int(input())\nfor l in range(T):\n\tN,M   = [int(x) for x in input().split()]\n\tdicti = defaultdict(lambda : inf)\n\tD     = [[inf]*(N+1) for x in range(N+1)]\n\tfor i in range(1,N+1):\n\t\tD[i][i]=0\n\n\n\t\n\tfor i in range(M):\n\t\tu,v,c = [int(x) for x in input().split()]\n\t\tif D[u][v] >c:\n\t\t\tD[u][v]=c\n\t\t\tD[v][u]=c\n\t\t\n\tfor key,value in dicti.items():\n\t\tD[key[0]][key[1]] = value\n\t\n\n\t'''\n\tfor i in range(1,N+1):\n\t\tprint D[i]\n\t'''\n\n\tfor k in range(1,N+1):\n\t\tfor i in range(1,N+1):\n\t\t\tfor j in range(1,N+1):\n\t\t\t\tif D[i][k] == inf or D[k][j] == inf:\n\t\t\t\t\tcontinue\n\t\t\t\telif D[i][j] > D[i][k]+D[k][j]:\n\t\t\t\t\tD[i][j] = D[i][k]+D[k][j]\n\n\tS,A,H = [int(x) for x in input().split()]\n\tdist = [-1]*(N+1) \n\tfor k in range(1,N+1):\n\t\tif k!=S and k!=A and k!=H:\n\t\t\tdist[k] = D[S][k]+2*D[k][A]+D[k][H]\n\tans = max(dist)\n\tprint(ans)\n\t\t\n\t\t\n\n\n\t   \n\t\n"
    },
    {
        "task_id": 186,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 2.9523003101348877,
        "fastest_time": 2.5204038619995117,
        "fastest_solution": "def snek(n):\n\tl = []\n\tfor z in range(n):\n\t\t(x, y) = map(int, input().split())\n\t\tl.append([x, y])\n\tl.sort()\n\td = {}\n\tfor j in range(n - 1):\n\t\t(x1, y1) = (l[j][0], l[j][1])\n\t\t(x2, y2) = (l[j + 1][0], l[j + 1][1])\n\t\tif x1 == x2:\n\t\t\tif (y1, y2) not in d:\n\t\t\t\td[y1, y2] = 0\n\t\t\td[y1, y2] += 1\n\tans = 0\n\tfor (k, v) in d.items():\n\t\tans += v * (v - 1) // 2\n\tprint(ans)\nwhile True:\n\tn = int(input())\n\tif n == 0:\n\t\tbreak\n\tsnek(n)\n",
        "slowest_solution": "def solve(points, N):\n\tpoints.sort()\n\tcnt = {}\n\tfor i in range(N - 1):\n\t\t(x1, y1, x2, y2) = (points[i][0], points[i][1], points[i + 1][0], points[i + 1][1])\n\t\tif x1 == x2:\n\t\t\tif (y1, y2) not in cnt:\n\t\t\t\tcnt[y1, y2] = 0\n\t\t\tcnt[y1, y2] += 1\n\tans = 0\n\tfor key in list(cnt.keys()):\n\t\tvalue = cnt[key]\n\t\tans += value * (value - 1) // 2\n\tprint(ans)\nwhile True:\n\tN = int(input())\n\tif N == 0:\n\t\tbreak\n\tpoints = []\n\tfor i in range(N):\n\t\t(x, y) = map(int, input().split())\n\t\tpoints.append((x, y))\n\tsolve(points, N)\n"
    },
    {
        "task_id": 237,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def proper_fractions(n):\n\tphi = n > 1 and n\n\tfor p in range(2, int(n ** 0.5) + 1):\n\t\tif not n % p:\n\t\t\tphi -= phi // p\n\t\t\twhile not n % p:\n\t\t\t\tn //= p\n\tif n > 1:\n\t\tphi -= phi // n\n\treturn phi\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 173,
        "slowest_solution_id": 6,
        "fastest_solution_id": 5,
        "slowest_time": 4.477275848388672,
        "fastest_time": 3.228539228439331,
        "fastest_solution": "def solve(n, mod):\n\tif n <= 3:\n\t\treturn 0\n\telse:\n\t\tlast_ans = 17\n\t\tans = 17\n\t\tsize = (n - 1) * (n - 2) // 2 + 1\n\t\tinv = 1\n\t\trecord = [[0 for i in range(size + 1)] for i in range(2)]\n\t\trecord[0][0:4] = [1, 2, 2, 1]\n\t\tfor m in range(4, n):\n\t\t\ttp_size = m * (m - 1) // 2\n\t\t\tans = (m + 1) * last_ans\n\t\t\ttp = 0\n\t\t\tfor i in range(m):\n\t\t\t\ttp += record[inv ^ 1][i]\n\t\t\t\trecord[inv][i] = tp % mod\n\t\t\tfor i in range(m, tp_size // 2 + 1):\n\t\t\t\ttp += record[inv ^ 1][i]\n\t\t\t\ttp -= record[inv ^ 1][i - m]\n\t\t\t\trecord[inv][i] = tp % mod\n\t\t\tfor i in range(tp_size // 2 + 1):\n\t\t\t\trecord[inv][tp_size - i] = record[inv][i]\n\t\t\ttotal = 0\n\t\t\tfor i in range(tp_size - 1):\n\t\t\t\ttp = 0\n\t\t\t\tfor j in range(max(1, -tp_size + i + m + 2), m + 1):\n\t\t\t\t\ttp += j * int(record[inv][m + 2 - j + i])\n\t\t\t\ttotal += int(record[inv][i])\n\t\t\t\ttotal %= mod\n\t\t\t\ttp *= total\n\t\t\t\ttp %= mod\n\t\t\t\tans += tp\n\t\t\t\tans %= mod\n\t\t\tlast_ans = ans\n\t\t\tinv ^= 1\n\t\treturn int(ans) % mod\n\ndef main():\n\t(n, mod) = map(int, input().split())\n\tprint(solve(n, mod))\nmain()\n",
        "slowest_solution": "from functools import lru_cache\nimport itertools\n\ndef invnum(seq):\n\tN = len(seq)\n\tres = 0\n\tfor i in range(N):\n\t\tfor j in range(i + 1, N):\n\t\t\tif seq[i] > seq[j]:\n\t\t\t\tres += 1\n\treturn res\n\ndef naive(N, k, flag):\n\tres = 0\n\tfor p in itertools.permutations(range(N), N):\n\t\tfor q in itertools.permutations(range(N), N):\n\t\t\tif (p < q or not flag) and invnum(p) - invnum(q) > k:\n\t\t\t\tres += 1\n\treturn res\n(n, mod) = map(int, input().split())\nmemo = [[{}, {}] for _ in range(n + 1)]\n\ndef solve(N, k, flag):\n\tif k in memo[N][flag]:\n\t\treturn memo[N][flag][k]\n\tif N == 1:\n\t\tres = -1\n\t\tif flag:\n\t\t\tres = 0\n\t\telif k < 0:\n\t\t\tres = 1\n\t\telse:\n\t\t\tres = 0\n\t\tmemo[N][flag][k] = res\n\t\treturn res\n\tinvnum_INF = N * (N - 1) // 2\n\tif k < -invnum_INF - 1:\n\t\tres = solve(N, -invnum_INF - 1, flag)\n\t\tmemo[N][flag][k] = res\n\t\treturn res\n\tif k >= invnum_INF:\n\t\tmemo[N][flag][k] = 0\n\t\treturn 0\n\tres = 0\n\tfor delta in range(-N + 1, N):\n\t\tif flag and delta > 0:\n\t\t\tcontinue\n\t\twt = min(N - delta, delta + N)\n\t\tres += solve(N - 1, k - delta, (delta == 0) & flag) * wt\n\t\tres %= mod\n\tmemo[N][flag][k] = res % mod\n\treturn res % mod\nans = solve(n, 0, 1) % mod\nprint(ans)\n"
    },
    {
        "task_id": 184,
        "slowest_solution_id": 8,
        "fastest_solution_id": 7,
        "slowest_time": 3.040614128112793,
        "fastest_time": 2.4232072830200195,
        "fastest_solution": "n = int(input())\nif n == 1:\n\tprint(0)\nelse:\n\ta = list(map(int, input().split()))\n\tl = [0 for i in range(n - 1)]\n\ts = set()\n\ts.add(a[-1])\n\tl[-1] = 1\n\tfor i in range(n - 2, 0, -1):\n\t\tif a[i] not in s:\n\t\t\ts.add(a[i])\n\t\t\tl[i - 1] = l[i] + 1\n\t\telse:\n\t\t\tl[i - 1] = l[i]\n\ts2 = set()\n\tp = 0\n\tfor i in range(n - 1):\n\t\tif a[i] not in s2:\n\t\t\ts2.add(a[i])\n\t\t\tp += l[i]\n\tprint(p)\n",
        "slowest_solution": "import math\n\ndef problem(in1, in2):\n\tn = int(in1)\n\tnumbers = list(map(int, in2.split()))\n\trobo1 = []\n\tset1 = set()\n\tfor num in numbers:\n\t\trobo1.append(num not in set1)\n\t\tset1.add(num)\n\tset2 = set()\n\trobo2 = []\n\tcount = 0\n\tfor num in numbers[::-1]:\n\t\tif num not in set2:\n\t\t\tcount += 1\n\t\tset2.add(num)\n\t\trobo2.append(count)\n\trobo2.reverse()\n\trobo2.append(0)\n\tresult = 0\n\tfor (i, unique) in enumerate(robo1):\n\t\tif unique:\n\t\t\tresult += robo2[i + 1]\n\treturn result\nin1 = input()\nin2 = input()\nresult = problem(in1, in2)\nprint(result)\n"
    },
    {
        "task_id": 189,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 2.7244441509246826,
        "fastest_time": 2.5570149421691895,
        "fastest_solution": "t = int(input())\nfor tt in range(t):\n\t(n, k) = map(int, input().split())\n\ta = []\n\thasa = False\n\tfor i in input().split():\n\t\tx = int(i)\n\t\tif x == k:\n\t\t\thasa = True\n\t\ta.append(x >= k)\n\tif not hasa:\n\t\tprint('no')\n\t\tcontinue\n\tif n == 1:\n\t\tprint('yes')\n\t\tcontinue\n\tans = a[-1] and a[-2]\n\tfor i in range(n - 2):\n\t\tif a[i] and (a[i + 1] or a[i + 2]):\n\t\t\tans = True\n\t\t\tbreak\n\t\tif ans:\n\t\t\tbreak\n\tprint('yes' if ans else 'no')\n",
        "slowest_solution": "from sys import stdin\ninput = stdin.readline\n\ndef solve(a, k, n):\n\tb = []\n\thas_k = False\n\tfor item in a:\n\t\tif item == k:\n\t\t\tb.append(1)\n\t\t\thas_k = True\n\t\telif item < k:\n\t\t\tb.append(0)\n\t\telse:\n\t\t\tb.append(2)\n\tif not has_k:\n\t\treturn False\n\tif n == 1:\n\t\treturn True\n\tfor i in range(n):\n\t\tif b[i] > 0:\n\t\t\tif i + 1 < n and b[i + 1] > 0:\n\t\t\t\treturn True\n\t\t\tif i + 2 < n and b[i + 2] > 0:\n\t\t\t\treturn True\n\treturn False\nfor i in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ta = [int(x) for x in input().split()]\n\tprint('yes' if solve(a, k, n) else 'no')\n"
    },
    {
        "task_id": 205,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 2.964967966079712,
        "fastest_time": 2.5555694103240967,
        "fastest_solution": "from collections import deque\nT = int(input())\nfor _ in range(T):\n\tN = int(input())\n\tX = [[] for i in range(N)]\n\tpp = [int(a) - 1 for a in input().split()]\n\tfor (i, p) in enumerate(pp, 1):\n\t\tX[i].append(p)\n\t\tX[p].append(i)\n\tP = [-1] * N\n\tQ = deque([0])\n\tR = []\n\twhile Q:\n\t\ti = deque.popleft(Q)\n\t\tR.append(i)\n\t\tfor a in X[i]:\n\t\t\tif a != P[i]:\n\t\t\t\tP[a] = i\n\t\t\t\tX[a].remove(i)\n\t\t\t\tdeque.append(Q, a)\n\tY = [[0]]\n\tD = [0] * N\n\tfor i in R[1:]:\n\t\tD[i] = D[P[i]] + 1\n\t\twhile len(Y) <= D[i]:\n\t\t\tY.append([])\n\t\tY[D[i]].append(i)\n\tA = [0] + [int(a) for a in input().split()]\n\td = max(D) + 1\n\tMI = [10 ** 9] * d\n\tMA = [0] * d\n\tfor (i, a) in enumerate(A):\n\t\tMI[D[i]] = min(MI[D[i]], a)\n\t\tMA[D[i]] = max(MA[D[i]], a)\n\tS = [0] * N\n\tfor i in Y[-1]:\n\t\tS[i] = max(abs(A[i] - MA[-1]), abs(A[i] - MI[-1]))\n\tfor de in range(d - 1)[::-1]:\n\t\tabc1 = 0\n\t\tabc2 = -10 ** 9\n\t\tfor i in Y[de]:\n\t\t\tma = 0\n\t\t\tfor j in X[i]:\n\t\t\t\tma = max(ma, S[j])\n\t\t\tabc1 = max(abc1, ma + A[i])\n\t\t\tabc2 = max(abc2, ma - A[i])\n\t\t\tS[i] = max(abs(A[i] - MI[de]), abs(MA[de] - A[i])) + ma\n\t\tfor i in Y[de]:\n\t\t\tS[i] = max(S[i], abc1 - A[i], abc2 + A[i])\n\tprint(S[0])\n",
        "slowest_solution": "from sys import stdin\nimport sys\nfrom collections import deque\n\ndef NC_Dij(lis, start):\n\tret = [float('inf')] * len(lis)\n\tret[start] = 0\n\tq = deque([start])\n\tplis = [i for i in range(len(lis))]\n\twhile len(q) > 0:\n\t\tnow = q.popleft()\n\t\tfor nex in lis[now]:\n\t\t\tif ret[nex] > ret[now] + 1:\n\t\t\t\tret[nex] = ret[now] + 1\n\t\t\t\tplis[nex] = now\n\t\t\t\tq.append(nex)\n\treturn (ret, plis)\ntt = int(stdin.readline())\nfor loop in range(tt):\n\tn = int(stdin.readline())\n\tlis = [[] for i in range(n)]\n\tvl = list(map(int, stdin.readline().split()))\n\ta = [0] + list(map(int, stdin.readline().split()))\n\tfor i in range(n - 1):\n\t\tvl[i] -= 1\n\t\tlis[i + 1].append(vl[i])\n\t\tlis[vl[i]].append(i + 1)\n\t(dis, tmp) = NC_Dij(lis, 0)\n\td = max(dis)\n\tdtov = [[] for i in range(d + 1)]\n\tfor i in range(n):\n\t\tdtov[dis[i]].append(i)\n\tdp = [0] * n\n\tfor nd in range(d, -1, -1):\n\t\tav = []\n\t\tfor v in dtov[nd]:\n\t\t\tav.append((a[v], v))\n\t\tav.sort()\n\t\tchildmax = [0] * len(av)\n\t\tfor i in range(len(av)):\n\t\t\t(na, nv) = av[i]\n\t\t\tfor c in lis[nv]:\n\t\t\t\tchildmax[i] = max(childmax[i], dp[c])\n\t\tleftmax = [float('-inf')] * len(av)\n\t\ttmpmax = float('-inf')\n\t\tfor i in range(len(av)):\n\t\t\t(na, nv) = av[i]\n\t\t\ttmpmax = max(tmpmax, childmax[i] - na)\n\t\t\tleftmax[i] = tmpmax\n\t\trightmax = [float('-inf')] * len(av)\n\t\ttmpmax = float('-inf')\n\t\tfor i in range(len(av) - 1, -1, -1):\n\t\t\t(na, nv) = av[i]\n\t\t\ttmpmax = max(tmpmax, childmax[i] + na)\n\t\t\trightmax[i] = tmpmax\n\t\tfor i in range(len(av)):\n\t\t\t(na, nv) = av[i]\n\t\t\tdp[nv] = max(dp[nv], leftmax[i] + na, rightmax[i] - na)\n\t\t\tdp[nv] = max(dp[nv], childmax[i] + max(abs(na - av[0][0]), abs(na - av[-1][0])))\n\tprint(dp[0])\n"
    },
    {
        "task_id": 211,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 2.652750015258789,
        "fastest_time": 2.507009983062744,
        "fastest_solution": "(n, k) = (0, int(input()))\np = [['0'] * 100 for i in range(100)]\nwhile k:\n\tfor i in range(n):\n\t\tif i > k:\n\t\t\tbreak\n\t\tp[n][i] = p[i][n] = '1'\n\t\tk -= i\n\tn += 1\nprint(n)\nfor i in range(n):\n\tprint(''.join(p[i][:n]))\n",
        "slowest_solution": "def f_3(n):\n\treturn n * (n - 1) * (n - 2) // 6\n\ndef f_2(n):\n\treturn n * (n - 1) // 2\na_3 = [f_3(i) for i in range(100)]\na_2 = [f_2(i) for i in range(100)]\n\ndef find_2(x, a):\n\tarr = []\n\tcur = len(a) - 1\n\twhile x > 0:\n\t\twhile x < a[cur]:\n\t\t\tcur -= 1\n\t\tarr.append(cur)\n\t\tx -= a[cur]\n\treturn arr\n\ndef find_3(x, a):\n\tcur = len(a) - 1\n\twhile x < a[cur]:\n\t\tcur -= 1\n\tx -= a[cur]\n\treturn (cur, x)\n\ndef build(x):\n\t(base, remain) = find_3(x, a_3)\n\tarr = find_2(remain, a_2)\n\tn = base\n\tif len(arr) > 0:\n\t\tn += len(arr)\n\tm = [[0] * n for _ in range(n)]\n\tfor i in range(base):\n\t\tfor j in range(base):\n\t\t\tif i == j:\n\t\t\t\tcontinue\n\t\t\tm[i][j] = 1\n\t\t\tm[j][i] = 1\n\tfor (i, x) in enumerate(arr):\n\t\tfor j in range(x):\n\t\t\tm[base + i][j] = 1\n\t\t\tm[j][base + i] = 1\n\treturn m\n\ndef pr(m):\n\tfor i in range(len(m)):\n\t\tprint(''.join([str(x) for x in m[i]]))\nk = int(input())\nm = build(k)\nprint(len(m))\npr(m)\n"
    },
    {
        "task_id": 206,
        "slowest_solution_id": 3,
        "fastest_solution_id": 2,
        "slowest_time": 2.8327488899230957,
        "fastest_time": 2.5700020790100098,
        "fastest_solution": "import sys\nn = int(input())\na = list(map(int, input().split()))\na = sorted([(a[i], i) for i in range(n)])\nd = []\nc = [False] * n\nfor i in range(n):\n\tif not c[i]:\n\t\tk = i\n\t\tp = []\n\t\twhile not c[k]:\n\t\t\tc[k] = True\n\t\t\tp.append(str(k + 1))\n\t\t\tk = a[k][1]\n\t\td.append(p)\nprint(len(d))\nfor i in d:\n\tprint(str(len(i)) + ' ' + ' '.join(i))\n",
        "slowest_solution": "from sys import stdin\nn = int(stdin.readline().strip())\na = list(map(int, stdin.readline().strip().split()))\na = [(a[i], i + 1) for i in range(n)]\na.sort()\nused = [False] * (n + 1)\nss = []\nfor i in range(1, n + 1):\n\tif not used[i]:\n\t\ts = [i]\n\t\tused[i] = True\n\t\tj = i\n\t\twhile True:\n\t\t\tj = a[j - 1][1]\n\t\t\tif not used[j]:\n\t\t\t\ts.append(j)\n\t\t\t\tused[j] = True\n\t\t\telse:\n\t\t\t\tbreak\n\t\tss.append(s)\nprint(len(ss))\nfor s in ss:\n\tprint(len(s), ' '.join(list(map(str, s))))\n"
    },
    {
        "task_id": 193,
        "slowest_solution_id": 5,
        "fastest_solution_id": 7,
        "slowest_time": 2.8680646419525146,
        "fastest_time": 2.4859607219696045,
        "fastest_solution": "T = int(input())\nfor i in range(T):\n\t(N, M) = map(int, input().split())\n\tcomp = pow(2, N, 10 ** 9 + 7) - 1\n\tres = pow(comp, M, 10 ** 9 + 7)\n\tprint(res)\n",
        "slowest_solution": "t = int(input())\nwhile t:\n\t(a, b) = map(int, input().split())\n\tprint(pow(pow(2, a, 1000000007) - 1, b, 1000000007))\n\tt = t - 1\n"
    },
    {
        "task_id": 198,
        "slowest_solution_id": 2,
        "fastest_solution_id": 3,
        "slowest_time": 2.7330732345581055,
        "fastest_time": 2.5426204204559326,
        "fastest_solution": "class Element:\n\n\tdef __init__(self, s=''):\n\t\tif len(s) >= 6:\n\t\t\tself.pref = s[:3]\n\t\t\tself.suf = s[-3:]\n\t\telse:\n\t\t\tself.pref = s[:3]\n\t\t\tself.suf = s[3:]\n\t\tself.ans = calc(s)\n\t\tself.orig = ''\n\t\tself.len = len(s)\n\ndef calc(s: str):\n\tans = 0\n\tfor (num, i) in enumerate(s):\n\t\tans += s[num:num + 4] == 'haha'\n\treturn ans\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ta = [input() for i in range(n)]\n\td = dict()\n\tfor i in a:\n\t\tif ':=' in i:\n\t\t\t(a1, shit, a2) = i.split()\n\t\t\tnew = Element(a2)\n\t\t\tnew.orig = a2\n\t\t\td[a1] = Element(a2)\n\t\telse:\n\t\t\t(a1, shit, b1, plus, b2) = i.split()\n\t\t\tnew = Element()\n\t\t\tnew.ans = d[b1].ans + d[b2].ans\n\t\t\ts = d[b1].pref + d[b1].suf + d[b2].pref + d[b2].suf\n\t\t\tif len(s) >= 6:\n\t\t\t\tnew.pref = s[:3]\n\t\t\t\tnew.suf = s[-3:]\n\t\t\telse:\n\t\t\t\tnew.pref = s[:3]\n\t\t\t\tnew.suf = s[3:]\n\t\t\tnew.ans += calc((d[b1].pref + d[b1].suf)[-3:] + (d[b2].pref + d[b2].suf)[:3])\n\t\t\td[a1] = new\n\tprint(d[a[-1].split()[0]].ans)\n",
        "slowest_solution": "def f(a):\n\tb = 0\n\tfor i in range(len(a) - 3):\n\t\tif a[i] + a[i + 1] + a[i + 2] + a[i + 3] == 'haha':\n\t\t\tb += 1\n\treturn b\nfor z in range(int(input())):\n\tb = []\n\tb1 = 0\n\tc = 0\n\tfor y in range(int(input())):\n\t\ta = input().split()\n\t\tif len(a) == 3:\n\t\t\tfor i in range(b1):\n\t\t\t\tif b[i][0] == a[0]:\n\t\t\t\t\tb[i] = [a[0], f(a[2]), a[2][:3], a[2][-3:]]\n\t\t\t\t\tc = b[i][1]\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tb.append([a[0], f(a[2]), a[2][:3], a[2][-3:]])\n\t\t\t\tc = b[b1][1]\n\t\t\t\tb1 += 1\n\t\telse:\n\t\t\td = []\n\t\t\te = []\n\t\t\tfor i in range(b1):\n\t\t\t\tif b[i][0] == a[2]:\n\t\t\t\t\td = b[i]\n\t\t\t\tif b[i][0] == a[4]:\n\t\t\t\t\te = b[i]\n\t\t\tfor i in range(b1):\n\t\t\t\tif b[i][0] == a[0]:\n\t\t\t\t\tb[i] = [a[0], d[1] + e[1] + f(d[3] + e[2]), str(d[2] + e[3])[:3], str(d[2] + e[3])[-3:]]\n\t\t\t\t\tc = b[i][1]\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tb.append([a[0], d[1] + e[1] + f(d[3] + e[2]), str(d[2] + e[3])[:3], str(d[2] + e[3])[-3:]])\n\t\t\t\tc = b[b1][1]\n\t\t\t\tb1 += 1\n\tprint(c)\n"
    },
    {
        "task_id": 195,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.7702579498291016,
        "fastest_time": 2.5026183128356934,
        "fastest_solution": "for iiiiiiiiiiiiiiii in range(int(input())):\n\t(x, y, z, a, b, c) = map(int, input().strip().split(' '))\n\taa = [x, y, z]\n\taa.sort()\n\tx = aa[0]\n\ty = aa[1]\n\tz = aa[2]\n\tn = x\n\tm = y - x\n\to = z - y\n\tcost = min(3 * b, 2 * c, 2 * b + 2 * a, 6 * a, b + 4 * a)\n\tans1 = o * a + m * min(2 * a, b)\n\tif n % 2 == 1:\n\t\tans1 += min(c, 3 * a, b + a)\n\tans1 = ans1 + cost * (n // 2)\n\tans2 = 0\n\tt = min(n, o)\n\tn -= t\n\to -= t\n\tm += 2 * t\n\tans2 = o * a + m * min(2 * a, b)\n\tif n % 2 == 1:\n\t\tans2 += min(c, 3 * a, b + a)\n\tans2 = ans2 + cost * (n // 2)\n\tprint(min(ans1, ans2))\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\t(x, y, z, a, b, c) = list(map(int, input().strip().split(' ')))\n\tans = 10 ** 18\n\t(x, y, z) = sorted([x, y, z])\n\tans = min(ans, (x + y + z) * a)\n\tif (x + y + z) % 2 == 0 and x + y >= z:\n\t\tans = min(ans, (x + y + z) // 2 * b)\n\tif x == y and y == z:\n\t\tans = min(ans, x * c)\n\tif x + y < z:\n\t\tans = min(ans, (x + y) * b + (z - x - y) * a)\n\telif (x + y + z) % 2 == 1:\n\t\tans = min(ans, a + (x + y + z) // 2 * b)\n\tans = min(ans, x * c + (y + z - 2 * x) * a)\n\tif (x + y + z) % 2 != 0 and x + y > z:\n\t\tans = min(ans, c + (x + y + z - 3) // 2 * b)\n\tcommon = min(x, z - y)\n\tif a + c <= 2 * b:\n\t\tans = min(ans, common * (a + c) + (x - common) * c + (z - y - common) * a + (y - x) * b)\n\telse:\n\t\tans = min(ans, common * (2 * b) + (x - common) * c + (z - y - common) * a + (y - x) * b)\n\tprint(int(ans))\n"
    },
    {
        "task_id": 196,
        "slowest_solution_id": 7,
        "fastest_solution_id": 3,
        "slowest_time": 2.702742576599121,
        "fastest_time": 2.515735149383545,
        "fastest_solution": "from collections import deque as dq, defaultdict as dd\nmod = 1000000007\n\ndef power(x, y):\n\tans = 1\n\twhile y:\n\t\tif y % 2:\n\t\t\tans = ans % mod * (x % mod) % mod\n\t\ty = y >> 1\n\t\tx = x % mod * (x % mod) % mod\n\treturn ans\n(n, k) = map(int, input().split())\nd = dd(list)\nfor i in range(n - 1):\n\t(u, v, a) = map(int, input().split())\n\tif a == 0:\n\t\td[u].append(v)\n\t\td[v].append(u)\nvis = [0] * (n + 1)\ncl = 0\nfor i in range(1, n + 1):\n\tif vis[i] == 0:\n\t\tq = [i]\n\t\tq = dq(q)\n\t\tcou = 0\n\t\twhile q:\n\t\t\tcou += 1\n\t\t\ta = q.pop()\n\t\t\tvis[a] = 1\n\t\t\tfor j in d[a]:\n\t\t\t\tif vis[j] == 0:\n\t\t\t\t\tq.appendleft(j)\n\t\tb = power(cou, k)\n\t\tcl = (cl % mod + b % mod) % mod\nprint((power(n, k) - cl + 1000000007) % mod)\n",
        "slowest_solution": "def dfs(edges, visited, node):\n\tred = 0\n\tif node not in visited:\n\t\tfor kid in edges[node]:\n\t\t\tif kid[1] == 0 and kid[0] not in visited:\n\t\t\t\tred += 1\n\t\t\t\tbreak\n\tstack = [node]\n\twhile stack:\n\t\tcurr = stack.pop()\n\t\tif curr not in visited:\n\t\t\tfound = False\n\t\t\tvisited.add(curr)\n\t\t\tfor kid in edges[curr]:\n\t\t\t\tif kid[1] == 0 and kid[0] not in visited:\n\t\t\t\t\tstack.append(kid[0])\n\t\t\t\t\tred += 1\n\treturn red\n\ndef solve(edges, k):\n\tmod = 10 ** 9 + 7\n\tn = len(edges)\n\ttotal = pow(n, k, mod)\n\tremove = 0\n\tvisited = set()\n\tfor i in range(1, n + 1):\n\t\tif i not in visited:\n\t\t\tred = dfs(edges, visited, i)\n\t\t\tremove += pow(red, k, mod)\n\t\t\tremove -= red\n\t\t\tremove = remove % mod\n\tremove += n\n\tremove = remove % mod\n\tprint((total - remove) % mod)\n\ndef main():\n\t(n, k) = map(int, input().split())\n\tedges = {}\n\tfor i in range(1, n + 1):\n\t\tedges[i] = []\n\tfor i in range(n - 1):\n\t\t(u, v, x) = map(int, input().split())\n\t\tedges[u].append((v, x))\n\t\tedges[v].append((u, x))\n\tsolve(edges, k)\nmain()\n"
    },
    {
        "task_id": 221,
        "slowest_solution_id": 1,
        "fastest_solution_id": 1,
        "slowest_time": 2.7400801181793213,
        "fastest_time": 2.7400801181793213,
        "fastest_solution": "n = int(input())\na = list(map(int, input().split()))\nproc = sorted([(a.count(i), i) for i in range(10, 100) if a.count(i) > 0])\n(left, right) = ([], [])\nfor (cnt, val) in proc:\n\thalf = cnt // 2\n\tleft.extend([val] * half)\n\tright.extend([val] * half)\n\tif cnt % 2 == 1:\n\t\tif len(left) < len(right):\n\t\t\tleft.append(val)\n\t\telse:\n\t\t\tright.append(val)\nprint(len(set(left)) * len(set(right)))\ncnt = [0 for i in range(100)]\nfor i in range(2 * n):\n\tif left.count(a[i]) == cnt[a[i]]:\n\t\tprint('2', end=' ')\n\telse:\n\t\tprint('1', end=' ')\n\t\tcnt[a[i]] += 1\n",
        "slowest_solution": "n = int(input())\na = list(map(int, input().split()))\nproc = sorted([(a.count(i), i) for i in range(10, 100) if a.count(i) > 0])\n(left, right) = ([], [])\nfor (cnt, val) in proc:\n\thalf = cnt // 2\n\tleft.extend([val] * half)\n\tright.extend([val] * half)\n\tif cnt % 2 == 1:\n\t\tif len(left) < len(right):\n\t\t\tleft.append(val)\n\t\telse:\n\t\t\tright.append(val)\nprint(len(set(left)) * len(set(right)))\ncnt = [0 for i in range(100)]\nfor i in range(2 * n):\n\tif left.count(a[i]) == cnt[a[i]]:\n\t\tprint('2', end=' ')\n\telse:\n\t\tprint('1', end=' ')\n\t\tcnt[a[i]] += 1\n"
    },
    {
        "task_id": 249,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5765717029571533,
        "fastest_time": 2.5765717029571533,
        "fastest_solution": "class Graph:\n\n\tdef __init__(self, n_vertices, edges, directed=True, weighted=False):\n\t\tself.n_vertices = n_vertices\n\t\tself.edges = edges\n\t\tself.directed = directed\n\t\tself.weighted = weighted\n\n\t@property\n\tdef adj(self):\n\t\ttry:\n\t\t\treturn self._adj\n\t\texcept AttributeError:\n\t\t\tadj = [[] for _ in range(self.n_vertices)]\n\n\t\t\tdef d_w(e):\n\t\t\t\tadj[e[0]].append((e[1], e[2]))\n\n\t\t\tdef ud_w(e):\n\t\t\t\tadj[e[0]].append((e[1], e[2]))\n\t\t\t\tadj[e[1]].append((e[0], e[2]))\n\n\t\t\tdef d_uw(e):\n\t\t\t\tadj[e[0]].append(e[1])\n\n\t\t\tdef ud_uw(e):\n\t\t\t\tadj[e[0]].append(e[1])\n\t\t\t\tadj[e[1]].append(e[0])\n\t\t\thelper = (ud_uw, d_uw, ud_w, d_w)[self.directed + self.weighted * 2]\n\t\t\tfor e in self.edges:\n\t\t\t\thelper(e)\n\t\t\tself._adj = adj\n\t\t\treturn adj\n\nclass RootedTree(Graph):\n\n\tdef __init__(self, n_vertices, edges, root_vertex):\n\t\tself.root = root_vertex\n\t\tsuper().__init__(n_vertices, edges, False, False)\n\n\t@property\n\tdef parent(self):\n\t\ttry:\n\t\t\treturn self._parent\n\t\texcept AttributeError:\n\t\t\tadj = self.adj\n\t\t\tparent = [None] * self.n_vertices\n\t\t\tparent[self.root] = -1\n\t\t\tstack = [self.root]\n\t\t\tfor i in range(self.n_vertices):\n\t\t\t\tv = stack.pop()\n\t\t\t\tfor u in adj[v]:\n\t\t\t\t\tif parent[u] is None:\n\t\t\t\t\t\tparent[u] = v\n\t\t\t\t\t\tstack.append(u)\n\t\t\tself._parent = parent\n\t\t\treturn parent\n\n\t@property\n\tdef children(self):\n\t\ttry:\n\t\t\treturn self._children\n\t\texcept AttributeError:\n\t\t\tchildren = [None] * self.n_vertices\n\t\t\tfor (v, (l, p)) in enumerate(zip(self.adj, self.parent)):\n\t\t\t\tchildren[v] = [u for u in l if u != p]\n\t\t\tself._children = children\n\t\t\treturn children\n\n\t@property\n\tdef dfs_order(self):\n\t\ttry:\n\t\t\treturn self._dfs_order\n\t\texcept AttributeError:\n\t\t\torder = [None] * self.n_vertices\n\t\t\tchildren = self.children\n\t\t\tstack = [self.root]\n\t\t\tfor i in range(self.n_vertices):\n\t\t\t\tv = stack.pop()\n\t\t\t\torder[i] = v\n\t\t\t\tfor u in children[v]:\n\t\t\t\t\tstack.append(u)\n\t\t\tself._dfs_order = order\n\t\t\treturn order\nfrom functools import reduce\nfrom itertools import accumulate, chain\n\ndef rerooting(rooted_tree, merge, identity, finalize):\n\tN = rooted_tree.n_vertices\n\tparent = rooted_tree.parent\n\tchildren = rooted_tree.children\n\torder = rooted_tree.dfs_order\n\tdp_down = [None] * N\n\tfor v in reversed(order[1:]):\n\t\tdp_down[v] = finalize(reduce(merge, (dp_down[c] for c in children[v]), identity))\n\tdp_up = [None] * N\n\tdp_up[0] = identity\n\tfor v in order:\n\t\tif len(children[v]) == 0:\n\t\t\tcontinue\n\t\ttemp = (dp_up[v],) + tuple((dp_down[u] for u in children[v])) + (identity,)\n\t\tleft = tuple(accumulate(temp, merge))\n\t\tright = tuple(accumulate(reversed(temp[2:]), merge))\n\t\tfor (u, l, r) in zip(children[v], left, reversed(right)):\n\t\t\tdp_up[u] = finalize(merge(l, r))\n\tres = [None] * N\n\tfor (v, l) in enumerate(children):\n\t\tres[v] = reduce(merge, (dp_down[u] for u in children[v]), identity)\n\t\tres[v] = finalize(merge(res[v], dp_up[v]))\n\treturn res\n\ndef solve(T):\n\tMOD = 10 ** 9 + 7\n\n\tdef merge(x, y):\n\t\treturn x * y % MOD\n\n\tdef finalize(x):\n\t\treturn x + 1\n\treturn [v - 1 for v in rerooting(T, merge, 1, finalize)]\n\ndef __starting_point():\n\tN = int(input())\n\tedges = [(i + 1, p - 1) for (i, p) in enumerate(map(int, input().split()))]\n\tT = RootedTree(N, edges, 0)\n\tprint(*solve(T))\n__starting_point()\n",
        "slowest_solution": "class Graph:\n\n\tdef __init__(self, n_vertices, edges, directed=True, weighted=False):\n\t\tself.n_vertices = n_vertices\n\t\tself.edges = edges\n\t\tself.directed = directed\n\t\tself.weighted = weighted\n\n\t@property\n\tdef adj(self):\n\t\ttry:\n\t\t\treturn self._adj\n\t\texcept AttributeError:\n\t\t\tadj = [[] for _ in range(self.n_vertices)]\n\n\t\t\tdef d_w(e):\n\t\t\t\tadj[e[0]].append((e[1], e[2]))\n\n\t\t\tdef ud_w(e):\n\t\t\t\tadj[e[0]].append((e[1], e[2]))\n\t\t\t\tadj[e[1]].append((e[0], e[2]))\n\n\t\t\tdef d_uw(e):\n\t\t\t\tadj[e[0]].append(e[1])\n\n\t\t\tdef ud_uw(e):\n\t\t\t\tadj[e[0]].append(e[1])\n\t\t\t\tadj[e[1]].append(e[0])\n\t\t\thelper = (ud_uw, d_uw, ud_w, d_w)[self.directed + self.weighted * 2]\n\t\t\tfor e in self.edges:\n\t\t\t\thelper(e)\n\t\t\tself._adj = adj\n\t\t\treturn adj\n\nclass RootedTree(Graph):\n\n\tdef __init__(self, n_vertices, edges, root_vertex):\n\t\tself.root = root_vertex\n\t\tsuper().__init__(n_vertices, edges, False, False)\n\n\t@property\n\tdef parent(self):\n\t\ttry:\n\t\t\treturn self._parent\n\t\texcept AttributeError:\n\t\t\tadj = self.adj\n\t\t\tparent = [None] * self.n_vertices\n\t\t\tparent[self.root] = -1\n\t\t\tstack = [self.root]\n\t\t\tfor i in range(self.n_vertices):\n\t\t\t\tv = stack.pop()\n\t\t\t\tfor u in adj[v]:\n\t\t\t\t\tif parent[u] is None:\n\t\t\t\t\t\tparent[u] = v\n\t\t\t\t\t\tstack.append(u)\n\t\t\tself._parent = parent\n\t\t\treturn parent\n\n\t@property\n\tdef children(self):\n\t\ttry:\n\t\t\treturn self._children\n\t\texcept AttributeError:\n\t\t\tchildren = [None] * self.n_vertices\n\t\t\tfor (v, (l, p)) in enumerate(zip(self.adj, self.parent)):\n\t\t\t\tchildren[v] = [u for u in l if u != p]\n\t\t\tself._children = children\n\t\t\treturn children\n\n\t@property\n\tdef dfs_order(self):\n\t\ttry:\n\t\t\treturn self._dfs_order\n\t\texcept AttributeError:\n\t\t\torder = [None] * self.n_vertices\n\t\t\tchildren = self.children\n\t\t\tstack = [self.root]\n\t\t\tfor i in range(self.n_vertices):\n\t\t\t\tv = stack.pop()\n\t\t\t\torder[i] = v\n\t\t\t\tfor u in children[v]:\n\t\t\t\t\tstack.append(u)\n\t\t\tself._dfs_order = order\n\t\t\treturn order\nfrom functools import reduce\nfrom itertools import accumulate, chain\n\ndef rerooting(rooted_tree, merge, identity, finalize):\n\tN = rooted_tree.n_vertices\n\tparent = rooted_tree.parent\n\tchildren = rooted_tree.children\n\torder = rooted_tree.dfs_order\n\tdp_down = [None] * N\n\tfor v in reversed(order[1:]):\n\t\tdp_down[v] = finalize(reduce(merge, (dp_down[c] for c in children[v]), identity))\n\tdp_up = [None] * N\n\tdp_up[0] = identity\n\tfor v in order:\n\t\tif len(children[v]) == 0:\n\t\t\tcontinue\n\t\ttemp = (dp_up[v],) + tuple((dp_down[u] for u in children[v])) + (identity,)\n\t\tleft = tuple(accumulate(temp, merge))\n\t\tright = tuple(accumulate(reversed(temp[2:]), merge))\n\t\tfor (u, l, r) in zip(children[v], left, reversed(right)):\n\t\t\tdp_up[u] = finalize(merge(l, r))\n\tres = [None] * N\n\tfor (v, l) in enumerate(children):\n\t\tres[v] = reduce(merge, (dp_down[u] for u in children[v]), identity)\n\t\tres[v] = finalize(merge(res[v], dp_up[v]))\n\treturn res\n\ndef solve(T):\n\tMOD = 10 ** 9 + 7\n\n\tdef merge(x, y):\n\t\treturn x * y % MOD\n\n\tdef finalize(x):\n\t\treturn x + 1\n\treturn [v - 1 for v in rerooting(T, merge, 1, finalize)]\n\ndef __starting_point():\n\tN = int(input())\n\tedges = [(i + 1, p - 1) for (i, p) in enumerate(map(int, input().split()))]\n\tT = RootedTree(N, edges, 0)\n\tprint(*solve(T))\n__starting_point()\n"
    },
    {
        "task_id": 229,
        "slowest_solution_id": 3,
        "fastest_solution_id": 1,
        "slowest_time": 2.6321499347686768,
        "fastest_time": 2.531785726547241,
        "fastest_solution": "import sys\nimport math\n\ndef alele():\n\treturn list(map(int, sys.stdin.readline().strip().split()))\n\ndef ilele():\n\treturn map(int, sys.stdin.readline().strip().split())\n\ndef input():\n\treturn sys.stdin.readline().strip()\nN = int(input())\nArr = alele()\ntot = sum(Arr)\na = 2\nb = math.ceil(tot ** 0.5) + 1\nvalues = []\nfor i in range(a, b):\n\tif tot % i == 0:\n\t\tvalues.append(i)\n\t\twhile tot % i == 0:\n\t\t\ttot = tot // i\nif tot > 1:\n\tvalues.append(tot)\nres = 3e+18\nfor i in values:\n\tv = 0\n\tans = 0\n\tfor j in range(N):\n\t\tv = (v + Arr[j]) % i\n\t\tans += min(v, i - v)\n\tres = min(res, ans)\nprint(-1) if res > 1e+18 else print(res)\n",
        "slowest_solution": "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\ndef divisor(n):\n\tret = []\n\tfor i in range(1, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\tret.append(i)\n\t\t\tif i * i != n:\n\t\t\t\tret.append(n // i)\n\treturn ret\n\ndef divisor2(n):\n\ti = 2\n\tm = n\n\tret = []\n\twhile m > 1 and i * i <= n:\n\t\tif m % i == 0:\n\t\t\tm //= i\n\t\t\tif len(ret) == 0 or i != ret[-1]:\n\t\t\t\tret.append(i)\n\t\telse:\n\t\t\ti += 1\n\tif m * m > n:\n\t\tret.append(m)\n\treturn ret\n\ndef solve():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ts = sum(a)\n\tans = float('inf')\n\tfor k in divisor2(s):\n\t\tif k == 1:\n\t\t\tcontinue\n\t\ttmp = 0\n\t\tcs = 0\n\t\tfor i in range(n):\n\t\t\tcs += a[i]\n\t\t\tcs %= k\n\t\t\ttmp += min(cs, k - cs)\n\t\tans = min(ans, tmp)\n\tif ans == float('inf'):\n\t\tprint(-1)\n\telse:\n\t\tprint(ans)\nsolve()\n"
    },
    {
        "task_id": 253,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def count_pal(n):\n\treturn [9 * 10 ** ((n - 1) // 2), 10 ** (n // 2) * (13 - 9 * (-1) ** n) // 2 - 2]\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 200,
        "slowest_solution_id": 4,
        "fastest_solution_id": 3,
        "slowest_time": 3.0186986923217773,
        "fastest_time": 2.5393834114074707,
        "fastest_solution": "def last_digit(n):\n\treturn [6, 2, 4, 8][n % 4]\nT = int(input())\nfor t in range(T):\n\tN = int(input())\n\ts1 = 0\n\ti = 1\n\twhile i <= N:\n\t\ts1 += last_digit(i)\n\t\ti *= 2\n\ts2 = [1, 5][N % 2]\n\tprint(s1 * s2 % 10)\n",
        "slowest_solution": "t = int(input())\nfor j in range(t):\n\tn = int(input())\n\ti = 0\n\tans1 = 0\n\ts1 = 0\n\twhile 2 ** i <= n:\n\t\ts1 += 1\n\t\ti += 1\n\tif s1:\n\t\tans1 += 2\n\t\ts1 -= 1\n\tif s1:\n\t\tans1 += 4\n\t\ts1 -= 1\n\tans1 += 6 * s1\n\tans2 = 1\n\tif n & 1:\n\t\tans2 += 4\n\tans1 *= ans2\n\tans1 %= 10\n\tprint(ans1)\n"
    },
    {
        "task_id": 250,
        "slowest_solution_id": 1,
        "fastest_solution_id": 1,
        "slowest_time": 2.6254587173461914,
        "fastest_time": 2.6254587173461914,
        "fastest_solution": "import math\n\ndef gcdExtended(a, b):\n\tif a == 0:\n\t\treturn (b, 0, 1)\n\t(gcd, x1, y1) = gcdExtended(b % a, a)\n\tx = y1 - b // a * x1\n\ty = x1\n\treturn (gcd, x, y)\n\ndef rev_elem(x, m):\n\treturn (gcdExtended(x, m)[1] % m + m) % m\n(n, m) = map(int, input().split())\na = []\nif n > 0:\n\ta = [int(i) for i in input().split()]\nbanned = [False] * (m + 5)\nfor i in a:\n\tbanned[i] = True\ncycle = [[] for i in range(m + 5)]\n(d, dp, p) = ([], [], [])\nfor i in range(m):\n\tcycle[math.gcd(m, i)].append(i)\ncycle = [[i for i in j if not banned[i]] for j in cycle]\nd = [i for i in range(1, m + 1) if m % i == 0]\ndp = [len(cycle[i]) for i in d]\np = [-1 for i in d]\n(ans, lst) = (-1, -1)\nfor i in range(len(d)):\n\tif dp[i] > ans:\n\t\t(ans, lst) = (dp[i], i)\n\tfor j in range(i + 1, len(d)):\n\t\tif d[j] % d[i] != 0 or dp[j] > dp[i] + len(cycle[d[j]]):\n\t\t\tcontinue\n\t\tdp[j] = dp[i] + len(cycle[d[j]])\n\t\tp[j] = i\nprint(ans)\n(pos, dpos, pref) = ([], [], [])\ncur = lst\nwhile cur != -1:\n\tdpos.append(d[cur])\n\tcur = p[cur]\ndpos.reverse()\nfor i in dpos:\n\tpref += cycle[i]\ncur = 1\nfor i in pref:\n\tad = 1\n\tif math.gcd(i, m) != math.gcd(cur, m):\n\t\tad = cur * math.gcd(i, m) // math.gcd(cur, math.gcd(i, m)) // cur % m\n\tncur = cur * ad % m\n\tad *= i // math.gcd(ncur, m) * rev_elem(ncur // math.gcd(ncur, m), m // math.gcd(ncur, m))\n\tad %= m\n\tcur = cur * ad % m\n\tpos.append(ad)\nprint(*pos)\n",
        "slowest_solution": "import math\n\ndef gcdExtended(a, b):\n\tif a == 0:\n\t\treturn (b, 0, 1)\n\t(gcd, x1, y1) = gcdExtended(b % a, a)\n\tx = y1 - b // a * x1\n\ty = x1\n\treturn (gcd, x, y)\n\ndef rev_elem(x, m):\n\treturn (gcdExtended(x, m)[1] % m + m) % m\n(n, m) = map(int, input().split())\na = []\nif n > 0:\n\ta = [int(i) for i in input().split()]\nbanned = [False] * (m + 5)\nfor i in a:\n\tbanned[i] = True\ncycle = [[] for i in range(m + 5)]\n(d, dp, p) = ([], [], [])\nfor i in range(m):\n\tcycle[math.gcd(m, i)].append(i)\ncycle = [[i for i in j if not banned[i]] for j in cycle]\nd = [i for i in range(1, m + 1) if m % i == 0]\ndp = [len(cycle[i]) for i in d]\np = [-1 for i in d]\n(ans, lst) = (-1, -1)\nfor i in range(len(d)):\n\tif dp[i] > ans:\n\t\t(ans, lst) = (dp[i], i)\n\tfor j in range(i + 1, len(d)):\n\t\tif d[j] % d[i] != 0 or dp[j] > dp[i] + len(cycle[d[j]]):\n\t\t\tcontinue\n\t\tdp[j] = dp[i] + len(cycle[d[j]])\n\t\tp[j] = i\nprint(ans)\n(pos, dpos, pref) = ([], [], [])\ncur = lst\nwhile cur != -1:\n\tdpos.append(d[cur])\n\tcur = p[cur]\ndpos.reverse()\nfor i in dpos:\n\tpref += cycle[i]\ncur = 1\nfor i in pref:\n\tad = 1\n\tif math.gcd(i, m) != math.gcd(cur, m):\n\t\tad = cur * math.gcd(i, m) // math.gcd(cur, math.gcd(i, m)) // cur % m\n\tncur = cur * ad % m\n\tad *= i // math.gcd(ncur, m) * rev_elem(ncur // math.gcd(ncur, m), m // math.gcd(ncur, m))\n\tad %= m\n\tcur = cur * ad % m\n\tpos.append(ad)\nprint(*pos)\n"
    },
    {
        "task_id": 203,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 2.9024765491485596,
        "fastest_time": 2.5133025646209717,
        "fastest_solution": "import sys\ngogeta = []\n\ndef pr(a, b):\n\tif b == 0:\n\t\treturn 1\n\tif b == 1:\n\t\treturn a\n\tif b % 2 == 1:\n\t\treturn pr(a, b - 1) * a % 998244353\n\tq = pr(a, b // 2)\n\treturn q * q % 998244353\n(m, n, k) = map(int, input().split())\nif m == 1 and n == 100000 and (k == 100000000):\n\tprint(222888005)\nelif m == 1 and n == 60395 and (k == 37276536):\n\tprint(749041447)\nelif m == 1 and n == 57565 and (k == 78606333):\n\tprint(487821417)\nelif m == 1 and n == 80719 and (k == 74790837):\n\tprint(60857904)\nelif m == 1 and n == 100000 and (k == 1):\n\tprint(1)\nelif k == 500 and m == 2 and (n == 500):\n\tprint(837516166)\nelif m == 2 and n == 2 and (k == 2):\n\tprint(873463811)\nelif m == 2 and n == 4 and (k == 4):\n\tprint(452329478)\nelif k == 401 and n == 312 and (m == 2):\n\tprint(725407210)\nelif k == 4 and m == 2 and (n == 4):\n\tprint(452329478)\nelif m == 1 and n == 1 and (k == 4):\n\tprint(1)\nelif m == 2 and k == 3 and (n == 3):\n\tprint('628524226')\nelif k == 427 and n == 404 and (m == 2):\n\tprint(518411087)\nelif k == 261 and m == 2 and (n == 245):\n\tprint(230618109)\nelif m - 1 == 1:\n\tkola = [[] for i in range(n)]\n\tfor i in range(n):\n\t\tfor j in range(2):\n\t\t\tkola[i].append(0)\n\tkola[0][0] = k\n\tdp = kola\n\tkola[0][1] = (k - 1) * 2 * k % 998244353\n\tfor i in range(1, n):\n\t\tkola[i][0] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tkola[i][0] %= 998244353\n\t\tkola[i][0] += dp[i - 1][0]\n\t\tkola[i][0] %= 998244353\n\t\tkola[i][0] += 2 * dp[i - 1][1] % 998244353\n\t\tkola[i][0] %= 998244353\n\t\tkola[i][0] += (k - 2) * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tkola[i][0] %= 998244353\n\t\tkola[i][1] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tkola[i][1] %= 998244353\n\t\tkola[i][1] += (k - 1) * (dp[i - 1][0] + k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tkola[i][1] += (k - 2) * (k - 1) % 998244353 * (dp[i - 1][0] + 2 * k * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tdp[i][1] %= 998244353\n\t\tdp[i][1] += dp[i - 1][1]\n\t\tdp[i][1] %= 998244353\n\t\tdp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tdp[i][1] %= 998244353\n\t\tdp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + k * (k - 1) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tdp[i][1] %= 998244353\n\t\tdp[i][1] += (k - 2) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tdp[i][1] %= 998244353\n\t\tdp[i][1] += (k - 1) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tdp[i][1] %= 998244353\n\t\tdp[i][1] += (k - 2) * max(k - 3, 0) % 998244353 * (dp[i - 1][1] + 2 * (k * (k - 1)) % 998244353 * pr(k, 2 * (i - 1)) % 998244353) % 998244353 % 998244353\n\t\tdp[i][1] %= 998244353\n\tans = dp[n - 1][0] + dp[n - 1][1]\n\tans %= 998244353\n\tx = pr(k, 2 * n)\n\tx = pr(x, 998244353 - 2)\n\tans *= x\n\tans %= 998244353\n\tgogeta.append(str(ans))\nelse:\n\tprint(kachra)\nvalue = '\\n'.join(gogeta[:])\nprint(value)\n",
        "slowest_solution": "MOD = 998244353\n\ndef fun1(x):\n\t(y, res) = (MOD - 2, 1)\n\twhile y > 0:\n\t\tif y & 1:\n\t\t\tres = int(res * x % MOD)\n\t\ty = int(y / 2)\n\t\tx = x * x % MOD\n\treturn res\n(M, N, K) = map(int, input().split())\nif M == 1:\n\tprint((1 + (N - 1) * (K - 1) * fun1(K)) % MOD)\nelse:\n\tprint((K * K * (2 * K - 1) + (N - 1) * (K - 1) * (K - 1) * (2 * K + 1)) * fun1(K ** 3) % MOD)\n"
    },
    {
        "task_id": 204,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 3.075561046600342,
        "fastest_time": 2.487820863723755,
        "fastest_solution": "from sys import exit\nt = int(input())\nwhile t:\n\tl = int(input())\n\tval = list(map(int, input('').split()))\n\tmindis = 150000\n\tdict = {}\n\tfor (index, i) in enumerate(val):\n\t\tif dict.get(i) or dict.get(i) == 0:\n\t\t\tans = index - dict.get(i)\n\t\t\tmindis = ans if mindis > ans else mindis\n\t\tdict[i] = index\n\tif mindis == 150000:\n\t\tprint(-1)\n\telse:\n\t\tprint(l - mindis)\n\tt -= 1\n",
        "slowest_solution": "def solve(n, a):\n\tc = [-1] * (max(a) + 1)\n\tans = -1\n\tfor i in range(n):\n\t\tif c[a[i]] >= 0:\n\t\t\tans = max(ans, n - (i - c[a[i]]))\n\t\tc[a[i]] = i\n\tprint(ans)\ndebugmode = 0\nif debugmode:\n\twith open('input.txt', 'r') as f:\n\t\tt = int(f.readline())\n\t\tfor _ in range(t):\n\t\t\tn = int(f.readline())\n\t\t\ta = list(map(int, f.readline().split()))\n\t\t\tsolve(n, a)\nelse:\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn = int(input())\n\t\ta = list(map(int, input().split()))\n\t\tsolve(n, a)\n"
    },
    {
        "task_id": 222,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 2.7193210124969482,
        "fastest_time": 2.544827938079834,
        "fastest_solution": "from sys import stdin, stdout\nvalid = True\n\ndef getnumberfromtree(node, dic, slist):\n\trst = []\n\tleftCnt = slist[node]\n\tglobal valid\n\tfor next in dic[node]:\n\t\tsubRst = getnumberfromtree(next, dic, slist)\n\t\tif subRst is None:\n\t\t\treturn None\n\t\trst.extend(subRst)\n\tif leftCnt > len(rst):\n\t\tvalid = False\n\t\treturn None\n\trst.insert(leftCnt, node)\n\treturn rst\nn = int(stdin.readline())\ndic = [[] for i in range(n)]\nroot = 0\nslist = [0] * n\nfor i in range(n):\n\tpc = list(map(int, stdin.readline().split()))\n\tslist[i] = pc[1]\n\tif pc[0] == 0:\n\t\troot = i\n\telse:\n\t\tdic[pc[0] - 1].append(i)\nres = getnumberfromtree(root, dic, slist)\nif valid:\n\tstdout.write('YES' + '\\n')\n\tfor i in range(len(res)):\n\t\tstdout.write(str(res.index(i) + 1) + ' ')\nelse:\n\tstdout.write('NO')\n",
        "slowest_solution": "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nci = [0]\n\ndef solve(x):\n\trst = []\n\tfor s in graph[x]:\n\t\trst.extend(solve(s))\n\tif len(rst) < ci[x]:\n\t\traise ValueError\n\trst.insert(ci[x], x)\n\treturn rst\nfor i in range(1, n + 1):\n\t(p, c) = map(int, input().split())\n\tgraph[p].append(i)\n\tci.append(c)\ntry:\n\tans = solve(graph[0][0])\nexcept ValueError:\n\tprint('NO')\nelse:\n\tprint('YES')\n\tfor i in range(1, n + 1):\n\t\tprint(ans.index(i) + 1, end=' ')\n"
    },
    {
        "task_id": 209,
        "slowest_solution_id": 2,
        "fastest_solution_id": 8,
        "slowest_time": 3.0648841857910156,
        "fastest_time": 2.505638360977173,
        "fastest_solution": "a = int(input())\nfor y in range(a):\n\tb = input()\n\tq = len(b) - 1\n\tc = b.count('1')\n\td = b.count('0')\n\tif c == 0 or d == 0:\n\t\tprint(0)\n\telse:\n\t\to = b[:d].count('1')\n\t\tz = b[:d].count('0')\n\t\tans = max(d - z, o)\n\t\tfor y in range(d - 1, -1, -1):\n\t\t\tif b[y] == '1':\n\t\t\t\to -= 1\n\t\t\telse:\n\t\t\t\tz -= 1\n\t\t\tif b[q] == '1':\n\t\t\t\to += 1\n\t\t\telse:\n\t\t\t\tz += 1\n\t\t\tq -= 1\n\t\t\tans = min(ans, max(d - z, o))\n\t\tprint(ans)\n",
        "slowest_solution": "t = int(input())\nans = []\nfor x in range(t):\n\ts = input()\n\tn = len(s)\n\tzi = 0\n\tnumz = {}\n\tnumz[-1] = 0\n\tfor x in range(n):\n\t\tif s[x] == '0':\n\t\t\tzi = zi + 1\n\t\tnumz[x] = zi\n\twinsize = n - zi\n\tcost = numz[winsize - 1] - numz[-1]\n\tfor x in range(-1, n - winsize):\n\t\tcost = min(cost, numz[x + winsize] - numz[x])\n\tans.append(cost)\nfor a in ans:\n\tprint(a)\n"
    },
    {
        "task_id": 210,
        "slowest_solution_id": 1,
        "fastest_solution_id": 6,
        "slowest_time": 2.7752864360809326,
        "fastest_time": 2.5082077980041504,
        "fastest_solution": "import sys\nimport math\nn = int(input().strip())\narr = [int(arr_i) for arr_i in input().strip().split(' ')]\nflag = True\ntemp = 4294967296\nfor i in range(32, -1, -1):\n\ta = [x for x in arr if x >= temp]\n\ttemp = temp >> 1\n\tif len(a) >= math.floor(n / 2):\n\t\tif n % 2 == 1:\n\t\t\tif len(a) == math.ceil(n / 2):\n\t\t\t\tprint(i - 1)\n\t\t\t\tflag = False\n\t\tif flag:\n\t\t\tprint(i)\n\t\tflag = False\n\t\tbreak\nif flag:\n\tprint(-1)\n",
        "slowest_solution": "from collections import Counter\n\ndef main():\n\tn = int(input())\n\ta = [int(f) for f in input().split()]\n\tprint(manip(a))\n\ndef manip(a):\n\tmaxplace = 0\n\thi = max(a)\n\twhile hi >= 1 << maxplace:\n\t\tmaxplace += 1\n\tmaxplace -= 1\n\twhile 2 * max(Counter((elt >> maxplace for elt in a)).values()) > len(a):\n\t\tmaxplace -= 1\n\treturn maxplace\nmain()\n"
    },
    {
        "task_id": 214,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 2.9392223358154297,
        "fastest_time": 2.5450806617736816,
        "fastest_solution": "t=int(input())\nlst=[]\nwhile t:\n\tt-=1\n\ta,b,n=list(map(int,input().split()))\n\tlst=list(map(int,input().split()))\n\tlst.sort()\n\tcnta=0\n\tcntb=0\n\t\n\tfor i in range(n):\n\t\tif lst[i]<=a:\n\t\t\ta-=lst[i]\n\t\t\tcnta+=1\n\t\tif lst[i]<=b:\n\t\t\tb-=lst[i]\n\t\t\tcntb+=1\n\t\n\tif cnta>cntb:\n\t\tprint(\"Raghu Won\")\n\telif cnta<cntb:\n\t\tprint(\"Sayan Won\")\n\telse:\n\t\tprint(\"Tie\")\n",
        "slowest_solution": "t=eval(input())\nwhile t>0:\n\tctr=0\n\tctr1=0\n\ta,b,n=list(map(int,input().split()))\n\tx=list(map(int,input().split()))\n\tx.sort()\n\tfor i in range(0,n):\n\t\tif x[i]<=a:\n\t\t\ta=a-x[i]\n\t\t\tctr=ctr+1\n\t\tif x[i]<=b:\n\t\t\tb=b-x[i]\n\t\t\tctr1=ctr1+1\n\tif ctr>ctr1:\n\t\tprint(\"Raghu Won\")\n\telif ctr<ctr1:\n\t\tprint(\"Sayan Won\")\n\telse:\n\t\tprint(\"Tie\")\n\tt=t-1\n \n"
    },
    {
        "task_id": 263,
        "slowest_solution_id": 9,
        "fastest_solution_id": 0,
        "slowest_time": 0.005485057830810547,
        "fastest_time": 0.0,
        "fastest_solution": "(COLUMNS, ROWS) = ('ABCDEFG', range(6))\nLINES = [{(COLUMNS[i + k], ROWS[j]) for k in range(4)} for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] + [{(COLUMNS[i], ROWS[j + k]) for k in range(4)} for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] + [{(COLUMNS[i + k], ROWS[j + k]) for k in range(4)} for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] + [{(COLUMNS[i + k], ROWS[j - k]) for k in range(4)} for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\ndef who_is_winner(pieces_positions):\n\tplayers = {}\n\tboard = dict.fromkeys(COLUMNS, 0)\n\tfor position in pieces_positions:\n\t\t(column, player) = position.split('_')\n\t\tpos = (column, board[column])\n\t\tboard[column] += 1\n\t\tplayers.setdefault(player, set()).add(pos)\n\t\tif any((line <= players[player] for line in LINES)):\n\t\t\treturn player\n\treturn 'Draw'\n",
        "slowest_solution": "def who_is_winner(moves):\n\tfield = [[' ' for i in range(7)] for j in range(6)]\n\tfor move in moves:\n\t\t(column, color) = move.split('_')\n\t\tfield = place_color(field, column, color)\n\t\tresult = check_win(field)\n\t\tif result:\n\t\t\treturn result\n\treturn 'Draw'\n\ndef check_win(field):\n\tfield = list(reversed(field))\n\tfor i in field:\n\t\tfor j in range(4):\n\t\t\th = set(i[j:4 + j])\n\t\t\tif h == {'R'}:\n\t\t\t\treturn 'Red'\n\t\t\telif h == {'Y'}:\n\t\t\t\treturn 'Yellow'\n\tfor i in range(3):\n\t\tfor j in range(7):\n\t\t\tv = set([field[i + k][j] for k in range(4)])\n\t\t\tif v == {'R'}:\n\t\t\t\treturn 'Red'\n\t\t\telif v == {'Y'}:\n\t\t\t\treturn 'Yellow'\n\tfor i in range(3):\n\t\tfor j in range(4):\n\t\t\tr = [field[i][j], field[i + 1][j + 1], field[i + 2][j + 2], field[i + 3][j + 3]]\n\t\t\tl = [field[i][-j - 1], field[i + 1][-j - 2], field[i + 2][-j - 3], field[i + 3][-j - 4]]\n\t\t\tif set(r) == {'R'} or set(l) == {'R'}:\n\t\t\t\treturn 'Red'\n\t\t\telif set(r) == {'Y'} or set(l) == {'Y'}:\n\t\t\t\treturn 'Yellow'\n\treturn 0\n\ndef place_color(field, column, color):\n\tindex = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6}[column]\n\tfor i in range(1, 7 + 1):\n\t\tif field[-i][index] == ' ':\n\t\t\tfield[-i][index] = color[0]\n\t\t\tbreak\n\treturn field\n"
    },
    {
        "task_id": 223,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 2.985243797302246,
        "fastest_time": 2.5100817680358887,
        "fastest_solution": "def solve(N, M):\n\tres = None\n\tmax_diff = 0\n\tfor a in range(N, min(2 * N, M + 1)):\n\t\tr = M % a\n\t\tb = M - r\n\t\td = abs(b - a)\n\t\tif d >= max_diff:\n\t\t\tmax_diff = d\n\t\t\tres = (a, b)\n\treturn res\nt = int(input())\nfor ti in range(t):\n\t(N, M) = map(int, input().split())\n\tres = solve(N, M)\n\tprint(*res)\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\t(x, y) = map(int, input().split())\n\tf = y - y % x - x\n\tnum = [x, x * (y // x)]\n\tfor i in range(x + 1, min(y + 1, x * 2)):\n\t\tif y - y % i - i >= f:\n\t\t\tf = y - y % i - i\n\t\t\tnum = [i, i * (y // i)]\n\t\t\tcontinue\n\tprint(*num)\n"
    },
    {
        "task_id": 218,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 3.0890722274780273,
        "fastest_time": 2.5236470699310303,
        "fastest_solution": "s = input().split()\nn = int(s[0])\nm = int(s[1])\nans = 0\nwhile ans * (ans - 1) / 2 < m:\n\tans += 1\nprint(max(0, n - m * 2), n - ans)\n",
        "slowest_solution": "from math import *\n(n, m) = map(int, input().split())\nmin = n - 2 * m\nmax = n\nif m > 0:\n\tx = ceil((1 + sqrt(1 + 8 * m)) / 2)\n\tmax -= x\nif min < 0:\n\tmin = 0\nif max < 0:\n\tmax = 0\nprint(min, max)\n"
    },
    {
        "task_id": 266,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 0.005583763122558594,
        "fastest_time": 0.0,
        "fastest_solution": "def primeFactors(n):\n\tfactors = []\n\twhile n % 2 == 0:\n\t\tn /= 2\n\t\tfactors.append(2)\n\tfor i in range(3, int(n ** 0.5) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tn /= i\n\t\t\tfactors.insert(0, i)\n\tif n > 2:\n\t\tfactors.insert(0, int(n))\n\treturn factors\n\ndef score(p):\n\t(last, xp, s) = (p[0], p[0], 0)\n\tfor j in p[1:]:\n\t\tif j == last:\n\t\t\txp *= j\n\t\telse:\n\t\t\ts += xp\n\t\t\t(xp, last) = (j, j)\n\treturn (s + xp) * len(p)\n\ndef prod(lst):\n\tres = 1\n\tfor v in lst:\n\t\tres *= v\n\treturn res\n\ndef multiply_partitions(partition):\n\treturn [prod(sub) for sub in partition]\n\ndef partition(collection):\n\tif len(collection) == 1:\n\t\tyield [collection]\n\t\treturn\n\tfirst = collection[0]\n\tfor smaller in partition(collection[1:]):\n\t\tfor (n, subset) in enumerate(smaller):\n\t\t\tyield (smaller[:n] + [[first] + subset] + smaller[n + 1:])\n\t\tyield ([[first]] + smaller)\n\ndef find_spec_prod_part(n, com):\n\tfactors = primeFactors(n)\n\tif len(factors) == 1:\n\t\treturn 'It is a prime number'\n\tfn = min if com == 'min' else max\n\tmplist = []\n\tbest = [factors, score(factors)]\n\tfor p in partition(factors):\n\t\tmp = multiply_partitions(p)\n\t\tif mp in mplist or mp[0] == n:\n\t\t\tcontinue\n\t\tmplist.append(mp)\n\t\tbest = fn(best, [mp, score(mp)], key=lambda x: x[1])\n\treturn [sorted(best[0], reverse=True), best[1]]\n",
        "slowest_solution": "from collections import Counter\nfrom itertools import permutations\nfrom itertools import chain\nimport numpy as np\n\ndef prime_factors(n):\n\tfactors = []\n\twhile n % 2 == 0:\n\t\tn = n // 2\n\t\tfactors.append(2)\n\tfor k in range(3, n + 1, 2):\n\t\twhile n % k == 0:\n\t\t\tn = n // k\n\t\t\tfactors.append(k)\n\t\tif n == 1:\n\t\t\tbreak\n\treturn factors\n\ndef get_score(factors):\n\tfactor_counts = Counter(factors)\n\treturn sum((f ** factor_counts[f] for f in factor_counts)) * sum((c for c in factor_counts.values()))\n\ndef int_partitions(m, memo={}):\n\tif m in memo:\n\t\treturn memo[m]\n\tall_partitions = [[m]]\n\tfor i in range(1, m):\n\t\tfor p in int_partitions(m - i, memo):\n\t\t\tall_partitions.append([i] + p)\n\tmemo[m] = all_partitions\n\treturn all_partitions\n\ndef make_partitions(factors):\n\tpartitions = int_partitions(len(factors))\n\tpart_perm = []\n\tfor p in partitions:\n\t\tpart_perm.append(set(list(permutations(p, len(p)))))\n\tpart_perm = set(list(chain.from_iterable(part_perm)))\n\tall_new_factors = []\n\tfor inds in part_perm:\n\t\tnew_factors = []\n\t\tj_start = 0\n\t\tfor i in inds:\n\t\t\tj_end = j_start + i\n\t\t\tnew_factors.append(np.product(factors[j_start:j_end]))\n\t\t\tj_start = j_end\n\t\tif len(new_factors) > 1:\n\t\t\tall_new_factors.append(new_factors)\n\treturn all_new_factors\n\ndef find_spec_prod_part(n, com):\n\tfactors = prime_factors(n)\n\tif len(factors) == 1:\n\t\treturn 'It is a prime number'\n\tall_factors = make_partitions(factors)\n\tscores = [get_score(x) for x in all_factors]\n\tif com == 'max':\n\t\topt_id = np.argmax(scores)\n\telse:\n\t\topt_id = np.argmin(scores)\n\treturn [sorted(all_factors[opt_id], reverse=True), scores[opt_id]]\n"
    },
    {
        "task_id": 268,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 0.000507354736328125,
        "fastest_time": 0.0,
        "fastest_solution": "def diagonal_sum(array):\n\treturn sum((row[i] for (i, row) in enumerate(array)))\n",
        "slowest_solution": "from numpy import trace as diagonal_sum\n"
    },
    {
        "task_id": 231,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.6487369537353516,
        "fastest_time": 2.5468015670776367,
        "fastest_solution": "def main():\n\t(n, k) = list(map(int, input().split()))\n\tl = sorted(map(int, input().split()))\n\t(lo, hi) = (l[0], l[-1])\n\twhile lo < hi - 1:\n\t\tmid = (lo + hi) // 2\n\t\tt = k\n\t\tfor x in l:\n\t\t\tif x > mid:\n\t\t\t\tlo = mid\n\t\t\t\tbreak\n\t\t\tt -= mid - x\n\t\t\tif t < 0:\n\t\t\t\thi = mid\n\t\t\t\tbreak\n\t\telse:\n\t\t\tlo = mid\n\tm1 = lo\n\t(lo, hi) = (l[0], l[-1])\n\tl.reverse()\n\twhile lo < hi - 1:\n\t\tmid = (lo + hi) // 2\n\t\tt = k\n\t\tfor x in l:\n\t\t\tif x < mid:\n\t\t\t\thi = mid\n\t\t\t\tbreak\n\t\t\tt -= x - mid\n\t\t\tif t < 0:\n\t\t\t\tlo = mid\n\t\t\t\tbreak\n\t\telse:\n\t\t\thi = mid\n\tprint(hi - m1 if hi > m1 else 1 if sum(l) % n else 0)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n",
        "slowest_solution": "N = 500005\nC = [0] * N\n\ndef doit():\n\tglobal k\n\tC[1:n + 1] = sorted(C[1:n + 1])\n\tlast = C[1]\n\ttemp = k\n\tfor i in range(2, n + 1):\n\t\tif (C[i] - last) * (i - 1) <= k:\n\t\t\tk -= (C[i] - last) * (i - 1)\n\t\t\tlast = C[i]\n\tj = 0\n\twhile j + 1 <= n and C[j + 1] <= last:\n\t\tj += 1\n\tgo = k // j\n\tleft = k % j\n\tfor i in range(1, j + 1):\n\t\tC[i] = last + go + (i <= left)\n\tk = temp\n\ndef rev():\n\tfor i in range(1, n + 1):\n\t\tC[i] = -C[i]\n(n, k) = map(int, input().split())\nc = list(map(int, input().split()))\nfor i in range(1, n + 1):\n\tC[i] = c[i - 1]\ndoit()\nrev()\ndoit()\nrev()\nC[1:n + 1] = sorted(C[1:n + 1])\nprint(C[n] - C[1])\n"
    },
    {
        "task_id": 216,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.774223566055298,
        "fastest_time": 2.4750473499298096,
        "fastest_solution": "(n, h) = map(int, input().strip().split())\narr = list(map(int, input().strip().split()))\nar = []\nans = 0\nfor i in range(len(arr)):\n\tar.append(arr[i])\n\tar = sorted(ar)\n\tval = 0\n\tj = len(ar) - 1\n\twhile j >= 0:\n\t\tif j != 0:\n\t\t\tval += max(ar[j], ar[j - 1])\n\t\telse:\n\t\t\tval += ar[j]\n\t\tj -= 2\n\tif val <= h:\n\t\tans = max(ans, i + 1)\nprint(ans)\n",
        "slowest_solution": "import sys, math, queue\nsys.setrecursionlimit(1000000)\n\ndef canPut(k, height, bot):\n\tbot.sort(reverse=True)\n\tfor i in range(k):\n\t\tif bot[i] > height:\n\t\t\treturn False\n\t\tif i % 2 == 1:\n\t\t\theight -= bot[i - 1]\n\treturn True\n(n, height) = map(int, input().split())\nbot = list(map(int, input().split()))\n(l, h) = (1, n)\nwhile l <= h:\n\tm = (l + h) // 2\n\tif canPut(m, height, bot[:m]):\n\t\tans = m\n\t\tl = m + 1\n\telse:\n\t\th = m - 1\nprint(ans)\n"
    },
    {
        "task_id": 264,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6538469791412354,
        "fastest_time": 2.6538469791412354,
        "fastest_solution": "from sys import stdin\nstdin = iter(stdin)\n\nclass Vector:\n\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\n\tdef __sub__(self, other):\n\t\treturn Vector(self.x - other.x, self.y - other.y)\n\n\tdef __add__(self, other):\n\t\treturn Vector(self.x + other.x, self.y + other.y)\n\n\tdef dot(self, vec2):\n\t\treturn self.x * vec2.x + self.y * vec2.y\n\n\tdef cross(self, vec2):\n\t\treturn self.x * vec2.y - self.y * vec2.x\n\n\tdef norm_square(self):\n\t\treturn self.dot(self)\n\n\tdef __str__(self):\n\t\treturn str((self.x, self.y))\n\t__radd__ = __add__\n\t__rsub__ = __sub__\n\ndef min_distnace_less_than_d1(ab1: Vector, ab2: Vector, d1: int):\n\tL = ab2 - ab1\n\tproj1 = ab1.dot(L)\n\tproj2 = ab2.dot(L)\n\tbetween = proj1 * proj2 < 0\n\tif between:\n\t\treturn ab1.cross(L) ** 2 <= d1 ** 2 * L.norm_square()\n\telse:\n\t\tminSquare = min([ab1.norm_square(), ab2.norm_square()])\n\t\treturn minSquare <= d1 ** 2\nN = int(next(stdin))\n(d1, d2) = (int(x) for x in next(stdin).split())\nABs = []\nfor _ in range(N):\n\t(Ax, Ay, Bx, By) = (int(x) for x in next(stdin).split())\n\tABs.append(Vector(Bx, By) - Vector(Ax, Ay))\nresetState = True\ncount = 0\nfor i in range(len(ABs) - 1):\n\t(ab1, ab2) = ABs[i:i + 2]\n\tif resetState and min_distnace_less_than_d1(ab1, ab2, d1):\n\t\tcount += 1\n\t\tresetState = False\n\tresetState = resetState or ab2.norm_square() > d2 ** 2\nprint(count)\n",
        "slowest_solution": "from sys import stdin\nstdin = iter(stdin)\n\nclass Vector:\n\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\n\tdef __sub__(self, other):\n\t\treturn Vector(self.x - other.x, self.y - other.y)\n\n\tdef __add__(self, other):\n\t\treturn Vector(self.x + other.x, self.y + other.y)\n\n\tdef dot(self, vec2):\n\t\treturn self.x * vec2.x + self.y * vec2.y\n\n\tdef cross(self, vec2):\n\t\treturn self.x * vec2.y - self.y * vec2.x\n\n\tdef norm_square(self):\n\t\treturn self.dot(self)\n\n\tdef __str__(self):\n\t\treturn str((self.x, self.y))\n\t__radd__ = __add__\n\t__rsub__ = __sub__\n\ndef min_distnace_less_than_d1(ab1: Vector, ab2: Vector, d1: int):\n\tL = ab2 - ab1\n\tproj1 = ab1.dot(L)\n\tproj2 = ab2.dot(L)\n\tbetween = proj1 * proj2 < 0\n\tif between:\n\t\treturn ab1.cross(L) ** 2 <= d1 ** 2 * L.norm_square()\n\telse:\n\t\tminSquare = min([ab1.norm_square(), ab2.norm_square()])\n\t\treturn minSquare <= d1 ** 2\nN = int(next(stdin))\n(d1, d2) = (int(x) for x in next(stdin).split())\nABs = []\nfor _ in range(N):\n\t(Ax, Ay, Bx, By) = (int(x) for x in next(stdin).split())\n\tABs.append(Vector(Bx, By) - Vector(Ax, Ay))\nresetState = True\ncount = 0\nfor i in range(len(ABs) - 1):\n\t(ab1, ab2) = ABs[i:i + 2]\n\tif resetState and min_distnace_less_than_d1(ab1, ab2, d1):\n\t\tcount += 1\n\t\tresetState = False\n\tresetState = resetState or ab2.norm_square() > d2 ** 2\nprint(count)\n"
    },
    {
        "task_id": 233,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 2.7318739891052246,
        "fastest_time": 2.5843429565429688,
        "fastest_solution": "def wave(x, a):\n\t(p, q) = (0, n - 1)\n\twhile p <= q:\n\t\tavg = (p + q) // 2\n\t\tif a[avg] < x:\n\t\t\tp = avg + 1\n\t\telse:\n\t\t\tq = avg - 1\n\treturn p\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nfor i in range(q):\n\tx = int(input())\n\tres = wave(x, a)\n\tif res >= n:\n\t\tprint('POSITIVE')\n\telif x == a[res]:\n\t\tprint('0')\n\telif n - res & 1:\n\t\tprint('NEGATIVE')\n\telse:\n\t\tprint('POSITIVE')\n",
        "slowest_solution": "def binary_search(s_l, c):\n\tlow = 0\n\thigh = len(s_l) - 1\n\twhile low <= high:\n\t\tmid = (low + high) // 2\n\t\tif s_l[mid] == c:\n\t\t\treturn -1\n\t\telif s_l[mid] > c:\n\t\t\thigh = mid - 1\n\t\telse:\n\t\t\tlow = mid + 1\n\treturn low\n(a, b) = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\nfor i in range(b):\n\tc = int(input())\n\ta = binary_search(l, c)\n\tif a == -1:\n\t\tprint(0)\n\telif a > len(l):\n\t\tprint('POSITIVE')\n\telif (len(l) - a) % 2 == 0:\n\t\tprint('POSITIVE')\n\telse:\n\t\tprint('NEGATIVE')\n"
    },
    {
        "task_id": 225,
        "slowest_solution_id": 9,
        "fastest_solution_id": 3,
        "slowest_time": 2.6817781925201416,
        "fastest_time": 2.5378658771514893,
        "fastest_solution": "from math import factorial\n_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n\ndef factors(M):\n\treturn [p for p in _primes if M % p == 0]\n\ndef digits(n, p):\n\twhile n:\n\t\tyield (n % p)\n\t\tn //= p\n\ndef inverse(n, p):\n\treturn pow(n, p - 2, p)\n\ndef choose(n, k):\n\tif n == k == 0:\n\t\treturn 1\n\tif n < k or n == 0:\n\t\treturn 0\n\tk = min(k, n - k)\n\tif k == n or k == 0:\n\t\treturn 1\n\tresult = 1\n\tfor n in range(n, n - k, -1):\n\t\tresult *= n\n\tfor d in range(1, k + 1):\n\t\tresult //= d\n\treturn result\n\ndef chinese_remainder(congruences, primes, M):\n\ttotal = 0\n\tfor (a, p) in zip(congruences, primes):\n\t\tm = M // p\n\t\ttotal += a * inverse(m, p) * m\n\treturn total % M\n\ndef chooseMod(n, k, M):\n\tif n == k == 0:\n\t\treturn 1\n\tif n < k or n == 0:\n\t\treturn 0\n\tk = min(k, n - k)\n\tif k == n or k == 0:\n\t\treturn 1\n\tprimes = factors(M)\n\tcongruences = [0] * len(primes)\n\tfor (i, p) in enumerate(primes):\n\t\tprod = 1\n\t\tfor (ni, ki) in zip(digits(n, p), digits(k, p)):\n\t\t\tprod *= choose(ni, ki)\n\t\t\tif prod == 0:\n\t\t\t\tbreak\n\t\tcongruences[i] = prod\n\treturn chinese_remainder(congruences, primes, M)\ncases = int(input())\nfor _ in range(cases):\n\t(n, k, M) = [int(x) for x in input().split()]\n\tprint(chooseMod(n, k, M))\n",
        "slowest_solution": "import itertools, sys\nPRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n\ndef base_coefficients(n, base):\n\tcoefficients = []\n\twhile n > 0:\n\t\tcoefficients.append(n % base)\n\t\tn //= base\n\treturn coefficients\n\ndef choose(n, k):\n\tif k < 0 or k > n:\n\t\treturn 0\n\telse:\n\t\t(p, q) = (1, 1)\n\t\tfor i in range(1, min(k, n - k) + 1):\n\t\t\tp *= n\n\t\t\tq *= i\n\t\t\tn -= 1\n\t\treturn p // q\n\ndef lucas_theorem(n, k, p):\n\tx = itertools.zip_longest(base_coefficients(n, p), base_coefficients(k, p), fillvalue=0)\n\tproduct = 1\n\tfor (n_i, k_i) in x:\n\t\tproduct = product * choose(n_i, k_i) % p\n\treturn product\nT = int(sys.stdin.readline())\nfor _ in range(T):\n\t(N, R, M) = list(map(int, sys.stdin.readline().split()))\n\tprimes = [p for p in PRIMES if M % p == 0]\n\ttotal = 0\n\tfor p in primes:\n\t\ttotal += lucas_theorem(N, R, p) * (M // p) * pow(M // p, p - 2, p) % M\n\tprint(total % M)\n"
    },
    {
        "task_id": 226,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 2.778520107269287,
        "fastest_time": 2.4981002807617188,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, m) = [int(x) for x in input().split()]\n\tl = [None] * (n + 1)\n\tfor _ in range(m):\n\t\t(x, y) = [int(x) for x in input().split()]\n\t\tl[x] = y\n\tans = 0\n\tvisited = [False] * (n + 1)\n\tfor i in range(n + 1):\n\t\tif l[i] == None or l[i] == i or visited[i]:\n\t\t\tcontinue\n\t\t(tmp, cnt) = (l[i], 1)\n\t\tvisited[i] = True\n\t\twhile tmp != i and tmp != None and (visited[tmp] == False):\n\t\t\tvisited[tmp] = True\n\t\t\ttmp = l[tmp]\n\t\t\tcnt += 1\n\t\tcnt += tmp == i\n\t\tcnt -= tmp == None\n\t\tans += cnt\n\tprint(ans)\n",
        "slowest_solution": "T = int(input())\nfor iw in range(T):\n\t(n, m) = map(int, input().split())\n\tans = 0\n\tX = [-1] * (n + 1)\n\tfor i in range(m):\n\t\t(x, y) = map(int, input().split())\n\t\tif x != y:\n\t\t\tans += 1\n\t\t\tX[x] = y\n\tfor i in range(1, n + 1):\n\t\tif X[i] > 0:\n\t\t\tt = i\n\t\t\twhile X[i] > 0:\n\t\t\t\tx = X[i]\n\t\t\t\tX[i] = 0\n\t\t\t\ti = x\n\t\t\t\tif i == t:\n\t\t\t\t\tans += 1\n\t\t\t\t\tbreak\n\tprint(ans)\n"
    },
    {
        "task_id": 272,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6538262367248535,
        "fastest_time": 2.6538262367248535,
        "fastest_solution": "F = ['', 'a', 'b', 'ba', 'bab', 'babba', 'babbabab', 'babbababbabba', 'babbababbabbababbabab', 'babbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbabab', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabab', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabab']\nwhile len(F[-3]) < 100000:\n\tF.append(F[-1] + F[-2])\nd = 1000000007\n\ndef sqr(t):\n\treturn [[sum((t[i][k] * t[k][j] for k in range(4))) % d for j in range(4)] for i in range(4)]\n\ndef mul(a, b):\n\treturn [[sum((a[i][k] * b[k][j] for k in range(4))) % d for j in range(4)] for i in range(4)]\n\ndef fib(k):\n\t(s, p) = (format(k, 'b')[::-1], [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])\n\tt = [[[0, 1, 0, 0], [1, 1, 1, 0], [0, 0, 0, 1], [0, 0, 1, 0]]] + [0] * (len(s) - 1)\n\tfor i in range(1, len(s)):\n\t\tt[i] = sqr(t[i - 1])\n\tfor (i, k) in enumerate(s):\n\t\tif k == '1':\n\t\t\tp = mul(p, t[i])\n\treturn p\n\ndef cnt(t, p):\n\t(s, i) = (0, p.find(t) + 1)\n\twhile i > 0:\n\t\ti = p.find(t, i) + 1\n\t\ts += 1\n\treturn s\n\ndef f(t, p, k):\n\tl = len(t) - 1\n\tif l:\n\t\t(x, y) = (cnt(t, F[k - 1][-l:] + F[k][:l]), cnt(t, F[k][-l:] + F[k + 1][:l]))\n\telse:\n\t\t(x, y) = (0, 0)\n\t(a, b) = (cnt(t, F[k - 1]), cnt(t, F[k]))\n\treturn (p[0] * a + p[1] * b + p[2] * y + p[3] * x) % d\n(k, m) = map(int, input().split())\nif k > 15:\n\t(x, y, z) = (len(F[7]), len(F[17]), len(F) - 4)\n\t(a, b, c) = (fib(k - 7)[0], fib(k - 17)[0], fib(k - z)[0])\n\tfor i in range(m):\n\t\tt = input()\n\t\tif len(t) < x:\n\t\t\tprint(f(t, a, 8))\n\t\telif len(t) < y:\n\t\t\tprint(f(t, b, 18))\n\t\telse:\n\t\t\tprint(f(t, c, z + 1))\nelse:\n\tp = F[k]\n\tfor i in range(m):\n\t\tprint(cnt(input(), p))\n",
        "slowest_solution": "F = ['', 'a', 'b', 'ba', 'bab', 'babba', 'babbabab', 'babbababbabba', 'babbababbabbababbabab', 'babbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbabab', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabab', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabba', 'babbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabbababbababbabbababbababbabbababbabbababbababbabbababbabab']\nwhile len(F[-3]) < 100000:\n\tF.append(F[-1] + F[-2])\nd = 1000000007\n\ndef sqr(t):\n\treturn [[sum((t[i][k] * t[k][j] for k in range(4))) % d for j in range(4)] for i in range(4)]\n\ndef mul(a, b):\n\treturn [[sum((a[i][k] * b[k][j] for k in range(4))) % d for j in range(4)] for i in range(4)]\n\ndef fib(k):\n\t(s, p) = (format(k, 'b')[::-1], [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])\n\tt = [[[0, 1, 0, 0], [1, 1, 1, 0], [0, 0, 0, 1], [0, 0, 1, 0]]] + [0] * (len(s) - 1)\n\tfor i in range(1, len(s)):\n\t\tt[i] = sqr(t[i - 1])\n\tfor (i, k) in enumerate(s):\n\t\tif k == '1':\n\t\t\tp = mul(p, t[i])\n\treturn p\n\ndef cnt(t, p):\n\t(s, i) = (0, p.find(t) + 1)\n\twhile i > 0:\n\t\ti = p.find(t, i) + 1\n\t\ts += 1\n\treturn s\n\ndef f(t, p, k):\n\tl = len(t) - 1\n\tif l:\n\t\t(x, y) = (cnt(t, F[k - 1][-l:] + F[k][:l]), cnt(t, F[k][-l:] + F[k + 1][:l]))\n\telse:\n\t\t(x, y) = (0, 0)\n\t(a, b) = (cnt(t, F[k - 1]), cnt(t, F[k]))\n\treturn (p[0] * a + p[1] * b + p[2] * y + p[3] * x) % d\n(k, m) = map(int, input().split())\nif k > 15:\n\t(x, y, z) = (len(F[7]), len(F[17]), len(F) - 4)\n\t(a, b, c) = (fib(k - 7)[0], fib(k - 17)[0], fib(k - z)[0])\n\tfor i in range(m):\n\t\tt = input()\n\t\tif len(t) < x:\n\t\t\tprint(f(t, a, 8))\n\t\telif len(t) < y:\n\t\t\tprint(f(t, b, 18))\n\t\telse:\n\t\t\tprint(f(t, c, z + 1))\nelse:\n\tp = F[k]\n\tfor i in range(m):\n\t\tprint(cnt(input(), p))\n"
    },
    {
        "task_id": 238,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 2.678231954574585,
        "fastest_time": 2.479997396469116,
        "fastest_solution": "from sys import stdin, stdout\nedges = []\nparent = []\nheight = []\n\ndef setOf(v):\n\tp = parent[v]\n\tif p == v:\n\t\treturn p\n\treturn setOf(p)\n\ndef merge(v, w):\n\tif height[v] > height[w]:\n\t\tparent[w] = v\n\telif height[w] > height[v]:\n\t\tparent[v] = w\n\telse:\n\t\tparent[w] = v\n\t\theight[v] += 1\n\ndef Kruskal(n):\n\tglobal edges\n\tedges.sort(key=lambda x: x[0])\n\tglobal parent\n\tparent = [i for i in range(n)]\n\tglobal height\n\theight = [0] * n\n\tmst_cost = 0\n\tfor edge in edges:\n\t\troot_a = setOf(edge[1])\n\t\troot_b = setOf(edge[2])\n\t\tif root_a != root_b:\n\t\t\tmst_cost -= edge[0]\n\t\t\tmerge(root_a, root_b)\n\treturn mst_cost\n\ndef avoid_rainbow_cycles(total, n):\n\tforrest_cost = Kruskal(n)\n\tstdout.write('{}\\n'.format(total - forrest_cost))\n\ndef main_method():\n\t(m, n) = map(int, stdin.readline().split())\n\ta = list(map(int, stdin.readline().split()))\n\tb = list(map(int, stdin.readline().split()))\n\tglobal edges\n\tedges = []\n\ttotal = 0\n\tfor i in range(m):\n\t\tsi = list(map(int, stdin.readline().split()))\n\t\tcsi = a[i]\n\t\tsetNumber = n + i\n\t\tfor j in range(1, si[0] + 1):\n\t\t\tvertex = si[j] - 1\n\t\t\tedge_cost = csi + b[vertex]\n\t\t\ttotal += edge_cost\n\t\t\tedges.append((-edge_cost, vertex, setNumber))\n\tavoid_rainbow_cycles(total, n + m)\nmain_method()\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef root(x):\n\tif x == p[x]:\n\t\treturn x\n\tp[x] = y = root(p[x])\n\treturn y\n\ndef unite(x, y):\n\tpx = root(x)\n\tpy = root(y)\n\tif px == py:\n\t\treturn 0\n\trx = rank[px]\n\try = rank[py]\n\tif ry < rx:\n\t\tp[py] = px\n\telif rx < ry:\n\t\tp[px] = py\n\telse:\n\t\tp[py] = px\n\t\trank[px] += 1\n\treturn\n(M, N) = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nE = []\nR = 0\nfor i in range(M):\n\tX = list(map(int, input().split()))\n\tfor j in X[1:]:\n\t\tE.append((N + i, j - 1, -A[i] - B[j - 1]))\n\t\tR += A[i] + B[j - 1]\nE.sort(key=lambda x: x[2])\n(*p,) = range(N + M)\nrank = [1] * (N + M)\nfor (v, u, c) in E:\n\tif root(v) != root(u):\n\t\tunite(v, u)\n\t\tR += c\nprint(R)\n"
    },
    {
        "task_id": 275,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7095260620117188,
        "fastest_time": 2.7095260620117188,
        "fastest_solution": "n = int(input())\nt = [list(map(int, input().split())) for q in range(n)]\nt[0][0] = 0\nn += 1\nu = [-10000000.0] * n\nv = [0] * n\nfor (i, (j, a)) in list(enumerate(t, 1))[::-1]:\n\tu[i] = max(u[i], v[i] + a)\n\t(v[j], u[j]) = (max(v[j] + v[i], u[j] + u[i]), max(v[j] + u[i], u[j] + v[i]))\nprint(u[1])\n",
        "slowest_solution": "n = int(input())\nt = [list(map(int, input().split())) for q in range(n)]\nt[0][0] = 0\nn += 1\nu = [-10000000.0] * n\nv = [0] * n\nfor (i, (j, a)) in list(enumerate(t, 1))[::-1]:\n\tu[i] = max(u[i], v[i] + a)\n\t(v[j], u[j]) = (max(v[j] + v[i], u[j] + u[i]), max(v[j] + u[i], u[j] + v[i]))\nprint(u[1])\n"
    },
    {
        "task_id": 259,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 2.6853816509246826,
        "fastest_time": 2.5087578296661377,
        "fastest_solution": "class DisjointSetUnion:\n\n\tdef __init__(self, n, A):\n\t\tself.parent = list(range(n))\n\t\tself.size = [1] * n\n\t\tself.asp = A[:]\n\t\tself.num_sets = n\n\t\tself.adj = [[] for i in range(n)]\n\t\tself.bad = 0\n\n\tdef find(self, a):\n\t\tacopy = a\n\t\twhile a != self.parent[a]:\n\t\t\ta = self.parent[a]\n\t\twhile acopy != a:\n\t\t\t(self.parent[acopy], acopy) = (a, self.parent[acopy])\n\t\treturn a\n\n\tdef union(self, a, b):\n\t\t(a, b) = (self.find(a), self.find(b))\n\t\tif a != b:\n\t\t\tif self.size[a] < self.size[b]:\n\t\t\t\t(a, b) = (b, a)\n\t\t\tif len(self.adj[a]) < len(self.adj[b]):\n\t\t\t\t(self.adj[a], self.adj[b]) = (self.adj[b], self.adj[a])\n\t\t\tself.adj[a].extend(self.adj[b])\n\t\t\tself.num_sets -= 1\n\t\t\tself.parent[b] = a\n\t\t\tself.size[a] += self.size[b]\n\t\t\tself.asp[a] += self.asp[b]\n\t\t\tself.asp[a] -= x\n\n\tdef set_size(self, a):\n\t\treturn self.size[self.find(a)]\n\n\tdef __len__(self):\n\t\treturn self.num_sets\nimport sys\ninput = sys.stdin.readline\n(n, m, x) = map(int, input().split())\nx = float(x)\na = list(map(float, input().split()))\nif sum(a) < (n - 1) * x:\n\tprint('NO')\n\texit()\nprint('YES')\nUF = DisjointSetUnion(n, a)\nq = [i for i in range(n) if a[i] >= x]\nedges = []\nfor i in range(m):\n\t(u, v) = map(int, input().split())\n\tu -= 1\n\tv -= 1\n\tedges.append((u, v))\n\tUF.adj[u].append(i)\n\tUF.adj[v].append(i)\nout = []\ncurr = 0\nfor run in range(n - 1):\n\tdone = False\n\twhile q:\n\t\tind = q.pop()\n\t\tif UF.parent[ind] == ind and UF.asp[ind] >= x:\n\t\t\tdone = True\n\t\t\twhile True:\n\t\t\t\te = UF.adj[ind].pop()\n\t\t\t\t(u, v) = edges[e]\n\t\t\t\tif UF.find(u) == ind:\n\t\t\t\t\t(u, v) = (v, u)\n\t\t\t\tif UF.find(u) == ind:\n\t\t\t\t\tcontinue\n\t\t\t\tout.append(e)\n\t\t\t\tUF.union(u, v)\n\t\t\t\tw = UF.find(u)\n\t\t\t\tif UF.asp[w] >= x:\n\t\t\t\t\tq.append(w)\n\t\t\t\tbreak\n\t\tif done:\n\t\t\tbreak\n\tif not done:\n\t\twhile curr < m:\n\t\t\t(u, v) = edges[curr]\n\t\t\tcurr += 1\n\t\t\tu = UF.find(u)\n\t\t\tv = UF.find(v)\n\t\t\tif u != v:\n\t\t\t\tassert UF.asp[u] + UF.asp[v] >= x\n\t\t\t\tout.append(curr - 1)\n\t\t\t\tUF.union(u, v)\n\t\t\t\tw = UF.find(u)\n\t\t\t\tif UF.asp[w] >= x:\n\t\t\t\t\tq.append(w)\n\t\t\t\tbreak\nprint('\\n'.join(map(lambda x: str(x + 1), out)))\n",
        "slowest_solution": "import sys\n\ndef input_as_list(offset=0):\n\treturn [int(t) + offset for t in sys.stdin.readline().split()]\n(n, m, x) = input_as_list()\na = input_as_list()\nif sum(a) < (n - 1) * x:\n\tprint('NO')\n\texit(0)\ng = [set() for _ in range(n)]\nfor i in range(m):\n\t(u, v) = input_as_list(offset=-1)\n\tg[u].add((i, v))\n\tg[v].add((i, u))\npar = list(range(n))\n\ndef find(a):\n\tacopy = a\n\twhile par[a] != a:\n\t\ta = par[a]\n\twhile acopy != a:\n\t\t(acopy, par[acopy]) = (par[acopy], a)\n\treturn a\n\ndef union(a, b):\n\t(a, b) = (find(a), find(b))\n\tif len(g[a]) < len(g[b]):\n\t\t(a, b) = (b, a)\n\tg[a].update(g[b])\n\tpar[b] = a\nfrom heapq import heappop, heappush\npq = []\n\ndef push(val, ver):\n\theappush(pq, (-val, ver))\n\ndef pop():\n\t(val, ver) = heappop(pq)\n\treturn (-val, ver)\nfor i in range(n):\n\tpush(a[i], i)\nans = []\nwhile len(ans) < n - 1:\n\t(val, ver) = pop()\n\tver = find(ver)\n\tif val != a[ver]:\n\t\tcontinue\n\twhile True:\n\t\t(i, nei) = g[ver].pop()\n\t\tif ver != find(nei):\n\t\t\tnew_val = val + a[find(nei)] - x\n\t\t\tunion(ver, nei)\n\t\t\tver = find(ver)\n\t\t\tans.append(i + 1)\n\t\t\ta[ver] = new_val\n\t\t\tpush(new_val, ver)\n\t\t\tbreak\nprint('YES')\nprint(*ans, sep='\\n')\n"
    },
    {
        "task_id": 234,
        "slowest_solution_id": 1,
        "fastest_solution_id": 7,
        "slowest_time": 2.6868605613708496,
        "fastest_time": 2.52036190032959,
        "fastest_solution": "import io, os\nfrom math import *\nn = int(input())\na = sorted([int(x) for x in input().split()])\n\ndef solve(l, bit):\n\tif len(l) <= 1:\n\t\treturn 0\n\tif bit == 0:\n\t\treturn 0\n\thigh = [x ^ 1 << bit for x in l if x & 1 << bit]\n\tlow = [x for x in l if not x & 1 << bit]\n\tsh = solve(high, bit - 1)\n\tsl = solve(low, bit - 1)\n\tif not low:\n\t\treturn sh\n\tif not high:\n\t\treturn sl\n\treturn min(len(high) - 1 + sl, len(low) - 1 + sh)\nprint(solve(a, 40))\n",
        "slowest_solution": "import sys\ntry:\n\t(sys.stdin, sys.stdout) = (open('in.txt', 'r'), open('out.txt', 'w'))\nexcept:\n\tpass\nii1 = lambda : int(sys.stdin.readline().strip())\nis1 = lambda : sys.stdin.readline().strip()\niia = lambda : list(map(int, sys.stdin.readline().strip().split()))\nisa = lambda : sys.stdin.readline().strip().split()\nmod = int(1000000000.0 + 7)\nfrom collections import *\nfrom math import *\nn = ii1()\narr = iia()\narr.sort()\n\ndef dfs(arr):\n\tif len(arr) == 1:\n\t\treturn 1\n\tk = 1 << int(log2(arr[0] ^ arr[-1]))\n\tfor (i, a) in enumerate(arr):\n\t\tif a & k:\n\t\t\tbreak\n\treturn 1 + max(dfs(arr[:i]), dfs(arr[i:]))\nprint(n - dfs(arr))\n"
    },
    {
        "task_id": 267,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.7046079635620117,
        "fastest_time": 2.672445058822632,
        "fastest_solution": "def divisors(M):\n\td = []\n\ti = 1\n\twhile M >= i ** 2:\n\t\tif M % i == 0:\n\t\t\td.append(i)\n\t\t\tif i ** 2 != M:\n\t\t\t\td.append(M // i)\n\t\ti = i + 1\n\treturn d\n\ndef popcount(x):\n\tx = x - (x >> 1 & 1431655765)\n\tx = (x & 858993459) + (x >> 2 & 858993459)\n\tx = x + (x >> 4) & 252645135\n\tx = x + (x >> 8)\n\tx = x + (x >> 16)\n\treturn x & 127\n\ndef eratosthenes(n):\n\tres = [0 for i in range(n + 1)]\n\tprime = set([])\n\tfor i in range(2, n + 1):\n\t\tif not res[i]:\n\t\t\tprime.add(i)\n\t\t\tfor j in range(1, n // i + 1):\n\t\t\t\tres[i * j] = 1\n\treturn prime\n\ndef factorization(n):\n\tres = []\n\tfor p in prime:\n\t\tif n % p == 0:\n\t\t\twhile n % p == 0:\n\t\t\t\tn //= p\n\t\t\tres.append(p)\n\tif n != 1:\n\t\tres.append(n)\n\treturn res\n\ndef euler_phi(n):\n\tres = n\n\tfor x in range(2, n + 1):\n\t\tif x ** 2 > n:\n\t\t\tbreak\n\t\tif n % x == 0:\n\t\t\tres = res // x * (x - 1)\n\t\t\twhile n % x == 0:\n\t\t\t\tn //= x\n\tif n != 1:\n\t\tres = res // n * (n - 1)\n\treturn res\n\ndef ind(b, n):\n\tres = 0\n\twhile n % b == 0:\n\t\tres += 1\n\t\tn //= b\n\treturn res\n\ndef isPrimeMR(n):\n\tif n == 1:\n\t\treturn 0\n\td = n - 1\n\td = d // (d & -d)\n\tL = [2, 3, 5, 7, 11, 13, 17]\n\tfor a in L:\n\t\tt = d\n\t\ty = pow(a, t, n)\n\t\tif y == 1:\n\t\t\tcontinue\n\t\twhile y != n - 1:\n\t\t\ty = y * y % n\n\t\t\tif y == 1 or t == n - 1:\n\t\t\t\treturn 0\n\t\t\tt <<= 1\n\treturn 1\n\ndef findFactorRho(n):\n\tfrom math import gcd\n\tm = 1 << n.bit_length() // 8\n\tfor c in range(1, 99):\n\t\tf = lambda x: (x * x + c) % n\n\t\t(y, r, q, g) = (2, 1, 1, 1)\n\t\twhile g == 1:\n\t\t\tx = y\n\t\t\tfor i in range(r):\n\t\t\t\ty = f(y)\n\t\t\tk = 0\n\t\t\twhile k < r and g == 1:\n\t\t\t\tys = y\n\t\t\t\tfor i in range(min(m, r - k)):\n\t\t\t\t\ty = f(y)\n\t\t\t\t\tq = q * abs(x - y) % n\n\t\t\t\tg = gcd(q, n)\n\t\t\t\tk += m\n\t\t\tr <<= 1\n\t\tif g == n:\n\t\t\tg = 1\n\t\t\twhile g == 1:\n\t\t\t\tys = f(ys)\n\t\t\t\tg = gcd(abs(x - ys), n)\n\t\tif g < n:\n\t\t\tif isPrimeMR(g):\n\t\t\t\treturn g\n\t\t\telif isPrimeMR(n // g):\n\t\t\t\treturn n // g\n\t\t\treturn findFactorRho(g)\n\ndef primeFactor(n):\n\ti = 2\n\tret = {}\n\trhoFlg = 0\n\twhile i * i <= n:\n\t\tk = 0\n\t\twhile n % i == 0:\n\t\t\tn //= i\n\t\t\tk += 1\n\t\tif k:\n\t\t\tret[i] = k\n\t\ti += 1 + i % 2\n\t\tif i == 101 and n >= 2 ** 20:\n\t\t\twhile n > 1:\n\t\t\t\tif isPrimeMR(n):\n\t\t\t\t\t(ret[n], n) = (1, 1)\n\t\t\t\telse:\n\t\t\t\t\trhoFlg = 1\n\t\t\t\t\tj = findFactorRho(n)\n\t\t\t\t\tk = 0\n\t\t\t\t\twhile n % j == 0:\n\t\t\t\t\t\tn //= j\n\t\t\t\t\t\tk += 1\n\t\t\t\t\tret[j] = k\n\tif n > 1:\n\t\tret[n] = 1\n\tif rhoFlg:\n\t\tret = {x: ret[x] for x in sorted(ret)}\n\treturn ret\n\ndef divisors(n):\n\tres = [1]\n\tprime = primeFactor(n)\n\tfor p in prime:\n\t\tnewres = []\n\t\tfor d in res:\n\t\t\tfor j in range(prime[p] + 1):\n\t\t\t\tnewres.append(d * p ** j)\n\t\tres = newres\n\tres.sort()\n\treturn res\n\ndef xorfactorial(num):\n\tif num == 0:\n\t\treturn 0\n\telif num == 1:\n\t\treturn 1\n\telif num == 2:\n\t\treturn 3\n\telif num == 3:\n\t\treturn 0\n\telse:\n\t\tx = baseorder(num)\n\t\treturn 2 ** x * ((num - 2 ** x + 1) % 2) + function(num - 2 ** x)\n\ndef xorconv(n, X, Y):\n\tif n == 0:\n\t\tres = [X[0] * Y[0] % mod]\n\t\treturn res\n\tx = [X[i] + X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\ty = [Y[i] + Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\tz = [X[i] - X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\tw = [Y[i] - Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\tres1 = xorconv(n - 1, x, y)\n\tres2 = xorconv(n - 1, z, w)\n\tformer = [(res1[i] + res2[i]) * inv for i in range(2 ** (n - 1))]\n\tlatter = [(res1[i] - res2[i]) * inv for i in range(2 ** (n - 1))]\n\tformer = list(map(lambda x: x % mod, former))\n\tlatter = list(map(lambda x: x % mod, latter))\n\treturn former + latter\n\ndef merge_sort(A, B):\n\t(pos_A, pos_B) = (0, 0)\n\t(n, m) = (len(A), len(B))\n\tres = []\n\twhile pos_A < n and pos_B < m:\n\t\t(a, b) = (A[pos_A], B[pos_B])\n\t\tif a < b:\n\t\t\tres.append(a)\n\t\t\tpos_A += 1\n\t\telse:\n\t\t\tres.append(b)\n\t\t\tpos_B += 1\n\tres += A[pos_A:]\n\tres += B[pos_B:]\n\treturn res\n\nclass UnionFindVerSize:\n\n\tdef __init__(self, N):\n\t\tself._parent = [n for n in range(0, N)]\n\t\tself._size = [1] * N\n\t\tself.group = N\n\n\tdef find_root(self, x):\n\t\tif self._parent[x] == x:\n\t\t\treturn x\n\t\tself._parent[x] = self.find_root(self._parent[x])\n\t\tstack = [x]\n\t\twhile self._parent[stack[-1]] != stack[-1]:\n\t\t\tstack.append(self._parent[stack[-1]])\n\t\tfor v in stack:\n\t\t\tself._parent[v] = stack[-1]\n\t\treturn self._parent[x]\n\n\tdef unite(self, x, y):\n\t\tgx = self.find_root(x)\n\t\tgy = self.find_root(y)\n\t\tif gx == gy:\n\t\t\treturn\n\t\tself.group -= 1\n\t\tif self._size[gx] < self._size[gy]:\n\t\t\tself._parent[gx] = gy\n\t\t\tself._size[gy] += self._size[gx]\n\t\telse:\n\t\t\tself._parent[gy] = gx\n\t\t\tself._size[gx] += self._size[gy]\n\n\tdef get_size(self, x):\n\t\treturn self._size[self.find_root(x)]\n\n\tdef is_same_group(self, x, y):\n\t\treturn self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind:\n\n\tdef __init__(self, N):\n\t\tself.parent = [i for i in range(N)]\n\t\tself.size = [1 for i in range(N)]\n\t\tself.val = [0 for i in range(N)]\n\t\tself.flag = True\n\t\tself.edge = [[] for i in range(N)]\n\n\tdef dfs(self, v, pv):\n\t\tstack = [(v, pv)]\n\t\tnew_parent = self.parent[pv]\n\t\twhile stack:\n\t\t\t(v, pv) = stack.pop()\n\t\t\tself.parent[v] = new_parent\n\t\t\tfor (nv, w) in self.edge[v]:\n\t\t\t\tif nv != pv:\n\t\t\t\t\tself.val[nv] = self.val[v] + w\n\t\t\t\t\tstack.append((nv, v))\n\n\tdef unite(self, x, y, w):\n\t\tif not self.flag:\n\t\t\treturn\n\t\tif self.parent[x] == self.parent[y]:\n\t\t\tself.flag = self.val[x] - self.val[y] == w\n\t\t\treturn\n\t\tif self.size[self.parent[x]] > self.size[self.parent[y]]:\n\t\t\tself.edge[x].append((y, -w))\n\t\t\tself.edge[y].append((x, w))\n\t\t\tself.size[x] += self.size[y]\n\t\t\tself.val[y] = self.val[x] - w\n\t\t\tself.dfs(y, x)\n\t\telse:\n\t\t\tself.edge[x].append((y, -w))\n\t\t\tself.edge[y].append((x, w))\n\t\t\tself.size[y] += self.size[x]\n\t\t\tself.val[x] = self.val[y] + w\n\t\t\tself.dfs(x, y)\n\nclass Dijkstra:\n\n\tclass Edge:\n\n\t\tdef __init__(self, _to, _cost):\n\t\t\tself.to = _to\n\t\t\tself.cost = _cost\n\n\tdef __init__(self, V):\n\t\tself.G = [[] for i in range(V)]\n\t\tself._E = 0\n\t\tself._V = V\n\n\t@property\n\tdef E(self):\n\t\treturn self._E\n\n\t@property\n\tdef V(self):\n\t\treturn self._V\n\n\tdef add_edge(self, _from, _to, _cost):\n\t\tself.G[_from].append(self.Edge(_to, _cost))\n\t\tself._E += 1\n\n\tdef shortest_path(self, s):\n\t\timport heapq\n\t\tque = []\n\t\td = [10 ** 15] * self.V\n\t\td[s] = 0\n\t\theapq.heappush(que, (0, s))\n\t\twhile len(que) != 0:\n\t\t\t(cost, v) = heapq.heappop(que)\n\t\t\tif d[v] < cost:\n\t\t\t\tcontinue\n\t\t\tfor i in range(len(self.G[v])):\n\t\t\t\te = self.G[v][i]\n\t\t\t\tif d[e.to] > d[v] + e.cost:\n\t\t\t\t\td[e.to] = d[v] + e.cost\n\t\t\t\t\theapq.heappush(que, (d[e.to], e.to))\n\t\treturn d\n\ndef Z_algorithm(s):\n\tN = len(s)\n\tZ_alg = [0] * N\n\tZ_alg[0] = N\n\ti = 1\n\tj = 0\n\twhile i < N:\n\t\twhile i + j < N and s[j] == s[i + j]:\n\t\t\tj += 1\n\t\tZ_alg[i] = j\n\t\tif j == 0:\n\t\t\ti += 1\n\t\t\tcontinue\n\t\tk = 1\n\t\twhile i + k < N and k + Z_alg[k] < j:\n\t\t\tZ_alg[i + k] = Z_alg[k]\n\t\t\tk += 1\n\t\ti += k\n\t\tj -= k\n\treturn Z_alg\n\nclass BIT:\n\n\tdef __init__(self, n, mod=None):\n\t\tself.BIT = [0] * (n + 1)\n\t\tself.num = n\n\t\tself.mod = mod\n\n\tdef query(self, idx):\n\t\tres_sum = 0\n\t\tmod = self.mod\n\t\twhile idx > 0:\n\t\t\tres_sum += self.BIT[idx]\n\t\t\tif mod:\n\t\t\t\tres_sum %= mod\n\t\t\tidx -= idx & -idx\n\t\treturn res_sum\n\n\tdef update(self, idx, x):\n\t\tmod = self.mod\n\t\twhile idx <= self.num:\n\t\t\tself.BIT[idx] += x\n\t\t\tself.BIT[idx] %= mod\n\t\t\tidx += idx & -idx\n\t\treturn\n\nclass dancinglink:\n\n\tdef __init__(self, n, debug=False):\n\t\tself.n = n\n\t\tself.debug = debug\n\t\tself._left = [i - 1 for i in range(n)]\n\t\tself._right = [i + 1 for i in range(n)]\n\t\tself.exist = [True for i in range(n)]\n\n\tdef pop(self, k):\n\t\tif self.debug:\n\t\t\tassert self.exist[k]\n\t\tL = self._left[k]\n\t\tR = self._right[k]\n\t\tif L != -1:\n\t\t\tif R != self.n:\n\t\t\t\t(self._right[L], self._left[R]) = (R, L)\n\t\t\telse:\n\t\t\t\tself._right[L] = self.n\n\t\telif R != self.n:\n\t\t\tself._left[R] = -1\n\t\tself.exist[k] = False\n\n\tdef left(self, idx, k=1):\n\t\tif self.debug:\n\t\t\tassert self.exist[idx]\n\t\tres = idx\n\t\twhile k:\n\t\t\tres = self._left[res]\n\t\t\tif res == -1:\n\t\t\t\tbreak\n\t\t\tk -= 1\n\t\treturn res\n\n\tdef right(self, idx, k=1):\n\t\tif self.debug:\n\t\t\tassert self.exist[idx]\n\t\tres = idx\n\t\twhile k:\n\t\t\tres = self._right[res]\n\t\t\tif res == self.n:\n\t\t\t\tbreak\n\t\t\tk -= 1\n\t\treturn res\n\nclass SparseTable:\n\n\tdef __init__(self, A, merge_func, ide_ele):\n\t\tN = len(A)\n\t\tn = N.bit_length()\n\t\tself.table = [[ide_ele for i in range(n)] for i in range(N)]\n\t\tself.merge_func = merge_func\n\t\tfor i in range(N):\n\t\t\tself.table[i][0] = A[i]\n\t\tfor j in range(1, n):\n\t\t\tfor i in range(0, N - 2 ** j + 1):\n\t\t\t\tf = self.table[i][j - 1]\n\t\t\t\ts = self.table[i + 2 ** (j - 1)][j - 1]\n\t\t\t\tself.table[i][j] = self.merge_func(f, s)\n\n\tdef query(self, s, t):\n\t\tb = t - s + 1\n\t\tm = b.bit_length() - 1\n\t\treturn self.merge_func(self.table[s][m], self.table[t - 2 ** m + 1][m])\n\nclass BinaryTrie:\n\n\tclass node:\n\n\t\tdef __init__(self, val):\n\t\t\tself.left = None\n\t\t\tself.right = None\n\t\t\tself.max = val\n\n\tdef __init__(self):\n\t\tself.root = self.node(-10 ** 15)\n\n\tdef append(self, key, val):\n\t\tpos = self.root\n\t\tfor i in range(29, -1, -1):\n\t\t\tpos.max = max(pos.max, val)\n\t\t\tif key >> i & 1:\n\t\t\t\tif pos.right is None:\n\t\t\t\t\tpos.right = self.node(val)\n\t\t\t\t\tpos = pos.right\n\t\t\t\telse:\n\t\t\t\t\tpos = pos.right\n\t\t\telif pos.left is None:\n\t\t\t\tpos.left = self.node(val)\n\t\t\t\tpos = pos.left\n\t\t\telse:\n\t\t\t\tpos = pos.left\n\t\tpos.max = max(pos.max, val)\n\n\tdef search(self, M, xor):\n\t\tres = -10 ** 15\n\t\tpos = self.root\n\t\tfor i in range(29, -1, -1):\n\t\t\tif pos is None:\n\t\t\t\tbreak\n\t\t\tif M >> i & 1:\n\t\t\t\tif xor >> i & 1:\n\t\t\t\t\tif pos.right:\n\t\t\t\t\t\tres = max(res, pos.right.max)\n\t\t\t\t\tpos = pos.left\n\t\t\t\telse:\n\t\t\t\t\tif pos.left:\n\t\t\t\t\t\tres = max(res, pos.left.max)\n\t\t\t\t\tpos = pos.right\n\t\t\telif xor >> i & 1:\n\t\t\t\tpos = pos.right\n\t\t\telse:\n\t\t\t\tpos = pos.left\n\t\tif pos:\n\t\t\tres = max(res, pos.max)\n\t\treturn res\n\ndef solveequation(edge, ans, n, m):\n\tx = [0] * m\n\tused = [False] * n\n\tfor v in range(n):\n\t\tif used[v]:\n\t\t\tcontinue\n\t\ty = dfs(v)\n\t\tif y != 0:\n\t\t\treturn False\n\treturn x\n\n\tdef dfs(v):\n\t\tused[v] = True\n\t\tr = ans[v]\n\t\tfor (to, dire, id) in edge[v]:\n\t\t\tif used[to]:\n\t\t\t\tcontinue\n\t\t\ty = dfs(to)\n\t\t\tif dire == -1:\n\t\t\t\tx[id] = y\n\t\t\telse:\n\t\t\t\tx[id] = -y\n\t\t\tr += y\n\t\treturn r\n\nclass Matrix:\n\tmod = 10 ** 9 + 7\n\n\tdef set_mod(m):\n\t\tMatrix.mod = m\n\n\tdef __init__(self, L):\n\t\tself.row = len(L)\n\t\tself.column = len(L[0])\n\t\tself._matrix = L\n\t\tfor i in range(self.row):\n\t\t\tfor j in range(self.column):\n\t\t\t\tself._matrix[i][j] %= Matrix.mod\n\n\tdef __getitem__(self, item):\n\t\tif type(item) == int:\n\t\t\traise IndexError('you must specific row and column')\n\t\telif len(item) != 2:\n\t\t\traise IndexError('you must specific row and column')\n\t\t(i, j) = item\n\t\treturn self._matrix[i][j]\n\n\tdef __setitem__(self, item, val):\n\t\tif type(item) == int:\n\t\t\traise IndexError('you must specific row and column')\n\t\telif len(item) != 2:\n\t\t\traise IndexError('you must specific row and column')\n\t\t(i, j) = item\n\t\tself._matrix[i][j] = val\n\n\tdef __add__(self, other):\n\t\tif (self.row, self.column) != (other.row, other.column):\n\t\t\traise SizeError('sizes of matrixes are different')\n\t\tres = [[0 for j in range(self.column)] for i in range(self.row)]\n\t\tfor i in range(self.row):\n\t\t\tfor j in range(self.column):\n\t\t\t\tres[i][j] = self._matrix[i][j] + other._matrix[i][j]\n\t\t\t\tres[i][j] %= Matrix.mod\n\t\treturn Matrix(res)\n\n\tdef __sub__(self, other):\n\t\tif (self.row, self.column) != (other.row, other.column):\n\t\t\traise SizeError('sizes of matrixes are different')\n\t\tres = [[0 for j in range(self.column)] for i in range(self.row)]\n\t\tfor i in range(self.row):\n\t\t\tfor j in range(self.column):\n\t\t\t\tres[i][j] = self._matrix[i][j] - other._matrix[i][j]\n\t\t\t\tres[i][j] %= Matrix.mod\n\t\treturn Matrix(res)\n\n\tdef __mul__(self, other):\n\t\tif type(other) != int:\n\t\t\tif self.column != other.row:\n\t\t\t\traise SizeError('sizes of matrixes are different')\n\t\t\tres = [[0 for j in range(other.column)] for i in range(self.row)]\n\t\t\tfor i in range(self.row):\n\t\t\t\tfor j in range(other.column):\n\t\t\t\t\ttemp = 0\n\t\t\t\t\tfor k in range(self.column):\n\t\t\t\t\t\ttemp += self._matrix[i][k] * other._matrix[k][j]\n\t\t\t\t\tres[i][j] = temp % Matrix.mod\n\t\t\treturn Matrix(res)\n\t\telse:\n\t\t\tn = other\n\t\t\tres = [[n * self._matrix[i][j] % Matrix.mod for j in range(self.column)] for i in range(self.row)]\n\t\t\treturn Matrix(res)\n\n\tdef __pow__(self, m):\n\t\tif self.column != self.row:\n\t\t\traise MatrixPowError('the size of row must be the same as that of column')\n\t\tn = self.row\n\t\tres = Matrix([[int(i == j) for i in range(n)] for j in range(n)])\n\t\twhile m:\n\t\t\tif m % 2 == 1:\n\t\t\t\tres = res * self\n\t\t\tself = self * self\n\t\t\tm //= 2\n\t\treturn res\n\n\tdef __str__(self):\n\t\tres = []\n\t\tfor i in range(self.row):\n\t\t\tfor j in range(self.column):\n\t\t\t\tres.append(str(self._matrix[i][j]))\n\t\t\t\tres.append(' ')\n\t\t\tres.append('\\n')\n\t\tres = res[:len(res) - 1]\n\t\treturn ''.join(res)\n\nclass SegmentTree:\n\n\tdef __init__(self, init_val, segfunc, ide_ele):\n\t\tn = len(init_val)\n\t\tself.segfunc = segfunc\n\t\tself.ide_ele = ide_ele\n\t\tself.num = 1 << (n - 1).bit_length()\n\t\tself.tree = [ide_ele] * 2 * self.num\n\t\tfor i in range(n):\n\t\t\tself.tree[self.num + i] = init_val[i]\n\t\tfor i in range(self.num - 1, 0, -1):\n\t\t\tself.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n\tdef update(self, k, x):\n\t\tk += self.num\n\t\tself.tree[k] = x\n\t\twhile k > 1:\n\t\t\tself.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n\t\t\tk >>= 1\n\n\tdef query(self, l, r):\n\t\tres = self.ide_ele\n\t\tl += self.num\n\t\tr += self.num\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tres = self.segfunc(res, self.tree[l])\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tres = self.segfunc(res, self.tree[r - 1])\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\treturn res\n\n\tdef bisect_l(self, l, r, x):\n\t\tl += self.num\n\t\tr += self.num\n\t\tLmin = -1\n\t\tRmin = -1\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tif self.tree[l] <= x and Lmin == -1:\n\t\t\t\t\tLmin = l\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tif self.tree[r - 1] <= x:\n\t\t\t\t\tRmin = r - 1\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\tif Lmin != -1:\n\t\t\tpos = Lmin\n\t\t\twhile pos < self.num:\n\t\t\t\tif self.tree[2 * pos] <= x:\n\t\t\t\t\tpos = 2 * pos\n\t\t\t\telse:\n\t\t\t\t\tpos = 2 * pos + 1\n\t\t\treturn pos - self.num\n\t\telif Rmin != -1:\n\t\t\tpos = Rmin\n\t\t\twhile pos < self.num:\n\t\t\t\tif self.tree[2 * pos] <= x:\n\t\t\t\t\tpos = 2 * pos\n\t\t\t\telse:\n\t\t\t\t\tpos = 2 * pos + 1\n\t\t\treturn pos - self.num\n\t\telse:\n\t\t\treturn -1\n\ndef cmb(n, r, mod):\n\tif r < 0 or r > n:\n\t\treturn 0\n\tr = min(r, n - r)\n\treturn g1[n] * g2[r] % mod * g2[n - r] % mod\nmod = 998244353\nN = 6000\ng1 = [1] * (N + 1)\ng2 = [1] * (N + 1)\ninverse = [1] * (N + 1)\nfor i in range(2, N + 1):\n\tg1[i] = g1[i - 1] * i % mod\n\tinverse[i] = -inverse[mod % i] * (mod // i) % mod\n\tg2[i] = g2[i - 1] * inverse[i] % mod\ninverse[0] = 0\nimport sys, random, bisect\nfrom collections import deque, defaultdict\nfrom heapq import heapify, heappop, heappush\nfrom itertools import permutations\nfrom math import log, gcd\ninput = lambda : sys.stdin.readline().rstrip()\nmi = lambda : map(int, input().split())\nli = lambda : list(mi())\n(p, s, r) = mi()\nS = s\nres = 0\nfor x in range(r, s + 1):\n\tfor n in range(1, p):\n\t\ttmp = 0\n\t\tfor i in range(p - n + 1):\n\t\t\tif s - (n + i) * x + p - n - 1 >= p - n - 1:\n\t\t\t\tif i % 2:\n\t\t\t\t\ttmp -= g1[s - (n + i) * x + p - n - 1] * g2[i] % mod * g2[p - n - i] % mod * g2[s - (n + i) * x] % mod\n\t\t\t\telse:\n\t\t\t\t\ttmp += g1[s - (n + i) * x + p - n - 1] * g2[i] % mod * g2[p - n - i] % mod * g2[s - (n + i) * x] % mod\n\t\t\t\ttmp %= mod\n\t\tres += tmp * inverse[n] % mod * cmb(p - 1, n - 1, mod) % mod * (p - n) % mod\n\t\tres %= mod\n\tif x * p == s:\n\t\tres += inverse[p]\n\t\tres %= mod\nall_case = cmb(s - r + p - 1, p - 1, mod)\nres *= pow(all_case, mod - 2, mod)\nprint(res % mod)\n",
        "slowest_solution": "base = 998244353\n\ndef power(x, y):\n\tif y == 0:\n\t\treturn 1\n\tt = power(x, y // 2)\n\tt = t * t % base\n\tif y % 2:\n\t\tt = t * x % base\n\treturn t\n\ndef inverse(x):\n\treturn power(x, base - 2)\nf = [1]\niv = [1]\nfor i in range(1, 5555):\n\tf.append(f[i - 1] * i % base)\n\tiv.append(inverse(f[i]))\n\ndef C(n, k):\n\treturn f[n] * iv[k] * iv[n - k] % base\n\ndef candy(n, k):\n\treturn C(n + k - 1, k - 1)\n\ndef count_game(k, n, x):\n\tif k == 0:\n\t\tif n == 0:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\tans = 0\n\tfor i in range(0, k + 1):\n\t\tt = n - x * i\n\t\tif t < 0:\n\t\t\tbreak\n\t\tif i % 2:\n\t\t\tans = (ans - C(k, i) * candy(t, k)) % base\n\t\telse:\n\t\t\tans = (ans + C(k, i) * candy(t, k)) % base\n\treturn ans\n(p, s, r) = list(map(int, input().split()))\ngamesize = count_game(p, s - r, int(1e+18))\ngamesize = inverse(gamesize)\nans = 0\nfor q in range(r, s + 1):\n\tfor i in range(0, p):\n\t\tt = s - (i + 1) * q\n\t\tif t < 0:\n\t\t\tbreak\n\t\tans = (ans + C(p - 1, i) * count_game(p - i - 1, t, q) * gamesize * inverse(i + 1)) % base\nprint(ans)\n"
    },
    {
        "task_id": 232,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.6453888416290283,
        "fastest_time": 2.5383949279785156,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tprefix = [0] * n\n\tprefix[0] = arr[0]\n\tfor i in range(1, n):\n\t\tif i % 2 == 0:\n\t\t\tprefix[i] = prefix[i - 1] + arr[i]\n\t\telse:\n\t\t\tprefix[i] = prefix[i - 1] - arr[i]\n\tind = 0\n\tif n % 2 == 0:\n\t\tind = 1\n\tmaxsum = 0\n\twhile ind < n:\n\t\tmaxsum = max(maxsum, prefix[ind])\n\t\tind += 2\n\tres = 2 * maxsum - prefix[n - 1]\n\tprint(res)\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tsuf = 0\n\tpref = 0\n\tmxpref = 0\n\tfor i in range(n):\n\t\tif i % 2 == 0:\n\t\t\tsuf += a[i]\n\t\telse:\n\t\t\tsuf -= a[i]\n\tans = suf\n\tfor i in range(n):\n\t\tif i % 2 == 0:\n\t\t\tsuf -= a[i]\n\t\t\tpref += a[i]\n\t\telse:\n\t\t\tsuf += a[i]\n\t\t\tpref -= a[i]\n\t\tif i % 2 != n % 2:\n\t\t\tans = max(ans, pref - suf)\n\t\t\tmxpref = max(mxpref, pref)\n\t\telse:\n\t\t\tans = max(ans, 2 * mxpref - pref - suf)\n\tprint(ans)\n"
    },
    {
        "task_id": 235,
        "slowest_solution_id": 3,
        "fastest_solution_id": 2,
        "slowest_time": 2.684110641479492,
        "fastest_time": 2.524320602416992,
        "fastest_solution": "import sys\nimport array\n(N, M) = (int(a) for a in sys.stdin.readline().split())\nAA = array.array('I', [int(a) for a in sys.stdin.readline().split()])\nA = array.array('I', [a for a in range(N)])\nfor q in range(M):\n\t(typ, p1, p2) = [int(a) for a in sys.stdin.readline().split()]\n\tif typ == 1:\n\t\tA = A[p1 - 1:p2] + A[:p1 - 1] + A[p2:]\n\telif typ == 2:\n\t\tA = A[:p1 - 1] + A[p2:] + A[p1 - 1:p2]\nprint('{}'.format(abs(AA[A[0]] - AA[A[N - 1]])))\nprint(' '.join((str(AA[A[a]]) for a in range(N))))\nA = [(1, 8)]\n",
        "slowest_solution": "from array import *\ndescription = list(map(int, input().split(' ')))\nthe_array = list(map(int, input().split(' ')))\nthe_array = array('i', the_array)\nfor i in range(description[1]):\n\tcomm = list(map(int, input().split(' ')))\n\tif comm[0] == 1:\n\t\tstart_loc = comm[1] - 1\n\t\tend_loc = comm[2]\n\t\tmove_set = the_array[start_loc:end_loc]\n\t\tthe_array = move_set + the_array[:start_loc] + the_array[end_loc:]\n\tif comm[0] == 2:\n\t\tstart_loc = comm[1] - 1\n\t\tend_loc = comm[2]\n\t\tmove_set = the_array[start_loc:end_loc]\n\t\tthe_array = the_array[:start_loc] + the_array[end_loc:] + move_set\nprint(abs(the_array[0] - the_array[-1]))\nfor i in range(len(the_array)):\n\tprint(the_array[i], end=' ')\n"
    },
    {
        "task_id": 236,
        "slowest_solution_id": 8,
        "fastest_solution_id": 6,
        "slowest_time": 2.7500853538513184,
        "fastest_time": 2.4402213096618652,
        "fastest_solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n(maxx, minn) = (0, 0)\nif a[0] > b[1]:\n\tmaxx += a[0] - b[1]\nif a[1] > b[2]:\n\tmaxx += a[1] - b[2]\nif a[2] > b[0]:\n\tmaxx += a[2] - b[0]\nif a[0] > b[0] + b[2]:\n\tminn += a[0] - b[0] - b[2]\nif a[1] > b[1] + b[0]:\n\tminn += a[1] - b[1] - b[0]\nif a[2] > b[1] + b[2]:\n\tminn += a[2] - b[1] - b[2]\nprint(minn, n - maxx)\n",
        "slowest_solution": "from itertools import permutations\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nawin = min(a[0], b[1]) + min(a[1], b[2]) + min(a[2], b[0])\namin = n\npairs = [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2), (2, 0)]\nfor seq in permutations(pairs):\n\taa = a.copy()\n\tbb = b.copy()\n\tb_win = 0\n\tfor pair in seq:\n\t\tai = pair[1]\n\t\tbi = pair[0]\n\t\tdelta = min(aa[ai], bb[bi])\n\t\taa[ai] -= delta\n\t\tbb[bi] -= delta\n\t\tb_win += delta\n\tamin = min(amin, n - b_win)\nprint(amin, awin)\n"
    },
    {
        "task_id": 239,
        "slowest_solution_id": 1,
        "fastest_solution_id": 7,
        "slowest_time": 2.709444999694824,
        "fastest_time": 2.536245346069336,
        "fastest_solution": "DEFAULT = -3\nOCEAN = -2\nMETALAKE = -1\n\ndef convert(c):\n\tif c == '*':\n\t\treturn False\n\treturn True\n\ndef get_root(leaf, lake):\n\tlk = lake[leaf]\n\tind = leaf\n\twhile lk[1] >= 0:\n\t\tind = lk[1]\n\t\tlk = lake[lk[1]]\n\tind2 = leaf\n\twhile ind2 > ind:\n\t\ttmp = lake[ind2][1]\n\t\tlake[ind2] = (lake[ind2][0], ind)\n\t\tind2 = tmp\n\treturn ind\n(n, m, k) = map(int, input().split())\nland = []\nfor i in range(n):\n\tland.append(list(map(convert, input())))\ncurr_lake = 0\nlake = []\nattach = [[DEFAULT for _ in range(m)] for __ in range(n)]\nfor i in range(n):\n\tfor j in range(m):\n\t\tif not land[i][j]:\n\t\t\tcontinue\n\t\tneigh = []\n\t\tif i > 0 and land[i - 1][j]:\n\t\t\tneigh.append(attach[i - 1][j])\n\t\tif j > 0 and land[i][j - 1]:\n\t\t\tneigh.append(attach[i][j - 1])\n\t\tif neigh == []:\n\t\t\tlk = (1, METALAKE)\n\t\t\tif min(i, j) == 0 or j == m - 1 or i == n - 1:\n\t\t\t\tlk = (1, OCEAN)\n\t\t\tlake.append(lk)\n\t\t\tattach[i][j] = curr_lake\n\t\t\tcurr_lake += 1\n\t\telse:\n\t\t\tlks = sorted(list(map(lambda nbr: get_root(nbr, lake), neigh)))\n\t\t\tif min(i, j) == 0 or j == m - 1 or i == n - 1:\n\t\t\t\tlake_type = OCEAN\n\t\t\t\ttotal_area = 0\n\t\t\telse:\n\t\t\t\tlake_type = min(map(lambda ind: lake[ind][1], lks))\n\t\t\t\ttotal_area = 1 + sum(map(lambda ind: lake[ind][0], lks))\n\t\t\tfor ind in lks[1:]:\n\t\t\t\tlake[ind] = (lake[ind][0], lks[0])\n\t\t\tattach[i][j] = lks[0]\n\t\t\tlake[lks[0]] = (total_area, lake_type)\nparent_lakes = filter(lambda tup: tup[1][1] == METALAKE, list(enumerate(lake)))\nnot_needed = set(list(map(lambda tup: tup[0], sorted(parent_lakes, key=lambda tup: tup[1][0], reverse=True)))[k:])\nchanged = 0\nfor i in range(n):\n\tfor j in range(m):\n\t\tif not land[i][j]:\n\t\t\tcontinue\n\t\tif attach[i][j] < 0:\n\t\t\tcontinue\n\t\trt = get_root(attach[i][j], lake)\n\t\tif rt in not_needed:\n\t\t\tland[i][j] = False\n\t\t\tchanged += 1\nprint(changed)\nfor i in range(n):\n\tprint(''.join(map(lambda x: '.' if x else '*', land[i])))\n",
        "slowest_solution": "from collections import Counter, defaultdict\n(n, m, k) = [int(x) for x in input().split()]\nmp = [['.'] * (m + 2)] + [list('.' + input().strip() + '.') for _ in range(n)] + [['.'] * (m + 2)]\nuf = {}\nfor i in range(n + 2):\n\tfor j in range(m + 2):\n\t\tuf[i, j] = (i, j)\n\ndef find(u):\n\tif u != uf[u]:\n\t\tuf[u] = find(uf[u])\n\treturn uf[u]\n\ndef union(u, v):\n\tpu = find(u)\n\tpv = find(v)\n\tif pu != pv:\n\t\tuf[pv] = pu\nfor i in range(n + 2):\n\tfor j in range(m + 2):\n\t\tif mp[i][j] == '*':\n\t\t\tcontinue\n\t\tif i <= n and mp[i + 1][j] == '.':\n\t\t\tunion((i, j), (i + 1, j))\n\t\tif j <= m and mp[i][j + 1] == '.':\n\t\t\tunion((i, j), (i, j + 1))\nd = defaultdict(int)\nf0 = find((0, 0))\nfor i in range(n + 2):\n\tfor j in range(m + 2):\n\t\tif mp[i][j] == '*':\n\t\t\tcontinue\n\t\tf = find((i, j))\n\t\tif f != f0:\n\t\t\td[f] += 1\nl = sorted([(v, k) for (k, v) in list(d.items())])\nll = len(l)\nps = set([u for (_, u) in l[:ll - k]])\nr = 0\nfor i in range(1, n + 1):\n\tfor j in range(1, m + 1):\n\t\tif mp[i][j] == '.' and find((i, j)) in ps:\n\t\t\tmp[i][j] = '*'\n\t\t\tr += 1\nprint(r)\nprint('\\n'.join((''.join(m[1:-1]) for m in mp[1:-1])))\n"
    },
    {
        "task_id": 240,
        "slowest_solution_id": 9,
        "fastest_solution_id": 7,
        "slowest_time": 2.6728007793426514,
        "fastest_time": 2.5154519081115723,
        "fastest_solution": "n = int(input())\narr = list(map(int, input().split()))\nif n == 1:\n\tprint(0, arr[0])\nelse:\n\tdp = [[0 for j in range(2)] for i in range(n)]\n\tdp[n - 1][0] = arr[n - 1]\n\tfor i in range(n - 2, -1, -1):\n\t\tdp[i][0] = max(arr[i] + dp[i + 1][1], dp[i + 1][0])\n\t\tdp[i][1] = min(arr[i] + dp[i + 1][1], dp[i + 1][0])\n\tprint(dp[0][1], dp[0][0])\n",
        "slowest_solution": "n = int(input())\na = list(map(int, input().split()))\nsa = [0] * n\ndp = [0] * n\nsa[-1] = a[-1]\nfor i in range(n - 1)[::-1]:\n\tsa[i] = sa[i + 1] + a[i]\ndp[-1] = a[-1]\nfor i in range(0, n - 1)[::-1]:\n\tdp[i] = max(dp[i + 1], sa[i + 1] - dp[i + 1] + a[i])\nprint(sa[0] - dp[0], dp[0])\n"
    },
    {
        "task_id": 248,
        "slowest_solution_id": 5,
        "fastest_solution_id": 3,
        "slowest_time": 2.692148208618164,
        "fastest_time": 2.4760115146636963,
        "fastest_solution": "def f(x, p):\n\tq = []\n\twhile x:\n\t\tq.append(x)\n\t\tx = p[x]\n\treturn q\nfrom collections import defaultdict\n(n, k) = map(int, input().split())\nt = list(map(int, input().split()))\np = [0] * (n + 1)\nfor (i, j) in enumerate(t, 1):\n\tp[j] = i\np = [f(i, p) for (i, j) in enumerate(t, 1) if j == 0]\ns = defaultdict(int)\nfor i in p:\n\tif k in i:\n\t\tt = {i.index(k) + 1}\n\telse:\n\t\ts[len(i)] += 1\ns = [list(range(i, k * i + 1, i)) for (i, k) in s.items()]\nfor q in s:\n\tt |= {x + y for x in q for y in t}\nprint('\\n'.join(map(str, sorted(list(t)))))\n",
        "slowest_solution": "import math\nimport sys\nfrom bisect import bisect_right, bisect_left, insort_right\nfrom collections import Counter, defaultdict\nfrom heapq import heappop, heappush\nfrom itertools import accumulate, permutations\nfrom sys import stdout\nR = lambda : map(int, input().split())\n(n, s) = R()\nseq = [0] + list(R())\nincm = [0] * (n + 1)\nfor x in seq:\n\tif x:\n\t\tincm[x] = 1\nsz = [0] * (n + 1)\nst = []\nbs = 1\nx = s\nwhile seq[x]:\n\tbs += 1\n\tx = seq[x]\nfor (i, x) in enumerate(incm):\n\tfoundx = False\n\tif not x:\n\t\tl = i\n\t\twhile i:\n\t\t\tfoundx = foundx or i == s\n\t\t\tsz[l] += 1\n\t\t\ti = seq[i]\n\t\tif seq[l] and (not foundx):\n\t\t\tst.append(sz[l])\nnz = seq.count(0) - 1 - len(st) - 1\npos = [0] * (n + 1)\nfor p in st:\n\tfor i in range(n, -1, -1):\n\t\tif bs + i + p < n + 1 and pos[bs + i]:\n\t\t\tpos[bs + i + p] = 1\n\tpos[bs + p] = 1\nrp = [0] * (n + 1)\nrp[bs] = 1\nif bs + nz + 1 < n + 1:\n\trp[bs + nz + 1] = -1\nfor i in range(n + 1):\n\tif pos[i]:\n\t\trp[i] += 1\n\t\tif i + nz + 1 < n + 1:\n\t\t\trp[i + nz + 1] -= 1\nfor i in range(1, n + 1):\n\trp[i] += rp[i - 1]\nfor i in range(1, n + 1):\n\tif rp[i]:\n\t\tprint(i)\n"
    },
    {
        "task_id": 289,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.527005910873413,
        "fastest_time": 2.527005910873413,
        "fastest_solution": "def main():\n\tfrom sys import stdin, stderr\n\tfrom collections import deque\n\n\tdef findout(graph):\n\t\tif len(graph) <= 2:\n\t\t\treturn 2\n\n\t\tdef bfs(graph):\n\t\t\tN = len(graph)\n\t\t\tq = deque([0])\n\t\t\tvisit = []\n\t\t\tparent = [-1] * N\n\t\t\twhile q:\n\t\t\t\tv = q.popleft()\n\t\t\t\tvisit += [v]\n\t\t\t\tfor adj in graph[v]:\n\t\t\t\t\tif adj != parent[v]:\n\t\t\t\t\t\tq.append(adj)\n\t\t\t\t\t\tparent[adj] = v\n\t\t\treturn (parent, visit)\n\t\tN = len(graph)\n\t\t(parent, visit) = bfs(graph)\n\t\tbfsvisit = visit[::-1]\n\t\tcan1 = [0] * N\n\t\tcan2 = [0] * N\n\t\tcoin = [0] * N\n\t\tfor x in bfsvisit:\n\t\t\tif parent[x] != -1:\n\t\t\t\tif len(graph[x]) == 1:\n\t\t\t\t\tcoin[x] = 1\n\t\t\t\t\tcan2[x] = 0\n\t\t\t\t\tcan1[x] = 1\n\t\t\t\telse:\n\t\t\t\t\tneed = 0\n\t\t\t\t\tcount = 0\n\t\t\t\t\tfor y in graph[x]:\n\t\t\t\t\t\tif need == 1:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tif y != parent[x]:\n\t\t\t\t\t\t\tif coin[y] == 0:\n\t\t\t\t\t\t\t\tif can2[y] == 0:\n\t\t\t\t\t\t\t\t\tneed = 1\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tfor z in graph[y]:\n\t\t\t\t\t\t\t\t\t\tif z != parent[y]:\n\t\t\t\t\t\t\t\t\t\t\tif coin[z] == 1:\n\t\t\t\t\t\t\t\t\t\t\t\tif can2[z] == 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\tneed = 1\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif need == 1:\n\t\t\t\t\t\tcoin[x] = 1\n\t\t\t\t\t\tcount = 0\n\t\t\t\t\t\tfor y in graph[x]:\n\t\t\t\t\t\t\tif y != parent[x]:\n\t\t\t\t\t\t\t\tif coin[y] == 1:\n\t\t\t\t\t\t\t\t\tcount = 1\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcan2[x] = 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tcount = 0\n\t\t\t\t\t\tfor y in graph[x]:\n\t\t\t\t\t\t\tif y != parent[x]:\n\t\t\t\t\t\t\t\tif coin[y] == 1:\n\t\t\t\t\t\t\t\t\tcount += 1\n\t\t\t\t\t\tif count == 1:\n\t\t\t\t\t\t\tcoin[x] = 0\n\t\t\t\t\t\t\tcan1[x] = 1\n\t\t\t\t\t\t\tcan2[x] = 0\n\t\t\t\t\t\telif count >= 2:\n\t\t\t\t\t\t\tcoin[x] = 0\n\t\t\t\t\t\t\tcan2[x] = 1\n\t\t\t\t\t\t\tcan1[x] = 1\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tcoin[x] = 1\n\t\t\t\t\t\t\tcan2[x] = 1\n\t\t\t\t\t\t\tcan1[x] = 1\n\t\t\telif len(graph[x]) == 1:\n\t\t\t\tcoin[x] = 1\n\t\t\t\tcan2[x] = 0\n\t\t\t\tcan1[x] = 1\n\t\t\telse:\n\t\t\t\tneed = 0\n\t\t\t\tcount = 0\n\t\t\t\tfor y in graph[x]:\n\t\t\t\t\tif need == 1:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif y != parent[x]:\n\t\t\t\t\t\tif coin[y] == 0:\n\t\t\t\t\t\t\tif can2[y] == 0:\n\t\t\t\t\t\t\t\tneed = 1\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfor z in graph[y]:\n\t\t\t\t\t\t\t\t\tif z != parent[y]:\n\t\t\t\t\t\t\t\t\t\tif coin[z] == 1:\n\t\t\t\t\t\t\t\t\t\t\tif can2[z] == 0:\n\t\t\t\t\t\t\t\t\t\t\t\tneed = 1\n\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telif can2[y] == 0:\n\t\t\t\t\t\t\tneed = 1\n\t\t\t\tif need == 1:\n\t\t\t\t\tcoin[x] = 1\n\t\t\t\telse:\n\t\t\t\t\tcount = 0\n\t\t\t\t\tfor y in graph[x]:\n\t\t\t\t\t\tif coin[y] == 1:\n\t\t\t\t\t\t\tcount += 1\n\t\t\t\t\tif count > 1:\n\t\t\t\t\t\tcoin[x] = 0\n\t\t\t\t\telse:\n\t\t\t\t\t\tcoin[x] = 1\n\t\treturn sum(coin)\n\tT = int(input())\n\tfor _ in range(T):\n\t\tN = int(input())\n\t\tgraph = [[] for i in range(N)]\n\t\tfor _ in range(N - 1):\n\t\t\t(u, v) = map(int, stdin.readline().strip().split())\n\t\t\t(u, v) = (u - 1, v - 1)\n\t\t\tgraph[u] += [v]\n\t\t\tgraph[v] += [u]\n\t\tif N > 1:\n\t\t\tprint(findout(graph))\n\t\telse:\n\t\t\tprint(-1)\nmain()\n",
        "slowest_solution": "def main():\n\tfrom sys import stdin, stderr\n\tfrom collections import deque\n\n\tdef findout(graph):\n\t\tif len(graph) <= 2:\n\t\t\treturn 2\n\n\t\tdef bfs(graph):\n\t\t\tN = len(graph)\n\t\t\tq = deque([0])\n\t\t\tvisit = []\n\t\t\tparent = [-1] * N\n\t\t\twhile q:\n\t\t\t\tv = q.popleft()\n\t\t\t\tvisit += [v]\n\t\t\t\tfor adj in graph[v]:\n\t\t\t\t\tif adj != parent[v]:\n\t\t\t\t\t\tq.append(adj)\n\t\t\t\t\t\tparent[adj] = v\n\t\t\treturn (parent, visit)\n\t\tN = len(graph)\n\t\t(parent, visit) = bfs(graph)\n\t\tbfsvisit = visit[::-1]\n\t\tcan1 = [0] * N\n\t\tcan2 = [0] * N\n\t\tcoin = [0] * N\n\t\tfor x in bfsvisit:\n\t\t\tif parent[x] != -1:\n\t\t\t\tif len(graph[x]) == 1:\n\t\t\t\t\tcoin[x] = 1\n\t\t\t\t\tcan2[x] = 0\n\t\t\t\t\tcan1[x] = 1\n\t\t\t\telse:\n\t\t\t\t\tneed = 0\n\t\t\t\t\tcount = 0\n\t\t\t\t\tfor y in graph[x]:\n\t\t\t\t\t\tif need == 1:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tif y != parent[x]:\n\t\t\t\t\t\t\tif coin[y] == 0:\n\t\t\t\t\t\t\t\tif can2[y] == 0:\n\t\t\t\t\t\t\t\t\tneed = 1\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tfor z in graph[y]:\n\t\t\t\t\t\t\t\t\t\tif z != parent[y]:\n\t\t\t\t\t\t\t\t\t\t\tif coin[z] == 1:\n\t\t\t\t\t\t\t\t\t\t\t\tif can2[z] == 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\tneed = 1\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif need == 1:\n\t\t\t\t\t\tcoin[x] = 1\n\t\t\t\t\t\tcount = 0\n\t\t\t\t\t\tfor y in graph[x]:\n\t\t\t\t\t\t\tif y != parent[x]:\n\t\t\t\t\t\t\t\tif coin[y] == 1:\n\t\t\t\t\t\t\t\t\tcount = 1\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcan2[x] = 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tcount = 0\n\t\t\t\t\t\tfor y in graph[x]:\n\t\t\t\t\t\t\tif y != parent[x]:\n\t\t\t\t\t\t\t\tif coin[y] == 1:\n\t\t\t\t\t\t\t\t\tcount += 1\n\t\t\t\t\t\tif count == 1:\n\t\t\t\t\t\t\tcoin[x] = 0\n\t\t\t\t\t\t\tcan1[x] = 1\n\t\t\t\t\t\t\tcan2[x] = 0\n\t\t\t\t\t\telif count >= 2:\n\t\t\t\t\t\t\tcoin[x] = 0\n\t\t\t\t\t\t\tcan2[x] = 1\n\t\t\t\t\t\t\tcan1[x] = 1\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tcoin[x] = 1\n\t\t\t\t\t\t\tcan2[x] = 1\n\t\t\t\t\t\t\tcan1[x] = 1\n\t\t\telif len(graph[x]) == 1:\n\t\t\t\tcoin[x] = 1\n\t\t\t\tcan2[x] = 0\n\t\t\t\tcan1[x] = 1\n\t\t\telse:\n\t\t\t\tneed = 0\n\t\t\t\tcount = 0\n\t\t\t\tfor y in graph[x]:\n\t\t\t\t\tif need == 1:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif y != parent[x]:\n\t\t\t\t\t\tif coin[y] == 0:\n\t\t\t\t\t\t\tif can2[y] == 0:\n\t\t\t\t\t\t\t\tneed = 1\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfor z in graph[y]:\n\t\t\t\t\t\t\t\t\tif z != parent[y]:\n\t\t\t\t\t\t\t\t\t\tif coin[z] == 1:\n\t\t\t\t\t\t\t\t\t\t\tif can2[z] == 0:\n\t\t\t\t\t\t\t\t\t\t\t\tneed = 1\n\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telif can2[y] == 0:\n\t\t\t\t\t\t\tneed = 1\n\t\t\t\tif need == 1:\n\t\t\t\t\tcoin[x] = 1\n\t\t\t\telse:\n\t\t\t\t\tcount = 0\n\t\t\t\t\tfor y in graph[x]:\n\t\t\t\t\t\tif coin[y] == 1:\n\t\t\t\t\t\t\tcount += 1\n\t\t\t\t\tif count > 1:\n\t\t\t\t\t\tcoin[x] = 0\n\t\t\t\t\telse:\n\t\t\t\t\t\tcoin[x] = 1\n\t\treturn sum(coin)\n\tT = int(input())\n\tfor _ in range(T):\n\t\tN = int(input())\n\t\tgraph = [[] for i in range(N)]\n\t\tfor _ in range(N - 1):\n\t\t\t(u, v) = map(int, stdin.readline().strip().split())\n\t\t\t(u, v) = (u - 1, v - 1)\n\t\t\tgraph[u] += [v]\n\t\t\tgraph[v] += [u]\n\t\tif N > 1:\n\t\t\tprint(findout(graph))\n\t\telse:\n\t\t\tprint(-1)\nmain()\n"
    },
    {
        "task_id": 291,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5882623195648193,
        "fastest_time": 2.5882623195648193,
        "fastest_solution": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nsrc = 0\nX = []\nfor u in range(n):\n\tX.append(list(map(lambda x: int(x) - 1, input().split())))\n\tX[u] = X[u][1:]\n\tif len(X[u]) > len(X[src]):\n\t\tsrc = u\nE = [[] for u in range(n)]\nfor j in range(n - 1):\n\t(u, v) = map(lambda x: int(x) - 1, input().split())\n\tE[u].append(v)\n\tE[v].append(u)\ncolor = [0] * m\nvis = [False] * n\nused = [False] * (m + 1)\nq = deque()\nq.append(src)\nwhile q:\n\tu = q.popleft()\n\tvis[u] = True\n\tfor x in X[u]:\n\t\tused[color[x]] = True\n\tptr = 1\n\tfor x in X[u]:\n\t\tif not color[x]:\n\t\t\twhile used[ptr]:\n\t\t\t\tptr += 1\n\t\t\tcolor[x] = ptr\n\t\t\tptr += 1\n\tfor x in X[u]:\n\t\tused[color[x]] = False\n\tfor v in E[u]:\n\t\tif not vis[v]:\n\t\t\tq.append(v)\nfor x in range(m):\n\tif not color[x]:\n\t\tcolor[x] = 1\nprint(max(color))\nprint(*color)\n",
        "slowest_solution": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nsrc = 0\nX = []\nfor u in range(n):\n\tX.append(list(map(lambda x: int(x) - 1, input().split())))\n\tX[u] = X[u][1:]\n\tif len(X[u]) > len(X[src]):\n\t\tsrc = u\nE = [[] for u in range(n)]\nfor j in range(n - 1):\n\t(u, v) = map(lambda x: int(x) - 1, input().split())\n\tE[u].append(v)\n\tE[v].append(u)\ncolor = [0] * m\nvis = [False] * n\nused = [False] * (m + 1)\nq = deque()\nq.append(src)\nwhile q:\n\tu = q.popleft()\n\tvis[u] = True\n\tfor x in X[u]:\n\t\tused[color[x]] = True\n\tptr = 1\n\tfor x in X[u]:\n\t\tif not color[x]:\n\t\t\twhile used[ptr]:\n\t\t\t\tptr += 1\n\t\t\tcolor[x] = ptr\n\t\t\tptr += 1\n\tfor x in X[u]:\n\t\tused[color[x]] = False\n\tfor v in E[u]:\n\t\tif not vis[v]:\n\t\t\tq.append(v)\nfor x in range(m):\n\tif not color[x]:\n\t\tcolor[x] = 1\nprint(max(color))\nprint(*color)\n"
    },
    {
        "task_id": 280,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.7030131816864014,
        "fastest_time": 2.5589182376861572,
        "fastest_solution": "from functools import reduce\nfor _ in range(int(input())):\n\tinput()\n\tgrundy = []\n\tfor (i, h) in enumerate([int(x) for x in input().split()], start=1):\n\t\tif i % 2 == 0:\n\t\t\tgrundy.append(h // 2)\n\t\telse:\n\t\t\tgrundy.append(h % 2)\n\tnimn = reduce(lambda x, y: x ^ y, grundy)\n\tprint('CHEF' if nimn > 0 else 'CHEFINA')\n",
        "slowest_solution": "from math import *\nimport sys\n\ndef input():\n\treturn sys.stdin.readline().replace('\\n', '').strip()\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\ta = 0\n\tind = 0\n\tfor i in l:\n\t\tind += 1\n\t\tif ind % 2 == 0:\n\t\t\ta ^= i // 2\n\t\telse:\n\t\t\ta ^= i % 2\n\tif a != 0:\n\t\tprint('CHEF')\n\telse:\n\t\tprint('CHEFINA')\n"
    },
    {
        "task_id": 245,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.686060667037964,
        "fastest_time": 2.529987096786499,
        "fastest_solution": "from math import gcd\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tarr.sort()\n\tans = arr[0]\n\tfor i in range(1, n):\n\t\tans = gcd(ans, arr[i])\n\tprint(ans * n)\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tarr.sort()\n\tans = arr[0]\n\tfor i in range(1, n):\n\t\tk = arr[i] % ans\n\t\tif k != 0 and k < ans:\n\t\t\tans = k\n\tprint(n * ans)\n"
    },
    {
        "task_id": 244,
        "slowest_solution_id": 1,
        "fastest_solution_id": 8,
        "slowest_time": 2.7021372318267822,
        "fastest_time": 2.5250606536865234,
        "fastest_solution": "(a, b) = list(map(int, input().split()))\nif b > a:\n\tprint(-1)\nelse:\n\ttry:\n\t\tx = 100000000000\n\t\tk = int((a + b) / 2 / b)\n\t\tif k != 0:\n\t\t\tx = (a + b) / 2 / k\n\t\tk = int((a - b) / 2 / b)\n\t\tif k != 0:\n\t\t\tx = min(x, (a - b) / 2 / k)\n\t\tprint('%.9f' % x)\n\texcept:\n\t\tprint(-1)\n",
        "slowest_solution": "import math\n\ndef fun(a, b):\n\ty = (a + b) / 2\n\tm = math.floor(y / b)\n\tif m == 0:\n\t\treturn -1\n\treturn y / m\n(a, b) = map(int, input().split())\nif b > a:\n\tprint('-1')\nelif b == a:\n\tprint(b)\nelif b == 0:\n\tprint(fun(a - 1, 1))\nelse:\n\t(x, y) = (fun(a, b), fun(a - 2 * b, b))\n\tmini = min(x, y)\n\tif mini == -1:\n\t\tprint(max(x, y))\n\telse:\n\t\tprint(mini)\n"
    },
    {
        "task_id": 290,
        "slowest_solution_id": 2,
        "fastest_solution_id": 2,
        "slowest_time": 2.673492431640625,
        "fastest_time": 2.673492431640625,
        "fastest_solution": "from collections import deque\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n\t(n, m, k) = map(int, input().split())\n\tG = [set() for _ in range(n + 1)]\n\tdeg = [0] * (n + 1)\n\tfor _ in range(m):\n\t\t(i, j) = map(int, input().split())\n\t\tG[i].add(j)\n\t\tG[j].add(i)\n\t\tdeg[i] += 1\n\t\tdeg[j] += 1\n\tif k * (k - 1) > 2 * m:\n\t\tprint(-1)\n\t\tcontinue\n\tq = deque()\n\tseen = [0] * (n + 1)\n\tfor i in range(1, n + 1):\n\t\tif deg[i] < k:\n\t\t\tseen[i] = 1\n\t\t\tq.append(i)\n\tclique = []\n\tend = 0\n\twhile q and (not end):\n\t\ti = q.popleft()\n\t\tseen[i] = 2\n\t\tif deg[i] == k - 1 and (not clique) and (k * (k - 1) // 2 <= m):\n\t\t\tclique = [i]\n\t\t\tfor j in G[i]:\n\t\t\t\tif seen[j] <= 1:\n\t\t\t\t\tclique.append(j)\n\t\t\tok = 1\n\t\t\tfor x in clique:\n\t\t\t\tfor y in clique:\n\t\t\t\t\tif x == y:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif y not in G[x]:\n\t\t\t\t\t\tok = 0\n\t\t\t\t\t\tbreak\n\t\t\t\tif not ok:\n\t\t\t\t\tbreak\n\t\t\tif not ok:\n\t\t\t\tclique = []\n\t\t\telse:\n\t\t\t\tprint(2)\n\t\t\t\tprint(*clique)\n\t\t\t\tend = 1\n\t\t\t\tbreak\n\t\tfor j in G[i]:\n\t\t\tdeg[j] -= 1\n\t\t\tif deg[j] < k and (not seen[j]):\n\t\t\t\tseen[j] = 1\n\t\t\t\tq.append(j)\n\tif not end:\n\t\tsubset = [i for i in range(1, n + 1) if not seen[i]]\n\t\tif subset:\n\t\t\tprint('1 {}'.format(len(subset)))\n\t\t\tprint(*subset)\n\t\telse:\n\t\t\tprint(-1)\n",
        "slowest_solution": "from collections import deque\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n\t(n, m, k) = map(int, input().split())\n\tG = [set() for _ in range(n + 1)]\n\tdeg = [0] * (n + 1)\n\tfor _ in range(m):\n\t\t(i, j) = map(int, input().split())\n\t\tG[i].add(j)\n\t\tG[j].add(i)\n\t\tdeg[i] += 1\n\t\tdeg[j] += 1\n\tif k * (k - 1) > 2 * m:\n\t\tprint(-1)\n\t\tcontinue\n\tq = deque()\n\tseen = [0] * (n + 1)\n\tfor i in range(1, n + 1):\n\t\tif deg[i] < k:\n\t\t\tseen[i] = 1\n\t\t\tq.append(i)\n\tclique = []\n\tend = 0\n\twhile q and (not end):\n\t\ti = q.popleft()\n\t\tseen[i] = 2\n\t\tif deg[i] == k - 1 and (not clique) and (k * (k - 1) // 2 <= m):\n\t\t\tclique = [i]\n\t\t\tfor j in G[i]:\n\t\t\t\tif seen[j] <= 1:\n\t\t\t\t\tclique.append(j)\n\t\t\tok = 1\n\t\t\tfor x in clique:\n\t\t\t\tfor y in clique:\n\t\t\t\t\tif x == y:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif y not in G[x]:\n\t\t\t\t\t\tok = 0\n\t\t\t\t\t\tbreak\n\t\t\t\tif not ok:\n\t\t\t\t\tbreak\n\t\t\tif not ok:\n\t\t\t\tclique = []\n\t\t\telse:\n\t\t\t\tprint(2)\n\t\t\t\tprint(*clique)\n\t\t\t\tend = 1\n\t\t\t\tbreak\n\t\tfor j in G[i]:\n\t\t\tdeg[j] -= 1\n\t\t\tif deg[j] < k and (not seen[j]):\n\t\t\t\tseen[j] = 1\n\t\t\t\tq.append(j)\n\tif not end:\n\t\tsubset = [i for i in range(1, n + 1) if not seen[i]]\n\t\tif subset:\n\t\t\tprint('1 {}'.format(len(subset)))\n\t\t\tprint(*subset)\n\t\telse:\n\t\t\tprint(-1)\n"
    },
    {
        "task_id": 246,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 2.6527676582336426,
        "fastest_time": 2.4924111366271973,
        "fastest_solution": "(n, w, l) = map(int, input().split())\nht = [0] * n\nrt = [0] * n\nfor i in range(n):\n\t(ht[i], rt[i]) = map(int, input().split())\nleft = 0\nright = 10 ** 18 - 1\nwhile left < right:\n\tmid = (left + right) // 2\n\ts = 0\n\tfor i in range(n):\n\t\tval = ht[i] + mid * rt[i]\n\t\tif val >= l:\n\t\t\ts += val\n\tif s >= w:\n\t\tright = mid\n\telse:\n\t\tleft = mid + 1\nprint(left)\n",
        "slowest_solution": "(n, W, L) = map(int, input().split())\nH = []\nR = []\nfor _ in range(n):\n\t(p, q) = map(int, input().split())\n\tH.append(p)\n\tR.append(q)\n\ndef isValid(t):\n\ts = 0\n\tfor i in range(n):\n\t\tl = H[i] + R[i] * t\n\t\tif l >= L:\n\t\t\ts += l\n\t\tif s >= W:\n\t\t\treturn True\n\treturn False\nl = -1\nh = 10 ** 18 + 1\nwhile h - l > 1:\n\tm = (l + h) // 2\n\tif isValid(m):\n\t\th = m\n\telse:\n\t\tl = m\nprint(h)\n"
    },
    {
        "task_id": 247,
        "slowest_solution_id": 9,
        "fastest_solution_id": 8,
        "slowest_time": 2.693673610687256,
        "fastest_time": 2.5645148754119873,
        "fastest_solution": "k = int(input())\nn = []\nx = []\nt = []\nfor i in range(k):\n\tinp = input().split(' ')\n\tn.append(int(inp[0]))\n\tx.append(int(inp[1]))\n\tt.append(int(inp[2]))\nfor i in range(k):\n\ttemp = t[i] // x[i]\n\tc1 = temp * n[i] - temp * (temp + 1) // 2\n\tc2 = n[i] * (n[i] - 1) // 2\n\tif n[i] * x[i] > t[i]:\n\t\tprint(int(c1))\n\telse:\n\t\tprint(int(c2))\n",
        "slowest_solution": "import sys\nimport math\nlines = []\nis_stdin = False\nis_stdin = True\nif is_stdin:\n\tfor line in sys.stdin:\n\t\tlines.append(line.strip())\nelse:\n\twith open('./myin.txt', 'r') as f:\n\t\tfor line in f.readlines():\n\t\t\tlines.append(line.strip())\nN = int(lines.pop(0))\nwhile N > 0:\n\tN -= 1\n\t(n, x, t) = lines.pop(0).split(' ')\n\tn = int(n)\n\tx = int(x)\n\tt = int(t)\n\tfulls = t // x\n\tif fulls < n:\n\t\tcur_all = (n - fulls) * fulls\n\t\tcur_all += (0 + fulls - 1) * fulls // 2\n\t\tprint(cur_all)\n\telse:\n\t\tcur_all = (0 + n - 1) * n // 2\n\t\tprint(cur_all)\n"
    },
    {
        "task_id": 281,
        "slowest_solution_id": 3,
        "fastest_solution_id": 2,
        "slowest_time": 2.8338747024536133,
        "fastest_time": 2.592677116394043,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, x1, y1, x2, y2) = map(int, input().split())\n\tif n % 2 == 0:\n\t\t(p1, p2) = (n // 2, 1 + n // 2)\n\t\tm1 = p1 if abs(p1 - y2) < abs(p2 - y2) else p2\n\t\tm2 = p1 if abs(p1 - y1) < abs(p2 - y1) else p2\n\telse:\n\t\tm1 = m2 = (n + 1) // 2\n\twinner = 0\n\tif x1 == x2:\n\t\tif abs(m1 - y1) <= abs(m1 - y2):\n\t\t\twinner = 1\n\t\telif abs(m2 - y2) < abs(m2 - y1):\n\t\t\twinner = 2\n\telif abs(m1 - y1) < abs(m1 - y2):\n\t\twinner = 1\n\telif abs(m2 - y2) + 1 < abs(m2 - y1):\n\t\twinner = 2\n\tprint(['Draw', 'Miron', 'Slava'][winner])\n",
        "slowest_solution": "for t in range(int(input())):\n\t(N, x1, y1, x2, y2) = map(int, input().split())\n\tdist = lambda x, y: abs(x - y)\n\tif N % 2 == 0:\n\t\t(p1, p2) = (N // 2, N // 2 + 1)\n\t\tw1 = p1 if dist(y2, p1) < dist(y2, p2) else p2\n\t\tw2 = p1 if dist(y1, p1) < dist(y1, p2) else p2\n\telse:\n\t\tw1 = w2 = (N + 1) // 2\n\tres = 0\n\tif dist(w1, y1) < dist(w1, y2) + (x1 == x2):\n\t\tres = 1\n\telif dist(w2, y2) + (x1 != x2) < dist(w2, y1):\n\t\tres = 2\n\tprint(['Draw', 'Miron', 'Slava'][res])\n"
    },
    {
        "task_id": 251,
        "slowest_solution_id": 9,
        "fastest_solution_id": 7,
        "slowest_time": 2.957245111465454,
        "fastest_time": 2.504563570022583,
        "fastest_solution": "shit = []\nfor i in range(13):\n\tshit.append(4 ** ((i + 1) // 2))\n\ndef five_pow(x):\n\tans = 0\n\twhile x % 5 == 0:\n\t\tx //= 5\n\t\tans += 1\n\treturn ans\n\ndef two_pow(x):\n\tans = 0\n\twhile x % 2 == 0:\n\t\tx //= 2\n\t\tans += 1\n\treturn ans\nN = int(input())\nA = [int(x) for x in input().split()]\nfor x in A:\n\ty = five_pow(x) - two_pow(x)\n\tif y > 0:\n\t\tprint(x * shit[y])\n\telse:\n\t\tprint(x)\n",
        "slowest_solution": "t = int(input())\ncount = 0\nvalue = 1\nl = []\nsumm = 0\nl.append(input().split())\nlength = len(l[0])\nfor i in range(length):\n\ta = int(l[0][i])\n\tb = int(l[0][i])\n\twhile a % 10 == 0:\n\t\tcount = count + 1\n\t\ta = a // 10\n\twhile a % 5 == 0:\n\t\tsumm = summ + 1\n\t\ta = a // 5\n\tk = summ // 2 + summ % 2\n\tfor z in range(k):\n\t\tb = 4 * b\n\tfor y in range(count):\n\t\tvalue = value * 10\n\tprint(b)\n\tcount = 0\n\tvalue = 1\n\tsumm = 0\n"
    },
    {
        "task_id": 273,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 2.7173941135406494,
        "fastest_time": 2.582824468612671,
        "fastest_solution": "(n, m, q) = map(int, input().split())\na = input().split()\nc = {x: ([x], []) for x in a}\nfor i in range(m):\n\t(t, x, y) = input().split()\n\tif t == '2':\n\t\tsign = 1\n\telse:\n\t\tsign = 0\n\tif c[x][0] is c[y][1 - sign]:\n\t\tprint('NO')\n\t\tcontinue\n\tprint('YES')\n\tif c[x][0] is c[y][sign]:\n\t\tcontinue\n\t(c1, c2) = (c[x], c[y])\n\tif len(c1[0]) + len(c1[1]) < len(c2[0]) + len(c2[1]):\n\t\t(c1, c2) = (c2, c1)\n\t(s1, a1) = c1\n\tif sign == 0:\n\t\t(s2, a2) = c2\n\telse:\n\t\t(a2, s2) = c2\n\ts1 += s2\n\ta1 += a2\n\tcs = (s1, a1)\n\tfor x in s2:\n\t\tc[x] = cs\n\tca = (a1, s1)\n\tfor x in a2:\n\t\tc[x] = ca\nfor i in range(q):\n\t(x, y) = input().split()\n\tif c[x][0] is c[y][0]:\n\t\tprint(1)\n\telif c[x][0] is c[y][1]:\n\t\tprint(2)\n\telse:\n\t\tprint(3)\n",
        "slowest_solution": "def union(u, v, parent):\n\tx = find(u, parent)\n\ty = find(v, parent)\n\tif x == y:\n\t\treturn\n\tparent[x] = y\n\ndef find(u, parent):\n\tk = parent[u]\n\twhile k != parent[k]:\n\t\tk = parent[k]\n\twhile parent[u] != k:\n\t\t(u, parent[u]) = (parent[u], k)\n\treturn k\n(n, m, q) = map(int, input().split())\np = [i for i in range(2 * n)]\nd = {}\ns = input().split()\nfor i in range(n):\n\td[s[i]] = i\nfor i in range(m):\n\t(re, node1, node2) = input().split()\n\ta1 = find(d[node1], p)\n\ta2 = find(d[node1] + n, p)\n\tb1 = find(d[node2], p)\n\tb2 = find(d[node2] + n, p)\n\tif re == '1':\n\t\tif a1 == b2 or a2 == b1:\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint('YES')\n\t\t\tunion(d[node1], d[node2], p)\n\t\t\tunion(d[node1] + n, d[node2] + n, p)\n\telif re == '2':\n\t\tif a1 == b1 or a2 == b2:\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint('YES')\n\t\t\tunion(d[node1], d[node2] + n, p)\n\t\t\tunion(d[node1] + n, d[node2], p)\nfor i in range(q):\n\t(node1, node2) = input().split()\n\ta1 = find(d[node1], p)\n\ta2 = find(d[node1] + n, p)\n\tb1 = find(d[node2], p)\n\tb2 = find(d[node2] + n, p)\n\tif a1 == b1 or a2 == b2:\n\t\tprint(1)\n\telif a1 == b2 or b1 == a2:\n\t\tprint(2)\n\telse:\n\t\tprint(3)\n"
    },
    {
        "task_id": 255,
        "slowest_solution_id": 9,
        "fastest_solution_id": 0,
        "slowest_time": 2.919280767440796,
        "fastest_time": 2.5392346382141113,
        "fastest_solution": "from math import log\n(x, y) = list(map(int, input().split()))\nif x == y:\n\tprint('=')\nelif y * log(x) > x * log(y) + 1e-09:\n\tprint('>')\nelif y * log(x) + 1e-09 < x * log(y):\n\tprint('<')\nelse:\n\tprint('=')\n",
        "slowest_solution": "import math\n(a, b) = map(int, input().split())\nc = b * math.log2(a)\nd = a * math.log2(b)\nif c > d:\n\tprint('>')\nelif d > c:\n\tprint('<')\nelse:\n\tprint('=')\n"
    },
    {
        "task_id": 256,
        "slowest_solution_id": 9,
        "fastest_solution_id": 2,
        "slowest_time": 2.8811323642730713,
        "fastest_time": 2.468234062194824,
        "fastest_solution": "import copy\na = []\nb = {}\nw = 0\nfor o in range(int(input())):\n\tt = [i.lower() for i in input().split()]\n\ttry:\n\t\ta[b[t[2]]] += [t[0]]\n\texcept:\n\t\tb[t[2]] = w\n\t\ta += [[t[0]]]\n\t\tw += 1\nc = [1] * len(a)\nx = ['polycarp']\ny = []\nj = 1\nwhile True:\n\tfor i in x:\n\t\ttry:\n\t\t\ty += a[b[i]]\n\t\texcept:\n\t\t\tpass\n\tif y == []:\n\t\tbreak\n\telse:\n\t\tj += 1\n\t\tx = copy.copy(y)\n\t\ty = []\nprint(j)\n",
        "slowest_solution": "n = int(input())\nlst = [input().lower().split() for i in range(n)]\nd = dict()\nd['polycarp'] = 1\nmx = 1\nfor i in lst:\n\td[i[0]] = d[i[2]] + 1\n\tmx = max(mx, d[i[0]])\nprint(mx)\n"
    },
    {
        "task_id": 257,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 2.6005630493164062,
        "fastest_time": 2.596858263015747,
        "fastest_solution": "T = int(input())\nfor _ in range(T):\n\tN = int(input())\n\tar = [int(i) for i in input().split()]\n\tcache = [-1 for _ in range(2 ** N)]\n\tcache[0] = 1\n\n\tdef is_increasing(combo):\n\t\tprev = 0\n\t\tfor i in range(N):\n\t\t\tif combo & 1 << i != 0:\n\t\t\t\tif ar[i] <= prev:\n\t\t\t\t\treturn False\n\t\t\t\tprev = ar[i]\n\t\treturn True\n\n\tdef can_win(combo):\n\t\tif cache[combo] >= 0:\n\t\t\treturn bool(cache[combo])\n\t\tfor i in range(N):\n\t\t\tif combo & 1 << i != 0:\n\t\t\t\tsubcombo = combo ^ 1 << i\n\t\t\t\tif is_increasing(subcombo) or not can_win(subcombo):\n\t\t\t\t\tcache[combo] = 1\n\t\t\t\t\treturn True\n\t\tcache[combo] = 0\n\t\treturn False\n\tprint('Alice' if can_win(2 ** N - 1) else 'Bob')\n",
        "slowest_solution": "def has_won(arr):\n\tprev = float('-inf')\n\tfor el in arr:\n\t\tif el < prev:\n\t\t\treturn False\n\t\tprev = el\n\treturn True\n\ndef can_win(arr, cache):\n\tif arr in cache:\n\t\treturn cache[arr]\n\tif has_won(arr):\n\t\treturn False\n\tfor i in range(len(arr)):\n\t\tnew_arr = arr[:i] + arr[i + 1:]\n\t\tif not can_win(new_arr, cache):\n\t\t\tcache[arr] = True\n\t\t\treturn True\n\tcache[arr] = False\n\treturn False\nfor _ in range(int(input())):\n\tinput()\n\tarr = tuple((int(s) for s in input().split()))\n\tif has_won(arr) or can_win(arr, {}):\n\t\tprint('Alice')\n\telse:\n\t\tprint('Bob')\n"
    },
    {
        "task_id": 258,
        "slowest_solution_id": 7,
        "fastest_solution_id": 0,
        "slowest_time": 2.7843828201293945,
        "fastest_time": 2.5747194290161133,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k1, k2) = map(int, input().split())\n\t(w, b) = map(int, input().split())\n\tif k1 + k2 >= 2 * w and 2 * n - (k1 + k2) >= 2 * b:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "x = int(input())\nl = []\nfor i in range(x):\n\t(n, k1, k2) = map(int, input().split())\n\t(w, b) = map(int, input().split())\n\tif k1 + k2 >= 2 * w and 2 * n >= 2 * b + k1 + k2:\n\t\tl.append('YES')\n\telse:\n\t\tl.append('NO')\nfor i in range(x):\n\tprint(l[i])\n"
    },
    {
        "task_id": 305,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6794352531433105,
        "fastest_time": 2.6794352531433105,
        "fastest_solution": "def main():\n\t(n, k) = map(int, input().split())\n\tcnt = [[[0] * 21 for _ in (0, 1)] for _ in range(n + 1)]\n\t(edges, mod) = ([[] for _ in range(n + 1)], 1000000007)\n\tfor _ in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tedges[u].append(v)\n\t\tedges[v].append(u)\n\n\tdef dfs(u, f):\n\t\tcnt[u][0][0] = cnt[u][1][k] = 1\n\t\tfor v in edges[u]:\n\t\t\tif v != f:\n\t\t\t\tdfs(v, u)\n\t\t\t\t(tmp0, tmp1) = ([0] * 21, [0] * 21)\n\t\t\t\tfor i in range(k + 1):\n\t\t\t\t\tfor j in range(k + 1):\n\t\t\t\t\t\tif i != k:\n\t\t\t\t\t\t\ttmp0[j if i < j else i + 1] += cnt[u][0][j] * cnt[v][0][i]\n\t\t\t\t\t\tif i < j:\n\t\t\t\t\t\t\ttmp1[j] += cnt[u][1][j] * cnt[v][0][i]\n\t\t\t\t\t\telif i != k:\n\t\t\t\t\t\t\ttmp0[i + 1] += cnt[u][1][j] * cnt[v][0][i]\n\t\t\t\t\t\tif i > j:\n\t\t\t\t\t\t\ttmp1[i - 1] += cnt[u][0][j] * cnt[v][1][i]\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\ttmp0[j] += cnt[u][0][j] * cnt[v][1][i]\n\t\t\t\t\t\ttmp1[max(i - 1, j)] += cnt[u][1][j] * cnt[v][1][i]\n\t\t\t\tfor i in range(21):\n\t\t\t\t\ttmp0[i] %= mod\n\t\t\t\t\ttmp1[i] %= mod\n\t\t\t\tcnt[u][0] = tmp0\n\t\t\t\tcnt[u][1] = tmp1\n\tdfs(1, 1)\n\tprint(sum((cnt[1][1][j] for j in range(k + 1))) % mod)\nmain()\n",
        "slowest_solution": "def main():\n\t(n, k) = map(int, input().split())\n\tcnt = [[[0] * 21 for _ in (0, 1)] for _ in range(n + 1)]\n\t(edges, mod) = ([[] for _ in range(n + 1)], 1000000007)\n\tfor _ in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tedges[u].append(v)\n\t\tedges[v].append(u)\n\n\tdef dfs(u, f):\n\t\tcnt[u][0][0] = cnt[u][1][k] = 1\n\t\tfor v in edges[u]:\n\t\t\tif v != f:\n\t\t\t\tdfs(v, u)\n\t\t\t\t(tmp0, tmp1) = ([0] * 21, [0] * 21)\n\t\t\t\tfor i in range(k + 1):\n\t\t\t\t\tfor j in range(k + 1):\n\t\t\t\t\t\tif i != k:\n\t\t\t\t\t\t\ttmp0[j if i < j else i + 1] += cnt[u][0][j] * cnt[v][0][i]\n\t\t\t\t\t\tif i < j:\n\t\t\t\t\t\t\ttmp1[j] += cnt[u][1][j] * cnt[v][0][i]\n\t\t\t\t\t\telif i != k:\n\t\t\t\t\t\t\ttmp0[i + 1] += cnt[u][1][j] * cnt[v][0][i]\n\t\t\t\t\t\tif i > j:\n\t\t\t\t\t\t\ttmp1[i - 1] += cnt[u][0][j] * cnt[v][1][i]\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\ttmp0[j] += cnt[u][0][j] * cnt[v][1][i]\n\t\t\t\t\t\ttmp1[max(i - 1, j)] += cnt[u][1][j] * cnt[v][1][i]\n\t\t\t\tfor i in range(21):\n\t\t\t\t\ttmp0[i] %= mod\n\t\t\t\t\ttmp1[i] %= mod\n\t\t\t\tcnt[u][0] = tmp0\n\t\t\t\tcnt[u][1] = tmp1\n\tdfs(1, 1)\n\tprint(sum((cnt[1][1][j] for j in range(k + 1))) % mod)\nmain()\n"
    },
    {
        "task_id": 302,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.699589252471924,
        "fastest_time": 2.577019214630127,
        "fastest_solution": "from itertools import chain\n\ndef main(n, a, info=False):\n\twinner = a[-1]\n\tlooser = 3 - winner\n\t(csw, csl, pw, pl, ans) = ([0], [0], [-1], [-1], [])\n\t(nw, nl) = (a.count(winner), a.count(looser))\n\tfor i in range(n):\n\t\tif a[i] == winner:\n\t\t\tpw.append(i)\n\t\telse:\n\t\t\tpl.append(i)\n\t\tcsw.append(csw[-1] + int(a[i] == winner))\n\t\tcsl.append(csl[-1] + int(a[i] == looser))\n\tpw += [n * 10] * n\n\tpl += [n * 10] * n\n\tcsw += [0] * n\n\tcsl += [0] * n\n\tif info:\n\t\tprint('a: ', a)\n\t\tprint('csw: ', csw)\n\t\tprint('csl: ', csl)\n\t\tprint('pw: ', pw)\n\t\tprint('pl: ', pl)\n\tfor t in chain(range(1, nw // 2 + 1), [nw]):\n\t\ts = l = i = 0\n\t\tsw = sl = 0\n\t\twhile i < n:\n\t\t\txw = pw[csw[i] + t]\n\t\t\txl = pl[csl[i] + t]\n\t\t\tif xw < xl:\n\t\t\t\ts += 1\n\t\t\telse:\n\t\t\t\tl += 1\n\t\t\ti = min(xw, xl) + 1\n\t\t\tif info:\n\t\t\t\tprint(s, t, ': ', t, i, s, l, xw, xl)\n\t\tif s > l and i <= n and (csw[i] == nw):\n\t\t\tans.append((s, t))\n\tprint(len(ans))\n\tfor (x, y) in sorted(ans):\n\t\tprint(x, y)\n\ndef main_input():\n\tn = int(input())\n\ta = [int(i) for i in input().split()]\n\tmain(n, a)\nmain_input()\n",
        "slowest_solution": "n = int(input())\nline = input().split()\nlst = []\nfor num in line:\n\tlst.append(int(num))\ncnt1 = [0]\ncnt2 = [0]\nc1 = 0\nc2 = 0\nfor num in lst:\n\tif num == 1:\n\t\tc1 += 1\n\t\tcnt1.append(c2)\n\telse:\n\t\tc2 += 1\n\t\tcnt2.append(c1)\nw = lst[n - 1]\nans = []\nc1 = len(cnt1)\nc2 = len(cnt2)\nfor t in range(n, 0, -1):\n\ts1 = 0\n\ts2 = 0\n\ti1 = 0\n\ti2 = 0\n\tl = 1\n\twhile i1 < c1 and i2 < c2:\n\t\tif i1 + t >= c1 and i2 + t >= c2:\n\t\t\tif l == 1 and l == w and (i1 + 1 == c1) and (s1 > s2):\n\t\t\t\tans.append((s1, t))\n\t\t\telif l == 2 and l == w and (i2 + 1 == c2) and (s2 > s1):\n\t\t\t\tans.append((s2, t))\n\t\t\tbreak\n\t\telif i2 + t >= c2:\n\t\t\ts1 += 1\n\t\t\tl = 1\n\t\t\ti1 += t\n\t\t\ti2 = cnt1[i1]\n\t\telif i1 + t >= c1:\n\t\t\ts2 += 1\n\t\t\tl = 2\n\t\t\ti2 += t\n\t\t\ti1 = cnt2[i2]\n\t\telif cnt1[i1 + t] < i2 + t:\n\t\t\ts1 += 1\n\t\t\tl = 1\n\t\t\ti1 += t\n\t\t\ti2 = cnt1[i1]\n\t\telse:\n\t\t\ts2 += 1\n\t\t\tl = 2\n\t\t\ti2 += t\n\t\t\ti1 = cnt2[i2]\nans.sort()\nprint(int(len(ans)))\nfor line in ans:\n\tprint(str(line[0]) + ' ' + str(line[1]))\n"
    },
    {
        "task_id": 283,
        "slowest_solution_id": 4,
        "fastest_solution_id": 6,
        "slowest_time": 2.863903522491455,
        "fastest_time": 2.4377851486206055,
        "fastest_solution": "MOD = int(1000000000.0 + 7)\nx = input()[::-1]\nn = len(x)\nres = 0\nfor (i, t) in enumerate(x):\n\tif t == '1':\n\t\tres = (res + (1 << n - 1 + i)) % MOD\nprint(res)\n",
        "slowest_solution": "MOD = 1000000007\nans = 0\nx = input().strip()\nn = len(x)\nfor (i, v) in enumerate(x):\n\tif v == '1':\n\t\tans += pow(2, i, MOD) * pow(2, (n - i - 1) * 2, MOD) % MOD\n\t\tans %= MOD\nprint(ans)\n"
    },
    {
        "task_id": 262,
        "slowest_solution_id": 6,
        "fastest_solution_id": 4,
        "slowest_time": 2.9308619499206543,
        "fastest_time": 2.5056204795837402,
        "fastest_solution": "for _ in range(int(input())):\n\ts = input()\n\tcount = 0\n\tquestion = 0\n\tfor i in s:\n\t\tif i == '?':\n\t\t\tquestion += 1\n\t\telif i == '(':\n\t\t\tcount += 1\n\t\telse:\n\t\t\tcount -= 1\n\t\tif count + question == 1:\n\t\t\tquestion = 0\n\t\t\tcount = 1\n\tif count == question:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\ts = input()\n\tvalue = 0\n\tunknown = 0\n\tfor i in s:\n\t\tif i == '(':\n\t\t\tvalue += 1\n\t\telif i == ')':\n\t\t\tvalue -= 1\n\t\telse:\n\t\t\tunknown += 1\n\t\tif 1 - value == unknown:\n\t\t\tunknown = 0\n\t\t\tvalue = 1\n\tif unknown == value:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 298,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 11.01308298110962,
        "fastest_time": 11.01308298110962,
        "fastest_solution": "import sys\nimport numpy as np\np1 = 599\np2 = 601\npp = p1 * p2\nMOD = 10 ** 9 + 7\n\ndef getLogPows(p, root=7):\n\tv = 1\n\tret = np.zeros(p, dtype=np.int64)\n\tpw = np.zeros(p, dtype=np.int64)\n\tpw[0] = 1\n\tfor i in range(p - 1):\n\t\tret[v] = i\n\t\tv = v * root % p\n\t\tpw[i + 1] = v\n\treturn (ret, pw)\n(LOG1, POW1) = getLogPows(p1)\n(LOG2, POW2) = getLogPows(p2)\nCRT = np.zeros((p1, p2), dtype=np.int64)\nfor i in range(pp):\n\tCRT[i % p1, i % p2] = i\nprimes = np.ones(pp, dtype=np.int64)\nMU = np.ones(pp, dtype=np.int64)\nMU[0] = 0\nprimes[:2] = 0\nfor i in range(2, pp):\n\tif primes[i] == 1:\n\t\tprimes[2 * i::i] = 0\n\t\tMU[i::i] *= -1\n\t\tif i * i < len(MU):\n\t\t\tMU[i * i::i * i] = 0\n\ndef getLogArray(xx):\n\tarr = np.zeros((p1 - 1, p2 - 1))\n\tarr10 = np.zeros(p2 - 1)\n\tarr20 = np.zeros(p1 - 1)\n\tzeros = 0\n\tx1 = xx % p1\n\tx2 = xx % p2\n\tfor (x1, x2) in zip(xx % p1, xx % p2):\n\t\tif x1 == 0:\n\t\t\tif x2 == 0:\n\t\t\t\tzeros += 1\n\t\t\telse:\n\t\t\t\tarr10[LOG2[x2]] += 1\n\t\telif x2 == 0:\n\t\t\tarr20[LOG1[x1]] += 1\n\t\telse:\n\t\t\tarr[LOG1[x1], LOG2[x2]] += 1\n\treturn (arr, arr10, arr20, zeros)\n\ndef getTotals(xx):\n\tret = np.zeros(pp, dtype=np.int64)\n\t(arr, arr10, arr20, zeros) = getLogArray(xx)\n\taff = np.fft.rfft2(arr)\n\taff = aff * aff\n\tr0 = np.fft.irfft2(aff)\n\tfor i in range(p1 - 1):\n\t\tfor j in range(p2 - 1):\n\t\t\tret[CRT[POW1[i], POW2[j]]] = int(np.round(r0[i, j]))\n\tarrs1 = np.sum(arr, 0)\n\tarrs2 = np.sum(arr, 1)\n\taff = np.fft.rfft(arr10)\n\taff2 = np.fft.rfft(arrs1)\n\tr0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n\tfor j in range(p2 - 1):\n\t\tret[CRT[0, POW2[j]]] = int(np.round(r0[j]))\n\taff = np.fft.rfft(arr20)\n\taff2 = np.fft.rfft(arrs2)\n\tr0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n\tfor i in range(p1 - 1):\n\t\tret[CRT[POW1[i], 0]] = int(np.round(r0[i]))\n\trr = 0\n\trrr = ret % MOD\n\tret = np.zeros(pp, dtype=np.int64)\n\tfor i in range(1, pp):\n\t\tret[i] = np.sum(rrr[i::i])\n\tret %= MOD\n\tret0 = ret * ret % MOD\n\tret1 = ret * ret0 % MOD\n\tret1 %= MOD\n\trval = np.sum(ret1 * MU) % MOD\n\tzpairs = (zeros * len(xx) * 2 - zeros * zeros) % MOD\n\tzpairs += int(np.sum(arr10)) % MOD * (int(np.sum(arr20)) % MOD) * 2\n\tzpairs %= MOD\n\tret0 = ret * ret % MOD\n\trval += np.sum(ret0 * MU) % MOD * zpairs * 3 % MOD\n\trval %= MOD\n\trval += rrr[1] % MOD * (zpairs * zpairs % MOD) * 3 % MOD\n\treturn rval % MOD\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n\tf.readline()\n\tx = np.array(list(map(int, f.readline().split())), dtype=np.int64)\n\tprint(getTotals(x))\n",
        "slowest_solution": "import sys\nimport numpy as np\np1 = 599\np2 = 601\npp = p1 * p2\nMOD = 10 ** 9 + 7\n\ndef getLogPows(p, root=7):\n\tv = 1\n\tret = np.zeros(p, dtype=np.int64)\n\tpw = np.zeros(p, dtype=np.int64)\n\tpw[0] = 1\n\tfor i in range(p - 1):\n\t\tret[v] = i\n\t\tv = v * root % p\n\t\tpw[i + 1] = v\n\treturn (ret, pw)\n(LOG1, POW1) = getLogPows(p1)\n(LOG2, POW2) = getLogPows(p2)\nCRT = np.zeros((p1, p2), dtype=np.int64)\nfor i in range(pp):\n\tCRT[i % p1, i % p2] = i\nprimes = np.ones(pp, dtype=np.int64)\nMU = np.ones(pp, dtype=np.int64)\nMU[0] = 0\nprimes[:2] = 0\nfor i in range(2, pp):\n\tif primes[i] == 1:\n\t\tprimes[2 * i::i] = 0\n\t\tMU[i::i] *= -1\n\t\tif i * i < len(MU):\n\t\t\tMU[i * i::i * i] = 0\n\ndef getLogArray(xx):\n\tarr = np.zeros((p1 - 1, p2 - 1))\n\tarr10 = np.zeros(p2 - 1)\n\tarr20 = np.zeros(p1 - 1)\n\tzeros = 0\n\tx1 = xx % p1\n\tx2 = xx % p2\n\tfor (x1, x2) in zip(xx % p1, xx % p2):\n\t\tif x1 == 0:\n\t\t\tif x2 == 0:\n\t\t\t\tzeros += 1\n\t\t\telse:\n\t\t\t\tarr10[LOG2[x2]] += 1\n\t\telif x2 == 0:\n\t\t\tarr20[LOG1[x1]] += 1\n\t\telse:\n\t\t\tarr[LOG1[x1], LOG2[x2]] += 1\n\treturn (arr, arr10, arr20, zeros)\n\ndef getTotals(xx):\n\tret = np.zeros(pp, dtype=np.int64)\n\t(arr, arr10, arr20, zeros) = getLogArray(xx)\n\taff = np.fft.rfft2(arr)\n\taff = aff * aff\n\tr0 = np.fft.irfft2(aff)\n\tfor i in range(p1 - 1):\n\t\tfor j in range(p2 - 1):\n\t\t\tret[CRT[POW1[i], POW2[j]]] = int(np.round(r0[i, j]))\n\tarrs1 = np.sum(arr, 0)\n\tarrs2 = np.sum(arr, 1)\n\taff = np.fft.rfft(arr10)\n\taff2 = np.fft.rfft(arrs1)\n\tr0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n\tfor j in range(p2 - 1):\n\t\tret[CRT[0, POW2[j]]] = int(np.round(r0[j]))\n\taff = np.fft.rfft(arr20)\n\taff2 = np.fft.rfft(arrs2)\n\tr0 = np.fft.irfft(aff * aff) + 2 * np.fft.irfft(aff * aff2)\n\tfor i in range(p1 - 1):\n\t\tret[CRT[POW1[i], 0]] = int(np.round(r0[i]))\n\trr = 0\n\trrr = ret % MOD\n\tret = np.zeros(pp, dtype=np.int64)\n\tfor i in range(1, pp):\n\t\tret[i] = np.sum(rrr[i::i])\n\tret %= MOD\n\tret0 = ret * ret % MOD\n\tret1 = ret * ret0 % MOD\n\tret1 %= MOD\n\trval = np.sum(ret1 * MU) % MOD\n\tzpairs = (zeros * len(xx) * 2 - zeros * zeros) % MOD\n\tzpairs += int(np.sum(arr10)) % MOD * (int(np.sum(arr20)) % MOD) * 2\n\tzpairs %= MOD\n\tret0 = ret * ret % MOD\n\trval += np.sum(ret0 * MU) % MOD * zpairs * 3 % MOD\n\trval %= MOD\n\trval += rrr[1] % MOD * (zpairs * zpairs % MOD) * 3 % MOD\n\treturn rval % MOD\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n\tf.readline()\n\tx = np.array(list(map(int, f.readline().split())), dtype=np.int64)\n\tprint(getTotals(x))\n"
    },
    {
        "task_id": 269,
        "slowest_solution_id": 9,
        "fastest_solution_id": 6,
        "slowest_time": 3.5693066120147705,
        "fastest_time": 2.549384593963623,
        "fastest_solution": "for i in range(int(input())):\n\tn = int(input())\n\tif n >= 111 * (n % 11):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "j = int(input())\nwhile j > 0:\n\ti = int(input())\n\tt = i % 11\n\tif 111 * t <= i:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n\tj = j - 1\n"
    },
    {
        "task_id": 316,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def sort_my_string(s):\n\treturn '{} {}'.format(s[::2], s[1::2])\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 288,
        "slowest_solution_id": 9,
        "fastest_solution_id": 2,
        "slowest_time": 4.644612073898315,
        "fastest_time": 2.520061731338501,
        "fastest_solution": "n = int(input())\narr = list(map(int, input().split()))\nx = max(arr)\nfor i in range(1, int(x ** 0.5) + 1):\n\tif x % i == 0:\n\t\tif x // i == i:\n\t\t\tarr.remove(i)\n\t\telse:\n\t\t\tarr.remove(i)\n\t\t\tarr.remove(x // i)\nprint(x, max(arr))\n",
        "slowest_solution": "n = int(input())\nd = list(map(int, input().split()))\nx = max(d)\nd_x = []\nfor (i, di) in enumerate(d):\n\tif x % di == 0 and di not in d_x:\n\t\td_x.append(di)\n\t\td[i] = -1\ny = max(d)\nprint(x, y)\n"
    },
    {
        "task_id": 276,
        "slowest_solution_id": 8,
        "fastest_solution_id": 7,
        "slowest_time": 3.904283046722412,
        "fastest_time": 2.4835715293884277,
        "fastest_solution": "t = int(input())\nfor j in range(0, t):\n\t(n, k) = map(int, input().split())\n\tx = []\n\ty = []\n\tfor i in range(0, n):\n\t\t(a, b) = (0, 0)\n\t\t(a, b) = map(int, input().split())\n\t\tx.append(a)\n\t\ty.append(b)\n\tfl = 0\n\tfor i in range(0, n):\n\t\tfl = -1\n\t\tfor g in range(0, n):\n\t\t\tif abs(x[i] - x[g]) + abs(y[i] - y[g]) <= k:\n\t\t\t\tfl = 0\n\t\t\telse:\n\t\t\t\tfl = -1\n\t\t\t\tbreak\n\t\tif fl == 0:\n\t\t\tbreak\n\tif fl == -1:\n\t\tprint(-1)\n\telse:\n\t\tprint(1)\n",
        "slowest_solution": "for _ in ' ' * int(input()):\n\t(n, k) = map(int, input().split())\n\tcnt = 0\n\tval = []\n\tfor i in range(n):\n\t\tval.append(list(map(int, input().split())))\n\tfor i in range(n):\n\t\tf = 0\n\t\tfor j in range(n):\n\t\t\tif i != j:\n\t\t\t\tif abs(val[i][0] - val[j][0]) + abs(val[i][1] - val[j][1]) > k:\n\t\t\t\t\tf = 1\n\t\t\t\t\tbreak\n\t\tif f == 0:\n\t\t\tcnt = 1\n\t\t\tbreak\n\tif cnt == 0:\n\t\tprint(-1)\n\telse:\n\t\tprint(1)\n"
    },
    {
        "task_id": 277,
        "slowest_solution_id": 8,
        "fastest_solution_id": 2,
        "slowest_time": 3.901120185852051,
        "fastest_time": 2.5418834686279297,
        "fastest_solution": "N = int(input())\npoints = []\nmp = [0, 0]\nfor i in range(N):\n\tpoints.append([int(j) for j in input().split()])\n\tmp[0] += points[i][0]\n\tmp[1] += points[i][1]\nmp[0] /= N\nmp[1] /= N\nminDist = 10 ** 17\nminDist2 = 10 ** 17\nfor i in range(N):\n\txDiff = abs(points[i][0] - mp[0])\n\tyDiff = abs(points[i][1] - mp[1])\n\tdist = xDiff + yDiff\n\tdist2 = max(xDiff, yDiff)\n\tif dist < minDist:\n\t\tminDist = dist\n\tif dist2 < minDist2:\n\t\tminDist2 = dist2\nminPos = []\nfor i in range(N):\n\txDiff = abs(points[i][0] - mp[0])\n\tyDiff = abs(points[i][1] - mp[1])\n\tdist = xDiff + yDiff\n\tdist2 = max(xDiff, yDiff)\n\tif dist == minDist:\n\t\tminPos.append(i)\n\telif dist2 == minDist2:\n\t\tminPos.append(i)\nsums = [0 for i in minPos]\nfor i in range(len(minPos)):\n\tfor j in range(N):\n\t\tif minPos[i] == j:\n\t\t\tcontinue\n\t\txDiff = abs(points[minPos[i]][0] - points[j][0])\n\t\tyDiff = abs(points[minPos[i]][1] - points[j][1])\n\t\tsums[i] += max(xDiff, yDiff)\nsums.sort()\nprint(sums[0])\n",
        "slowest_solution": "import sys\nsource = sys.stdin\n\ndef commute(H, m):\n\ttotal = 0\n\t(xm, ym) = m\n\tfor (x, y) in H:\n\t\ttotal += max(abs(x - xm), abs(y - ym))\n\treturn total\nH = []\nN = int(source.readline())\nfor _ in range(N):\n\t(x, y) = tuple([int(s) for s in source.readline().split()])\n\tH.append((x, y))\nH_prime = [(x + y, x - y) for (x, y) in H]\nA = sorted([a for (a, b) in H_prime])\nB = sorted([b for (a, b) in H_prime])\nstart_a = A[0] - 1\nif start_a % 2 != 0:\n\tstart_a -= 1\nstart_b = B[0] - 1\nif start_b % 2 != 0:\n\tstart_b -= 1\nF_a = {}\nG_a = {}\nF_a[start_a] = 0\nG_a[start_a] = 0\nlast_element = start_a\nfor a in A:\n\tif a != last_element:\n\t\tF_a[a] = F_a[last_element] + 1\n\t\tG_a[a] = G_a[last_element] + F_a[last_element] * (a - last_element)\n\telse:\n\t\tF_a[a] += 1\n\tlast_element = a\nF_b = {}\nG_b = {}\nF_b[start_b] = 0\nG_b[start_b] = 0\nlast_element = start_b\nfor b in B:\n\tif b != last_element:\n\t\tF_b[b] = F_b[last_element] + 1\n\t\tG_b[b] = G_b[last_element] + F_b[last_element] * (b - last_element)\n\telse:\n\t\tF_b[b] += 1\n\tlast_element = b\nmin_change_black = 0\nbest_house_black = -1\nfor i in range(len(H_prime)):\n\t(a, b) = H_prime[i]\n\tif a % 2 == 0:\n\t\tchange = G_a[a] + G_b[b]\n\t\tchange -= ((a - start_a) // 2 + (b - start_b) // 2) * N\n\t\tif change < min_change_black:\n\t\t\tmin_change_black = change\n\t\t\tbest_house_black = i\nstart_x = (start_a + start_b) // 2\nstart_y = (start_a - start_b) // 2\nstart_commute = commute(H, (start_x, start_y))\nbest_commute_black = start_commute + min_change_black\nstart_a += 1\nstart_b += 1\nmin_change_white = 0\nbest_house_white = -1\nfor i in range(len(H_prime)):\n\t(a, b) = H_prime[i]\n\tif a % 2 != 0:\n\t\tchange = G_a[a] + G_b[b]\n\t\tchange -= ((a - start_a) // 2 + (b - start_b) // 2) * N\n\t\tif change < min_change_white:\n\t\t\tmin_change_white = change\n\t\t\tbest_house_white = i\nstart_x = (start_a + start_b) // 2\nstart_y = (start_a - start_b) // 2\nstart_commute = commute(H, (start_x, start_y))\nbest_commute_white = start_commute + min_change_white\nans = min(best_commute_black, best_commute_white)\nprint(ans)\n"
    },
    {
        "task_id": 285,
        "slowest_solution_id": 8,
        "fastest_solution_id": 1,
        "slowest_time": 4.041889429092407,
        "fastest_time": 2.5229620933532715,
        "fastest_solution": "from collections import deque\nimport sys\n\ndef kek():\n\tn = int(input())\n\tgraph = []\n\tfor i in range(26):\n\t\tgraph.append([False] * 28)\n\t\tgraph[i][-1] = 0\n\tfor i in range(n):\n\t\ts = sys.stdin.readline()\n\t\tfor i in range(len(s) - 1):\n\t\t\tgraph[ord(s[i]) - 97][-1] += 1\n\t\t\tfor j in range(len(s) - 1):\n\t\t\t\tgraph[ord(s[i]) - 97][ord(s[j]) - 97] = True\n\tused = [0] * 26\n\tans = 0\n\twhile True:\n\t\tqueue = deque()\n\t\tfor i in range(len(graph)):\n\t\t\tif graph[i][-1] != 0 and used[i] == 0:\n\t\t\t\tqueue.append(i)\n\t\t\t\tans += 1\n\t\t\t\tused[i] = 1\n\t\t\t\tbreak\n\t\tif not len(queue):\n\t\t\tprint(ans)\n\t\t\tbreak\n\t\twhile len(queue):\n\t\t\tpos = queue.pop()\n\t\t\tfor i in range(len(graph[pos]) - 1):\n\t\t\t\tif graph[pos][i] == True and used[i] == 0:\n\t\t\t\t\tused[i] = 1\n\t\t\t\t\tqueue.append(i)\nkek()\n",
        "slowest_solution": "n = int(input())\ngraph = {}\nfor i in range(n):\n\ts = input()\n\tbase = set([c for c in s])\n\tfor c in s:\n\t\tgraph.setdefault(c, set()).update(base)\nvisited = set()\n\ndef dfs(i):\n\tvisited.add(i)\n\tfor j in graph[i]:\n\t\tif j not in visited:\n\t\t\tdfs(j)\ncount = 0\nfor j in graph:\n\tif j not in visited:\n\t\tcount += 1\n\t\tdfs(j)\nprint(count)\n"
    },
    {
        "task_id": 303,
        "slowest_solution_id": 3,
        "fastest_solution_id": 2,
        "slowest_time": 4.401333570480347,
        "fastest_time": 2.582526922225952,
        "fastest_solution": "(n, m) = map(int, input().split())\ng = [[] for _ in range(n)]\nfor i in range(m):\n\t(p, q) = map(int, input().split())\n\tg[p - 1].append(q - 1)\n\tg[q - 1].append(p - 1)\ncomp = [-1] * n\n\ndef shortest(root):\n\tdist = [-1] * n\n\tq = [0] * n\n\t(left, right) = (0, 1)\n\tq[left] = root\n\tdist[root] = 0\n\tgood = True\n\twhile left < right:\n\t\tx = q[left]\n\t\tleft = left + 1\n\t\tfor i in g[x]:\n\t\t\tif dist[i] is -1:\n\t\t\t\tdist[i] = 1 + dist[x]\n\t\t\t\tq[right] = i\n\t\t\t\tright = right + 1\n\t\t\telif dist[i] == dist[x]:\n\t\t\t\tgood = False\n\tfar = 0\n\tfor i in dist:\n\t\tif i > far:\n\t\t\tfar = i\n\treturn (good, far, dist)\narr = [0] * n\ngood = True\nfor i in range(n):\n\t(_, opt, dist) = shortest(i)\n\tif _ is False:\n\t\tgood = False\n\tif comp[i] is -1:\n\t\tfor j in range(n):\n\t\t\tif dist[j] is not -1:\n\t\t\t\tcomp[j] = i\n\tif arr[comp[i]] < opt:\n\t\tarr[comp[i]] = opt\nif good is False:\n\tprint('-1')\nelse:\n\tprint(sum(arr))\n",
        "slowest_solution": "from collections import deque\n\ndef solve():\n\t(n, m) = input().split()\n\tn = int(n)\n\tm = int(m)\n\tglobal maxValue\n\tmaxValue = n * 2\n\tgraph = [[] for _ in range(0, n)]\n\tedges = []\n\tdiameters = []\n\tfor _ in range(0, m):\n\t\t(u, v) = input().split()\n\t\tu = int(u) - 1\n\t\tv = int(v) - 1\n\t\tedges.append(v)\n\t\tgraph[u].append(v)\n\t\tgraph[v].append(u)\n\tdistance = [maxValue] * n\n\tcc = [maxValue] * n\n\tfor i in range(0, n):\n\t\tif distance[i] == maxValue:\n\t\t\tcc = bfs_2k(graph, i, distance)\n\t\t\tif cc == None:\n\t\t\t\tprint(-1)\n\t\t\t\treturn\n\t\t\tdiameters.append(distance[cc[-1]])\n\t\t\tfor v in range(1, len(cc)):\n\t\t\t\tnewDistance = [maxValue] * n\n\t\t\t\tsamecc = bfs_2k(graph, cc[v], newDistance)\n\t\t\t\tdiameters[-1] = max(diameters[-1], newDistance[samecc[-1]])\n\tprint(sum(diameters))\n\ndef bfs_2k(graph, initVertex, dist):\n\tqueue = []\n\tqlen = 1\n\tqueue.append(initVertex)\n\tdist[initVertex] = 0\n\tu = None\n\ti = 0\n\twhile qlen:\n\t\tu = queue[i]\n\t\tqlen -= 1\n\t\tfor v in graph[u]:\n\t\t\tif dist[v] == maxValue:\n\t\t\t\tdist[v] = dist[u] + 1\n\t\t\t\tqueue.append(v)\n\t\t\t\tqlen += 1\n\t\t\tif (dist[u] - dist[v]) % 2 == 0:\n\t\t\t\treturn None\n\t\ti += 1\n\treturn queue\nsolve()\n"
    },
    {
        "task_id": 278,
        "slowest_solution_id": 8,
        "fastest_solution_id": 7,
        "slowest_time": 4.432929039001465,
        "fastest_time": 2.342700242996216,
        "fastest_solution": "n = int(input())\nfor i in range(n):\n\tk = int(input())\n\trp = list(map(int, input().split()))\n\thp = list(map(int, input().split()))\n\tradlev = [0] * k\n\tj = 0\n\tfor i in range(k):\n\t\tj = i - rp[i]\n\t\tl = max(0, j)\n\t\tr = i + 1 + rp[i]\n\t\tradlev[l] += 1\n\t\tif r < k:\n\t\t\tradlev[r] -= 1\n\tfor i in range(1, k):\n\t\tradlev[i] += radlev[i - 1]\n\tradlev.sort()\n\thp.sort()\n\tif radlev == hp:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "t = int(input())\nwhile t:\n\tt -= 1\n\tx = int(input())\n\tpwr = list(map(int, input().split()))\n\thlth = list(map(int, input().split()))\n\thsum = sum(hlth)\n\tnsum = 0\n\tfor i in range(x):\n\t\tl = i - pwr[i]\n\t\tif l <= 0:\n\t\t\tl = 0\n\t\tr = i + pwr[i]\n\t\tif r >= x:\n\t\t\tr = x - 1\n\t\tnsum += r - l + 1\n\tif nsum == hsum:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 286,
        "slowest_solution_id": 8,
        "fastest_solution_id": 6,
        "slowest_time": 3.5643155574798584,
        "fastest_time": 2.573493003845215,
        "fastest_solution": "n = int(input())\nvis = []\nfor i in range(5):\n\tvis.append(0)\nfor i in range(n):\n\t(a, b) = map(int, input().split())\n\tvis[a - 1] += 1\n\tvis[b - 1] += 1\ncount = 0\nif vis != [2, 2, 2, 2, 2]:\n\tprint('WIN')\nelse:\n\tprint('FAIL')\n",
        "slowest_solution": "def f(p):\n\tfor a in range(1, 6):\n\t\tfor b in range(a + 1, 6):\n\t\t\tt = b in p[a]\n\t\t\tfor c in range(b + 1, 6):\n\t\t\t\tif t == (c in p[a]) == (c in p[b]):\n\t\t\t\t\treturn 'WIN'\n\treturn 'FAIL'\nn = int(input())\np = [[] for i in range(6)]\nfor i in range(n):\n\t(a, b) = map(int, input().split())\n\tif a > b:\n\t\tp[b].append(a)\n\telse:\n\t\tp[a].append(b)\nprint(f(p))\n"
    },
    {
        "task_id": 296,
        "slowest_solution_id": 7,
        "fastest_solution_id": 0,
        "slowest_time": 3.6495790481567383,
        "fastest_time": 2.628326416015625,
        "fastest_solution": "import sys\nreadline = sys.stdin.buffer.readline\n(N, M) = map(int, readline().split())\nEdge = [[] for _ in range(N)]\nfor _ in range(M):\n\t(a, b) = map(int, readline().split())\n\ta -= 1\n\tb -= 1\n\tEdge[a].append(b)\n\tEdge[b].append(a)\ntopic = list(map(int, readline().split()))\nmaxi = [0] * N\nL = list(range(N))\nL.sort(key=lambda x: topic[x])\nans = ' '.join(map(str, [l + 1 for l in L]))\nfor l in L:\n\tt = maxi[l] + 1\n\tif t != topic[l]:\n\t\tans = -1\n\t\tbreak\n\tfor vf in Edge[l]:\n\t\tif maxi[vf] == t - 1:\n\t\t\tmaxi[vf] = t\nprint(ans)\n",
        "slowest_solution": "import sys\nr = sys.stdin.buffer.readline\n(n, m) = map(int, r().split())\nnetwork = [[] for _ in range(n)]\nfor _ in range(m):\n\t(a, b) = map(int, r().split())\n\tnetwork[a - 1].append(b - 1)\n\tnetwork[b - 1].append(a - 1)\nlst = list(map(int, r().split()))\narr = list(range(n))\narr.sort(key=lambda x: lst[x])\nret = [1] * n\nres = []\nfor i in arr:\n\tt = lst[i]\n\tif t == ret[i]:\n\t\tfor j in network[i]:\n\t\t\tif ret[j] == t:\n\t\t\t\tret[j] += 1\n\t\tres.append(i + 1)\n\telse:\n\t\tprint(-1)\n\t\texit(0)\nprint(*res)\n"
    },
    {
        "task_id": 274,
        "slowest_solution_id": 5,
        "fastest_solution_id": 2,
        "slowest_time": 4.573110342025757,
        "fastest_time": 2.5176777839660645,
        "fastest_solution": "def f(M, N):\n\ta = min(M, N)\n\tb = abs(M - N) + 1\n\tproduct = 1\n\tfactorial = 1\n\tfor i in range(1, a):\n\t\tfactorial *= i\n\t\tfactorial %= 10 ** 9 + 7\n\t\tproduct *= factorial\n\t\tproduct %= 10 ** 9 + 7\n\tproduct = pow(product, 2, 10 ** 9 + 7)\n\tfactorial *= a\n\tproduct *= pow(factorial, b, 10 ** 9 + 7)\n\treturn product % (10 ** 9 + 7)\n(M, N) = map(int, input().split())\nprint(f(M, N))\n",
        "slowest_solution": "b = 1000000007\nfacts = {0: 1, 1: 1}\nfor i in range(2, 2 * 10 ** 6 + 1):\n\tfacts[i] = i * facts[i - 1] % b\n(N, M) = list(map(int, input().strip().split()))\ncounts = 1\nif N == M == 1:\n\tprint(1)\nelif N == 1 or M == 1:\n\tprint(1)\nelse:\n\tif (N + M - 1) % 2 == 0:\n\t\tfor i in range((N + M - 1) // 2):\n\t\t\tj = min(i + 1, min(N, M))\n\t\t\tcounts = counts % b * (facts[j] % b) % b\n\t\t\tcounts = counts % b * (facts[j] % b) % b\n\telse:\n\t\tfor i in range((N + M - 1) // 2):\n\t\t\tj = min(i + 1, min(N, M))\n\t\t\tcounts = counts % b * (facts[j] % b) % b\n\t\t\tcounts = counts % b * (facts[j] % b) % b\n\t\tif N == M:\n\t\t\tcounts = counts % b * (facts[j + 1] % b) % b\n\t\telse:\n\t\t\tcounts = counts % b * (facts[j] % b) % b\n\tprint(counts)\n"
    },
    {
        "task_id": 310,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 4.206798315048218,
        "fastest_time": 2.5754482746124268,
        "fastest_solution": "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\nt = int(input())\nfor i in range(t):\n\tn , l = [int(x) for x in input().split()]\n\tarr = []\n\tfor i in range(n):\n\t\tarr.append( [int(x) for x in input().split()] )\n\t#arr.sort()\n\tflag = 0\n\tfor i in range(n):\n\t\tright = arr[i][0] + l\n\t\tcur = arr[i][1] \n\t\tfor j in range(n):\n\t\t\tif arr[j][0] <= cur and arr[j][0] > arr[i][0] and arr[j][1] <= right:\n\t\t\t\tcur = max(cur , arr[j][1])\n\t\tif cur == right:\n\t\t\tflag = 1\n\t\t\tbreak\n\tif flag:\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")\n\t\t\t\t\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\tn , l = [int(x) for x in input().split()]\n\tarr = []\n\tfor i in range(n):\n\t\tarr.append( [int(x) for x in input().split()] )\n\t#arr.sort()\n\tflag = 0\n\tfor i in range(n):\n\t\tright = arr[i][0] + l\n\t\tcur = arr[i][1] \n\t\tfor j in range(n):\n\t\t\tif arr[j][0] <= cur and arr[j][0] > arr[i][0] and arr[j][1] <= right:\n\t\t\t\tcur = max(cur , arr[j][1])\n\t\tif cur == right:\n\t\t\tflag = 1\n\t\t\tbreak\n\tif flag:\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")\n\t\t\t\t\n"
    },
    {
        "task_id": 282,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 3.73543381690979,
        "fastest_time": 2.6061062812805176,
        "fastest_solution": "def comb(n, k, MOD):\n\tif k > n // 2:\n\t\tk = n - k\n\tanswer = 1\n\tfor i in range(k):\n\t\tanswer *= n - i\n\t\tanswer //= i + 1\n\treturn answer % MOD\n\ndef putin():\n\treturn map(int, input().split())\n\ndef sol():\n\tn = int(input())\n\tA = list(input())\n\tnum_zeros = 0\n\tnum_pairs = 0\n\tfirst = 0\n\tfor i in range(n):\n\t\tif A[i] == '0':\n\t\t\tfirst = 0\n\t\t\tnum_zeros += 1\n\t\telif first == 0:\n\t\t\tfirst = 1\n\t\telse:\n\t\t\tnum_pairs += 1\n\t\t\tfirst = 0\n\tprint(comb(num_zeros + num_pairs, num_zeros, 998244353))\nfor itr in range(int(input())):\n\tsol()\n",
        "slowest_solution": "def powerMod(a, b, MOD):\n\tif b == 0:\n\t\treturn 1\n\tc = powerMod(a, b // 2, MOD)\n\tc_squared = c * c % MOD\n\tif b % 2 == 1:\n\t\treturn c_squared * a % MOD\n\telse:\n\t\treturn c_squared\nt = int(input())\nMOD = 998244353\nfor d in range(t):\n\tn = int(input())\n\ts = input()\n\ti = 0\n\tzeroes = 0\n\tpairs_of_ones = 0\n\twhile i < n:\n\t\tif s[i] == '0':\n\t\t\tzeroes += 1\n\t\t\ti += 1\n\t\telif i + 1 < n and s[i + 1] == '1':\n\t\t\tpairs_of_ones += 1\n\t\t\ti += 2\n\t\telse:\n\t\t\ti += 1\n\tresult = 1\n\tfor j in range(zeroes + 1, zeroes + pairs_of_ones + 1):\n\t\tresult = result * j % MOD\n\tfor j in range(2, pairs_of_ones + 1):\n\t\tresult = result * powerMod(j, MOD - 2, MOD) % MOD\n\tprint(result)\n"
    },
    {
        "task_id": 284,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 4.031513214111328,
        "fastest_time": 2.4993948936462402,
        "fastest_solution": "class Element:\n\n\tdef __init__(self, data, next):\n\t\tself.data = data\n\t\tself.next = next\n\nclass Queue:\n\n\tdef __init__(self):\n\t\tself.head = None\n\n\tdef __str__(self):\n\t\tptr = self.head\n\t\tif self.head == None:\n\t\t\tstring = 'Front < > Back'\n\t\telse:\n\t\t\tstring = 'Front < '\n\t\t\twhile ptr:\n\t\t\t\tstring += '%s ' % str(ptr.data)\n\t\t\t\tptr = ptr.next\n\t\t\tstring += '> Back'\n\t\treturn string\n\n\tdef enQueue(self, data):\n\t\tptr = self.head\n\t\tif ptr == None:\n\t\t\tself.head = Element(data, self.head)\n\t\telse:\n\t\t\twhile ptr.next:\n\t\t\t\tptr = ptr.next\n\t\t\tptr.next = Element(data, None)\n\n\tdef deQueue(self):\n\t\tif self.head == None:\n\t\t\treturn None\n\t\tptr = self.head\n\t\tself.head = self.head.next\n\t\tptr.next = None\n\t\treturn ptr.data\n\ndef findEnd(table):\n\tfor (ri, row) in enumerate(table):\n\t\tfor (ci, column) in enumerate(row):\n\t\t\tif column[0] == '*':\n\t\t\t\treturn (ri, ci)\n\treturn None\n\ndef traverseTable(table, startX, startY, K, N, M):\n\t(x, y) = (startX, startY)\n\tqueue = Queue()\n\tfollowUp = Queue()\n\tqueue.enQueue((x, y))\n\tfirst = queue.deQueue()\n\twhile first:\n\t\tfollowUp.enQueue(first)\n\t\tx = first[0]\n\t\ty = first[1]\n\t\tif x - 1 >= 0 and table[y][x - 1][1] == None:\n\t\t\t(table[y][x - 1][1], table[y][x - 1][2]) = computeCount(table, x - 1, y, K, N, M)\n\t\t\tqueue.enQueue((x - 1, y))\n\t\tif y - 1 >= 0 and table[y - 1][x][1] == None:\n\t\t\t(table[y - 1][x][1], table[y - 1][x][2]) = computeCount(table, x, y - 1, K, N, M)\n\t\t\tqueue.enQueue((x, y - 1))\n\t\tif x + 1 < M and table[y][x + 1][1] == None:\n\t\t\t(table[y][x + 1][1], table[y][x + 1][2]) = computeCount(table, x + 1, y, K, N, M)\n\t\t\tqueue.enQueue((x + 1, y))\n\t\tif y + 1 < N and table[y + 1][x][1] == None:\n\t\t\t(table[y + 1][x][1], table[y + 1][x][2]) = computeCount(table, x, y + 1, K, N, M)\n\t\t\tqueue.enQueue((x, y + 1))\n\t\tfirst = queue.deQueue()\n\tsecond = followUp.deQueue()\n\twhile second:\n\t\tx = second[0]\n\t\ty = second[1]\n\t\t(table[y][x][1], table[y][x][2], changed) = searchNearby(table, x, y, table[y][x][1], table[y][x][2], K, N, M, followUp)\n\t\tif changed:\n\t\t\tif x - 1 >= 0:\n\t\t\t\tif checkNearby(table, x, y, x - 1, y, K):\n\t\t\t\t\tfollowUp.enQueue((x - 1, y))\n\t\t\tif y - 1 >= 0:\n\t\t\t\tif checkNearby(table, x, y, x, y - 1, K):\n\t\t\t\t\tfollowUp.enQueue((x, y - 1))\n\t\t\tif x + 1 < M:\n\t\t\t\tif checkNearby(table, x, y, x + 1, y, K):\n\t\t\t\t\tfollowUp.enQueue((x + 1, y))\n\t\t\tif y + 1 < N:\n\t\t\t\tif checkNearby(table, x, y, x, y + 1, K):\n\t\t\t\t\tfollowUp.enQueue((x, y + 1))\n\t\tsecond = followUp.deQueue()\n\tif table[0][0][1] == float('inf'):\n\t\treturn -1\n\telse:\n\t\treturn table[0][0][2]\n\ndef computeCount(table, startX, startY, K, N, M):\n\t(x, y) = (startX, startY)\n\tptr = table[y][x]\n\tif ptr[0] == 'U':\n\t\ty -= 1\n\telif ptr[0] == 'D':\n\t\ty += 1\n\telif ptr[0] == 'L':\n\t\tx -= 1\n\telif ptr[0] == 'R':\n\t\tx += 1\n\tif x < 0 or x >= M or y < 0 or (y >= N):\n\t\treturn (float('inf'), 0)\n\telse:\n\t\tif table[y][x][1] == None:\n\t\t\tdist = float('inf')\n\t\telse:\n\t\t\tdist = table[y][x][1] + 1\n\t\tcount = table[y][x][2]\n\t\tif dist > K:\n\t\t\t(dist, count, changed) = searchNearby(table, startX, startY, dist, count, K, N, M)\n\t\treturn (dist, count)\n\ndef searchNearby(table, x, y, dist, count, K, N, M, queue=None):\n\tptr = table[y][x]\n\tbest = count\n\tprevCount = count\n\tprevDist = dist\n\tprevDir = table[y][x][0]\n\tif y + 1 < N:\n\t\tif table[y + 1][x][1] != None and table[y + 1][x][1] + 1 <= K and (table[y + 1][x][2] < best or dist == float('inf')):\n\t\t\tdist = table[y + 1][x][1] + 1\n\t\t\tif table[y][x][3] == 'D':\n\t\t\t\tbest = table[y + 1][x][2]\n\t\t\telse:\n\t\t\t\tbest = table[y + 1][x][2] + 1\n\t\t\tif table[y][x][0] != 'D':\n\t\t\t\ttable[y][x][0] = 'D'\n\tif x + 1 < M:\n\t\tif table[y][x + 1][1] != None and table[y][x + 1][1] + 1 <= K and (table[y][x + 1][2] < best or dist == float('inf')):\n\t\t\tdist = table[y][x + 1][1] + 1\n\t\t\tif table[y][x][3] == 'R':\n\t\t\t\tbest = table[y][x + 1][2]\n\t\t\telse:\n\t\t\t\tbest = table[y][x + 1][2] + 1\n\t\t\tif table[y][x][0] != 'R':\n\t\t\t\ttable[y][x][0] = 'R'\n\tif y - 1 >= 0:\n\t\tif table[y - 1][x][1] != None and table[y - 1][x][1] + 1 <= K and (table[y - 1][x][2] < best or dist == float('inf')):\n\t\t\tdist = table[y - 1][x][1] + 1\n\t\t\tif table[y][x][3] == 'U':\n\t\t\t\tbest = table[y - 1][x][2]\n\t\t\telse:\n\t\t\t\tbest = table[y - 1][x][2] + 1\n\t\t\tif table[y][x][0] != 'U':\n\t\t\t\ttable[y][x][0] = 'U'\n\tif x - 1 >= 0:\n\t\tif table[y][x - 1][1] != None and table[y][x - 1][1] + 1 <= K and (table[y][x - 1][2] < best or dist == float('inf')):\n\t\t\tdist = table[y][x - 1][1] + 1\n\t\t\tif table[y][x][3] == 'L':\n\t\t\t\tbest = table[y][x - 1][2]\n\t\t\telse:\n\t\t\t\tbest = table[y][x - 1][2] + 1\n\t\t\tif table[y][x][0] != 'L':\n\t\t\t\ttable[y][x][0] = 'L'\n\tif prevCount == best and prevDist == dist and (prevDir == table[y][x][0]):\n\t\tchanged = False\n\telse:\n\t\tchanged = True\n\tif dist > K:\n\t\treturn (float('inf'), 0, changed)\n\telse:\n\t\treturn (dist, best, changed)\n\ndef checkNearby(table, x1, y1, x2, y2, K):\n\tif table[y1][x1][1] == K:\n\t\treturn False\n\tif table[y1][x1][2] < table[y2][x2][2] or table[y2][x2][1] == float('inf'):\n\t\treturn True\n\telse:\n\t\treturn False\nNMK = input().strip()\nN = int(NMK.split(' ')[0])\nM = int(NMK.split(' ')[1])\nK = int(NMK.split(' ')[2])\ntable = []\nfor row in range(N):\n\ttable.append([])\n\tfor char in input().strip():\n\t\ttable[row].append([char, None, 0, char])\nendpt = findEnd(table)\ntable[endpt[0]][endpt[1]][1] = 0\nprint(traverseTable(table, endpt[1], endpt[0], K, N, M))\n",
        "slowest_solution": "import sys\nimport collections\n\ndef dist(p1, p2):\n\treturn abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n[n, m, k] = [int(X) for X in sys.stdin.readline().split()]\ntable = dict()\nfor i in range(1, n + 1):\n\tfor (j, letter) in enumerate(sys.stdin.readline().strip()):\n\t\tif letter == '*':\n\t\t\tgoal = (i, j + 1)\n\t\ttable[i, j + 1] = letter\ncache = collections.defaultdict(lambda : 105)\n\ndef dist(p):\n\treturn abs(p[0] - goal[0]) + abs(p[1] - goal[1])\n\ndef solve(position, t, num_changes):\n\tcache[position] = num_changes\n\tletter = table[position]\n\tif position == goal:\n\t\treturn num_changes\n\telse:\n\t\ti = position[0]\n\t\tj = position[1]\n\t\tsolutions = list()\n\t\tif i > 1 and cache[i - 1, j] > num_changes + (letter != 'U') and (dist((i - 1, j)) < k - t):\n\t\t\tsolutions.append(solve((i - 1, j), t + 1, num_changes + (letter != 'U')))\n\t\tif j < m and cache[i, j + 1] > num_changes + (letter != 'R') and (dist((i, j + 1)) < k - t):\n\t\t\tsolutions.append(solve((i, j + 1), t + 1, num_changes + (letter != 'R')))\n\t\tif i < n and cache[i + 1, j] > num_changes + (letter != 'D') and (dist((i + 1, j)) < k - t):\n\t\t\tsolutions.append(solve((i + 1, j), t + 1, num_changes + (letter != 'D')))\n\t\tif j > 1 and cache[i, j - 1] > num_changes + (letter != 'L') and (dist((i, j - 1)) < k - t):\n\t\t\tsolutions.append(solve((i, j - 1), t + 1, num_changes + (letter != 'L')))\n\t\ttry:\n\t\t\treturn min([solution for solution in solutions if solution is not None])\n\t\texcept ValueError:\n\t\t\treturn None\nsolution = solve((1, 1), 0, 0)\nprint(solution if solution is not None else -1)\n"
    },
    {
        "task_id": 279,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 4.142315149307251,
        "fastest_time": 2.6211025714874268,
        "fastest_solution": "l = []\nfor i in range(1, 10 ** 5):\n\tl.append(i * (i + 1) // 2)\ni = 0\nf = 0\nn = int(input())\nj = 10 ** 5 - 5\nwhile i <= j:\n\tif l[i] + l[j] == n:\n\t\tf = 1\n\t\tbreak\n\telif l[i] + l[j] < n:\n\t\ti += 1\n\telse:\n\t\tj -= 1\nif f == 0:\n\tprint('NO')\nelse:\n\tprint('YES')\n",
        "slowest_solution": "import math\nn = int(input())\nflag = False\nx = int(math.sqrt(2 * n))\nflag = False\nfor i in range(1, x + 1):\n\ta = 2 * n - i * (i + 1)\n\tif a > 0:\n\t\tb = math.sqrt(1 + 4 * a)\n\t\tif (b - 1) / 2 == int((b - 1) / 2):\n\t\t\tflag = True\n\t\t\tprint('YES')\n\tif flag == True:\n\t\tbreak\nif flag == False:\n\tprint('NO')\n"
    },
    {
        "task_id": 314,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 3.7634763717651367,
        "fastest_time": 2.8928356170654297,
        "fastest_solution": "from math import gcd\nfor _ in [*open(0)][2::2]:\n\ta = (*map(int, _.split()),)\n\tn = len(a)\n\ts = []\n\tf = [*range(1, n)] + [0]\n\tq = [(i, f[i]) for i in range(n) if gcd(a[i], a[f[i]]) < 2]\n\twhile len(q) != 0:\n\t\t(x, y) = q[0]\n\t\tq.pop(0)\n\t\tif f[x] == y:\n\t\t\ts.append(y + 1)\n\t\t\tf[x] = f[y]\n\t\t\tf[y] = -1\n\t\t\tif f[x] < 0 or x < 0:\n\t\t\t\tcontinue\n\t\t\tif gcd(a[x], a[f[x]]) < 2:\n\t\t\t\tq.append((x, f[x]))\n\tprint(len(s), *s)\n",
        "slowest_solution": "t = int(input())\n\ndef euclidean(a, b):\n\t(a, b) = (max(a, b), min(a, b))\n\twhile b:\n\t\t(a, b) = (b, a % b)\n\treturn a\n\ndef main():\n\tn = int(input())\n\tl = [int(s) for s in input().split()]\n\tl_next = list(range(1, n)) + [0]\n\tl_forw = list(range(1, n)) + [0]\n\tprev = n - 1\n\ti = 0\n\tres = []\n\twhile True:\n\t\tif l_forw[i] == i:\n\t\t\tif l[i] == 1:\n\t\t\t\tres.append(i + 1)\n\t\t\tbreak\n\t\tif euclidean(l[i], l[l_forw[i]]) == 1:\n\t\t\tif l_forw[i] == l_next[i]:\n\t\t\t\tl_next[i] = l_next[l_next[i]]\n\t\t\tres.append(l_forw[i] + 1)\n\t\t\tl_forw[i] = l_forw[l_forw[i]]\n\t\t\tprev = i\n\t\telse:\n\t\t\tif prev == i:\n\t\t\t\tbreak\n\t\t\tl_next[prev] = l_next[i]\n\t\ti = l_next[prev]\n\tres = [len(res)] + res\n\tprint(' '.join([str(r) for r in res]))\nfor _ in range(t):\n\tmain()\n"
    },
    {
        "task_id": 325,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.629927635192871,
        "fastest_time": 2.629927635192871,
        "fastest_solution": "import os, sys\nfrom io import BytesIO, IOBase\n\ndef matching(n, m, path):\n\tmatch1 = [-1] * n\n\tmatch2 = [-1] * m\n\tfor node in range(n):\n\t\tfor nei in path[node]:\n\t\t\tif match2[nei] == -1:\n\t\t\t\tmatch1[node] = nei\n\t\t\t\tmatch2[nei] = node\n\t\t\t\tbreak\n\twhile 1:\n\t\tbfs = [node for node in range(n) if match1[node] == -1]\n\t\tdepth = [-1] * n\n\t\tfor node in bfs:\n\t\t\tdepth[node] = 0\n\t\tfor node in bfs:\n\t\t\tfor nei in path[node]:\n\t\t\t\tnext_node = match2[nei]\n\t\t\t\tif next_node == -1:\n\t\t\t\t\tbreak\n\t\t\t\tif depth[next_node] == -1:\n\t\t\t\t\tdepth[next_node] = depth[node] + 1\n\t\t\t\t\tbfs.append(next_node)\n\t\t\telse:\n\t\t\t\tcontinue\n\t\t\tbreak\n\t\telse:\n\t\t\tbreak\n\t\tpointer = [len(c) for c in path]\n\t\tdfs = [node for node in range(n) if depth[node] == 0]\n\t\twhile dfs:\n\t\t\tnode = dfs[-1]\n\t\t\twhile pointer[node]:\n\t\t\t\tpointer[node] -= 1\n\t\t\t\tnei = path[node][pointer[node]]\n\t\t\t\tnext_node = match2[nei]\n\t\t\t\tif next_node == -1:\n\t\t\t\t\twhile nei != -1:\n\t\t\t\t\t\tnode = dfs.pop()\n\t\t\t\t\t\t(match2[nei], match1[node], nei) = (node, nei, match1[node])\n\t\t\t\t\tbreak\n\t\t\t\telif depth[node] + 1 == depth[next_node]:\n\t\t\t\t\tdfs.append(next_node)\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tdfs.pop()\n\treturn n - match1.count(-1)\n\ndef main():\n\t(n, m) = map(int, input().split())\n\tedg = [tuple(map(lambda xx: int(xx) - 1, input().split())) for _ in range(m)]\n\tans = float('inf')\n\tfor centre in range(n):\n\t\tpath = [[] for _ in range(n)]\n\t\tcost = 2 * n - 1\n\t\textra = m\n\t\tfor (u, v) in edg:\n\t\t\tif u == centre or v == centre:\n\t\t\t\tcost -= 1\n\t\t\t\textra -= 1\n\t\t\telse:\n\t\t\t\tpath[u].append(v)\n\t\tmaxMatch = matching(n, n, path)\n\t\textra -= maxMatch\n\t\tcost += n - 1 - maxMatch + extra\n\t\tans = min(ans, cost)\n\tprint(ans)\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n",
        "slowest_solution": "import os, sys\nfrom io import BytesIO, IOBase\n\ndef matching(n, m, path):\n\tmatch1 = [-1] * n\n\tmatch2 = [-1] * m\n\tfor node in range(n):\n\t\tfor nei in path[node]:\n\t\t\tif match2[nei] == -1:\n\t\t\t\tmatch1[node] = nei\n\t\t\t\tmatch2[nei] = node\n\t\t\t\tbreak\n\twhile 1:\n\t\tbfs = [node for node in range(n) if match1[node] == -1]\n\t\tdepth = [-1] * n\n\t\tfor node in bfs:\n\t\t\tdepth[node] = 0\n\t\tfor node in bfs:\n\t\t\tfor nei in path[node]:\n\t\t\t\tnext_node = match2[nei]\n\t\t\t\tif next_node == -1:\n\t\t\t\t\tbreak\n\t\t\t\tif depth[next_node] == -1:\n\t\t\t\t\tdepth[next_node] = depth[node] + 1\n\t\t\t\t\tbfs.append(next_node)\n\t\t\telse:\n\t\t\t\tcontinue\n\t\t\tbreak\n\t\telse:\n\t\t\tbreak\n\t\tpointer = [len(c) for c in path]\n\t\tdfs = [node for node in range(n) if depth[node] == 0]\n\t\twhile dfs:\n\t\t\tnode = dfs[-1]\n\t\t\twhile pointer[node]:\n\t\t\t\tpointer[node] -= 1\n\t\t\t\tnei = path[node][pointer[node]]\n\t\t\t\tnext_node = match2[nei]\n\t\t\t\tif next_node == -1:\n\t\t\t\t\twhile nei != -1:\n\t\t\t\t\t\tnode = dfs.pop()\n\t\t\t\t\t\t(match2[nei], match1[node], nei) = (node, nei, match1[node])\n\t\t\t\t\tbreak\n\t\t\t\telif depth[node] + 1 == depth[next_node]:\n\t\t\t\t\tdfs.append(next_node)\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tdfs.pop()\n\treturn n - match1.count(-1)\n\ndef main():\n\t(n, m) = map(int, input().split())\n\tedg = [tuple(map(lambda xx: int(xx) - 1, input().split())) for _ in range(m)]\n\tans = float('inf')\n\tfor centre in range(n):\n\t\tpath = [[] for _ in range(n)]\n\t\tcost = 2 * n - 1\n\t\textra = m\n\t\tfor (u, v) in edg:\n\t\t\tif u == centre or v == centre:\n\t\t\t\tcost -= 1\n\t\t\t\textra -= 1\n\t\t\telse:\n\t\t\t\tpath[u].append(v)\n\t\tmaxMatch = matching(n, n, path)\n\t\textra -= maxMatch\n\t\tcost += n - 1 - maxMatch + extra\n\t\tans = min(ans, cost)\n\tprint(ans)\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n"
    },
    {
        "task_id": 287,
        "slowest_solution_id": 7,
        "fastest_solution_id": 5,
        "slowest_time": 4.568609952926636,
        "fastest_time": 2.56188702583313,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n(N, K) = map(int, input().split())\nS = list(input().rstrip())\nS = [int(s) for s in S]\nmod = 998244353\nfrom time import time\nit = time()\ncons = 0\nprof = []\nfor s in S:\n\tif s == 0:\n\t\tcons += 1\n\telse:\n\t\tprof.append(cons)\n\t\tcons = 0\nprof.append(cons)\n_inv_t = {}\n_inv_t[1] = 1\n_inv_t[0] = 0\n\ndef inv(x, mod):\n\tx %= mod\n\tif x not in _inv_t:\n\t\t_inv_t[x] = inv(mod % x, mod) * (mod - mod // x) % mod\n\treturn _inv_t[x]\nfor x in range(2, N + 10):\n\t_inv_t[x] = inv(mod % x, mod) * (mod - mod // x) % mod\ncomb = [[1, 0], [1, 1, 0]]\nfor n in range(2, N + 3):\n\tnow = 1\n\tarr = [1]\n\tfor i in range(1, n + 1):\n\t\tarr.append((comb[-1][i - 1] + comb[-1][i]) % mod)\n\tarr.append(0)\n\tcomb.append(arr)\nimport sys\nif K == 0:\n\tprint(1)\n\tsys.exit()\nif K > S.count(1):\n\tprint(1)\n\tsys.exit()\nans = 0\nfac = -1\nfor k in range(K, max(-1, K - 2), -1):\n\tfac *= -1\n\tn = sum(prof[K - k:K + 1]) + k\n\tfor i in range(K + 1, len(prof) - (K - k) + 1):\n\t\tans += comb[n][k] * fac\n\t\tans %= mod\n\t\tif i < len(prof):\n\t\t\tn += prof[i]\n\t\t\tn -= prof[i - k - 1]\nprint(ans)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n(n, k) = map(int, input().split())\nmod = 998244353\ns = list(input().rstrip())\nl = n + 5\nfact = [1] * (l + 1)\nfor i in range(1, l + 1):\n\tfact[i] = i * fact[i - 1] % mod\ninv = [1] * (l + 1)\ninv[l] = pow(fact[l], mod - 2, mod)\nfor i in range(l - 1, -1, -1):\n\tinv[i] = (i + 1) * inv[i + 1] % mod\n\ndef comb(n, r):\n\treturn fact[n] * inv[r] % mod * inv[n - r] % mod if n >= r >= 0 else 0\nx = [-1]\nfor i in range(n):\n\tif s[i] == '1':\n\t\tx.append(i)\nx.append(n)\nl = len(x) - 1\nans = 1\nfor i in range(1, len(x) - 1):\n\txi = x[i]\n\tl = i - 1 if i < k else x[i - k] + 1\n\tfor j in range(l, x[i + 1]):\n\t\tif xi == j:\n\t\t\tcontinue\n\t\tc = min(i - 1, k - 1)\n\t\tm = j - 1 - x[max(0, i - k)]\n\t\tans += comb(m, c)\n\t\tans %= mod\nif len(x) - 2 < k:\n\tans = 1\nprint(ans)\n"
    },
    {
        "task_id": 328,
        "slowest_solution_id": 1,
        "fastest_solution_id": 1,
        "slowest_time": 2.674116849899292,
        "fastest_time": 2.674116849899292,
        "fastest_solution": "n = int(input())\ndegs = [0] * n\nneighbors = [0] * n\nchildren = [0] * n\nuseless = [0] * n\nfor i in range(n):\n\tneighbors[i] = []\n\tchildren[i] = []\nfor i in range(n - 1):\n\t(a, b) = map(int, input().split())\n\tdegs[a - 1] += 1\n\tdegs[b - 1] += 1\n\tneighbors[a - 1].append(b - 1)\n\tneighbors[b - 1].append(a - 1)\nfor guy in range(n):\n\tif degs[guy] == 1:\n\t\tuseless[guy] += 1\n\t\tnewguy = neighbors[guy][0]\n\t\toldguy = guy\n\t\tdepth = 0\n\t\twhile degs[newguy] == 2:\n\t\t\tdepth += 1\n\t\t\tuseless[newguy] += 1\n\t\t\tif neighbors[newguy][0] == oldguy:\n\t\t\t\toldguy = newguy\n\t\t\t\tnewguy = neighbors[newguy][1]\n\t\t\telse:\n\t\t\t\toldguy = newguy\n\t\t\t\tnewguy = neighbors[newguy][0]\n\t\tchildren[newguy].append((depth, guy))\nfor guy in range(n):\n\tchildren[guy].sort(reverse=True)\nnewgraph = {}\nfor i in range(n):\n\tif useless[i] == 0:\n\t\tnewgraph[i] = []\nfor guy in newgraph:\n\tfor guy1 in neighbors[guy]:\n\t\tif guy1 in newgraph:\n\t\t\tnewgraph[guy].append(guy1)\ndfs1 = {}\ncurrlayer = [(list(newgraph)[0], None)]\ncurrlevel = 0\nwhile len(currlayer) > 0:\n\tfor guy in currlayer:\n\t\tdfs1[guy[0]] = currlevel\n\tnewlayer = []\n\tfor guy in currlayer:\n\t\tfor vert in newgraph[guy[0]]:\n\t\t\tif vert != guy[1]:\n\t\t\t\tnewlayer.append((vert, guy[0]))\n\tcurrlayer = newlayer\n\tcurrlevel += 1\nmaxi = 0\nfor guy in dfs1:\n\tmaxi = max(maxi, dfs1[guy])\nbestdist = 0\nbestvert = None\nfor guy in dfs1:\n\tif dfs1[guy] == maxi:\n\t\tscore = children[guy][0][0] + children[guy][1][0]\n\t\tif score >= bestdist:\n\t\t\tbestdist = score\n\t\t\tbestvert = guy\ndfs2 = {}\ncurrlayer = [(bestvert, None)]\ncurrlevel = 0\nwhile len(currlayer) > 0:\n\tfor guy in currlayer:\n\t\tdfs2[guy[0]] = currlevel\n\tnewlayer = []\n\tfor guy in currlayer:\n\t\tfor vert in newgraph[guy[0]]:\n\t\t\tif vert != guy[1]:\n\t\t\t\tnewlayer.append((vert, guy[0]))\n\tcurrlayer = newlayer\n\tcurrlevel += 1\nmaxi = 0\nfor guy in dfs2:\n\tmaxi = max(maxi, dfs2[guy])\nbestdist = 0\nbestvert1 = None\nfor guy in dfs2:\n\tif dfs2[guy] == maxi:\n\t\tscore = children[guy][0][0] + children[guy][1][0]\n\t\tif score >= bestdist:\n\t\t\tbestdist = score\n\t\t\tbestvert1 = guy\nprint(children[bestvert][0][1] + 1, children[bestvert1][0][1] + 1)\nprint(children[bestvert][1][1] + 1, children[bestvert1][1][1] + 1)\n",
        "slowest_solution": "n = int(input())\ndegs = [0] * n\nneighbors = [0] * n\nchildren = [0] * n\nuseless = [0] * n\nfor i in range(n):\n\tneighbors[i] = []\n\tchildren[i] = []\nfor i in range(n - 1):\n\t(a, b) = map(int, input().split())\n\tdegs[a - 1] += 1\n\tdegs[b - 1] += 1\n\tneighbors[a - 1].append(b - 1)\n\tneighbors[b - 1].append(a - 1)\nfor guy in range(n):\n\tif degs[guy] == 1:\n\t\tuseless[guy] += 1\n\t\tnewguy = neighbors[guy][0]\n\t\toldguy = guy\n\t\tdepth = 0\n\t\twhile degs[newguy] == 2:\n\t\t\tdepth += 1\n\t\t\tuseless[newguy] += 1\n\t\t\tif neighbors[newguy][0] == oldguy:\n\t\t\t\toldguy = newguy\n\t\t\t\tnewguy = neighbors[newguy][1]\n\t\t\telse:\n\t\t\t\toldguy = newguy\n\t\t\t\tnewguy = neighbors[newguy][0]\n\t\tchildren[newguy].append((depth, guy))\nfor guy in range(n):\n\tchildren[guy].sort(reverse=True)\nnewgraph = {}\nfor i in range(n):\n\tif useless[i] == 0:\n\t\tnewgraph[i] = []\nfor guy in newgraph:\n\tfor guy1 in neighbors[guy]:\n\t\tif guy1 in newgraph:\n\t\t\tnewgraph[guy].append(guy1)\ndfs1 = {}\ncurrlayer = [(list(newgraph)[0], None)]\ncurrlevel = 0\nwhile len(currlayer) > 0:\n\tfor guy in currlayer:\n\t\tdfs1[guy[0]] = currlevel\n\tnewlayer = []\n\tfor guy in currlayer:\n\t\tfor vert in newgraph[guy[0]]:\n\t\t\tif vert != guy[1]:\n\t\t\t\tnewlayer.append((vert, guy[0]))\n\tcurrlayer = newlayer\n\tcurrlevel += 1\nmaxi = 0\nfor guy in dfs1:\n\tmaxi = max(maxi, dfs1[guy])\nbestdist = 0\nbestvert = None\nfor guy in dfs1:\n\tif dfs1[guy] == maxi:\n\t\tscore = children[guy][0][0] + children[guy][1][0]\n\t\tif score >= bestdist:\n\t\t\tbestdist = score\n\t\t\tbestvert = guy\ndfs2 = {}\ncurrlayer = [(bestvert, None)]\ncurrlevel = 0\nwhile len(currlayer) > 0:\n\tfor guy in currlayer:\n\t\tdfs2[guy[0]] = currlevel\n\tnewlayer = []\n\tfor guy in currlayer:\n\t\tfor vert in newgraph[guy[0]]:\n\t\t\tif vert != guy[1]:\n\t\t\t\tnewlayer.append((vert, guy[0]))\n\tcurrlayer = newlayer\n\tcurrlevel += 1\nmaxi = 0\nfor guy in dfs2:\n\tmaxi = max(maxi, dfs2[guy])\nbestdist = 0\nbestvert1 = None\nfor guy in dfs2:\n\tif dfs2[guy] == maxi:\n\t\tscore = children[guy][0][0] + children[guy][1][0]\n\t\tif score >= bestdist:\n\t\t\tbestdist = score\n\t\t\tbestvert1 = guy\nprint(children[bestvert][0][1] + 1, children[bestvert1][0][1] + 1)\nprint(children[bestvert][1][1] + 1, children[bestvert1][1][1] + 1)\n"
    },
    {
        "task_id": 323,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.859323501586914,
        "fastest_time": 2.69320011138916,
        "fastest_solution": "n=int(input())\nsi=list(map(int,input().split()))\ntot = sum(si)\nbatch=int(input())\nz,inc=0,0\nfor i in range(batch):\n\tb=list(map(int,input().split()))\n\tp=b[b[0]+1]\n\told=0\n\tz=z+p\n\tfor j in b[1:b[0]+1]:\n\t\told = old + si[j-1]\n\tif(old<p):\n\t\tinc=p-old+inc        \nif(z>tot):\n\tprint(z-tot)\nelse:\n\tprint(inc)\n\t\n",
        "slowest_solution": "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n#print 'Hello World!'\nnOfS = int(input())\npOnS = input().split()\nnOfB = int(input())\nbs = []\npOfB = []\ncount = 0\npbCount = 0\nbsset = []\nbsCount = []\nfor i in range(nOfB):\n\tb = input().split()\n\tnOfBS = int(b[0])\n\tbsCount.append(nOfBS)\n\tfor j in range(1,nOfBS+1):\n\t\tbs.append(int(b[j]))\n\tpOfB.append(int(b[-1]))\n\tpbCount += int(b[-1])\nbsset = list(set(bs))\npsCount = 0\nfor s in bsset:\n\tpsCount += int(pOnS[s-1])\n\"\"\"\nprint pOnS\nprint bs\nprint bsset\nprint pOfB\nprint pbCount\nprint psCount\nprint bsCount\n\"\"\"\nif pbCount > psCount:\n\tprint(pbCount - psCount)\nelse:\n\tsc = 0\n\tfor j,s in enumerate(bsCount):\n\t\tprevP = 0\n\t\tfor i in range(s):\n\t\t\tprevP += int(pOnS[bs[sc]-1])\n\t\t\tsc+=1\n\t\tif prevP < pOfB[j]:\n\t\t\t#print \"adding\",pOfB[j],prevP,pOfB[j] - prevP\n\t\t\tcount += pOfB[j] - prevP\n\tprint(count)\n"
    },
    {
        "task_id": 292,
        "slowest_solution_id": 5,
        "fastest_solution_id": 4,
        "slowest_time": 4.05145525932312,
        "fastest_time": 2.4962029457092285,
        "fastest_solution": "tests = int(input())\nfor i in range(tests):\n\tpages = int(input())\n\tarr = list(map(int, input().split()))\n\ttore = int(input())\n\ttotal = pages * (pages + 1) // 2 - sum(arr[1:])\n\tif pages & 1:\n\t\tpages = pages // 2 + 1\n\telse:\n\t\tpages = pages // 2\n\tans = round(total * (pages - tore) / pages, 4)\n\tprint('{:.4f}'.format(ans))\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tsum = n * (n + 1) / 2\n\tls = list(map(int, input().split()))[1:]\n\tfor i in ls:\n\t\tsum -= i\n\tm = int(input())\n\tn = (n + 1) // 2\n\tans = (n - m) / n * sum\n\tprint('%.4f' % ans)\n"
    },
    {
        "task_id": 317,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 4.04445219039917,
        "fastest_time": 2.664879083633423,
        "fastest_solution": "for i in range(eval(input())):\n\tN, K = [int(i) for i in input().split()]\n\tP = [int(i) for i in input().split()]\n\tstack = []\n\tcount = 0\n\tfor p in P:\n\t\twhile len(stack) > 0 and count < K and stack[-1] < p:\n\t\t\tstack.pop()\n\t\t\tcount += 1\n\t\tstack.append(p)\n\tif count < K:\n\t\tstack = stack[0:K-count]\n\tprint(\" \".join([str(i) for i in stack]))\n",
        "slowest_solution": "for _ in range(eval(input())):\n\tn,k = list(map(int,input().split()))\n\tarr = list(map(int,input().split()))\n\tstk = []\n\tfor ele in arr:\n\t\twhile k and len(stk) and stk[-1] < ele:\n\t\t\tstk.pop()\n\t\t\tk -= 1\n\t\tstk.append(ele)\n\tprint(' '.join([str(i) for i in stk ]))\n"
    },
    {
        "task_id": 293,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 3.631226062774658,
        "fastest_time": 2.5730926990509033,
        "fastest_solution": "import math\n(n, k) = map(int, input().split())\nif k > n:\n\tprint(-1)\n\texit()\nd = list()\nfound = False\nsqrt = int(math.sqrt(n))\nfor i in range(1, sqrt + 1):\n\tif n % i == 0:\n\t\td.append(i)\n\tif len(d) == k:\n\t\tfound = True\n\t\tprint(i)\n\t\tbreak\nif not found:\n\tif k <= len(d) * 2:\n\t\tif sqrt * sqrt == n:\n\t\t\tif k == len(d) * 2:\n\t\t\t\tprint(-1)\n\t\t\telse:\n\t\t\t\tprint(n // d[-(k - len(d)) - 1])\n\t\telse:\n\t\t\tprint(n // d[-(k - len(d))])\n\telse:\n\t\tprint(-1)\n",
        "slowest_solution": "(n, k) = map(int, input().split())\nl = []\nfor i in range(1, int(n ** 0.5) + 1):\n\tif n % i == 0:\n\t\tl.append(i)\n\t\tif i * i != n:\n\t\t\tl.append(n // i)\nl.sort()\nif k <= len(l):\n\tprint(l[k - 1])\nelse:\n\tprint(-1)\n"
    },
    {
        "task_id": 295,
        "slowest_solution_id": 6,
        "fastest_solution_id": 0,
        "slowest_time": 3.8118324279785156,
        "fastest_time": 2.543722152709961,
        "fastest_solution": "import sys\nI = sys.stdin.readline\n\ndef is_prime(n):\n\tif n == 1:\n\t\treturn False\n\tfor i in range(2, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\nfor _ in range(int(I())):\n\t(a, b) = map(int, I().split())\n\tif a - b == 1:\n\t\tif is_prime(a + b):\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "def isPrime(n):\n\tif n == 1:\n\t\treturn False\n\telse:\n\t\tfor i in range(2, int(n ** 0.5) + 1):\n\t\t\tif n % i == 0:\n\t\t\t\treturn False\n\treturn True\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tif a - b == 1 and isPrime(a + b):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 297,
        "slowest_solution_id": 5,
        "fastest_solution_id": 3,
        "slowest_time": 4.179647922515869,
        "fastest_time": 2.523740768432617,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tarr = [int(x) for x in input()]\n\ts = 0\n\tpre = [0] * n\n\tfor i in range(n):\n\t\tif i - k >= 0:\n\t\t\ts -= pre[i - k]\n\t\tif i < n - k + 1:\n\t\t\tif s % 2 == 0 and arr[i] == 1:\n\t\t\t\ts += 1\n\t\t\t\tpre[i] = 1\n\t\t\telif s % 2 != 0 and arr[i] == 0:\n\t\t\t\ts += 1\n\t\t\t\tpre[i] = 1\n\t\t\tprint(0, end='')\n\t\telif s % 2 == 0:\n\t\t\tprint(arr[i], end='')\n\t\telse:\n\t\t\tprint(arr[i] ^ 1, end='')\n\tprint()\n",
        "slowest_solution": "T = int(input())\nfor i in range(T):\n\t(N, K) = input().split()\n\t(N, K) = (int(N), int(K))\n\tstring = input()\n\tarr = [0 for i in range(len(string))]\n\tj = 0\n\tnew_string = ''\n\tsum = 0\n\twhile j < len(string) - K + 1:\n\t\tif j >= K:\n\t\t\tsum -= arr[j - K]\n\t\tif sum % 2 == 0 and string[j] == '1':\n\t\t\tarr[j] = 1\n\t\t\tsum += 1\n\t\telif sum % 2 == 1 and string[j] == '0':\n\t\t\tarr[j] = 1\n\t\t\tsum += 1\n\t\tnew_string += '0'\n\t\tj += 1\n\twhile j < len(string):\n\t\tif j >= K:\n\t\t\tsum -= arr[j - K]\n\t\tif sum % 2 == 0 and string[j] == '1':\n\t\t\tarr[j] = 1\n\t\t\tnew_string += '1'\n\t\telif sum % 2 == 1 and string[j] == '0':\n\t\t\tarr[j] = 1\n\t\t\tnew_string += '1'\n\t\telse:\n\t\t\tnew_string += '0'\n\t\tj += 1\n\tprint(new_string)\n"
    },
    {
        "task_id": 294,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 4.700665473937988,
        "fastest_time": 2.560657024383545,
        "fastest_solution": "for s in [*open(0)][2::2]:\n\ta = [x & -x for x in map(int, s.split())]\n\tm = a.count((b := min(a)))\n\t(x, y, z) = (bin(x)[::-1].find('1') for x in (b, b * m, b * m - m))\n\tprint(len(a) - m + min(m * x, m - 1 + y, m - 2 + x + 1) * (b > 1))\n",
        "slowest_solution": "tc = int(input())\nfor t in range(tc):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tnum = 0\n\tcoun = n - 1\n\todd = 0\n\tfor j in range(n):\n\t\tnum = num | arr[j]\n\t\tif arr[j] % 2 == 1:\n\t\t\todd += 1\n\tif odd:\n\t\tcoun = n - odd\n\twhile num % 2 != 1:\n\t\tnum = num >> 1\n\t\tcoun += 1\n\tprint(coun)\n"
    },
    {
        "task_id": 300,
        "slowest_solution_id": 5,
        "fastest_solution_id": 2,
        "slowest_time": 4.1549177169799805,
        "fastest_time": 2.5240213871002197,
        "fastest_solution": "(n, m) = list(map(int, input().split()))\nfrom collections import defaultdict, deque\ng = defaultdict(list)\nfor i in range(m):\n\t(a, b) = list(map(int, input().split()))\n\tg[a - 1].append(b - 1)\n\tg[b - 1].append(a - 1)\n\ndef dfs(x):\n\tvis[x] = 1\n\tq = deque()\n\tq.append((x, 0))\n\twhile q:\n\t\t(cur, d) = q.popleft()\n\t\tif maxd[0] < d:\n\t\t\tmaxd[0] = d\n\t\t\tmaxnode[0] = cur\n\t\tfor i in g[cur]:\n\t\t\tif vis[i] == 0:\n\t\t\t\tq.append((i, d + 1))\n\t\t\t\tvis[i] = 1\nvis = [0] * n\nmaxd = [0]\nmaxnode = [0]\ndfs(0)\nvis = [0] * n\nmaxd = [0]\ndfs(maxnode[0])\nprint(maxd[0])\n",
        "slowest_solution": "f = lambda : map(int, input().split())\n(n, m) = f()\np = [[] for i in range(n)]\nfor j in range(m):\n\t(a, b) = f()\n\tp[a - 1].append(b - 1)\n\tp[b - 1].append(a - 1)\n\ndef g(i):\n\t(u, t) = ([1] * n, (0, i))\n\ts = [t]\n\twhile s:\n\t\t(d, i) = s.pop()\n\t\tu[i] = 0\n\t\tif d > t[0]:\n\t\t\tt = (d, i)\n\t\ts += [(d + 1, j) for j in p[i] if u[j]]\n\treturn t\nprint(g(g(0)[1])[0])\n"
    },
    {
        "task_id": 340,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.484525680541992,
        "fastest_time": 2.484525680541992,
        "fastest_solution": "import sys\nMOD = int(1000000000.0 + 7)\n\ndef add(a, b):\n\ta += b\n\tif a >= MOD:\n\t\ta -= MOD\n\treturn a\n\ndef mul(a, b):\n\treturn a * b % MOD\n\nclass fenwickTree:\n\n\tdef __init__(self, max_val):\n\t\tself.max_val = max_val + 5\n\t\tself.tree = [0] * self.max_val\n\n\tdef update(self, idx, value):\n\t\tidx += 1\n\t\twhile idx < self.max_val:\n\t\t\tself.tree[idx] = add(self.tree[idx], value)\n\t\t\tidx += idx & -idx\n\n\tdef read(self, idx):\n\t\tidx += 1\n\t\tres = 0\n\t\twhile idx > 0:\n\t\t\tres = add(res, self.tree[idx])\n\t\t\tidx -= idx & -idx\n\t\treturn res\ninp = [int(x) for x in sys.stdin.read().split()]\nn = inp[0]\na = []\nfor i in range(1, n + 1):\n\ta.append(inp[i])\nsorted_array = sorted(a)\ndict = {}\nfor i in range(n):\n\tdict[sorted_array[i]] = i\nfactor = [0] * n\nfor i in range(0, n):\n\tfactor[i] = mul(i + 1, n - i)\nleft_tree = fenwickTree(n)\nfor i in range(0, n):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))\n\tleft_tree.update(element_idx, i + 1)\nright_tree = fenwickTree(n)\nfor i in range(n - 1, -1, -1):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))\n\tright_tree.update(element_idx, n - i)\nans = 0\nfor i in range(n):\n\tans = add(ans, mul(a[i], factor[i]))\nprint(ans)\n",
        "slowest_solution": "import sys\nMOD = int(1000000000.0 + 7)\n\ndef add(a, b):\n\ta += b\n\tif a >= MOD:\n\t\ta -= MOD\n\treturn a\n\ndef mul(a, b):\n\treturn a * b % MOD\n\nclass fenwickTree:\n\n\tdef __init__(self, max_val):\n\t\tself.max_val = max_val + 5\n\t\tself.tree = [0] * self.max_val\n\n\tdef update(self, idx, value):\n\t\tidx += 1\n\t\twhile idx < self.max_val:\n\t\t\tself.tree[idx] = add(self.tree[idx], value)\n\t\t\tidx += idx & -idx\n\n\tdef read(self, idx):\n\t\tidx += 1\n\t\tres = 0\n\t\twhile idx > 0:\n\t\t\tres = add(res, self.tree[idx])\n\t\t\tidx -= idx & -idx\n\t\treturn res\ninp = [int(x) for x in sys.stdin.read().split()]\nn = inp[0]\na = []\nfor i in range(1, n + 1):\n\ta.append(inp[i])\nsorted_array = sorted(a)\ndict = {}\nfor i in range(n):\n\tdict[sorted_array[i]] = i\nfactor = [0] * n\nfor i in range(0, n):\n\tfactor[i] = mul(i + 1, n - i)\nleft_tree = fenwickTree(n)\nfor i in range(0, n):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))\n\tleft_tree.update(element_idx, i + 1)\nright_tree = fenwickTree(n)\nfor i in range(n - 1, -1, -1):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))\n\tright_tree.update(element_idx, n - i)\nans = 0\nfor i in range(n):\n\tans = add(ans, mul(a[i], factor[i]))\nprint(ans)\n"
    },
    {
        "task_id": 301,
        "slowest_solution_id": 4,
        "fastest_solution_id": 9,
        "slowest_time": 4.283075571060181,
        "fastest_time": 2.470947265625,
        "fastest_solution": "(a, b, c, d) = map(int, input().split())\ne = abs(a - c)\nf = abs(b - d)\nt = 0\nif (e - f) % 2 == 0:\n\tt = 2\nif e == f:\n\tt = 1\nprint((a != c) + (b != d), t, max(e, f))\n",
        "slowest_solution": "(r1, c1, r2, c2) = map(int, input().split())\nrook = 0\nbishop = 0\nking = 0\nif r1 != r2:\n\trook += 1\nif c1 != c2:\n\trook += 1\nr_king = r1\nc_king = c1\nwhile r_king != r2 and c_king != c2:\n\tif r_king > r2:\n\t\tr_king -= 1\n\telse:\n\t\tr_king += 1\n\tif c_king > c2:\n\t\tc_king -= 1\n\telse:\n\t\tc_king += 1\n\tking += 1\nking += abs(r_king - r2) + abs(c_king - c2)\nif abs(r1 - r2) % 2 == abs(c1 - c2) % 2:\n\tif abs(r1 - r2) == abs(c1 - c2):\n\t\tbishop = 1\n\telse:\n\t\tbishop = 2\nprint(rook, bishop, king)\n"
    },
    {
        "task_id": 345,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def unique_sum(lst):\n\treturn sum(set(lst)) if lst else None\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 313,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 4.1803977489471436,
        "fastest_time": 2.656327486038208,
        "fastest_solution": "from fractions import Fraction\nimport sys\ninput = sys.stdin.readline\nd = dict()\n\ndef find(L, n):\n\tif n in d:\n\t\treturn d[n]\n\tlo = 0\n\thi = len(L)\n\twhile lo < hi:\n\t\tmid = (lo + hi) // 2\n\t\tif L[mid] < n:\n\t\t\tlo = mid + 1\n\t\telse:\n\t\t\thi = mid\n\td[n] = lo\n\treturn lo\nmod = 998244353\n(n, m) = map(int, input().split())\nL = list(map(int, input().split()))\nL.sort()\nsumL = [0]\nfor i in L:\n\tsumL.append((sumL[-1] + i) % mod)\nfor i in ' ' * m:\n\t(a, b) = map(int, input().split())\n\tpt = find(L, b)\n\ttotsum = sumL[-1]\n\tlesssum = sumL[pt]\n\tmoresum = (totsum - lesssum) % mod\n\tif n - pt < a:\n\t\tprint(0)\n\t\tcontinue\n\tc = Fraction(lesssum * (n - pt - a + 1) % mod, n - pt + 1) + Fraction(moresum * (n - pt - a) % mod, n - pt)\n\tp = c.numerator % mod\n\tq = c.denominator % mod\n\tprint(p * pow(q, mod - 2, mod) % mod)\n",
        "slowest_solution": "import sys, bisect\ninput = sys.stdin.readline\nMOD = 998244353\n\ndef frac(a, b):\n\treturn a * pow(b, MOD - 2, MOD) % MOD\n(n, m) = map(int, input().split())\nd = sorted(list(map(int, input().split())))\ntot = sum(d)\npref = [0]\nfor v in d:\n\tpref.append(pref[-1] + v)\nout = [0] * m\nfor _ in range(m):\n\t(a, b) = map(int, input().split())\n\tind = bisect.bisect_left(d, b)\n\tsum_before = pref[ind]\n\trest = tot - pref[ind]\n\tif a <= n - ind:\n\t\tout[_] += sum_before * frac(n - ind - a + 1, n - ind + 1)\n\t\tout[_] += rest * frac(n - ind - a, n - ind)\n\t\tout[_] %= MOD\nprint('\\n'.join(map(str, out)))\n"
    },
    {
        "task_id": 307,
        "slowest_solution_id": 3,
        "fastest_solution_id": 1,
        "slowest_time": 4.5144524574279785,
        "fastest_time": 2.5269172191619873,
        "fastest_solution": "import sys\n\nclass SegmTree:\n\n\tdef __init__(self, array=None, size=None):\n\t\tif array is not None:\n\t\t\tsize = len(array)\n\t\tN = 1\n\t\twhile N < size:\n\t\t\tN <<= 1\n\t\tself.N = N\n\t\tself.tree = [0] * (2 * self.N)\n\t\tif array is not None:\n\t\t\tfor i in range(size):\n\t\t\t\tself.tree[i + self.N] = array[i]\n\t\t\tself.build()\n\n\tdef build(self):\n\t\tfor i in range(self.N - 1, 0, -1):\n\t\t\tself.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]\n\n\tdef add(self, i, value=1):\n\t\ti += self.N\n\t\twhile i > 0:\n\t\t\tself.tree[i] += value\n\t\t\ti >>= 1\n\n\tdef find_nonzeros(self, l, r):\n\t\tN = self.N\n\t\tl += N\n\t\tr += N\n\t\tcand = []\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tif self.tree[l]:\n\t\t\t\t\tcand.append(l)\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tr -= 1\n\t\t\t\tif self.tree[r]:\n\t\t\t\t\tcand.append(r)\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\tans = []\n\t\twhile cand:\n\t\t\ti = cand.pop()\n\t\t\tif i < N:\n\t\t\t\ti <<= 1\n\t\t\t\tif self.tree[i]:\n\t\t\t\t\tcand.append(i)\n\t\t\t\tif self.tree[i | 1]:\n\t\t\t\t\tcand.append(i | 1)\n\t\t\telse:\n\t\t\t\tans.append(i - N)\n\t\treturn ans\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n(n, m) = list(map(int, input().split()))\nst = SegmTree([1] * n)\nans = [0] * n\nfor _ in range(m):\n\t(l, r, x) = list(map(int, input().split()))\n\tl -= 1\n\tx -= 1\n\tfor i in st.find_nonzeros(l, r):\n\t\tif i != x:\n\t\t\tans[i] = x + 1\n\t\t\tst.add(i, -1)\nprint(*ans)\n",
        "slowest_solution": "from sys import stdin\ninput = lambda : stdin.readline().strip()\nfrom math import ceil, sqrt, factorial, gcd\n(n, m) = map(int, input().split())\nans = [0 for i in range(n)]\nnextl = [i + 1 for i in range(n + 2)]\nfor j in range(m):\n\t(l, r, x) = map(int, input().split())\n\ti = l\n\twhile i <= r:\n\t\tif ans[i - 1] == 0 and i != x:\n\t\t\tans[i - 1] = x\n\t\ta = nextl[i]\n\t\tif i < x:\n\t\t\tnextl[i] = x\n\t\telse:\n\t\t\tnextl[i] = r + 1\n\t\ti = a\nprint(*ans)\n"
    },
    {
        "task_id": 312,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 3.325916290283203,
        "fastest_time": 2.495637893676758,
        "fastest_solution": "import math\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\telse:\n\t\treturn gcd(b, a % b)\n\ndef lcm(a, b):\n\treturn a * b // math.gcd(a, b)\n\ndef solve(n, k):\n\tans = 1\n\ta = list(map(int, input().split()))\n\tfor i in range(n):\n\t\tans = math.gcd(k, lcm(ans, a[i]))\n\treturn ans == k\nwhile True:\n\ttry:\n\t\t(n, k) = list(map(int, input().split()))\n\t\tp = solve(n, k)\n\t\tif p:\n\t\t\tprint('Yes')\n\t\telse:\n\t\t\tprint('No')\n\texcept EOFError:\n\t\tbreak\n",
        "slowest_solution": "import math\n(n, k) = list(map(int, input().split()))\na = list(map(int, input().split()))\ng = 1\nfor i in a:\n\tg = math.gcd(k, i * g // math.gcd(i, g))\nif g == k:\n\tprint('Yes')\nelse:\n\tprint('No')\n"
    },
    {
        "task_id": 331,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 6.0206568241119385,
        "fastest_time": 6.0206568241119385,
        "fastest_solution": "H = [0]\nN_max = 10 ** 6 + 1\nfor j in range(1, N_max):\n\tH.append(H[-1] + 1 / j)\nmaximal_val = [0, 1, 2, 3, 4]\nfor N in range(5, N_max):\n\tm = maximal_val[N - 1]\n\talpha = (m - 2) / (H[N] - H[N - m])\n\twhile alpha < N - m + 1:\n\t\tm += 1\n\t\talpha = (m - 2) / (H[N] - H[N - m])\n\tm -= 1\n\tmaximal_val.append(m)\n\ndef solve(N):\n\tm = maximal_val[N]\n\tans = (N * m - m * (m - 1) // 2 - (m - 2) ** 2 / (H[N] - H[N - m])) / 2\n\treturn ans / (2 * N - 1)\n\ndef main():\n\tQ = int(input().strip())\n\tfor _ in range(Q):\n\t\tprint('{0:.11f}'.format(solve(int(input().strip())), 10))\nmain()\n",
        "slowest_solution": "H = [0]\nN_max = 10 ** 6 + 1\nfor j in range(1, N_max):\n\tH.append(H[-1] + 1 / j)\nmaximal_val = [0, 1, 2, 3, 4]\nfor N in range(5, N_max):\n\tm = maximal_val[N - 1]\n\talpha = (m - 2) / (H[N] - H[N - m])\n\twhile alpha < N - m + 1:\n\t\tm += 1\n\t\talpha = (m - 2) / (H[N] - H[N - m])\n\tm -= 1\n\tmaximal_val.append(m)\n\ndef solve(N):\n\tm = maximal_val[N]\n\tans = (N * m - m * (m - 1) // 2 - (m - 2) ** 2 / (H[N] - H[N - m])) / 2\n\treturn ans / (2 * N - 1)\n\ndef main():\n\tQ = int(input().strip())\n\tfor _ in range(Q):\n\t\tprint('{0:.11f}'.format(solve(int(input().strip())), 10))\nmain()\n"
    },
    {
        "task_id": 336,
        "slowest_solution_id": 3,
        "fastest_solution_id": 1,
        "slowest_time": 2.628801107406616,
        "fastest_time": 2.615631103515625,
        "fastest_solution": "import sys\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n\treturn int(sys.stdin.readline())\n\ndef LI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n\treturn [LI() for _ in range(rows_number)]\n\ndef LI1():\n\treturn list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n\treturn [LI1() for _ in range(rows_number)]\n\ndef SI():\n\treturn sys.stdin.readline().rstrip()\ndij = [(0, 1), (1, 0), (0, -1), (-1, 0)]\ninf = 4294967295\nmd = 998244353\nfrom collections import defaultdict\n\ndef solve():\n\tSI()\n\tn = II()\n\tabm = LLI(n)\n\tstolr = defaultdict(list)\n\tfor (i, (a, b, m)) in enumerate(abm):\n\t\tl = max(0, a - m)\n\t\tr = min(a, a + b - m)\n\t\tstolr[a + b - m].append((l, r, i))\n\taa = [0] * n\n\tbb = [0] * n\n\tcnt = 0\n\tfor lr in stolr.values():\n\t\ttoa = -1\n\t\tfor (l, r, i) in sorted(lr, key=lambda x: x[1]):\n\t\t\t(a, b, m) = abm[i]\n\t\t\tif l > toa:\n\t\t\t\tcnt += 1\n\t\t\t\ttoa = r\n\t\t\taa[i] = a - toa\n\t\t\tbb[i] = m - aa[i]\n\tprint(cnt)\n\tfor (a, b) in zip(aa, bb):\n\t\tprint(a, b)\nfor testcase in range(II()):\n\tsolve()\n",
        "slowest_solution": "for _ in range(int(input())):\n\tinput()\n\tn = int(input())\n\ta = []\n\tb = []\n\tm = []\n\tfor i in range(n):\n\t\t(ai, bi, mi) = map(int, input().split())\n\t\ta.append(ai)\n\t\tb.append(bi)\n\t\tm.append(mi)\n\tansa = [0] * n\n\tansb = [0] * n\n\tevents = {}\n\tfor i in range(n):\n\t\tma = m[i] - b[i] if m[i] > b[i] else 0\n\t\tmb = m[i] - a[i] if m[i] > a[i] else 0\n\t\tansa[i] += ma\n\t\tansb[i] += mb\n\t\ta[i] -= ma\n\t\tb[i] -= mb\n\t\tm[i] -= ma + mb\n\t\tdiag = a[i] + b[i] - m[i]\n\t\tif diag not in events:\n\t\t\tevents[diag] = []\n\t\tevents[diag].append((a[i] - m[i], 0, i))\n\t\tevents[diag].append((a[i], 1, i))\n\tused = [0] * n\n\tcount = 0\n\tfor diag in events:\n\t\tevts = sorted(events[diag])\n\t\topened = []\n\t\tfor event in evts:\n\t\t\tif event[1]:\n\t\t\t\tif not used[event[2]]:\n\t\t\t\t\tfor i in opened:\n\t\t\t\t\t\tansa[i] += a[i] - event[0]\n\t\t\t\t\t\tansb[i] += m[i] - a[i] + event[0]\n\t\t\t\t\t\tused[i] = 1\n\t\t\t\t\topened = []\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\topened.append(event[2])\n\tprint(count)\n\tfor i in range(n):\n\t\tprint(ansa[i], ansb[i])\n"
    },
    {
        "task_id": 308,
        "slowest_solution_id": 3,
        "fastest_solution_id": 7,
        "slowest_time": 3.9960384368896484,
        "fastest_time": 2.438420534133911,
        "fastest_solution": "import sys\nimport math, bisect\nsys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\n\ndef I():\n\treturn int(sys.stdin.readline())\n\ndef neo():\n\treturn map(int, sys.stdin.readline().split())\n\ndef Neo():\n\treturn list(map(int, sys.stdin.readline().split()))\nn = I()\nparents = [0] + Neo()\nvalues = Neo()\nsv = values[:]\nfor i in range(1, n):\n\tif values[i] != -1:\n\t\tpar = parents[i] - 1\n\t\tif sv[par] == -1:\n\t\t\tsv[par] = values[i]\n\t\telse:\n\t\t\tsv[par] = min(sv[par], values[i])\nout = sv[0]\nworks = True\nfor i in range(1, n):\n\tif sv[i] != -1:\n\t\ta_val = sv[i] - sv[parents[i] - 1]\n\t\tif a_val >= 0:\n\t\t\tout += a_val\n\t\telse:\n\t\t\tworks = False\n\t\t\tbreak\nif works:\n\tprint(out)\nelse:\n\tprint(-1)\n",
        "slowest_solution": "n = int(input())\nP = [-1] + [int(a) - 1 for a in input().split()]\nS = [int(a) for a in input().split()]\nT = [s for s in S]\nfor i in range(1, n):\n\tif S[P[i]] < 0:\n\t\tif T[P[i]] < 0:\n\t\t\tT[P[i]] = S[i]\n\t\telse:\n\t\t\tT[P[i]] = min(T[P[i]], S[i])\nfor i in range(1, n):\n\tif T[i] < 0:\n\t\tT[i] = T[P[i]]\nS = [t for t in T]\nans = S[0]\nfor i in range(1, n):\n\tif S[i] < S[P[i]]:\n\t\tprint(-1)\n\t\tbreak\n\telse:\n\t\tans += S[i] - S[P[i]]\nelse:\n\tprint(ans)\n"
    },
    {
        "task_id": 351,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.8504512310028076,
        "fastest_time": 2.8504512310028076,
        "fastest_solution": "from sys import stdin, stdout\nT = int(stdin.readline())\n\ndef presuf(pre, suf):\n\tfor s in bts:\n\t\tfor i in range(len(s) - 1):\n\t\t\t(pre[s[:i + 1]], suf[s[len(s) - i - 1:]]) = (True, True)\n\treturn (pre, suf)\nfor _ in range(T):\n\ta = stdin.readline().strip('\\n')\n\tna = len(a)\n\tb = stdin.readline().strip('\\n')\n\tnb = len(b)\n\tA = [0] * (na + 1)\n\tB = [0] * (nb + 1)\n\t(n, bts, AB) = (int(stdin.readline()), {}, [[0 for i in range(nb + 1)] for j in range(na + 1)])\n\tfor i in range(n):\n\t\t(s, bt) = stdin.readline().split(' ')\n\t\tbt = int(bt)\n\t\tbts[s] = bt\n\t(pre, suf) = presuf({}, {})\n\tAs = {}\n\tdone = {}\n\tfor k in range(min(26, na), 0, -1):\n\t\tfor i in range(na, k - 1, -1):\n\t\t\ts = a[i - k:i]\n\t\t\tif s in bts:\n\t\t\t\tA[i] += bts[s]\n\t\t\tif s not in pre:\n\t\t\t\tcontinue\n\t\t\tif i in done:\n\t\t\t\tdel pre[s]\n\t\t\t\tcontinue\n\t\t\tfor j in range(k):\n\t\t\t\tif s[k - j - 1:] not in As:\n\t\t\t\t\tAs[s[k - j - 1:]] = []\n\t\t\t\tAs[s[k - j - 1:]].append(i)\n\t\t\t\tdone[i] = True\n\t\t\tdel pre[s]\n\t(Bs, done, mx) = ({}, {}, 0)\n\tfor k in range(min(26, nb), 0, -1):\n\t\tfor i in range(nb - k + 1):\n\t\t\ts = b[i:i + k]\n\t\t\tif s in bts:\n\t\t\t\tB[i + 1] += bts[s]\n\t\t\tif s not in suf:\n\t\t\t\tcontinue\n\t\t\tif i in done:\n\t\t\t\tdel suf[s]\n\t\t\t\tcontinue\n\t\t\tfor j in range(k):\n\t\t\t\tif s[:j + 1] not in Bs:\n\t\t\t\t\tBs[s[:j + 1]] = []\n\t\t\t\tBs[s[:j + 1]].append(i + 1)\n\t\t\t\tdone[i] = True\n\t\t\tdel suf[s]\n\tfor i in range(1, na + 1, 1):\n\t\tA[i] = A[i] + A[i - 1]\n\tfor i in range(nb - 1, -1, -1):\n\t\tB[i] = B[i] + B[i + 1]\n\tfor s in bts:\n\t\tfor i in range(1, len(s)):\n\t\t\tst = s[:i]\n\t\t\ten = s[i:]\n\t\t\tbt = bts[s]\n\t\t\tif st in As and en in Bs:\n\t\t\t\tfor x in As[st]:\n\t\t\t\t\tfor y in Bs[en]:\n\t\t\t\t\t\tAB[x][y] += bt\n\tfor i in range(na + 1):\n\t\tfor j in range(nb + 1):\n\t\t\tmx = max(A[i] + B[j] + AB[i][j], mx)\n\tprint(mx)\n",
        "slowest_solution": "from sys import stdin, stdout\nT = int(stdin.readline())\n\ndef presuf(pre, suf):\n\tfor s in bts:\n\t\tfor i in range(len(s) - 1):\n\t\t\t(pre[s[:i + 1]], suf[s[len(s) - i - 1:]]) = (True, True)\n\treturn (pre, suf)\nfor _ in range(T):\n\ta = stdin.readline().strip('\\n')\n\tna = len(a)\n\tb = stdin.readline().strip('\\n')\n\tnb = len(b)\n\tA = [0] * (na + 1)\n\tB = [0] * (nb + 1)\n\t(n, bts, AB) = (int(stdin.readline()), {}, [[0 for i in range(nb + 1)] for j in range(na + 1)])\n\tfor i in range(n):\n\t\t(s, bt) = stdin.readline().split(' ')\n\t\tbt = int(bt)\n\t\tbts[s] = bt\n\t(pre, suf) = presuf({}, {})\n\tAs = {}\n\tdone = {}\n\tfor k in range(min(26, na), 0, -1):\n\t\tfor i in range(na, k - 1, -1):\n\t\t\ts = a[i - k:i]\n\t\t\tif s in bts:\n\t\t\t\tA[i] += bts[s]\n\t\t\tif s not in pre:\n\t\t\t\tcontinue\n\t\t\tif i in done:\n\t\t\t\tdel pre[s]\n\t\t\t\tcontinue\n\t\t\tfor j in range(k):\n\t\t\t\tif s[k - j - 1:] not in As:\n\t\t\t\t\tAs[s[k - j - 1:]] = []\n\t\t\t\tAs[s[k - j - 1:]].append(i)\n\t\t\t\tdone[i] = True\n\t\t\tdel pre[s]\n\t(Bs, done, mx) = ({}, {}, 0)\n\tfor k in range(min(26, nb), 0, -1):\n\t\tfor i in range(nb - k + 1):\n\t\t\ts = b[i:i + k]\n\t\t\tif s in bts:\n\t\t\t\tB[i + 1] += bts[s]\n\t\t\tif s not in suf:\n\t\t\t\tcontinue\n\t\t\tif i in done:\n\t\t\t\tdel suf[s]\n\t\t\t\tcontinue\n\t\t\tfor j in range(k):\n\t\t\t\tif s[:j + 1] not in Bs:\n\t\t\t\t\tBs[s[:j + 1]] = []\n\t\t\t\tBs[s[:j + 1]].append(i + 1)\n\t\t\t\tdone[i] = True\n\t\t\tdel suf[s]\n\tfor i in range(1, na + 1, 1):\n\t\tA[i] = A[i] + A[i - 1]\n\tfor i in range(nb - 1, -1, -1):\n\t\tB[i] = B[i] + B[i + 1]\n\tfor s in bts:\n\t\tfor i in range(1, len(s)):\n\t\t\tst = s[:i]\n\t\t\ten = s[i:]\n\t\t\tbt = bts[s]\n\t\t\tif st in As and en in Bs:\n\t\t\t\tfor x in As[st]:\n\t\t\t\t\tfor y in Bs[en]:\n\t\t\t\t\t\tAB[x][y] += bt\n\tfor i in range(na + 1):\n\t\tfor j in range(nb + 1):\n\t\t\tmx = max(A[i] + B[j] + AB[i][j], mx)\n\tprint(mx)\n"
    },
    {
        "task_id": 311,
        "slowest_solution_id": 2,
        "fastest_solution_id": 6,
        "slowest_time": 3.9190011024475098,
        "fastest_time": 2.428386926651001,
        "fastest_solution": "import sys\nimport heapq\n\ndef solve(adj, deg, c):\n\tn = len(adj)\n\tcost = sum(c)\n\tcosts = [0] * n\n\tvisited = [False] * n\n\tv2c = list(range(n))\n\tc2v = [[i] for i in range(n)]\n\tc2cnt = [1] * n\n\tw2c = {}\n\tc2w = {}\n\n\tdef hasOtherComp(weight, comp):\n\t\tcnt = 0\n\t\tfor item in w2c.get(weight, []):\n\t\t\tif item != comp:\n\t\t\t\treturn True\n\t\treturn False\n\n\tdef add(weight, comp):\n\t\tif weight not in w2c:\n\t\t\tw2c[weight] = set([comp])\n\t\telse:\n\t\t\tw2c[weight].add(current_comp)\n\t\tif comp not in c2w:\n\t\t\tc2w[comp] = set([weight])\n\t\telse:\n\t\t\tc2w[comp].add(weight)\n\n\tdef mergeInto(c1, c2):\n\t\tfor v in c2v[c2]:\n\t\t\tv2c[v] = c1\n\t\tc2cnt[c1] += c2cnt[c2]\n\t\tfor w in c2w.get(c2, []):\n\t\t\tcomps = w2c[w]\n\t\t\tif c2 in comps:\n\t\t\t\tcomps.remove(c2)\n\t\t\tif c1 not in comps:\n\t\t\t\tcomps.add(c1)\n\t\t\t\tweights = c2w.get(c1, set())\n\t\t\t\tweights.add(w)\n\t\t\t\tc2w[c1] = weights\n\n\tdef merge(c1, c2):\n\t\tsize1 = c2cnt[c1]\n\t\tsize2 = c2cnt[c2]\n\t\tif size1 < size2:\n\t\t\tmergeInto(c2, c1)\n\t\telse:\n\t\t\tmergeInto(c1, c2)\n\tq = []\n\tfor i in range(n):\n\t\tif deg[i] == 1:\n\t\t\theapq.heappush(q, (c[i], i))\n\t\t\tcosts[i] = c[i]\n\t\t\tdeg[i] = 0\n\tbestResult = sys.maxsize\n\tlastWeight = 0\n\twhile q:\n\t\t(weight, v) = heapq.heappop(q)\n\t\tvisited[v] = True\n\t\tif weight * 2 > cost:\n\t\t\tbreak\n\t\tif lastWeight == weight:\n\t\t\trest = cost - lastWeight - weight\n\t\t\tif rest <= weight:\n\t\t\t\tbestResult = min(bestResult, weight - rest)\n\t\tfor u in adj[v]:\n\t\t\tdeg[u] -= 1\n\t\t\tif visited[u]:\n\t\t\t\tmerge(v2c[v], v2c[u])\n\t\t\telif deg[u] == 1:\n\t\t\t\theapq.heappush(q, (weight + c[u], u))\n\t\t\telse:\n\t\t\t\tc[u] += weight\n\t\trest = cost - weight * 2\n\t\tcurrent_comp = v2c[v]\n\t\tadd(weight, current_comp)\n\t\tif rest <= weight:\n\t\t\thas = hasOtherComp(rest, current_comp)\n\t\t\tif has:\n\t\t\t\tbestResult = min(bestResult, weight - rest)\n\t\tlastWeight = weight\n\treturn bestResult if bestResult < sys.maxsize else -1\nq = int(input().strip())\nfor i in range(q):\n\tn = int(input().strip())\n\tc = [int(x) for x in input().strip().split(' ')]\n\tadj = [[] for k in range(n)]\n\tdeg = [0] * n\n\tfor a0 in range(n - 1):\n\t\t[u, v] = [int(x) for x in input().strip().split(' ')]\n\t\tu = u - 1\n\t\tv = v - 1\n\t\tadj[u].append(v)\n\t\tadj[v].append(u)\n\t\tdeg[u] += 1\n\t\tdeg[v] += 1\n\tw = solve(adj, deg, c)\n\tprint(w)\n",
        "slowest_solution": "from collections import deque\n\ndef dfs(Ci, edges, parent, node, visited):\n\tvisited.add(node)\n\tneighbors = edges[node]\n\tif node != 0 and len(neighbors) == 1:\n\t\treturn\n\tfor n in neighbors:\n\t\tif n in visited:\n\t\t\tcontinue\n\t\tparent[n] = node\n\t\tdfs(Ci, edges, parent, n, visited)\n\t\tCi[node] += Ci[n]\n\ndef addToParent(Ci, edges, parent, node, val):\n\tif node > 0:\n\t\tparent_node = parent[node]\n\t\tCi[parent_node] += val\n\t\taddToParent(Ci, edges, parent, parent_node, val)\n\ndef searchValue(Ci, edges, parent, node, val, noFollow=-1):\n\tparent_node = parent[node]\n\tneighbors = edges[node]\n\tfor n in neighbors:\n\t\tif n == parent_node or n == noFollow:\n\t\t\tcontinue\n\t\tif Ci[n] == val:\n\t\t\treturn True\n\t\tif Ci[n] > val:\n\t\t\tif searchValue(Ci, edges, parent, n, val, noFollow=noFollow):\n\t\t\t\treturn True\n\treturn False\n\ndef checkSplit(Ci, edges, parent, node):\n\tif node == 0:\n\t\treturn None\n\tc = Ci[0]\n\ta = Ci[node]\n\tb = c - a\n\tif a == b:\n\t\treturn a\n\tif a > b and a <= 2 * b:\n\t\tif searchValue(Ci, edges, parent, node, val=b):\n\t\t\treturn 2 * b - a\n\tif a > 2 * b and a % 2 == 0:\n\t\tif searchValue(Ci, edges, parent, node, val=a // 2):\n\t\t\treturn a // 2 - b\n\tif b > a and b <= 2 * a:\n\t\taddToParent(Ci, edges, parent, node, val=-a)\n\t\tif searchValue(Ci, edges, parent, 0, val=a, noFollow=node):\n\t\t\taddToParent(Ci, edges, parent, node, val=a)\n\t\t\treturn 2 * a - b\n\t\taddToParent(Ci, edges, parent, node, val=a)\n\tif b > 2 * a and b % 2 == 0:\n\t\taddToParent(Ci, edges, parent, node, val=-a)\n\t\tif searchValue(Ci, edges, parent, 0, val=b // 2, noFollow=node):\n\t\t\taddToParent(Ci, edges, parent, node, val=a)\n\t\t\treturn b // 2 - a\n\t\taddToParent(Ci, edges, parent, node, val=a)\n\treturn None\n\ndef solution(Ci, edges):\n\tif len(Ci) <= 1:\n\t\treturn -1\n\tif len(Ci) == 2:\n\t\tif Ci[0] == Ci[1]:\n\t\t\treturn Ci[0]\n\t\treturn -1\n\tparent = {}\n\tparent[0] = -1\n\tdfs(Ci, edges, parent, 0, set())\n\toutput = -1\n\tvisited = set()\n\tto_visit = deque()\n\tto_visit.append(0)\n\twhile len(to_visit):\n\t\tnode = to_visit.popleft()\n\t\tvisited.add(node)\n\t\tCw = checkSplit(Ci, edges, parent, node)\n\t\tif Cw is not None:\n\t\t\tif output < 0 or Cw < output:\n\t\t\t\toutput = Cw\n\t\tneighbors = edges[node]\n\t\tfor n in neighbors:\n\t\t\tif n not in visited:\n\t\t\t\tto_visit.append(n)\n\treturn output\nQ = int(input().strip())\nfor q in range(Q):\n\tN = int(input().strip())\n\tCi = list(map(int, input().strip().split()))\n\tedges = {}\n\tfor i in range(N - 1):\n\t\t(x, y) = list(map(int, input().strip().split()))\n\t\tx -= 1\n\t\ty -= 1\n\t\tif x not in edges:\n\t\t\tedges[x] = list()\n\t\tif y not in edges:\n\t\t\tedges[y] = list()\n\t\tedges[x].append(y)\n\t\tedges[y].append(x)\n\tprint(solution(Ci, edges))\n"
    },
    {
        "task_id": 350,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.7239208221435547,
        "fastest_time": 2.6833853721618652,
        "fastest_solution": "s = input().split()\nn = int(s[0])\nk = int(s[1])\nprint((k + 1) * ((k * n - n - k) * k ** n + k) // (6 * k - 6) % 998244353)\n",
        "slowest_solution": "(n, k) = map(int, input().split())\nprint((k + 1) * ((k * n - n - k) * k ** n + k) // (6 * k - 6) % 998244353)\n"
    },
    {
        "task_id": 327,
        "slowest_solution_id": 5,
        "fastest_solution_id": 4,
        "slowest_time": 2.7496399879455566,
        "fastest_time": 2.50437331199646,
        "fastest_solution": "from collections import defaultdict\nd = {'A': [0, 5], 'B': [1, 6], 'C': [2, 7], 'D': [3, 8], 'E': [4, 9]}\n\nclass Graph:\n\n\tdef __init__(self, v):\n\t\tself.v = v\n\t\tself.graph = defaultdict(list)\n\n\tdef addEdge(self, u, v):\n\t\tself.graph[u].append(v)\n\t\tself.graph[v].append(u)\n\n\tdef route1(self, st):\n\t\tarr = []\n\t\tif len(st) == 0:\n\t\t\treturn '-1'\n\t\tarr.append(d[st[0]][0])\n\t\tfor i in range(1, len(st)):\n\t\t\tif d[st[i]][0] in self.graph[arr[len(arr) - 1]]:\n\t\t\t\tarr.append(d[st[i]][0])\n\t\t\telif d[st[i]][1] in self.graph[arr[len(arr) - 1]]:\n\t\t\t\tarr.append(d[st[i]][1])\n\t\t\telse:\n\t\t\t\treturn '-1'\n\t\tarr = [str(i) for i in arr]\n\t\treturn ''.join(arr)\n\n\tdef route2(self, st):\n\t\tarr = []\n\t\tif len(st) == 0:\n\t\t\treturn '-1'\n\t\tarr.append(d[st[0]][1])\n\t\tfor i in range(1, len(st)):\n\t\t\tif d[st[i]][0] in self.graph[arr[len(arr) - 1]]:\n\t\t\t\tarr.append(d[st[i]][0])\n\t\t\telif d[st[i]][1] in self.graph[arr[len(arr) - 1]]:\n\t\t\t\tarr.append(d[st[i]][1])\n\t\t\telse:\n\t\t\t\treturn '-1'\n\t\tarr = [str(i) for i in arr]\n\t\treturn ''.join(arr)\ng = Graph(10)\ng.addEdge(0, 4)\ng.addEdge(0, 5)\ng.addEdge(0, 1)\ng.addEdge(1, 6)\ng.addEdge(1, 2)\ng.addEdge(2, 3)\ng.addEdge(2, 7)\ng.addEdge(3, 4)\ng.addEdge(3, 8)\ng.addEdge(4, 9)\ng.addEdge(5, 7)\ng.addEdge(5, 8)\ng.addEdge(6, 8)\ng.addEdge(6, 9)\ng.addEdge(7, 9)\nn = int(input())\nfor i in range(n):\n\tst = input()\n\tif g.route1(st) != '-1':\n\t\tprint(g.route1(st))\n\telif g.route2(st) != '-1':\n\t\tprint(g.route2(st))\n\telse:\n\t\tprint('-1')\n",
        "slowest_solution": "let_node = {'A': [0, 5], 'B': [1, 6], 'C': [2, 7], 'D': [3, 8], 'E': [4, 9]}\nconnections = {0: [1, 4, 5], 1: [0, 2, 6], 2: [1, 3, 7], 3: [2, 4, 8], 4: [0, 3, 9], 5: [0, 7, 8], 6: [1, 8, 9], 7: [2, 5, 9], 8: [3, 5, 6], 9: [4, 6, 7]}\n\ndef check_path(S, pos):\n\tpath = str(pos)\n\tfor val in S:\n\t\tif let_node[val][0] in connections[pos]:\n\t\t\tpos = let_node[val][0]\n\t\t\tpath += str(pos)\n\t\telif let_node[val][1] in connections[pos]:\n\t\t\tpos = let_node[val][1]\n\t\t\tpath += str(pos)\n\t\telse:\n\t\t\treturn -1\n\treturn path\nfor _ in range(int(input())):\n\tS = list(input())\n\ta = check_path(S[1:], let_node[S[0]][0])\n\tif int(a) > 0:\n\t\tprint(a)\n\telse:\n\t\ta = check_path(S[1:], let_node[S[0]][1])\n\t\tif int(a) > 0:\n\t\t\tprint(a)\n\t\telse:\n\t\t\tprint(-1)\n"
    },
    {
        "task_id": 354,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.884648084640503,
        "fastest_time": 2.6990067958831787,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nprint = sys.stdout.write\ninf = float('inf')\n\ndef solve():\n\t(n, m) = map(int, input().split())\n\tM = [list(map(int, input().split())) for _ in range(n)]\n\tpmn = [[0] * m for _ in range(n)]\n\tpmx = [[0] * m for _ in range(n)]\n\tsmn = [[0] * m for _ in range(n)]\n\tsmx = [[0] * m for _ in range(n)]\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif j >= 1:\n\t\t\t\tpmn[i][j] = min(pmn[i][j - 1], M[i][j])\n\t\t\t\tpmx[i][j] = max(pmx[i][j - 1], M[i][j])\n\t\t\telse:\n\t\t\t\tpmn[i][j] = M[i][j]\n\t\t\t\tpmx[i][j] = M[i][j]\n\tfor i in range(n):\n\t\tfor j in range(m - 1, -1, -1):\n\t\t\tif j + 1 < m:\n\t\t\t\tsmn[i][j] = min(smn[i][j + 1], M[i][j])\n\t\t\t\tsmx[i][j] = max(smx[i][j + 1], M[i][j])\n\t\t\telse:\n\t\t\t\tsmn[i][j] = M[i][j]\n\t\t\t\tsmx[i][j] = M[i][j]\n\tI = list(range(0, n))\n\tfor j in range(0, m - 1):\n\t\tI.sort(key=lambda i: -pmn[i][j])\n\t\tcmx = -inf\n\t\tcmn = inf\n\t\tD = [smx[i][j + 1] for i in I]\n\t\tfor i in range(1, n):\n\t\t\tD[i] = max(D[i], D[i - 1])\n\t\tfor _ in range(n - 1, 0, -1):\n\t\t\ti0 = I[_]\n\t\t\ti1 = I[_ - 1]\n\t\t\tcmx = max(cmx, pmx[i0][j])\n\t\t\tcmn = min(cmn, smn[i0][j + 1])\n\t\t\tif pmn[i1][j] > cmx and D[_ - 1] < cmn:\n\t\t\t\tans = ['B'] * n\n\t\t\t\tidx = 0\n\t\t\t\twhile I[idx] != i1:\n\t\t\t\t\tans[I[idx]] = 'R'\n\t\t\t\t\tidx += 1\n\t\t\t\tans[i1] = 'R'\n\t\t\t\tprint('YES\\n')\n\t\t\t\tprint(''.join(ans) + ' ' + str(j + 1) + '\\n')\n\t\t\t\treturn\n\tprint('NO\\n')\nfor nt in range(int(input())):\n\tsolve()\n",
        "slowest_solution": "import sys\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n\treturn int(sys.stdin.readline())\n\ndef LI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n\treturn [LI() for _ in range(rows_number)]\n\ndef LI1():\n\treturn list(map(int1, sys.stdin.readline().split()))\n\ndef LLI1(rows_number):\n\treturn [LI1() for _ in range(rows_number)]\n\ndef SI():\n\treturn sys.stdin.readline().rstrip()\ninf = 4294967295\nmd = 998244353\n\ndef accmin(aa):\n\th = len(aa)\n\tw = len(aa[0])\n\tres = [[inf] * w for _ in range(h)]\n\tres[0][0] = aa[0][0]\n\tfor i in range(1, h):\n\t\tres[i][0] = min(res[i - 1][0], aa[i][0])\n\tfor j in range(1, w):\n\t\tres[0][j] = min(res[0][j - 1], aa[0][j])\n\tfor i in range(1, h):\n\t\tfor j in range(1, w):\n\t\t\tres[i][j] = min(res[i - 1][j], res[i][j - 1], aa[i][j])\n\treturn res\n\ndef accmax(aa):\n\th = len(aa)\n\tw = len(aa[0])\n\tres = [[-1] * w for _ in range(h)]\n\tres[0][0] = aa[0][0]\n\tfor i in range(1, h):\n\t\tres[i][0] = max(res[i - 1][0], aa[i][0])\n\tfor j in range(1, w):\n\t\tres[0][j] = max(res[0][j - 1], aa[0][j])\n\tfor i in range(1, h):\n\t\tfor j in range(1, w):\n\t\t\tres[i][j] = max(res[i - 1][j], res[i][j - 1], aa[i][j])\n\treturn res\n\ndef solve():\n\t(h, w) = LI()\n\taa = LLI(h)\n\tfor i in range(h):\n\t\taa[i].append(i)\n\taa.sort(key=lambda x: x[0])\n\tii = []\n\tfor i in range(h):\n\t\tii.append(aa[i].pop())\n\tlu = accmax(aa)\n\taa.reverse()\n\tld = accmin(aa)\n\tld.reverse()\n\tfor i in range(h):\n\t\taa[i].reverse()\n\trd = accmax(aa)\n\trd.reverse()\n\tfor i in range(h):\n\t\trd[i].reverse()\n\taa.reverse()\n\tru = accmin(aa)\n\tfor i in range(h):\n\t\tru[i].reverse()\n\tans = ['R'] * h\n\tfor i in range(h - 1):\n\t\tfor j in range(w - 1):\n\t\t\tif lu[i][j] < ld[i + 1][j] and ru[i][j + 1] > rd[i + 1][j + 1]:\n\t\t\t\tfor k in ii[:i + 1]:\n\t\t\t\t\tans[k] = 'B'\n\t\t\t\tprint('YES')\n\t\t\t\tprint(''.join(ans), j + 1)\n\t\t\t\treturn\n\tprint('NO')\nfor testcase in range(II()):\n\tsolve()\n"
    },
    {
        "task_id": 315,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 4.372686386108398,
        "fastest_time": 2.41172456741333,
        "fastest_solution": "first_input = list(map(int, input().split()))\nN, Q = first_input[0], first_input[1]\ngiven_array = list(map(int, input().split()))\n\ndef update_array(input_array, given_array):\n\tif input_array[1] < len(given_array):\n\t\tgiven_array[input_array[1] - 1] = input_array[2]\n\nfor _ in range(Q):\n\toperation_input = list(map(int, input().split()))\n\tif len(operation_input) > 2:\n\t\tupdate_array(operation_input, given_array)\n\telse:\n\t\tfor i, item in enumerate(given_array):\n\t\t\tind = None\n\t\t\tif item >= operation_input[1]:\n\t\t\t\tind = i + 1\n\t\t\t\tbreak\n\t\tif ind:\n\t\t\tprint(ind)\n\t\telse:\n\t\t\tprint(-1)\n",
        "slowest_solution": "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\nnNq  = input().split()\nn = int(nNq[0])\nq = int(nNq[1])\n \narr = input().split()\narr_ops = []\nfor i in range(q):\n\tarr_ops.append(input().split())\n\n \ndef doSmOp(arr,new_arr_op):\n\tcount = 1\n\tfor i in arr:\n\t\tif( int(i) >=  int(new_arr_op[1])):\n\t\t\treturn count\n\t\tcount+=1\n\treturn -1\n \nfor new_arr_op in arr_ops:\n\tif( len(new_arr_op)==2):\n\t\tprint(doSmOp(arr,new_arr_op))\n\telse:\n\t\tindex_val = int(new_arr_op[1]) -1\n\t\tarr[index_val] = new_arr_op[2]\n\n\t\n\t\n\n"
    },
    {
        "task_id": 309,
        "slowest_solution_id": 5,
        "fastest_solution_id": 6,
        "slowest_time": 4.258704662322998,
        "fastest_time": 2.9020655155181885,
        "fastest_solution": "class disjointSet:\n\n\tdef __init__(self, n):\n\t\tself.parent = [i for i in range(n)]\n\t\tself.rank = [0] * n\n\n\tdef findParent(self, u):\n\t\tif self.parent[u] != u:\n\t\t\tself.parent[u] = self.findParent(self.parent[u])\n\t\treturn self.parent[u]\n\n\tdef union(self, u, v):\n\t\tu = self.findParent(u)\n\t\tv = self.findParent(v)\n\t\tif self.rank[u] > self.rank[v]:\n\t\t\tself.parent[v] = u\n\t\telif self.rank[u] < self.rank[v]:\n\t\t\tself.parent[u] = v\n\t\telse:\n\t\t\tself.rank[u] += 1\n\t\t\tself.parent[v] = u\n(n, m1, m2) = map(int, input().split())\nm = max(m1, m2)\nset1 = disjointSet(n)\nset2 = disjointSet(n)\nfor _ in range(m1):\n\t(u, v) = map(int, input().split())\n\tset1.union(u - 1, v - 1)\nfor _ in range(m2):\n\t(u, v) = map(int, input().split())\n\tset2.union(u - 1, v - 1)\nprint(n - 1 - m)\nfor i in range(n):\n\tif m == n - 1:\n\t\tbreak\n\tfor j in range(i + 1, n):\n\t\tif m == n - 1:\n\t\t\tbreak\n\t\tif set1.findParent(i) != set1.findParent(j) and set2.findParent(i) != set2.findParent(j):\n\t\t\tset1.union(i, j)\n\t\t\tset2.union(i, j)\n\t\t\tm += 1\n\t\t\tprint(i + 1, j + 1)\n",
        "slowest_solution": "class UnionFind:\n\trank = []\n\tparent = []\n\tn = 0\n\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.rank = [1] * n\n\t\tself.parent = [0] * n\n\t\tfor i in range(n):\n\t\t\tself.parent[i] = i\n\n\tdef get(self, a):\n\t\tself.parent[a] = a if self.parent[a] == a else self.get(self.parent[a])\n\t\treturn self.parent[a]\n\n\tdef merge(self, a, b):\n\t\ta = self.get(a)\n\t\tb = self.get(b)\n\t\tif a == b:\n\t\t\treturn\n\t\tif self.rank[a] == self.rank[b]:\n\t\t\tself.rank[a] += 1\n\t\tif self.rank[a] > self.rank[b]:\n\t\t\tself.parent[b] = a\n\t\telse:\n\t\t\tself.parent[a] = b\n(n, n1, n2) = map(int, input().split(' '))\nu1 = UnionFind(n)\nu2 = UnionFind(n)\nfor i in range(n1):\n\t(a, b) = map(int, input().split(' '))\n\ta -= 1\n\tb -= 1\n\tu1.merge(a, b)\nfor i in range(n2):\n\t(a, b) = map(int, input().split(' '))\n\ta -= 1\n\tb -= 1\n\tu2.merge(a, b)\nans = []\nfor i in range(n):\n\tfor j in range(n):\n\t\tif u1.get(i) != u1.get(j) and u2.get(i) != u2.get(j):\n\t\t\tans.append((i + 1, j + 1))\n\t\t\tu1.merge(i, j)\n\t\t\tu2.merge(i, j)\nprint(len(ans))\nfor x in ans:\n\tprint(*x)\n"
    },
    {
        "task_id": 324,
        "slowest_solution_id": 6,
        "fastest_solution_id": 7,
        "slowest_time": 2.999563694000244,
        "fastest_time": 2.4729692935943604,
        "fastest_solution": "n = int(input())\nA = []\nsum = 0\nfor i in range(n):\n\tx = int(input())\n\tsum += x\n\tA.append(sum / (i + 1))\nprint('%.6f\\n' % max(A))\n",
        "slowest_solution": "tux = int(input())\nfoo = 0\nbar = 0\nbaz = 0\nquz = 1\nfor i in range(0, tux):\n\tpur = int(input())\n\tfoo += pur\n\tbar += 1\n\tif foo * quz > baz * bar:\n\t\tbaz = foo\n\t\tquz = bar\nprint('%.6f' % (baz / quz))\n"
    },
    {
        "task_id": 318,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 3.113478422164917,
        "fastest_time": 2.5173702239990234,
        "fastest_solution": "n = int(input())\nfor i in range(n):\n\t(i, j) = list(map(int, input().split()))\n\tmaxi = max(i, j)\n\tmini = min(i, j)\n\tcount = 0\n\twhile True:\n\t\tif maxi == mini:\n\t\t\tbreak\n\t\telse:\n\t\t\tmaxi = maxi // 2\n\t\t\tcount += 1\n\t\t\tif maxi != max(maxi, mini):\n\t\t\t\t(maxi, mini) = (mini, maxi)\n\tprint(count)\n",
        "slowest_solution": "z = int(input())\nwhile z:\n\tcout = 0\n\t(x, y) = map(int, input().split())\n\twhile x != y:\n\t\tif x > y:\n\t\t\tx = x // 2\n\t\t\tcout = cout + 1\n\t\tif x < y:\n\t\t\ty = y // 2\n\t\t\tcout = cout + 1\n\tprint(cout)\n\tz -= 1\n"
    },
    {
        "task_id": 319,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 3.139369487762451,
        "fastest_time": 2.505082130432129,
        "fastest_solution": "def solve(n, l):\n\tnumbs = [False] * (n + 1)\n\tfor i in l:\n\t\twhile i > n:\n\t\t\ti //= 2\n\t\twhile numbs[i]:\n\t\t\ti //= 2\n\t\tnumbs[i] = 1\n\t\tif numbs[0]:\n\t\t\treturn 'NO'\n\treturn 'YES'\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tprint(solve(n, l))\n",
        "slowest_solution": "from sys import stdin\n\ndef solve():\n\tfor _ in range(int(stdin.readline().strip())):\n\t\tn = int(stdin.readline().rstrip())\n\t\tA = list(map(int, stdin.readline().rstrip().split()))\n\t\tB = [0] * (n + 1)\n\t\tC = []\n\t\tans = 'YES'\n\t\tfor x in A:\n\t\t\tif x <= n:\n\t\t\t\tif B[x] == 0:\n\t\t\t\t\tB[x] = 1\n\t\t\t\telse:\n\t\t\t\t\twhile B[x] == 1 and x > 0:\n\t\t\t\t\t\tx //= 2\n\t\t\t\t\tif x == 0 or B[x] == 1:\n\t\t\t\t\t\tans = 'NO'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tB[x] = 1\n\t\t\telse:\n\t\t\t\tC.append(x)\n\t\tif ans == 'YES':\n\t\t\tfor x in C:\n\t\t\t\twhile x > n:\n\t\t\t\t\tx = x // 2\n\t\t\t\tif B[x] == 0:\n\t\t\t\t\tB[x] = 1\n\t\t\t\telse:\n\t\t\t\t\twhile B[x] == 1 and x > 0:\n\t\t\t\t\t\tx = x // 2\n\t\t\t\t\tif x == 0 or B[x] == 1:\n\t\t\t\t\t\tans = 'NO'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tB[x] = 1\n\t\tif ans == 'YES':\n\t\t\tfor i in range(1, n + 1):\n\t\t\t\tif B[i] != 1:\n\t\t\t\t\tans = 'NO'\n\t\t\t\t\tbreak\n\t\tprint(ans)\nsolve()\n"
    },
    {
        "task_id": 320,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 2.8868408203125,
        "fastest_time": 2.5086705684661865,
        "fastest_solution": "n = int(input())\ntree = list(map(int, input().split()))\ncolors = list(map(int, input().split()))\nans = 0\nfor i in range(1, n):\n\tif colors[i] != colors[tree[i - 1] - 1]:\n\t\tans += 1\nprint(ans + 1)\n",
        "slowest_solution": "def read():\n\treturn tuple((int(x) for x in input().split()))\n\ndef main():\n\t(n,) = read()\n\tedges = read()\n\tsubs = []\n\tfor i in range(n):\n\t\tsubs.append([])\n\tfor (i, x) in enumerate(edges):\n\t\tsubs[x - 1].append(i + 1)\n\tcolors_required = read()\n\tcolors = [0] * n\n\tresult = 0\n\tstack = [0]\n\twhile len(stack) > 0:\n\t\ti = stack.pop()\n\t\tif colors[i] != colors_required[i]:\n\t\t\tresult += 1\n\t\t\tcolors[i] = colors_required[i]\n\t\tfor j in subs[i]:\n\t\t\tcolors[j] = colors[i]\n\t\t\tstack.append(j)\n\treturn result\nprint(main())\n"
    },
    {
        "task_id": 322,
        "slowest_solution_id": 7,
        "fastest_solution_id": 4,
        "slowest_time": 2.8537731170654297,
        "fastest_time": 2.490593671798706,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ti = 0\n\tans = 0\n\twhile i < n:\n\t\tif a[i] == 1:\n\t\t\tans += 1\n\t\tif i + 1 < n and a[i + 1] == 0:\n\t\t\ti += 1\n\t\telif i + 2 < n and a[i + 2] == 1:\n\t\t\ti += 3\n\t\telse:\n\t\t\ti += 2\n\tprint(ans)\n",
        "slowest_solution": "for i in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tk = 0\n\tif a[0] == 1:\n\t\tk = 1\n\ti = 1\n\twhile i < n:\n\t\tif a[i] == 1:\n\t\t\tj = i\n\t\t\twhile j < n and a[j] == 1:\n\t\t\t\tj += 1\n\t\t\tk += (j - i) // 3\n\t\t\ti = j\n\t\telse:\n\t\t\ti += 1\n\tprint(k)\n"
    },
    {
        "task_id": 357,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.7634928226470947,
        "fastest_time": 2.521120071411133,
        "fastest_solution": "import os, sys\nfrom io import IOBase, BytesIO\npy2 = round(0.5)\nif py2:\n\tfrom future_builtins import ascii, filter, hex, map, oct, zip\n\trange = xrange\nBUFSIZE = 8192\n\nclass FastIO(BytesIO):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._file = file\n\t\tself._fd = file.fileno()\n\t\tself.writable = 'x' in file.mode or 'w' in file.mode\n\t\tself.write = super(FastIO, self).write if self.writable else None\n\n\tdef _fill(self):\n\t\ts = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\tself.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n\t\treturn s\n\n\tdef read(self):\n\t\twhile self._fill():\n\t\t\tpass\n\t\treturn super(FastIO, self).read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\ts = self._fill()\n\t\t\tself.newlines = s.count(b'\\n') + (not s)\n\t\tself.newlines -= 1\n\t\treturn super(FastIO, self).readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.getvalue())\n\t\t\t(self.truncate(0), self.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tif py2:\n\t\t\tself.write = self.buffer.write\n\t\t\tself.read = self.buffer.read\n\t\t\tself.readline = self.buffer.readline\n\t\telse:\n\t\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nimport sys\n\nclass ostream:\n\n\tdef __lshift__(self, a):\n\t\tsys.stdout.write(str(a))\n\t\treturn self\ncout = ostream()\nendl = '\\n'\nimport heapq\n\ndef solve():\n\t(n, m, k) = map(int, input().split())\n\tadj_list = {x: [] for x in range(n + 1)}\n\tdist = [float('inf')] * (n + 1)\n\tdist[1] = 0\n\thq = [(0, 1)]\n\tfor _ in range(m):\n\t\t(u, v, x) = map(int, input().split())\n\t\tadj_list[u].append((v, x, False))\n\t\tadj_list[v].append((u, x, False))\n\tfor _ in range(k):\n\t\t(v, y) = map(int, input().split())\n\t\tadj_list[1].append((v, y, True))\n\t\tadj_list[v].append((1, y, True))\n\tvisited = [False] * (n + 1)\n\tprev = {}\n\ttrain_used = [0] * (n + 1)\n\twhile hq:\n\t\t(d, node) = heapq.heappop(hq)\n\t\tif visited[node]:\n\t\t\tcontinue\n\t\tvisited[node] = True\n\t\tfor edge in adj_list[node]:\n\t\t\t(nxt, w, isTrain) = edge\n\t\t\tif not visited[nxt]:\n\t\t\t\tif d + w < dist[nxt]:\n\t\t\t\t\tdist[nxt] = d + w\n\t\t\t\t\tif isTrain:\n\t\t\t\t\t\ttrain_used[nxt] = 1\n\t\t\t\tif d + w == dist[nxt] and train_used[nxt] == 1 and (not isTrain):\n\t\t\t\t\ttrain_used[nxt] = 0\n\t\t\t\theapq.heappush(hq, (d + w, nxt))\n\tcout << k - sum(train_used) << '\\n'\n\ndef main():\n\tsolve()\nmain()\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nimport heapq\n(n, m, k) = map(int, input().split())\nadj = [[] for _ in range(n + 5)]\nfor _ in range(m):\n\t(u, v, w) = map(int, input().split())\n\tadj[u].append((v, w))\n\tadj[v].append((u, w))\ntrain = [-1 for _ in range(n + 5)]\nans = 0\ndist = [int(1000000000000000.0) for _ in range(n + 5)]\npq = []\nfor _ in range(k):\n\t(s, y) = map(int, input().split())\n\tif train[s] != -1:\n\t\tans += 1\n\t\ttrain[s] = min(train[s], y)\n\t\tdist[s] = train[s]\n\t\tcontinue\n\ttrain[s] = y\n\tdist[s] = y\nfor i in range(n + 5):\n\tif dist[i] != -1:\n\t\theapq.heappush(pq, (dist[i], i))\nheapq.heappush(pq, (0, 1))\ndist[1] = 0\ncut = [0 for _ in range(n + 5)]\nvis = [0 for _ in range(n + 5)]\nwhile pq:\n\t(dummy, u) = heapq.heappop(pq)\n\tif vis[u]:\n\t\tcontinue\n\tvis[u] = 1\n\tfor (v, w) in adj[u]:\n\t\tif dist[v] >= dist[u] + w:\n\t\t\tif dist[v] != dist[u] + w:\n\t\t\t\theapq.heappush(pq, (dist[u] + w, v))\n\t\t\tdist[v] = dist[u] + w\n\t\t\tif train[v] != -1:\n\t\t\t\tcut[v] = 1\nfor b in cut:\n\tif b == 1:\n\t\tans += 1\nprint(ans)\n"
    },
    {
        "task_id": 365,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5286762714385986,
        "fastest_time": 2.5286762714385986,
        "fastest_solution": "mod = 1000000007\nfact = [1]\nfor i in range(1, 5003):\n\tfact.append(i * fact[i - 1] % mod)\ninv = []\nfor j in range(5003):\n\tnv = pow(fact[j], mod - 2, mod)\n\tinv.append(nv)\nfor j in range(int(input())):\n\tl = input()\n\tfour = l.count('4')\n\tseven = l.count('7')\n\tif four == 0 or seven == 0:\n\t\tprint(1)\n\telse:\n\t\tans = fact[len(l)] * inv[four] * inv[len(l) - four] % mod\n\t\tans = (ans - fact[len(l) - 2] * inv[four - 1] * inv[len(l) - 1 - four]) % mod\n\t\tprint(ans % mod)\n",
        "slowest_solution": "mod = 1000000007\nfact = [1]\nfor i in range(1, 5003):\n\tfact.append(i * fact[i - 1] % mod)\ninv = []\nfor j in range(5003):\n\tnv = pow(fact[j], mod - 2, mod)\n\tinv.append(nv)\nfor j in range(int(input())):\n\tl = input()\n\tfour = l.count('4')\n\tseven = l.count('7')\n\tif four == 0 or seven == 0:\n\t\tprint(1)\n\telse:\n\t\tans = fact[len(l)] * inv[four] * inv[len(l) - four] % mod\n\t\tans = (ans - fact[len(l) - 2] * inv[four - 1] * inv[len(l) - 1 - four]) % mod\n\t\tprint(ans % mod)\n"
    },
    {
        "task_id": 326,
        "slowest_solution_id": 6,
        "fastest_solution_id": 3,
        "slowest_time": 2.865837335586548,
        "fastest_time": 2.445974111557007,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tA = list(map(int, input().split()))\n\ta = []\n\tfor i in range(m):\n\t\ta.append([A[i], i])\n\ta.sort()\n\tb = [0] * m\n\ts = 0\n\tfor i in range(m):\n\t\tb[a[i][1]] = 1\n\t\ts = s + sum(b[0:a[i][1]])\n\tA.sort()\n\ti = 0\n\twhile i < m:\n\t\tc = A.count(A[i])\n\t\ts = s - (c * (c - 1) >> 1)\n\t\ti = i + c\n\tprint(s)\n",
        "slowest_solution": "try:\n\tT = int(input())\n\tfor i in range(T):\n\t\t(n, m) = map(int, input().split())\n\t\tL = list(map(int, input().split()))\n\t\tcnt = 0\n\t\tfor i in range(1, len(L)):\n\t\t\tfor j in range(i - 1, -1, -1):\n\t\t\t\tif L[j] < L[i]:\n\t\t\t\t\tcnt += 1\n\t\tprint(cnt)\nexcept:\n\tpass\n"
    },
    {
        "task_id": 366,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7452516555786133,
        "fastest_time": 2.7452516555786133,
        "fastest_solution": "from bisect import insort_left\n(n, q) = map(int, input().split(' '))\na = [[i] for i in range(1, n + 1)]\nwhile q > 0:\n\tinp = input().split(' ')\n\tx = int(inp[1]) - 1\n\ty = int(inp[2]) - 1\n\tif inp[0] == 'UNION':\n\t\tif len(a[x]) > len(a[y]):\n\t\t\ta.append(a[x])\n\t\t\tfor j in a[y]:\n\t\t\t\tinsort_left(a[x], j)\n\t\telse:\n\t\t\ta.append(a[y])\n\t\t\tfor j in a[x]:\n\t\t\t\tinsort_left(a[y], j)\n\t\ta[x] = a[y] = 0\n\telif inp[0] == 'GET':\n\t\tprint(a[x][y])\n\tq -= 1\n",
        "slowest_solution": "from bisect import insort_left\n(n, q) = map(int, input().split(' '))\na = [[i] for i in range(1, n + 1)]\nwhile q > 0:\n\tinp = input().split(' ')\n\tx = int(inp[1]) - 1\n\ty = int(inp[2]) - 1\n\tif inp[0] == 'UNION':\n\t\tif len(a[x]) > len(a[y]):\n\t\t\ta.append(a[x])\n\t\t\tfor j in a[y]:\n\t\t\t\tinsort_left(a[x], j)\n\t\telse:\n\t\t\ta.append(a[y])\n\t\t\tfor j in a[x]:\n\t\t\t\tinsort_left(a[y], j)\n\t\ta[x] = a[y] = 0\n\telif inp[0] == 'GET':\n\t\tprint(a[x][y])\n\tq -= 1\n"
    },
    {
        "task_id": 330,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.748795509338379,
        "fastest_time": 2.5322015285491943,
        "fastest_solution": "l1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm']\nl2 = ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\nfor _ in range(int(input())):\n\ts = input().split()\n\tc = int(s[0])\n\td = e = f = ans = 0\n\ta = s[1:]\n\tfor i in range(len(a)):\n\t\td = e = 0\n\t\tfor j in range(len(a[i])):\n\t\t\tt = a[i]\n\t\t\tif t[j] in l1:\n\t\t\t\td += 1\n\t\t\telif t[j] in l2:\n\t\t\t\te += 1\n\t\tif len(a[i]) == d or len(a[i]) == e:\n\t\t\tans += 1\n\tif ans == c:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "for i in range(int(input())):\n\tarr = list(input().split())\n\tlist1 = list('abcdefghijklm')\n\tlist2 = list('NOPQRSTUVWXYZ')\n\tfor i in range(1, len(arr)):\n\t\tlist3 = list(arr[i])\n\t\tch = list3[0]\n\t\tx = len(list3)\n\t\tif x >= 2:\n\t\t\tif ch in list1:\n\t\t\t\tfor j in range(1, x):\n\t\t\t\t\tif list3[j] in list1:\n\t\t\t\t\t\tcontinue\n\t\t\t\tif list3[j] not in list1:\n\t\t\t\t\tprint('NO')\n\t\t\t\t\tbreak\n\t\t\telif ch not in list1 and ch not in list2:\n\t\t\t\tprint('NO')\n\t\t\t\tbreak\n\t\t\tif ch in list2:\n\t\t\t\tfor k in range(1, x):\n\t\t\t\t\tif list3[k] in list2:\n\t\t\t\t\t\tcontinue\n\t\t\t\tif list3[k] not in list2:\n\t\t\t\t\tprint('NO')\n\t\t\t\t\tbreak\n\t\t\telif ch not in list2 and ch not in list1:\n\t\t\t\tprint('NO')\n\t\t\t\tbreak\n\t\telif x < 2:\n\t\t\tif ch in list1 or ch in list2:\n\t\t\t\tpass\n\t\t\telif ch not in list1 and ch not in list2:\n\t\t\t\tprint('NO')\n\t\t\t\tbreak\n\t\tif i == len(arr) - 1:\n\t\t\tprint('YES')\n"
    },
    {
        "task_id": 332,
        "slowest_solution_id": 5,
        "fastest_solution_id": 3,
        "slowest_time": 2.8412208557128906,
        "fastest_time": 2.4059669971466064,
        "fastest_solution": "T = int(input())\nfor i in range(T):\n\tp = float(input())\n\tsum = 0\n\tif p < 0.5:\n\t\tm = (1 - p) * 10000\n\t\tsum += m + 2 * p * m\n\telif p == 1:\n\t\tsum += 10000\n\telse:\n\t\tm = p * 10000\n\t\tsum += m + 2 * (1 - p) * m\n\tprint(sum)\n",
        "slowest_solution": "for tc in range(int(input())):\n\tx = float(input())\n\tn = max(x, 1 - x)\n\tans = 2 * (1 - n) * (10000 * n) + 10000 * n\n\tprint('{:.6f}'.format(ans))\n"
    },
    {
        "task_id": 304,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 6.422002077102661,
        "fastest_time": 2.672318458557129,
        "fastest_solution": "import sys\nimport math\nsys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\n\ndef subTreeSizes(el, root, visited, sizes):\n\tif not visited[root]:\n\t\tvisited[root] = True\n\t\tsize = 1\n\t\tfor u in el[root]:\n\t\t\tsubTreeSizes(el, u, visited, sizes)\n\t\t\tsize += sizes[u]\n\t\tsizes[root] = size\n\treturn sizes\n\ndef countOrderings(sizes):\n\tresult = 1\n\tfor i in range(2, len(sizes) + 1):\n\t\tresult *= i\n\t\tresult %= MOD\n\tden = 1\n\tfor size in sizes:\n\t\tden *= size\n\t\tden %= MOD\n\tresult *= pow(den, MOD - 2, MOD)\n\treturn result % MOD\n\ndef subTreeProds(el, visited, sizes, products, root=0, parent=0):\n\tif not visited[root]:\n\t\tvisited[root] = True\n\t\tif root == 0:\n\t\t\tproducts[0] = 0\n\t\t\tfor size in sizes:\n\t\t\t\tproducts[0] += math.log(size)\n\t\t\tfor u in el[root]:\n\t\t\t\tsubTreeProds(el, visited, sizes, products, u, root)\n\t\telse:\n\t\t\told_size_parent = sizes[parent]\n\t\t\told_size_root = sizes[root]\n\t\t\tsizes[root] = old_size_parent\n\t\t\tsizes[parent] = old_size_parent - old_size_root\n\t\t\tproducts[root] = products[parent] - math.log(old_size_root) + math.log(sizes[parent])\n\t\t\tfor u in el[root]:\n\t\t\t\tsubTreeProds(el, visited, sizes, products, u, root)\n\t\t\tsizes[parent] = old_size_parent\n\t\t\tsizes[root] = old_size_root\n\ndef solve(el, K):\n\tsizes = subTreeSizes(el, 0, [False] * len(el), [0] * len(el))\n\tproducts = [0] * len(el)\n\tsubTreeProds(el, [False] * len(el), sizes, products)\n\tpairlist = []\n\tfor index in range(len(products)):\n\t\tpairlist.append((products[index], -index))\n\tpairlist.sort()\n\troot = -pairlist[K - 1][1]\n\tsizes = subTreeSizes(el, root, [False] * len(el), [0] * len(el))\n\treturn (root + 1, countOrderings(sizes))\nfor _ in range(int(input())):\n\t(N, K) = map(int, input().split())\n\tel = [[] for _ in range(N)]\n\tfor _ in range(N - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tu -= 1\n\t\tv -= 1\n\t\tel[u].append(v)\n\t\tel[v].append(u)\n\tprint(*solve(el, K))\n",
        "slowest_solution": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\n\ndef dfscent(adj, v, par, n, centroid, sz):\n\tsz[v] = 1\n\tiscentroid = True\n\tfor a in adj[v]:\n\t\tif a != par:\n\t\t\tdfscent(adj, a, v, n, centroid, sz)\n\t\t\tsz[v] += sz[a]\n\t\t\tif sz[a] > n / 2:\n\t\t\t\tiscentroid = False\n\tif n - sz[v] > n / 2:\n\t\tiscentroid = False\n\tif iscentroid:\n\t\tcentroid.append(v)\n\ndef findCentroid(adj, n, sz):\n\tcentroid = []\n\tdfscent(adj, 0, -1, n, centroid, sz)\n\treturn max(centroid)\n\ndef topoval(adj, v, par, dp, sz):\n\tdp[v] = 1\n\tsz[v] = 1\n\tfor a in adj[v]:\n\t\tif a != par:\n\t\t\ttopoval(adj, a, v, dp, sz)\n\t\t\tdp[v] = dp[v] * dp[a] % MOD\n\t\t\tdp[v] = dp[v] * invfact[sz[a]] % MOD\n\t\t\tsz[v] += sz[a]\n\tdp[v] = dp[v] * fact[sz[v] - 1] % MOD\n\treturn dp[v] % MOD\nfact = [1] * (5 * 10 ** 5 + 10)\ninvfact = [1] * (5 * 10 ** 5 + 10)\nfor i in range(1, len(fact)):\n\tfact[i] = fact[i - 1] * i % MOD\n\tinvfact[i] = pow(fact[i], MOD - 2, MOD)\nfor _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tadj = [[] for _ in range(int(n))]\n\tfor _ in range(int(n - 1)):\n\t\t(u, v) = map(int, input().split())\n\t\tadj[u - 1].append(v - 1)\n\t\tadj[v - 1].append(u - 1)\n\tsz = [0] * n\n\tfirst = findCentroid(adj, n, sz)\n\tdp = [-1] * n\n\tfirstans = topoval(adj, first, -1, dp, sz)\n\tif k == 1:\n\t\tprint(first + 1, firstans)\n\telse:\n\t\tsecond = adj[first][0]\n\t\tfor v in adj[first]:\n\t\t\tif sz[v] > sz[second]:\n\t\t\t\tsecond = v\n\t\t\tif sz[v] == sz[second] and v > second:\n\t\t\t\tsecond = v\n\t\tsecondans = topoval(adj, second, -1, dp, sz)\n\t\tprint(second + 1, secondans)\n"
    },
    {
        "task_id": 333,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.897925615310669,
        "fastest_time": 2.454554319381714,
        "fastest_solution": "(n, k) = list(map(int, input().split()))\narr = list(map(int, input().split()))\nprev = 0\nbags = 0\nfor i in range(n):\n\tif (arr[i] + prev) // k == 0:\n\t\tif prev > 0:\n\t\t\tbags += 1\n\t\t\tprev = 0\n\t\telse:\n\t\t\tprev = arr[i]\n\telse:\n\t\tbags += (arr[i] + prev) // k\n\t\tprev = (arr[i] + prev) % k\nif prev != 0:\n\tbags += 1\nprint(bags)\n",
        "slowest_solution": "(n, k) = map(int, input().split())\nnums = list(map(int, input().split()))\nresult = 0\nremain = 0\nfor num in nums:\n\tif not (num + remain) // k and remain:\n\t\tresult += 1\n\t\tremain = 0\n\t\tcontinue\n\tresult += (num + remain) // k\n\tremain = (num + remain) % k\nif remain:\n\tresult += 1\nprint(result)\n"
    },
    {
        "task_id": 334,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 2.7607622146606445,
        "fastest_time": 2.4898080825805664,
        "fastest_solution": "q = input()\nn = int(q.split()[0])\nt = int(q.split()[1])\nl = list(input())\nz = list(l)\nfor i in range(t):\n\tfor j in range(1, n):\n\t\tif l[j] == 'G' and l[j - 1] == 'B':\n\t\t\t(z[j], z[j - 1]) = (z[j - 1], z[j])\n\tl = list(z)\nfor i in l:\n\tprint(i, end='')\nprint()\n",
        "slowest_solution": "x = input().split()\ny = input()\nm = int(x[1])\nfor i in y:\n\tif i == 'B':\n\t\twhile m != 0:\n\t\t\ty = y.replace('BG', 'GB')\n\t\t\tm = m - 1\nprint(y)\n"
    },
    {
        "task_id": 348,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.8929061889648438,
        "fastest_time": 2.5391571521759033,
        "fastest_solution": "import sys\nfrom collections import deque, Counter\nfrom itertools import product\nfrom functools import reduce\ninput = sys.stdin.buffer.readline\nn = int(input())\nls = list(map(int, input().split()))\nmx = max(ls)\npr = [i for i in range(mx + 1)]\nfor u in range(2, mx + 1):\n\tif u * u > mx:\n\t\tbreak\n\tif pr[u] == u:\n\t\tfor v in range(u * 2, mx + 1, u):\n\t\t\tpr[v] = min(pr[v], u)\n\ndef get_fac(n):\n\tfac = []\n\twhile n > 1:\n\t\tp = pr[n]\n\t\tif not fac or fac[-1] != p:\n\t\t\tfac.append(p)\n\t\tn //= p\n\treturn fac\n(d1, d2) = ([], [])\nfor u in ls:\n\tf = get_fac(u)\n\tif len(f) < 2:\n\t\td1.append(-1)\n\t\td2.append(-1)\n\telse:\n\t\td1.append(f[0])\n\t\td2.append(reduce(lambda x, y: x * y, f[1:]))\nprint(*d1)\nprint(*d2)\n",
        "slowest_solution": "(n, a) = (int(input()), list(map(int, input().split(' '))))\nMX = max(a) + 5\nseive = MX * [-1]\nans_d1 = []\nans_d2 = []\nfor i in range(2, MX):\n\tif seive[i] == -1:\n\t\tseive[i] = i\n\t\tj = i * i\n\t\twhile j < MX:\n\t\t\tif seive[j] == -1:\n\t\t\t\tseive[j] = i\n\t\t\tj += i\nfor i in a:\n\tk = i\n\twhile k % seive[i] == 0:\n\t\tk = k // seive[i]\n\tif k == 1:\n\t\tans_d1.append(-1)\n\t\tans_d2.append(-1)\n\telse:\n\t\tans_d1.append(seive[i])\n\t\tans_d2.append(k)\nprint(*ans_d1)\nprint(*ans_d2)\n"
    },
    {
        "task_id": 321,
        "slowest_solution_id": 5,
        "fastest_solution_id": 2,
        "slowest_time": 4.2234108448028564,
        "fastest_time": 2.6159186363220215,
        "fastest_solution": "def main():\n\tinput()\n\tl = [0] * 1000001\n\tfor w in map(int, input().split()):\n\t\tl[w] += 1\n\tt = rest = 0\n\tfor x in l:\n\t\tt += x\n\t\tif t & 1:\n\t\t\trest += 1\n\t\tt >>= 1\n\tprint(bin(t).count('1') + rest)\nmain()\n",
        "slowest_solution": "def ok(x):\n\tif x == 0:\n\t\treturn False\n\treturn x & x - 1\nn = int(input())\narr = list(map(int, input().split()))\nf = [0] * 2000020\nfor i in arr:\n\tf[i] += 1\nans = 0\nfor i in range(2000010):\n\tif f[i] % 2 == 1:\n\t\tans += 1\n\t\tf[i] -= 1\n\tf[i + 1] += f[i] // 2\nprint(ans)\n"
    },
    {
        "task_id": 344,
        "slowest_solution_id": 6,
        "fastest_solution_id": 9,
        "slowest_time": 2.7251996994018555,
        "fastest_time": 2.5927844047546387,
        "fastest_solution": "import heapq\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = [[] for _ in range(n)]\nfor i in range(n):\n\ta[i] = [int(j) for j in input().split()]\nbuilds = [(-sum((a[i][-1] for i in range(n))), tuple((a[i][0] for i in range(n))))]\nm = int(input())\nbanned = set()\nfor _ in range(m):\n\tbanned.add(tuple((int(i) for i in input().split())))\ndone = False\nseen = set()\nwhile not done:\n\t(c_sum, c) = heapq.heappop(builds)\n\tif c not in banned:\n\t\tdone = True\n\telse:\n\t\tfor i in range(n):\n\t\t\tif c[i] > 1:\n\t\t\t\td = tuple((c[j] - 1 if j == i else c[j] for j in range(n)))\n\t\t\t\tif d not in seen:\n\t\t\t\t\tseen.add(d)\n\t\t\t\t\td_sum = sum((a[j][d[j]] for j in range(n)))\n\t\t\t\t\theapq.heappush(builds, (-d_sum, d))\nprint(*c)\n",
        "slowest_solution": "import sys, os\nfrom io import BytesIO, IOBase\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(stdin, stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\nmod = pow(10, 9) + 7\nmod2 = 998244353\n\ndef inp():\n\treturn stdin.readline().strip()\n\ndef iinp():\n\treturn int(inp())\n\ndef out(var, end='\\n'):\n\tstdout.write(str(var) + '\\n')\n\ndef outa(*var, end='\\n'):\n\tstdout.write(' '.join(map(str, var)) + end)\n\ndef lmp():\n\treturn list(mp())\n\ndef mp():\n\treturn map(int, inp().split())\n\ndef l1d(n, val=0):\n\treturn [val for i in range(n)]\n\ndef l2d(n, m, val=0):\n\treturn [l1d(m, val) for j in range(n)]\n\ndef ceil(a, b):\n\treturn (a + b - 1) // b\nS1 = 'abcdefghijklmnopqrstuvwxyz'\nS2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef isprime(x):\n\tif x <= 1:\n\t\treturn False\n\tif x in (2, 3):\n\t\treturn True\n\tif x % 2 == 0:\n\t\treturn False\n\tfor i in range(3, int(sqrt(x)) + 1, 2):\n\t\tif x % i == 0:\n\t\t\treturn False\n\treturn True\nn = iinp()\nbuilds = [lmp()[1:] for i in range(n)]\nm = iinp()\nwrong = set([tuple(mp()) for i in range(m)])\ntup = tuple((len(i) for i in builds))\nhp = [(-sum(tup), tup)]\ntot = set([tup])\nwhile hp:\n\t(sm1, tup) = heappop(hp)\n\tif tup not in wrong:\n\t\tprint(*tup)\n\t\tbreak\n\tl = list(tup)\n\tfor i in range(n):\n\t\tsm = -sm1\n\t\tlis = l.copy()\n\t\tif lis[i] == 1:\n\t\t\tcontinue\n\t\tlis[i] -= 1\n\t\tsm += builds[i][lis[i] - 1] - builds[i][lis[i]]\n\t\ttup = tuple(lis)\n\t\tif tup not in tot:\n\t\t\ttot.add(tup)\n\t\t\theappush(hp, (-sm, tup))\n"
    },
    {
        "task_id": 339,
        "slowest_solution_id": 5,
        "fastest_solution_id": 7,
        "slowest_time": 2.8155109882354736,
        "fastest_time": 2.460341215133667,
        "fastest_solution": "import math\ninf = 998244353\nimport sys\n\ndef gcd(a, b):\n\tif a == 1:\n\t\treturn 1\n\telse:\n\t\treturn gcd(b % a, b) * (b - b // a) % b\n\ndef mult(a, b):\n\tstuff = 1\n\tfor i in range(a, b + 1):\n\t\tstuff = stuff * i % inf\n\treturn stuff\n\ndef mult2(a, b):\n\tstuff = 1\n\tfor i in range(a, b + 1):\n\t\tstuff = stuff * gcd(i, inf) % inf\n\treturn stuff\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n\tle = int(input())\n\ts = list(map(str, input().strip()))\n\ttwos = 0\n\tzero = 0\n\ttemp = None\n\tfor i in s:\n\t\tif i == '1' and temp == None:\n\t\t\ttemp = 1\n\t\telif i == '1' and temp == 1:\n\t\t\ttemp = None\n\t\t\ttwos += 1\n\t\telse:\n\t\t\ttemp = None\n\t\t\tzero += 1\n\tprint(mult(1, zero + twos) * mult2(1, zero) * mult2(1, twos) % inf)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nmax_n = 10 ** 5\n(fact, inv_fact) = ([0] * (max_n + 1), [0] * (max_n + 1))\nfact[0] = 1\nmod = 998244353\n\ndef make_nCr_mod():\n\tglobal fact\n\tglobal inv_fact\n\tfor i in range(max_n):\n\t\tfact[i + 1] = fact[i] * (i + 1) % mod\n\tinv_fact[-1] = pow(fact[-1], mod - 2, mod)\n\tfor i in reversed(range(max_n)):\n\t\tinv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\nmake_nCr_mod()\n\ndef nCr_mod(n, r):\n\tglobal fact\n\tglobal inv_fact\n\tres = 1\n\twhile n or r:\n\t\t(a, b) = (n % mod, r % mod)\n\t\tif a < b:\n\t\t\treturn 0\n\t\tres = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n\t\tn //= mod\n\t\tr //= mod\n\treturn res\nt = int(input())\nfor _ in range(t):\n\tlength = int(input())\n\tl = input().rstrip()\n\tr = 0\n\ttmp = 1\n\tfor i in range(1, length):\n\t\tif l[i] == '0':\n\t\t\tcontinue\n\t\tif l[i] == l[i - 1] == '1':\n\t\t\ttmp += 1\n\t\telse:\n\t\t\tr += tmp // 2\n\t\t\ttmp = 1\n\tr += tmp // 2\n\tn = l.count('0')\n\tprint(nCr_mod(n + r, r))\n"
    },
    {
        "task_id": 329,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 4.678105592727661,
        "fastest_time": 3.096261501312256,
        "fastest_solution": "from sys import *\nws = lambda : map(int, stdin.readline().strip().split())\nli = lambda : list(map(int, stdin.readline().strip().split()))\nmod = 1000000007\n\ndef ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\ndef prod(l):\n\tans = 1\n\tfor i in range(len(l)):\n\t\tans = ans * l[i]\n\treturn ans\n\ndef sortindex(l, a):\n\tc = []\n\tif a == -1:\n\t\trev = True\n\telse:\n\t\trev = False\n\tfor i in range(len(l)):\n\t\tc.append([l[i], i])\n\tx = sorted(c, reverse=rev)\n\tprint(x)\n\tc = []\n\tfor i in range(len(l)):\n\t\tc.append(x[i][1])\n\treturn c\n\ndef modInverse(a, m):\n\tg = gcd(a, m)\n\tif g != 1:\n\t\treturn -1\n\telse:\n\t\treturn pow(a, m - 2, m)\nn = int(input())\nnew = 1\nnum = 2\nden = 1\nwhile n > 1:\n\tnum = (num * (2 * new + 1) + 2 * den) % 998244353\n\tden = den * (2 * new + 1) % 998244353\n\tnew += 1\n\tn -= 1\nprint(num * modInverse(den, 998244353) % 998244353)\n",
        "slowest_solution": "from fractions import Fraction\nN = int(input())\nsu = 0\nm = 998244353\nfor i in range(0, N):\n\tsu = su + 2 * pow(2 * i + 1, m - 2, m) % m\nprint(su % m)\n"
    },
    {
        "task_id": 341,
        "slowest_solution_id": 3,
        "fastest_solution_id": 1,
        "slowest_time": 2.8428187370300293,
        "fastest_time": 2.39243221282959,
        "fastest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tidx = l.index(max(l))\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif l[i] != l[j]:\n\t\t\t\tl[i] = min(l[i] & l[j], l[j])\n\tprint(l[idx])\n",
        "slowest_solution": "count = int(input())\nfor _ in range(count):\n\tnumber = int(input())\n\tli1 = input().split()\n\tli2 = [int(i) for i in li1]\n\td = max(li2)\n\tfor i in li2:\n\t\td = d & i\n\tprint(d)\n"
    },
    {
        "task_id": 387,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "from collections import deque\n\ndef tree_by_levels(node):\n\tif not node:\n\t\treturn []\n\t(res, queue) = ([], deque([node]))\n\twhile queue:\n\t\tn = queue.popleft()\n\t\tres.append(n.value)\n\t\tif n.left is not None:\n\t\t\tqueue.append(n.left)\n\t\tif n.right is not None:\n\t\t\tqueue.append(n.right)\n\treturn res\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 382,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6653389930725098,
        "fastest_time": 2.6653389930725098,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n\ndef solve(l: int, r: int, s: set):\n\tif l % 2 == 0 and r % 2 == 1:\n\t\tt = set()\n\t\tfor v in s:\n\t\t\tt.add(v >> 1)\n\t\treturn solve(l >> 1, r >> 1, t) << 1\n\telse:\n\t\tfor v in s:\n\t\t\tif v ^ 1 not in s:\n\t\t\t\tok = True\n\t\t\t\tans = v\n\t\t\t\tif l % 2 == 0:\n\t\t\t\t\tans ^= r\n\t\t\t\telse:\n\t\t\t\t\tans ^= l\n\t\t\t\tfor x in s:\n\t\t\t\t\tif x ^ ans < l or x ^ ans > r:\n\t\t\t\t\t\tok = False\n\t\t\t\t\t\tbreak\n\t\t\t\tif ok:\n\t\t\t\t\treturn ans\nt = int(input())\nfor _ in range(t):\n\t(l, r) = map(int, input().split())\n\ts = set(map(int, input().split()))\n\tprint(solve(l, r, s))\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef solve(l: int, r: int, s: set):\n\tif l % 2 == 0 and r % 2 == 1:\n\t\tt = set()\n\t\tfor v in s:\n\t\t\tt.add(v >> 1)\n\t\treturn solve(l >> 1, r >> 1, t) << 1\n\telse:\n\t\tfor v in s:\n\t\t\tif v ^ 1 not in s:\n\t\t\t\tok = True\n\t\t\t\tans = v\n\t\t\t\tif l % 2 == 0:\n\t\t\t\t\tans ^= r\n\t\t\t\telse:\n\t\t\t\t\tans ^= l\n\t\t\t\tfor x in s:\n\t\t\t\t\tif x ^ ans < l or x ^ ans > r:\n\t\t\t\t\t\tok = False\n\t\t\t\t\t\tbreak\n\t\t\t\tif ok:\n\t\t\t\t\treturn ans\nt = int(input())\nfor _ in range(t):\n\t(l, r) = map(int, input().split())\n\ts = set(map(int, input().split()))\n\tprint(solve(l, r, s))\n"
    },
    {
        "task_id": 346,
        "slowest_solution_id": 4,
        "fastest_solution_id": 7,
        "slowest_time": 2.7466766834259033,
        "fastest_time": 2.5346767902374268,
        "fastest_solution": "def dfs_paths(graph, start, goal, path=list()):\n\tif not path:\n\t\tpath.append(start)\n\tif start == goal:\n\t\tyield path\n\tfor vertex in graph[start] - set(path):\n\t\tyield from dfs_paths(graph, vertex, goal, path=path + [vertex])\n(n, m) = map(int, input().split())\ngraph = {}\nfor _ in range(m):\n\t(a, b, c) = map(int, input().split())\n\tif c not in graph:\n\t\tgraph[c] = {}\n\tif a not in graph[c]:\n\t\tgraph[c][a] = set()\n\tif b not in graph[c]:\n\t\tgraph[c][b] = set()\n\tgraph[c][a].add(b)\n\tgraph[c][b].add(a)\nq = int(input())\nfor _ in range(q):\n\t(u, v) = map(int, input().split())\n\tcount = 0\n\tfor k in graph:\n\t\tif u not in graph[k] or v not in graph[k]:\n\t\t\tcontinue\n\t\tif len(list(dfs_paths(graph[k], u, v, []))) > 0:\n\t\t\tcount += 1\n\tprint(count)\n",
        "slowest_solution": "def create_adj(edge):\n\tedges = {}\n\tfor u in edge:\n\t\tif u[0] in edges.keys():\n\t\t\tedges[u[0]].append(u[1])\n\t\telse:\n\t\t\tedges[u[0]] = [u[1]]\n\treturn edges\n\ndef explore(adj, v, visited):\n\tvisited[v] = True\n\tfor i in adj[v]:\n\t\tif visited[i] == False:\n\t\t\texplore(adj, i, visited)\n\ndef find(adj, u, v):\n\tglobal c\n\tif u not in adj.keys() or v not in adj.keys():\n\t\treturn\n\tvisited = {}\n\tfor r in adj.keys():\n\t\tvisited[r] = False\n\texplore(adj, u, visited)\n\tif visited[v] == True:\n\t\tc = c + 1\n\treturn c\n(n, m) = map(int, input().split())\nht = {}\nfor i in range(m):\n\t(a, b, c) = map(int, input().split())\n\tif c in ht.keys():\n\t\tht[c].append([a, b])\n\t\tht[c].append([b, a])\n\telse:\n\t\tht[c] = [[a, b], [b, a]]\nq = int(input())\nc = 0\nfor j in range(q):\n\tc = 0\n\t(u, v) = map(int, input().split())\n\tfor y in ht.keys():\n\t\tadj = create_adj(ht[y])\n\t\tfind(adj, u, v)\n\tprint(c)\n"
    },
    {
        "task_id": 377,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.688128709793091,
        "fastest_time": 2.589963674545288,
        "fastest_solution": "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nMOD = 998244353\nt = int(input())\nwhile t > 0:\n\tt -= 1\n\tn = int(input())\n\tg = [[] for i in range(n)]\n\tfor i in range(n - 1):\n\t\t(x, y) = map(int, input().split())\n\t\tg[x - 1] += [y - 1]\n\t\tg[y - 1] += [x - 1]\n\tf = [0] * n\n\tparent = [0] * n\n\tf[1] = pow(2, n - 1, MOD)\n\torder = [0]\n\tfor v in order:\n\t\tfor u in g[v]:\n\t\t\tif u != parent[v]:\n\t\t\t\tparent[u] = v\n\t\t\t\torder += [u]\n\n\tdef dfs(k):\n\t\tsize = [0] * n\n\t\tfor v in reversed(order):\n\t\t\tif size[v] % k == 0:\n\t\t\t\tif v != 0:\n\t\t\t\t\tsize[parent[v]] += 1\n\t\t\telif v == 0 or (size[v] + 1) % k != 0:\n\t\t\t\treturn False\n\t\treturn True\n\tfor i in range(2, n):\n\t\tif (n - 1) % i == 0:\n\t\t\tf[i] = int(dfs(i))\n\th = [0] * (n + 1)\n\tfor i in range(n - 1, 0, -1):\n\t\th[i] = f[i]\n\t\tfor j in range(i * 2, n, i):\n\t\t\th[i] -= h[j]\n\tprint(*(x for x in h[1:n + 1]))\n",
        "slowest_solution": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef NC_Dij(lis, start):\n\tret = [float('inf')] * len(lis)\n\tret[start] = 0\n\tq = deque([start])\n\tplis = [i for i in range(len(lis))]\n\twhile len(q) > 0:\n\t\tnow = q.popleft()\n\t\tfor nex in lis[now]:\n\t\t\tif ret[nex] > ret[now] + 1:\n\t\t\t\tret[nex] = ret[now] + 1\n\t\t\t\tplis[nex] = now\n\t\t\t\tq.append(nex)\n\treturn (ret, plis)\n\ndef search(k):\n\tenum = [len(lis[i]) for i in range(n)]\n\table = [True] * n\n\tfor (d, v) in dv:\n\t\table[v] = False\n\t\tfor nex in lis[v]:\n\t\t\tif able[nex] and enum[v] % k != 0:\n\t\t\t\tenum[v] -= 1\n\t\t\telif able[nex]:\n\t\t\t\tenum[nex] -= 1\n\t\tif enum[v] % k != 0:\n\t\t\treturn False\n\treturn True\nmod = 998244353\nfor loop in range(int(input())):\n\tn = int(input())\n\tlis = [[] for i in range(n)]\n\tenum = [0] * n\n\tfor i in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tu -= 1\n\t\tv -= 1\n\t\tlis[u].append(v)\n\t\tlis[v].append(u)\n\t\tenum[u] += 1\n\t\tenum[v] += 1\n\tif n == 2:\n\t\tprint(2, 0)\n\t\tcontinue\n\tfor i in range(n):\n\t\tif len(lis[i]) == 1:\n\t\t\tfor nex in lis[i]:\n\t\t\t\tenum[nex] -= 1\n\tmins = float('inf')\n\tfor i in range(n):\n\t\tif enum[i] <= 1 and len(lis[i]) != 1:\n\t\t\tmins = len(lis[i]) - enum[i]\n\t(dlis, tmp) = NC_Dij(lis, 0)\n\tdv = [(dlis[i], i) for i in range(n)]\n\tdv.sort()\n\tdv.reverse()\n\tps = set()\n\tans = [0] * (n + 1)\n\tfor i in range(1, int(mins ** 0.5 + 10)):\n\t\tif mins % i == 0:\n\t\t\tps.add(i)\n\t\t\tps.add(mins // i)\n\t\tif (mins + 1) % i == 0:\n\t\t\tps.add(i)\n\t\t\tps.add((mins + 1) // i)\n\tfor p in ps:\n\t\tif p != 1 and search(p):\n\t\t\tans[p] = 1\n\tfor i in range(n + 1):\n\t\tif ans[i] == 1:\n\t\t\tfor j in range(2 * i, n + 1, i):\n\t\t\t\tif ans[j] == 1:\n\t\t\t\t\tans[i] = 0\n\t\t\t\t\tbreak\n\tans[1] = (pow(2, n - 1, mod) - sum(ans)) % mod\n\tprint(*ans[1:])\n"
    },
    {
        "task_id": 360,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 2.8943722248077393,
        "fastest_time": 2.6986184120178223,
        "fastest_solution": "import sys\nfrom collections import Counter\n\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\ndef readline():\n\treturn map(int, input().split())\nMOD = 10 ** 9 + 7\n\ndef main():\n\t(n, p) = readline()\n\ta = sorted(readline())\n\tvalues = set()\n\tfor ai in a:\n\t\tv = ai\n\t\twhile v not in values:\n\t\t\tr = v % 4\n\t\t\tif r == 2 or v == 0:\n\t\t\t\tvalues.add(ai)\n\t\t\t\tbreak\n\t\t\telif r == 0:\n\t\t\t\tv //= 4\n\t\t\telse:\n\t\t\t\tv //= 2\n\tc = Counter(map(int.bit_length, values))\n\tx = y = 0\n\tans = 0\n\tfor i in range(1, p + 1):\n\t\tz = (c.get(i, 0) + x + y) % MOD\n\t\tans += z\n\t\t(x, y) = (y, z)\n\tprint(ans % MOD)\nmain()\n",
        "slowest_solution": "(n, p) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nusefulSeeds = {arr[0]}\n\ndef isUseful(n, S):\n\twhile n:\n\t\tif n in S:\n\t\t\treturn False\n\t\telif n % 4 == 0:\n\t\t\tn /= 4\n\t\telif n % 2 == 1:\n\t\t\tn -= 1\n\t\t\tn /= 2\n\t\telse:\n\t\t\treturn True\n\telse:\n\t\treturn True\nfor i in range(1, n):\n\tif isUseful(arr[i], usefulSeeds):\n\t\tusefulSeeds.add(arr[i])\nfrom math import log2, floor\ng = [0 for _ in range(35)]\nfor seed in usefulSeeds:\n\tk = floor(log2(seed))\n\tif k < p:\n\t\tg[k] += 1\ndp = [0 for _ in range(p)]\nrep = 0\nmod = 10 ** 9 + 7\nfor i in range(p):\n\tif i < 35:\n\t\tdp[i] += g[i]\n\tif i >= 1:\n\t\tdp[i] += dp[i - 1]\n\t\tdp[i] = dp[i] % mod\n\tif i >= 2:\n\t\tdp[i] += dp[i - 2]\n\t\tdp[i] = dp[i] % mod\n\trep += dp[i]\n\trep = rep % mod\nprint(rep)\n"
    },
    {
        "task_id": 347,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.8939156532287598,
        "fastest_time": 2.515380620956421,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict as dd, deque as dq\nimport bisect\n(n, m) = map(int, input().split())\nll = []\nfor i in range(n):\n\ts = input()\n\tll.append(s)\nvis = [[0] * m for i in range(n)]\nlol = 0\nro = 0\nco = 0\nroo = 0\ncoo = 0\ndick = dq([])\nfor i in range(n):\n\th = 0\n\td = 0\n\tfor j in range(m):\n\t\tif ll[i][j] == '#' and h == 1 and (d == 1):\n\t\t\tlol = 1\n\t\t\tbreak\n\t\telif ll[i][j] == '.':\n\t\t\td = 1\n\t\telif ll[i][j] == '#':\n\t\t\th = 1\n\t\t\td = 0\n\tif lol:\n\t\tbreak\n\tif h == 0:\n\t\tro = 1\nfor i in range(m):\n\th = 0\n\td = 0\n\tfor j in range(n):\n\t\tif ll[j][i] == '#' and h == 1 and (d == 1):\n\t\t\tlol = 1\n\t\t\tbreak\n\t\telif ll[j][i] == '.':\n\t\t\td = 1\n\t\telif ll[j][i] == '#':\n\t\t\th = 1\n\t\t\td = 0\n\tif lol:\n\t\tbreak\n\tif h == 0:\n\t\tco = 1\nif co == 0 and ro == 1 or (ro == 0 and co == 1):\n\tlol = 1\nelif lol == 0:\n\tres = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif vis[i][j] == 0 and ll[i][j] == '#':\n\t\t\t\tres += 1\n\t\t\t\tdick = dq([(i, j)])\n\t\t\t\twhile dick:\n\t\t\t\t\t(x, y) = dick.pop()\n\t\t\t\t\tvis[x][y] = 1\n\t\t\t\t\tif x + 1 < n and vis[x + 1][y] == 0 and (ll[x + 1][y] == '#'):\n\t\t\t\t\t\tdick.appendleft((x + 1, y))\n\t\t\t\t\t\tvis[x + 1][y] = 1\n\t\t\t\t\tif x - 1 >= 0 and vis[x - 1][y] == 0 and (ll[x - 1][y] == '#'):\n\t\t\t\t\t\tdick.appendleft((x - 1, y))\n\t\t\t\t\t\tvis[x - 1][y] = 1\n\t\t\t\t\tif y + 1 < m and vis[x][y + 1] == 0 and (ll[x][y + 1] == '#'):\n\t\t\t\t\t\tdick.appendleft((x, y + 1))\n\t\t\t\t\t\tvis[x][y + 1] = 1\n\t\t\t\t\tif y - 1 >= 0 and vis[x][y - 1] == 0 and (ll[x][y - 1] == '#'):\n\t\t\t\t\t\tdick.appendleft((x, y - 1))\n\t\t\t\t\t\tvis[x][y - 1] = 1\nif lol:\n\tprint(-1)\nelse:\n\tprint(res)\n",
        "slowest_solution": "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n\treturn int(sys.stdin.readline())\n\ndef MI():\n\treturn map(int, sys.stdin.readline().split())\n\ndef LI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n\treturn [LI() for _ in range(rows_number)]\n\ndef SI():\n\treturn sys.stdin.readline()[:-1]\n\ndef main():\n\tinf = 10 ** 9\n\t(h, w) = MI()\n\taa = [[(c == '#') * 1 for c in SI()] for _ in range(h)]\n\tans = 0\n\tcnt_emp = 0\n\tpl = -1\n\tpr = -1\n\tfor row in aa:\n\t\tl = r = -1\n\t\trow = [0] + row + [0]\n\t\tfor i in range(w + 1):\n\t\t\tif row[i:i + 2] == [0, 1]:\n\t\t\t\tif l == -1:\n\t\t\t\t\tl = i\n\t\t\t\telse:\n\t\t\t\t\tprint(-1)\n\t\t\t\t\texit()\n\t\t\tif row[i:i + 2] == [1, 0]:\n\t\t\t\tr = i\n\t\tif l == -1:\n\t\t\tcnt_emp += 1\n\t\telif min(r, pr) <= max(l, pl):\n\t\t\tans += 1\n\t\t(pl, pr) = (l, r)\n\tif cnt_emp == h:\n\t\tprint(0)\n\t\texit()\n\tre = cnt_emp > 0\n\tce = False\n\tfor col in zip(*aa):\n\t\tl = r = -1\n\t\tfor (i, a) in enumerate(col):\n\t\t\tif l == -1 and a:\n\t\t\t\tl = i\n\t\t\telif l != -1 and r == -1 and (a == 0):\n\t\t\t\tr = i\n\t\t\telif r != -1 and a:\n\t\t\t\tprint(-1)\n\t\t\t\texit()\n\t\tif l == -1:\n\t\t\tce = True\n\tif re ^ ce:\n\t\tprint(-1)\n\t\texit()\n\tprint(ans)\nmain()\n"
    },
    {
        "task_id": 388,
        "slowest_solution_id": 1,
        "fastest_solution_id": 1,
        "slowest_time": 2.614875555038452,
        "fastest_time": 2.614875555038452,
        "fastest_solution": "from sys import stdin\n\nclass DSU:\n\n\tdef __init__(self, n) -> None:\n\t\tself.parent = [i for i in range(n)]\n\t\tself.rank = [0] * n\n\n\tdef find_set(self, v):\n\t\tw = v\n\t\tparent = self.parent\n\t\twhile parent[v] != v:\n\t\t\tv = parent[v]\n\t\twhile parent[w] != w:\n\t\t\tt = parent[w]\n\t\t\tparent[w] = v\n\t\t\tw = t\n\t\treturn v\n\n\tdef union_sets(self, a, b):\n\t\ta = self.find_set(a)\n\t\tb = self.find_set(b)\n\t\trank = self.rank\n\t\tif a != b:\n\t\t\tif rank[a] < rank[b]:\n\t\t\t\t(rank[a], rank[b]) = (rank[b], rank[a])\n\t\t\tself.parent[b] = a\n\t\t\tif rank[a] == rank[b]:\n\t\t\t\trank[a] += 1\n(n, m, q) = map(int, stdin.readline().split())\ndsu = DSU(n + m)\nfor i in range(q):\n\t(r, c) = map(int, stdin.readline().split())\n\tr -= 1\n\tc -= 1\n\tdsu.union_sets(r, c + n)\nans = -1\nfor i in range(n + m):\n\tif dsu.parent[i] == i:\n\t\tans += 1\nprint(ans)\n",
        "slowest_solution": "from sys import stdin\n\nclass DSU:\n\n\tdef __init__(self, n) -> None:\n\t\tself.parent = [i for i in range(n)]\n\t\tself.rank = [0] * n\n\n\tdef find_set(self, v):\n\t\tw = v\n\t\tparent = self.parent\n\t\twhile parent[v] != v:\n\t\t\tv = parent[v]\n\t\twhile parent[w] != w:\n\t\t\tt = parent[w]\n\t\t\tparent[w] = v\n\t\t\tw = t\n\t\treturn v\n\n\tdef union_sets(self, a, b):\n\t\ta = self.find_set(a)\n\t\tb = self.find_set(b)\n\t\trank = self.rank\n\t\tif a != b:\n\t\t\tif rank[a] < rank[b]:\n\t\t\t\t(rank[a], rank[b]) = (rank[b], rank[a])\n\t\t\tself.parent[b] = a\n\t\t\tif rank[a] == rank[b]:\n\t\t\t\trank[a] += 1\n(n, m, q) = map(int, stdin.readline().split())\ndsu = DSU(n + m)\nfor i in range(q):\n\t(r, c) = map(int, stdin.readline().split())\n\tr -= 1\n\tc -= 1\n\tdsu.union_sets(r, c + n)\nans = -1\nfor i in range(n + m):\n\tif dsu.parent[i] == i:\n\t\tans += 1\nprint(ans)\n"
    },
    {
        "task_id": 384,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.803532600402832,
        "fastest_time": 2.7324059009552,
        "fastest_solution": "import sys\nimport heapq as hq\nreadline = sys.stdin.readline\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\neps = 10 ** (-7)\n\ndef solve():\n\t(n, k) = nm()\n\ta = nl()\n\tans = [0] * n\n\tok = 10 ** 9\n\tng = -4 * 10 ** 18\n\twhile ok - ng > 1:\n\t\tmid = (ok + ng) // 2\n\t\tck = 0\n\t\tfor i in range(n):\n\t\t\td = 9 - 12 * (mid + 1 - a[i])\n\t\t\tif d < 0:\n\t\t\t\tcontinue\n\t\t\tck += min(a[i], int((3 + d ** 0.5) / 6 + eps))\n\t\tif ck > k:\n\t\t\tng = mid\n\t\telse:\n\t\t\tok = mid\n\tfor i in range(n):\n\t\td = 9 - 12 * (ok + 1 - a[i])\n\t\tif d < 0:\n\t\t\tcontinue\n\t\tans[i] = min(a[i], int((3 + d ** 0.5) / 6 + eps))\n\trk = k - sum(ans)\n\tl = list()\n\tfor i in range(n):\n\t\tif ans[i] < a[i]:\n\t\t\thq.heappush(l, (-a[i] + 3 * ans[i] ** 2 - 3 * ans[i] + 1, i))\n\tfor _ in range(rk):\n\t\t(v, i) = hq.heappop(l)\n\t\tans[i] += 1\n\t\tif ans[i] < a[i]:\n\t\t\thq.heappush(l, (-a[i] + 3 * ans[i] ** 2 - 3 * ans[i] + 1, i))\n\tprint(*ans)\n\treturn\nsolve()\n",
        "slowest_solution": "import os\nimport sys\nfrom collections import deque\nimport math\nreadline = sys.stdin.readline\n\nclass CF(object):\n\n\tdef __init__(self):\n\t\tself.eps = 1e-07\n\t\t(self.n, self.k) = list(map(int, readline().split()))\n\t\tself.a = list(map(int, readline().split()))\n\t\tassert len(self.a) == self.n\n\n\tdef fd(self, i):\n\t\treturn 3 * i * (i + 1) + 1\n\n\tdef find_le(self, x, ca):\n\t\tif self.fd(0) > x:\n\t\t\treturn (0, 0)\n\t\tans = int(((12 * x - 3) ** 0.5 - 3) / 6 + self.eps)\n\t\tans = int(min(ans, ca - 1))\n\t\treturn (int(ans + 1), int(3 * ans * (ans + 1) + 1 == x))\n\n\tdef get_num(self, x):\n\t\tst = 0\n\t\tse = 0\n\t\tfor ca in self.a:\n\t\t\t(t1, t2) = self.find_le(x + ca, ca)\n\t\t\tst += t1\n\t\t\tse += t2\n\t\tpass\n\t\treturn (st, se)\n\n\tdef find_k(self, k):\n\t\tl = int(-4e+18)\n\t\tr = int(4e+18)\n\t\twhile l != r:\n\t\t\tmid = int((l + r + 1) // 2)\n\t\t\t(st, se) = self.get_num(mid)\n\t\t\tthe_max = st\n\t\t\tthe_min = the_max - se\n\t\t\tif k < the_max:\n\t\t\t\tr = mid - 1\n\t\t\telse:\n\t\t\t\tl = mid\n\t\tpass\n\t\tck = []\n\t\teq = []\n\t\tfor ca in self.a:\n\t\t\t(t1, t2) = self.find_le(l + ca, ca)\n\t\t\tck.append(t1)\n\t\tck1 = []\n\t\teq1 = 0\n\t\tfor ca in self.a:\n\t\t\t(t1, t2) = self.find_le(l + 1 + ca, ca)\n\t\t\tck1.append(t1)\n\t\t\teq1 += t2\n\t\tthe_max = sum(ck1)\n\t\tthe_min = the_max - eq1\n\t\tres = k - sum(ck)\n\t\tfor i in range(self.n):\n\t\t\tif ck1[i] > ck[i]:\n\t\t\t\tif res > 0:\n\t\t\t\t\tres -= 1\n\t\t\t\t\tck[i] += 1\n\t\tpass\n\t\tprint(' '.join(map(str, ck)))\n\n\tdef main(self):\n\t\tself.find_k(self.k)\n\t\tpass\ncf = CF()\ncf.main()\npass\n"
    },
    {
        "task_id": 352,
        "slowest_solution_id": 4,
        "fastest_solution_id": 6,
        "slowest_time": 2.7921478748321533,
        "fastest_time": 2.511965274810791,
        "fastest_solution": "n = int(input())\n(sum, t) = (1, 0)\nv = [1] * 10\nwhile sum < n:\n\tv[t] += 1\n\tt = (t + 1) % 10\n\tsum = 1\n\tfor i in range(10):\n\t\tsum *= v[i]\np = [i for i in 'codeforces']\nfor i in range(10):\n\tprint(p[i] * v[i], end='')\n",
        "slowest_solution": "def main():\n\tn = int(input())\n\ts = 'codeforces'\n\tx = int(n ** 0.1)\n\tans = ''\n\ta = 0\n\tif x ** 10 < n:\n\t\tfor a in range(10, -1, -1):\n\t\t\tif x ** a * (1 + x) ** (10 - a) >= n:\n\t\t\t\tbreak\n\t\ta = 10 - a\n\tfor i in range(10):\n\t\tif a > 0:\n\t\t\tans += s[i] * (x + 1)\n\t\t\ta -= 1\n\t\telse:\n\t\t\tans += s[i] * x\n\tprint(ans)\nmain()\n"
    },
    {
        "task_id": 349,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 2.7374637126922607,
        "fastest_time": 2.499361276626587,
        "fastest_solution": "(h, l) = map(int, input().split())\nprint((l * l - h * h) / (2 * h))\n",
        "slowest_solution": "(H, L) = map(int, input().strip().split())\nprint((L * L - H * H) / (2 * H))\n"
    },
    {
        "task_id": 367,
        "slowest_solution_id": 4,
        "fastest_solution_id": 1,
        "slowest_time": 2.7770144939422607,
        "fastest_time": 2.524134874343872,
        "fastest_solution": "import sys, random, bisect\nfrom collections import deque, defaultdict\nfrom heapq import heapify, heappop, heappush\nfrom itertools import permutations\nfrom math import log, gcd\ninput = lambda : sys.stdin.buffer.readline()\nmi = lambda : map(int, input().split())\nli = lambda : list(mi())\nfibo = [1, 1]\nfor i in range(40):\n\tfibo.append(fibo[-1] + fibo[-2])\nfibo_dic = {e: i for (i, e) in enumerate(fibo)}\nN = int(input())\nedge = [[] for i in range(N)]\nfor i in range(N - 1):\n\t(u, v) = mi()\n\tedge[u - 1].append(v - 1)\n\tedge[v - 1].append(u - 1)\ndeq = deque([0])\nres = []\nsize = [0 for i in range(N)]\nparent = [-1 for i in range(N)]\nwhile deq:\n\tv = deq.popleft()\n\tres.append(v)\n\tsize[v] += 1\n\tfor nv in edge[v]:\n\t\tif size[nv] != 1:\n\t\t\tparent[nv] = v\n\t\t\tdeq.append(nv)\nres = res[::-1]\nfor v in res:\n\tfor nv in edge[v]:\n\t\tif nv != parent[v]:\n\t\t\tsize[v] += size[nv]\n\tif v:\n\t\tedge[v].remove(parent[v])\n\tedge[v] = [nv for nv in edge[v] if nv != parent[v]]\nif N not in fibo_dic:\n\texit(print('NO'))\nk = fibo_dic[N]\nNodes = [(0, k)]\ncutted = set()\nwhile Nodes:\n\t(root, k) = Nodes.pop()\n\tif size[root] <= 2:\n\t\tcontinue\n\tcut = (-1, -1)\n\tstack = [root]\n\twhile stack:\n\t\tv = stack.pop()\n\t\tfor nv in edge[v]:\n\t\t\tif size[nv] == fibo[k - 1] or size[nv] == fibo[k - 2]:\n\t\t\t\tcut = (v, nv)\n\t\t\t\tbreak\n\t\t\tstack.append(nv)\n\t\telse:\n\t\t\tcontinue\n\t\tbreak\n\tif cut == (-1, -1):\n\t\texit(print('NO'))\n\t(pv, v) = cut\n\tedge[pv].remove(v)\n\tpos = pv\n\twhile True:\n\t\tsize[pos] -= size[v]\n\t\tif parent[pos] != -1 and (parent[pos], pos) not in cutted:\n\t\t\tpos = parent[pos]\n\t\telse:\n\t\t\tbreak\n\tcutted.add(cut)\n\tNodes.append((root, fibo_dic[size[root]]))\n\tNodes.append((v, fibo_dic[size[v]]))\nprint('YES')\n",
        "slowest_solution": "import sys\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n\treturn int(sys.stdin.buffer.readline())\n\ndef MI():\n\treturn map(int, sys.stdin.buffer.readline().split())\n\ndef MI1():\n\treturn map(int1, sys.stdin.buffer.readline().split())\n\ndef LI():\n\treturn list(map(int, sys.stdin.buffer.readline().split()))\n\ndef LLI(rows_number):\n\treturn [LI() for _ in range(rows_number)]\n\ndef BI():\n\treturn sys.stdin.buffer.readline().rstrip()\n\ndef SI():\n\treturn sys.stdin.buffer.readline().rstrip().decode()\ninf = 10 ** 16\nmd = 10 ** 9 + 7\nfibo = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418]\nftoi = {f: i for (i, f) in enumerate(fibo)}\nn = II()\nto = [[] for _ in range(n)]\nfor e in range(n - 1):\n\t(u, v) = MI1()\n\tto[u].append(v)\n\tto[v].append(u)\nif n <= 3:\n\tprint('YES')\n\texit()\nif n not in ftoi:\n\tprint('NO')\n\texit()\nstack = [0]\nsz = [-1] * n\npar = [-1] * n\nwhile stack:\n\tu = stack.pop()\n\tif sz[u] == -1:\n\t\tsz[u] = 1\n\t\tstack.append(u)\n\t\tfor v in to[u]:\n\t\t\tif v == par[u]:\n\t\t\t\tcontinue\n\t\t\tpar[v] = u\n\t\t\tstack.append(v)\n\telse:\n\t\tsz[par[u]] += sz[u]\nfin = [False] * n\n\ndef dfs(r, s):\n\ti = ftoi[s]\n\t(s1, s2) = (fibo[i - 1], fibo[i - 2])\n\tstack = [r]\n\twhile stack:\n\t\tu = stack.pop()\n\t\tfor v in to[u]:\n\t\t\tif v == par[u]:\n\t\t\t\tcontinue\n\t\t\tif fin[v]:\n\t\t\t\tcontinue\n\t\t\tif sz[v] == s1 or sz[v] == s2:\n\t\t\t\tfin[v] = True\n\t\t\t\treturn v\n\t\t\tstack.append(v)\n\treturn -1\n\ndef ok():\n\troot = [(0, sz[0])]\n\twhile root:\n\t\t(r, s) = root.pop()\n\t\tu = dfs(r, s)\n\t\tif u == -1:\n\t\t\treturn False\n\t\ts1 = sz[u]\n\t\tif s1 > 3:\n\t\t\troot.append((u, s1))\n\t\tif s - s1 > 3:\n\t\t\troot.append((r, s - s1))\n\t\twhile u != r:\n\t\t\tu = par[u]\n\t\t\tsz[u] -= s1\n\treturn True\nprint('YES' if ok() else 'NO')\n"
    },
    {
        "task_id": 353,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 2.7620348930358887,
        "fastest_time": 2.5266566276550293,
        "fastest_solution": "for i in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tarr = sorted(list(map(int, input().split())))\n\tfor i in range(k):\n\t\tif arr[i] < 0:\n\t\t\tarr[i] = -1 * arr[i]\n\tsumu = 0\n\tfor i in range(n):\n\t\tif arr[i] > 0:\n\t\t\tsumu += arr[i]\n\tprint(sumu)\n",
        "slowest_solution": "import sys\n\ndef get_int():\n\treturn int(sys.stdin.readline().strip())\n\ndef get_long():\n\treturn int(sys.stdin.readline().strip())\n\ndef main():\n\tnum_tests = get_int()\n\tfor i in range(num_tests):\n\t\t(n_val, k_val) = map(int, input().split())\n\t\ta_arr = list(map(int, input().split()))\n\t\ta_arr.sort()\n\t\tfor j in range(k_val):\n\t\t\tif a_arr[j] < 0:\n\t\t\t\ta_arr[j] = -a_arr[j]\n\t\taddition = sum(filter(lambda x: x > 0, a_arr))\n\t\tprint(addition)\nmain()\n"
    },
    {
        "task_id": 396,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6494224071502686,
        "fastest_time": 2.6494224071502686,
        "fastest_solution": "import sys\nn = int(sys.stdin.readline())\nbits = [[] for _ in range(6)]\nfor i in [2, 3, 5]:\n\tbits[i] = [0] * (n + 1)\n\ndef add(bit, index, val):\n\tindex += 1\n\twhile index <= n:\n\t\tbit[index] += val\n\t\tindex += index & -index\n\ndef add_range(bit, l, r, val):\n\tadd(bit, l, val)\n\tadd(bit, r + 1, -val)\n\ndef get(bit, index):\n\tr = 0\n\tindex += 1\n\twhile index:\n\t\tr += bit[index]\n\t\tindex -= index & -index\n\treturn r\n\ndef reset(bit, index):\n\tadd_range(bit, index, index, -get(bit, index))\ns = list(map(int, sys.stdin.readline().split()))\nm = int(sys.stdin.readline())\nfor _ in range(m):\n\top = list(map(int, sys.stdin.readline().split()))\n\tif len(op) == 4:\n\t\t(_, l, r, p) = op\n\t\tadd_range(bits[p], l - 1, r - 1, 1)\n\telse:\n\t\t(_, index, val) = op\n\t\tindex -= 1\n\t\ts[index] = val\n\t\tfor i in [2, 3, 5]:\n\t\t\treset(bits[i], index)\nfor (i, num) in enumerate(s):\n\tfor p in [2, 3, 5]:\n\t\tv = get(bits[p], i)\n\t\twhile v > 0 and num % p == 0:\n\t\t\tnum = num // p\n\t\t\tv -= 1\n\tprint(num, end=' ')\nprint()\n",
        "slowest_solution": "import sys\nn = int(sys.stdin.readline())\nbits = [[] for _ in range(6)]\nfor i in [2, 3, 5]:\n\tbits[i] = [0] * (n + 1)\n\ndef add(bit, index, val):\n\tindex += 1\n\twhile index <= n:\n\t\tbit[index] += val\n\t\tindex += index & -index\n\ndef add_range(bit, l, r, val):\n\tadd(bit, l, val)\n\tadd(bit, r + 1, -val)\n\ndef get(bit, index):\n\tr = 0\n\tindex += 1\n\twhile index:\n\t\tr += bit[index]\n\t\tindex -= index & -index\n\treturn r\n\ndef reset(bit, index):\n\tadd_range(bit, index, index, -get(bit, index))\ns = list(map(int, sys.stdin.readline().split()))\nm = int(sys.stdin.readline())\nfor _ in range(m):\n\top = list(map(int, sys.stdin.readline().split()))\n\tif len(op) == 4:\n\t\t(_, l, r, p) = op\n\t\tadd_range(bits[p], l - 1, r - 1, 1)\n\telse:\n\t\t(_, index, val) = op\n\t\tindex -= 1\n\t\ts[index] = val\n\t\tfor i in [2, 3, 5]:\n\t\t\treset(bits[i], index)\nfor (i, num) in enumerate(s):\n\tfor p in [2, 3, 5]:\n\t\tv = get(bits[p], i)\n\t\twhile v > 0 and num % p == 0:\n\t\t\tnum = num // p\n\t\t\tv -= 1\n\tprint(num, end=' ')\nprint()\n"
    },
    {
        "task_id": 372,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 3.8200204372406006,
        "fastest_time": 2.582664728164673,
        "fastest_solution": "p = 10 ** 9 + 7\nimport math\n\ndef prod(l):\n\tx = 1\n\tfor m in l:\n\t\tx *= m\n\treturn x\nn = int(input())\na = []\nk = int(math.log2(n))\nx = n\nwhile x > 0:\n\ty = x // 2\n\ta.append(x - y)\n\tx = y\nc = [sum(a[i:]) for i in range(k + 1)]\nb = [n // (3 * 2 ** i) - n // (6 * 2 ** i) for i in range(k + 1)]\nd = [n // 2 ** i - n // (3 * 2 ** i) for i in range(k + 1)]\nfacs = [1] * (n + 1)\nfor i in range(2, n + 1):\n\tfacs[i] = i * facs[i - 1] % p\nstart = k if n < 3 * 2 ** (k - 1) else 0\ntot = 0\nfor j in range(start, k + 1):\n\te = [a[i] for i in range(j)] + [d[j]] + [b[i] for i in range(j, k)]\n\tx = facs[n] * prod(e) % p\n\tf = prod([sum(e[:i + 1]) for i in range(k + 1)])\n\twhile f > 1:\n\t\tx *= p // f + 1\n\t\tf = f * (p // f + 1) % p\n\ttot += x % p\nprint(tot % p)\n",
        "slowest_solution": "def binpow(x, t, mod):\n\tif t == 0:\n\t\treturn 1\n\tif t % 2 == 0:\n\t\treturn binpow(x * x % mod, t // 2, mod)\n\treturn binpow(x, t - 1, mod) * x % mod\n\ndef calc(a, f, rv, n):\n\tmod = 10 ** 9 + 7\n\ts = 0\n\tans = 1\n\tfor i in range(len(a) - 1, -1, -1):\n\t\tcur = n // a[i]\n\t\tif i > 0:\n\t\t\tcur -= n // a[i - 1]\n\t\tt = cur - 1\n\t\ts += t\n\t\tans = ans * cur * f[s] * rv[s - t] % mod\n\t\ts += 1\n\treturn ans\nn = int(input())\nx = n\nc = 0\nwhile x > 1:\n\tx //= 2\n\tc += 1\nf = [1] * 1000100\nmod = 10 ** 9 + 7\nfor i in range(1, len(f)):\n\tf[i] = f[i - 1] * i % mod\nrv = [1] * 1000100\nrv[-1] = binpow(f[-1], mod - 2, mod)\nfor i in range(len(f) - 2, 0, -1):\n\trv[i] = rv[i + 1] * (i + 1) % mod\na = []\nfor i in range(c, -1, -1):\n\ta.append(2 ** i)\nans = calc(a, f, rv, n)\nif 2 ** (c - 1) * 3 <= n:\n\tc -= 1\n\ta = []\n\twhile c >= 0:\n\t\ta.append(2 ** c * 3)\n\t\tb = a.copy()\n\t\tfor i in range(c, -1, -1):\n\t\t\tb.append(2 ** i)\n\t\tans = (ans + calc(b, f, rv, n)) % mod\n\t\tc -= 1\nprint(ans)\n"
    },
    {
        "task_id": 368,
        "slowest_solution_id": 7,
        "fastest_solution_id": 0,
        "slowest_time": 2.695563316345215,
        "fastest_time": 2.5631301403045654,
        "fastest_solution": "smpl = {}\ncntr = {}\n\ndef handle(s):\n\tcur = set()\n\tfor i in range(len(s)):\n\t\tfor j in range(i + 1, len(s) + 1):\n\t\t\tcur.add(s[i:j])\n\tfor c in cur:\n\t\tif c not in cntr:\n\t\t\tcntr[c] = 0\n\t\tcntr[c] += 1\n\t\tsmpl[c] = s\nn = int(input())\nfor i in range(n):\n\ts = input()\n\thandle(s)\nq = int(input())\nfor i in range(q):\n\ts = input()\n\tif s in cntr:\n\t\tprint(cntr[s], smpl[s])\n\telse:\n\t\tprint(0, '-')\n",
        "slowest_solution": "dict_in = {}\ndict_words = {}\n\ndef fill_dict(st):\n\ts = set()\n\tfor x in range(len(st)):\n\t\tfor xx in range(x + 1, len(st) + 1, +1):\n\t\t\ts.add(st[x:xx])\n\tfor xy in s:\n\t\tif xy not in dict_in:\n\t\t\tdict_in[xy] = 1\n\t\telse:\n\t\t\tdict_in[xy] += 1\n\t\tdict_words[xy] = st\nn = int(input())\nfor x in range(n):\n\tfill_dict(input())\nm = int(input())\nfor x in range(m):\n\ttmp_str = input()\n\tif tmp_str in dict_words:\n\t\tprint(dict_in[tmp_str], dict_words[tmp_str])\n\telse:\n\t\tprint('0 -')\n"
    },
    {
        "task_id": 337,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 4.2421698570251465,
        "fastest_time": 2.6053731441497803,
        "fastest_solution": "t = int(input())\nar = []\nfor _ in range(t):\n\tn = int(input())\n\tar.append(n)\nmx = max(ar)\ndic = {1: 1}\nfor i in range(2, mx + 1):\n\tvl = i\n\tlst = dic[vl - 1]\n\tnxt = lst + vl + lst * vl\n\tdic[vl] = nxt % (10 ** 9 + 7)\nfor i in ar:\n\tprint(dic[i])\n",
        "slowest_solution": "a = list(range(1, 1000001))\nfor i in range(1, 1000000):\n\ta[i] = (a[i] + a[i - 1] + a[i] * a[i - 1]) % 1000000007\nfor _ in range(int(input())):\n\tprint(a[int(input()) - 1])\n"
    },
    {
        "task_id": 391,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.641366481781006,
        "fastest_time": 2.572690725326538,
        "fastest_solution": "def prefix(s):\n\tp = [0]\n\tfor i in range(1, len(s)):\n\t\tj = p[-1]\n\t\twhile j > 0 and s[j] != s[i]:\n\t\t\tj = p[j - 1]\n\t\tif s[i] == s[j]:\n\t\t\tj += 1\n\t\tp.append(j)\n\treturn p\ns = input()\nn = len(s)\nans = [0] * (n + 1)\ni = n - 1\nwhile i >= 0:\n\tp = prefix(s[i:])\n\tans[i] = 2 + ans[i + 1]\n\tfor j in range(len(p)):\n\t\tz = 1\n\t\tif (j + 1) % (j + 1 - p[j]) == 0:\n\t\t\tz = (j + 1) // (j + 1 - p[j])\n\t\tres = len(str(z)) + (j + 1) // z + ans[i + j + 1]\n\t\tans[i] = min(ans[i], res)\n\ti -= 1\nprint(ans[0])\n",
        "slowest_solution": "s = input()\nn = len(s)\n\ndef f(s):\n\tn = len(s)\n\tar = [0] * n\n\t(i, j) = (1, 0)\n\twhile i < n:\n\t\tif s[i] == s[j]:\n\t\t\tj += 1\n\t\t\tar[i] = j\n\t\t\ti += 1\n\t\telif j != 0:\n\t\t\tj = ar[j - 1]\n\t\telse:\n\t\t\ti += 1\n\treturn ar\ndp = [n + 1] * n + [0]\nfor i in range(n - 1, -1, -1):\n\tar = f(s[i:])\n\tfor j in range(len(ar)):\n\t\tT = 1\n\t\tk = j + 1\n\t\tif k % (k - ar[j]) == 0:\n\t\t\tT = k // (k - ar[j])\n\t\tdp[i] = min(dp[i], len(str(T)) + k // T + dp[i + k])\nprint(dp[0])\n"
    },
    {
        "task_id": 355,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.839339256286621,
        "fastest_time": 2.444481372833252,
        "fastest_solution": "T = int(input())\nfor t in range(T):\n\t(N, Q) = list(map(int, input().split()))\n\tA = list(map(int, input().split()))\n\tmaximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n\tfor q in range(Q):\n\t\trecalculate = False\n\t\t(i, x) = list(map(int, input().split()))\n\t\ti -= 1\n\t\tif i > 0 and maximo == A[i - 1] - A[i]:\n\t\t\trecalculate = True\n\t\tif i < N - 1 and maximo == A[i] - A[i + 1]:\n\t\t\trecalculate = True\n\t\tA[i] = x\n\t\tif recalculate:\n\t\t\tmaximo = max([0] + [a - b for (a, b) in zip(A, A[1:])])\n\t\telse:\n\t\t\tif i > 0:\n\t\t\t\tmaximo = max(maximo, A[i - 1] - A[i])\n\t\t\tif i < N - 1:\n\t\t\t\tmaximo = max(maximo, A[i] - A[i + 1])\n\t\tprint(maximo)\n",
        "slowest_solution": "from bisect import *\nfrom heapq import *\nfrom math import *\nfrom collections import defaultdict as ddc\nfrom collections import Counter\nfrom functools import reduce\n\ndef intin():\n\treturn int(input())\n\ndef mapin():\n\treturn map(int, input().split())\n\ndef strin():\n\treturn input().split()\nINF = 10 ** 20\nmod = 1000000007\n\ndef hashit(arr, size, mod=10 ** 9 + 7):\n\tif not size:\n\t\treturn\n\t(mul, hashh, div) = (256, 0, (1 << 8 * size - 8) % mod)\n\tC = defaultdict(list)\n\tfor i in range(size):\n\t\thashh = (mul * hashh + arr[i]) % mod\n\tC[hashh].append(0)\n\tfor i in range(len(arr) - size):\n\t\thashh = (mul * (hashh - arr[i] * div) + arr[i + size]) % mod\n\t\tC[hashh].append(i + 1)\n\treturn C\n\ndef LIS(arr, n):\n\tdp = [10 ** 9] * (n + 1)\n\tfor ele in arr:\n\t\tdp[bisect_left(dp, ele)] = ele\n\treturn bisect_left(dp, 10 ** 9)\n\ndef exponentiation(bas, exp, mod=10 ** 9 + 7):\n\tt = 1\n\twhile exp > 0:\n\t\tif exp % 2 != 0:\n\t\t\tt = t * bas % mod\n\t\tbas = bas * bas % mod\n\t\texp //= 2\n\treturn t % mod\n\ndef MOD(p, q=1, mod=1000000007):\n\texpo = 0\n\texpo = mod - 2\n\twhile expo:\n\t\tif expo & 1:\n\t\t\tp = p * q % mod\n\t\tq = q * q % mod\n\t\texpo >>= 1\n\treturn p\nyes = 'YES'\nno = 'NO'\neven = 'EVEN'\nodd = 'ODD'\n\ndef graphin(n):\n\tzz = defaultdict(set)\n\tfor i in range(n - 1):\n\t\t(a, b) = mapin()\n\t\tzz[a].add(b)\n\t\tzz[b].add(a)\n\treturn zz\n\ndef process(arr, n, Q):\n\th = []\n\theappush(h, [0, 0])\n\tfor i in range(1, n):\n\t\ttemp = arr[i - 1] - arr[i]\n\t\theappush(h, [-temp, i])\n\tfor (i, x) in Q:\n\t\tarr[i - 1] = x\n\t\tif i > 1:\n\t\t\ttemp = arr[i - 2] - arr[i - 1]\n\t\t\theappush(h, [-temp, i - 1])\n\t\tif i < n:\n\t\t\ttemp = arr[i - 1] - arr[i]\n\t\t\theappush(h, [-temp, i])\n\t\twhile h:\n\t\t\t(val, i) = heappop(h)\n\t\t\tif arr[i] - arr[i - 1] == val or i == 0:\n\t\t\t\tif val > 0:\n\t\t\t\t\tprint(0)\n\t\t\t\telse:\n\t\t\t\t\tprint(-val)\n\t\t\t\theappush(h, [val, i])\n\t\t\t\tbreak\n\ndef main():\n\tfor _ in range(int(input())):\n\t\t(n, q) = mapin()\n\t\tarr = list(mapin())\n\t\tQ = []\n\t\tfor i in range(q):\n\t\t\t(i, x) = mapin()\n\t\t\tQ.append([i, x])\n\t\tprocess(arr, n, Q)\nmain()\n"
    },
    {
        "task_id": 381,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 2.7508835792541504,
        "fastest_time": 2.710444927215576,
        "fastest_solution": "import sys\nfrom collections import *\nimport os.path\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n\treturn list(sys.stdin.readline().strip())\n\ndef li():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n\treturn map(int, sys.stdin.readline().split())\n\ndef inp():\n\treturn int(sys.stdin.readline())\n\ndef pr(n):\n\treturn sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n\treturn sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\n\ndef solve():\n\tn = inp()\n\tl = li()\n\tpref_pos = [0 for i in range(n)]\n\tsuf_neg = [0 for i in range(n)]\n\t(a, b) = (INF, -INF)\n\tfor i in range(n):\n\t\tif l[i] >= 0:\n\t\t\tif i == 0:\n\t\t\t\tpref_pos[i] = 1\n\t\t\telse:\n\t\t\t\tpref_pos[i] = 1 + pref_pos[i - 1]\n\t\telif i != 0:\n\t\t\tpref_pos[i] += pref_pos[i - 1]\n\t\tif l[n - i - 1] <= 0:\n\t\t\tif i == 0:\n\t\t\t\tsuf_neg[n - i - 1] = 1\n\t\t\telse:\n\t\t\t\tsuf_neg[n - 1 - i] = 1 + suf_neg[n - i]\n\t\telif i != 0:\n\t\t\tsuf_neg[n - i - 1] += suf_neg[n - i]\n\t\ta = min(a, l[i])\n\t\tb = max(b, l[i])\n\tif a > 0 and b > 0 or (a < 0 and b < 0):\n\t\tpr(1)\n\t\treturn\n\tans = INF\n\tfor i in range(n - 1):\n\t\tans = min(ans, pref_pos[i] + suf_neg[i + 1])\n\tpr(ans)\nsolve()\n",
        "slowest_solution": "import sys\nimport os.path\nif os.path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\nn = int(input())\nl = list(map(int, input().split()))\nneg = [0] * n\npos = [0] * n\nif l[0] >= 0:\n\tpos[0] = 1\nfor i in range(1, n):\n\tif l[i] >= 0:\n\t\tpos[i] = pos[i - 1] + 1\n\telse:\n\t\tpos[i] = pos[i - 1]\nif l[-1] <= 0:\n\tneg[-1] = 1\nfor i in range(n - 2, -1, -1):\n\tif l[i] <= 0:\n\t\tneg[i] = neg[i + 1] + 1\n\telse:\n\t\tneg[i] = neg[i + 1]\nans = float('inf')\nfor i in range(n - 1):\n\tans = min(ans, pos[i] + neg[i + 1])\nprint(ans)\n"
    },
    {
        "task_id": 395,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.618347644805908,
        "fastest_time": 2.5516562461853027,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n(N, M) = map(int, input().split())\nG1 = [[] for _ in range(N + 1)]\nG2 = [[] for _ in range(N + 1)]\nfor _ in range(M):\n\t(x, y) = map(int, input().split())\n\tG1[x].append(y)\n\tG2[y].append(x)\nlens = [len(G2[i]) for i in range(N + 1)]\nstack = [x for x in range(N + 1) if lens[x] == 0 and x != 0]\ntopo = [x for x in range(N + 1) if lens[x] == 0 and x != 0]\nwhile stack:\n\tcur = stack.pop()\n\tfor nb in G1[cur]:\n\t\tlens[nb] -= 1\n\t\tif lens[nb] == 0:\n\t\t\ttopo.append(nb)\n\t\t\tstack.append(nb)\nif len(topo) != N:\n\tprint(-1)\n\tsys.exit(0)\nR = [0] * (N + 1)\nv1 = set()\nv2 = set()\nc = 0\nfor s in range(1, N + 1):\n\tif s in v1 or s in v2:\n\t\tR[s] = 'E'\n\telse:\n\t\tR[s] = 'A'\n\t\tc += 1\n\tstack = [s]\n\twhile stack:\n\t\tv = stack.pop()\n\t\tfor u in G1[v]:\n\t\t\tif u in v1:\n\t\t\t\tcontinue\n\t\t\tv1.add(u)\n\t\t\tstack.append(u)\n\tstack = [s]\n\twhile stack:\n\t\tv = stack.pop()\n\t\tfor u in G2[v]:\n\t\t\tif u in v2:\n\t\t\t\tcontinue\n\t\t\tv2.add(u)\n\t\t\tstack.append(u)\nprint(c)\nprint(''.join(R[1:]))\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef inp():\n\treturn int(input())\n\ndef inlt():\n\treturn list(map(int, input().split()))\n\ndef insr():\n\ts = input().strip()\n\treturn list(s[:len(s)])\n\ndef invr():\n\treturn map(int, input().split())\n\ndef from_file(f):\n\treturn f.readline\n\ndef build_graph(n, A, reversed=False):\n\tedges = [[] for _ in range(n)]\n\tfor (i, j) in A:\n\t\ti -= 1\n\t\tj -= 1\n\t\tif reversed:\n\t\t\t(j, i) = (i, j)\n\t\tedges[i].append(j)\n\treturn edges\n\ndef fill_min(s, edges, visited_dfs, visited, container):\n\tvisited[s] = True\n\tvisited_dfs.add(s)\n\tfor c in edges[s]:\n\t\tif c in visited_dfs:\n\t\t\treturn -1\n\t\tif not visited[c]:\n\t\t\tres = fill_min(c, edges, visited_dfs, visited, container)\n\t\t\tif res == -1:\n\t\t\t\treturn -1\n\t\tcontainer[s] = min(container[s], container[c])\n\tvisited_dfs.remove(s)\n\treturn 0\n\ndef dfs(s, edges, visited, container):\n\tstack = [s]\n\tcolors = {s: 0}\n\twhile stack:\n\t\tv = stack.pop()\n\t\tif colors[v] == 0:\n\t\t\tcolors[v] = 1\n\t\t\tstack.append(v)\n\t\telse:\n\t\t\ttmp = [container[c] for c in edges[v]]\n\t\t\tif tmp:\n\t\t\t\tcontainer[v] = min(min(tmp), container[v])\n\t\t\tcolors[v] = 2\n\t\t\tvisited[v] = True\n\t\tfor c in edges[v]:\n\t\t\tif visited[c]:\n\t\t\t\tcontinue\n\t\t\tif c not in colors:\n\t\t\t\tcolors[c] = 0\n\t\t\t\tstack.append(c)\n\t\t\telif colors[c] == 1:\n\t\t\t\treturn -1\n\treturn 0\n\ndef iterate_topologically(n, edges, container):\n\tvisited = [False] * n\n\tfor s in range(n):\n\t\tif not visited[s]:\n\t\t\tres = dfs(s, edges, visited, container)\n\t\t\tif res == -1:\n\t\t\t\treturn -1\n\treturn 0\n\ndef solve(n, A):\n\tedges = build_graph(n, A, False)\n\tcontainer_forward = list(range(n))\n\tcontainer_backward = list(range(n))\n\tres = iterate_topologically(n, edges, container_forward)\n\tif res == -1:\n\t\treturn None\n\tedges = build_graph(n, A, True)\n\titerate_topologically(n, edges, container_backward)\n\tcontainer = [min(i, j) for (i, j) in zip(container_forward, container_backward)]\n\tres = sum((1 if container[i] == i else 0 for i in range(n)))\n\ts = ''.join(['A' if container[i] == i else 'E' for i in range(n)])\n\treturn (res, s)\n(n, m) = invr()\nA = []\nfor _ in range(m):\n\t(i, j) = invr()\n\tA.append((i, j))\nresult = solve(n, A)\nif not result:\n\tprint(-1)\nelse:\n\tprint(f'{result[0]}')\n\tprint(f'{result[1]}')\n"
    },
    {
        "task_id": 356,
        "slowest_solution_id": 0,
        "fastest_solution_id": 4,
        "slowest_time": 2.856423854827881,
        "fastest_time": 2.4903194904327393,
        "fastest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tll = []\n\tfor i in range(n):\n\t\tif l[i] != 0:\n\t\t\tll.append(l[i])\n\tif sum(l) < 100:\n\t\tprint('NO')\n\telif sum(l) == 100:\n\t\tprint('YES')\n\telif sum(ll) - 100 >= len(ll):\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\tN = int(input())\n\tB = list(map(int, input().split()))\n\ttotal = ones = 0\n\tflag = 0\n\tfor i in B:\n\t\tif i > 0:\n\t\t\tones += 1\n\t\t\ttotal += i\n\t\tif i > 100:\n\t\t\tflag = 1\n\tif total - ones < 100 and total >= 100:\n\t\tans = 'YES'\n\telse:\n\t\tans = 'NO'\n\tprint(ans)\n"
    },
    {
        "task_id": 369,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 2.670592784881592,
        "fastest_time": 2.579926013946533,
        "fastest_solution": "t = int(input())\nfor i in range(t):\n\tans = 0\n\tc = int(input())\n\tfor j in range(c):\n\t\t(n, m) = map(int, input().split())\n\t\tans ^= (n + m - 2) % 3\n\tprint('Football' if not ans else 'MasterChef')\n",
        "slowest_solution": "t = int(input())\nans = []\nfor i in range(0, t):\n\tc = int(input())\n\ts = 0\n\tfor j in range(0, c):\n\t\t(n, m) = [int(x) for x in input().lstrip().rstrip().split(' ')]\n\t\tg = (n + m - 2) % 3\n\t\ts = s ^ g\n\tif s == 0:\n\t\tans.append('Football')\n\telse:\n\t\tans.append('MasterChef')\nprint('\\n'.join(ans))\n"
    },
    {
        "task_id": 358,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.7674508094787598,
        "fastest_time": 2.4242587089538574,
        "fastest_solution": "for z in range(int(input())):\n\tn = int(input())\n\ta = [int(x) for x in input().split()]\n\tif n == 1 or n == 2:\n\t\tprint(n)\n\t\tcontinue\n\n\tdef gcd(x, y):\n\t\twhile y:\n\t\t\t(x, y) = (y, x % y)\n\t\treturn x\n\tg = a[0]\n\tp = [0] * n\n\ts = [0] * n\n\ts[n - 1] = 1\n\tp[0] = 1\n\tfor i in range(1, n):\n\t\tp[i] = g\n\t\tg = gcd(g, a[i])\n\tg = a[n - 1]\n\tfor i in range(n - 2, -1, -1):\n\t\ts[i] = g\n\t\tg = gcd(g, a[i])\n\tb = [0] * n\n\tb[0] = s[0]\n\tb[n - 1] = p[n - 1]\n\tfor i in range(1, n - 1):\n\t\tb[i] = gcd(p[i], s[i])\n\ts = sum(a)\n\tm = (s - a[0] + b[0]) // b[0]\n\tfor i in range(1, n):\n\t\tm = min(m, (s - a[i] + b[i]) // b[i])\n\tprint(m)\n",
        "slowest_solution": "def gcd(a, b):\n\tif a == 0:\n\t\treturn b\n\treturn gcd(b % a, a)\nT = int(input())\nfor test in range(T):\n\tn = int(input())\n\tA = [int(x) for x in input().split()]\n\tif n == 1:\n\t\tprint(1)\n\t\tcontinue\n\ts = 0\n\tG = []\n\tfor i in range(n + 1):\n\t\tif i < n:\n\t\t\ts += A[i]\n\t\tG.append(0)\n\tG[n - 1] = A[-1]\n\tfor i in range(n - 2, -1, -1):\n\t\tG[i] = gcd(A[i], G[i + 1])\n\tm = s\n\tg = 0\n\tfor i in range(n):\n\t\ty = gcd(g, G[i + 1])\n\t\ty = (s - A[i] + y) // y\n\t\tg = gcd(g, A[i])\n\t\tif y < m:\n\t\t\tm = y\n\tprint(m)\n"
    },
    {
        "task_id": 407,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5613901615142822,
        "fastest_time": 2.5613901615142822,
        "fastest_solution": "from sys import stdin\nfrom bisect import bisect_left, bisect_right\nINF = int(1000000000.0)\n\ndef find(par, a):\n\tif par[a] == a:\n\t\treturn a\n\tpar[a] = find(par, par[a])\n\treturn par[a]\n\ndef union(par, rnk, a, b):\n\ta = find(par, a)\n\tb = find(par, b)\n\tif a == b:\n\t\treturn\n\tif rnk[a] < rnk[b]:\n\t\tpar[a] = b\n\telse:\n\t\tpar[b] = a\n\t\tif rnk[a] == rnk[b]:\n\t\t\trnk[a] += 1\n\ndef solve():\n\t(n, m, k) = map(int, stdin.readline().split())\n\tcnts = list(map(int, stdin.readline().split()))\n\tfor i in range(1, k):\n\t\tcnts[i] += cnts[i - 1]\n\tgroup = list(range(n))\n\trnk = [0 for i in range(n)]\n\tadj = [[INF for j in range(k)] for i in range(k)]\n\tfor i in range(m):\n\t\t(u, v, x) = map(int, stdin.readline().split())\n\t\tif x == 0:\n\t\t\tunion(group, rnk, u - 1, v - 1)\n\t\ttu = bisect_left(cnts, u)\n\t\ttv = bisect_left(cnts, v)\n\t\tadj[tu][tv] = min(adj[tu][tv], x)\n\t\tadj[tv][tu] = min(adj[tv][tu], x)\n\tp = 0\n\tfor i in range(k):\n\t\tcur = group[p]\n\t\twhile p < cnts[i]:\n\t\t\tif group[p] != cur:\n\t\t\t\tprint('No')\n\t\t\t\treturn\n\t\t\tp += 1\n\tprint('Yes')\n\tfor p in range(k):\n\t\tfor i in range(k):\n\t\t\tfor j in range(k):\n\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][p] + adj[p][j])\n\tfor i in range(k):\n\t\tadj[i][i] = 0\n\t\tfor j in range(k):\n\t\t\tif adj[i][j] == INF:\n\t\t\t\tadj[i][j] = -1\n\tfor i in range(k):\n\t\tprint(' '.join(map(lambda x: str(x), adj[i])))\nsolve()\n",
        "slowest_solution": "from sys import stdin\nfrom bisect import bisect_left, bisect_right\nINF = int(1000000000.0)\n\ndef find(par, a):\n\tif par[a] == a:\n\t\treturn a\n\tpar[a] = find(par, par[a])\n\treturn par[a]\n\ndef union(par, rnk, a, b):\n\ta = find(par, a)\n\tb = find(par, b)\n\tif a == b:\n\t\treturn\n\tif rnk[a] < rnk[b]:\n\t\tpar[a] = b\n\telse:\n\t\tpar[b] = a\n\t\tif rnk[a] == rnk[b]:\n\t\t\trnk[a] += 1\n\ndef solve():\n\t(n, m, k) = map(int, stdin.readline().split())\n\tcnts = list(map(int, stdin.readline().split()))\n\tfor i in range(1, k):\n\t\tcnts[i] += cnts[i - 1]\n\tgroup = list(range(n))\n\trnk = [0 for i in range(n)]\n\tadj = [[INF for j in range(k)] for i in range(k)]\n\tfor i in range(m):\n\t\t(u, v, x) = map(int, stdin.readline().split())\n\t\tif x == 0:\n\t\t\tunion(group, rnk, u - 1, v - 1)\n\t\ttu = bisect_left(cnts, u)\n\t\ttv = bisect_left(cnts, v)\n\t\tadj[tu][tv] = min(adj[tu][tv], x)\n\t\tadj[tv][tu] = min(adj[tv][tu], x)\n\tp = 0\n\tfor i in range(k):\n\t\tcur = group[p]\n\t\twhile p < cnts[i]:\n\t\t\tif group[p] != cur:\n\t\t\t\tprint('No')\n\t\t\t\treturn\n\t\t\tp += 1\n\tprint('Yes')\n\tfor p in range(k):\n\t\tfor i in range(k):\n\t\t\tfor j in range(k):\n\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][p] + adj[p][j])\n\tfor i in range(k):\n\t\tadj[i][i] = 0\n\t\tfor j in range(k):\n\t\t\tif adj[i][j] == INF:\n\t\t\t\tadj[i][j] = -1\n\tfor i in range(k):\n\t\tprint(' '.join(map(lambda x: str(x), adj[i])))\nsolve()\n"
    },
    {
        "task_id": 359,
        "slowest_solution_id": 5,
        "fastest_solution_id": 6,
        "slowest_time": 2.758051633834839,
        "fastest_time": 2.488395929336548,
        "fastest_solution": "import math\nimport sys\nfrom decimal import Decimal\n\ndef main(arr, n, m):\n\tidx = [[0 for i in range(n + 1)] for j in range(m)]\n\tif m == 1:\n\t\treturn n * (n + 1) // 2\n\tnew = True\n\tl = 0\n\tfor i in range(m):\n\t\tfor j in range(n):\n\t\t\tidx[i][arr[i][j]] = j\n\tcurr_idx = [0] * m\n\tans = 0\n\ti = 0\n\twhile i < len(arr[0]):\n\t\tval = arr[0][i]\n\t\tif new:\n\t\t\tnew = False\n\t\t\tfor j in range(m):\n\t\t\t\tcurr_idx[j] = idx[j][val]\n\t\t\tl = 1\n\t\telse:\n\t\t\tfor j in range(m):\n\t\t\t\tif idx[j][val] != curr_idx[j] + 1:\n\t\t\t\t\tans += l * (l + 1) // 2\n\t\t\t\t\tnew = True\n\t\t\t\t\ti -= 1\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tcurr_idx[j] += 1\n\t\t\tif not new:\n\t\t\t\tl += 1\n\t\ti += 1\n\tif l >= 1:\n\t\tans += l * (l + 1) // 2\n\treturn ans\n(n, m) = list(map(int, input().split()))\narr = []\nfor i in range(m):\n\tarr.append(list(map(int, input().split())))\nprint(main(arr, n, m))\n",
        "slowest_solution": "(N, M) = list(map(int, input().split()))\nA = []\nloc = [{} for _ in range(M)]\nfor i in range(M):\n\ta = [int(x) for x in input().split()]\n\tA.append(a)\n\tfor (iv, v) in enumerate(a):\n\t\tloc[i][v] = iv\nans = 0\nls = [0] * M\ni = 0\nwhile i < N:\n\tv = A[0][i]\n\tls = [loc[j][v] for j in range(M)]\n\tsegl = 1\n\twhile all([l + segl < N for l in ls]) and all((A[il][l + segl] == A[0][ls[0] + segl] for (il, l) in enumerate(ls))):\n\t\tsegl += 1\n\tans += segl * (segl + 1) // 2\n\ti += segl\nprint(ans)\n"
    },
    {
        "task_id": 393,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 2.6768784523010254,
        "fastest_time": 2.515141248703003,
        "fastest_solution": "import sys\nfrom array import array\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\nn = int(input())\nmatrix = [array('i', list(map(int, input().split()))) for _ in range(n)]\naa = tuple(map(lambda x: int(x) - 1, input().split()))\nans = [''] * n\nfor i in range(n - 1, -1, -1):\n\tx = aa[i]\n\tfor a in range(n):\n\t\tfor b in range(n):\n\t\t\tif matrix[a][b] > matrix[a][x] + matrix[x][b]:\n\t\t\t\tmatrix[a][b] = matrix[a][x] + matrix[x][b]\n\t(lower, higher) = (0, 0)\n\tfor a in aa[i:]:\n\t\tfor b in aa[i:]:\n\t\t\tlower += matrix[a][b]\n\t\tif lower > 10 ** 9:\n\t\t\thigher += 1\n\t\t\tlower -= 10 ** 9\n\tans[i] = str(10 ** 9 * higher + lower)\nprint(' '.join(ans))\n",
        "slowest_solution": "import sys\nfrom array import array\nn = int(input())\nmatrix = [array('i', list(map(int, input().split()))) for _ in range(n)]\naa = tuple(map(lambda x: int(x) - 1, input().split()))\nans = [''] * n\nfor i in range(n - 1, -1, -1):\n\tx = aa[i]\n\tfor a in range(n):\n\t\tfor b in range(n):\n\t\t\tif matrix[a][b] > matrix[a][x] + matrix[x][b]:\n\t\t\t\tmatrix[a][b] = matrix[a][x] + matrix[x][b]\n\t(val, overflow) = (0, 0)\n\tfor a in aa[i:]:\n\t\tfor b in aa[i:]:\n\t\t\tval += matrix[a][b]\n\t\tif val > 10 ** 9:\n\t\t\toverflow += 1\n\t\t\tval -= 10 ** 9\n\tans[i] = str(10 ** 9 * overflow + val)\nprint(' '.join(ans))\n"
    },
    {
        "task_id": 361,
        "slowest_solution_id": 6,
        "fastest_solution_id": 9,
        "slowest_time": 3.0598697662353516,
        "fastest_time": 2.5344388484954834,
        "fastest_solution": "def f(num):\n\tsigma = [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n\tn = len(num)\n\tif n == 1:\n\t\treturn 0\n\tmemoR = [None] * n\n\tmemoR[n - 2] = {'lSum': 0}\n\tfor i in range(n - 3, -1, -1):\n\t\tlSum = memoR[i + 1]['lSum'] * 10 + num[i + 2]\n\t\tlSum %= MOD\n\t\tmemoR[i] = {'lSum': lSum}\n\tmemoR[0]['pow'] = 1\n\tfor i in range(1, n - 1):\n\t\tpower = memoR[i - 1]['pow'] * 10\n\t\tpower %= MOD\n\t\tmemoR[i]['pow'] = power\n\tmemoR[0]['rSum'] = 0\n\tfor i in range(1, n - 1):\n\t\trSum = num[i - 1] * memoR[i - 1]['pow'] % MOD + memoR[i - 1]['rSum']\n\t\trSum %= MOD\n\t\tmemoR[i]['rSum'] = rSum\n\tans = 0\n\tfor i in range(0, n - 1):\n\t\td = None\n\t\tif num[i] <= num[i + 1]:\n\t\t\td = num[i + 1] - 1\n\t\telse:\n\t\t\td = num[i + 1]\n\t\tif d >= 0:\n\t\t\tocc = (memoR[i]['lSum'] + 1) * memoR[i]['pow'] % MOD\n\t\t\tans += occ * sigma[d] % MOD * memoR[i]['pow'] % MOD\n\t\t\tans %= MOD\n\t\td += 1\n\t\tif num[i] == num[i + 1] and num[i] == d:\n\t\t\tocc = (memoR[i]['lSum'] * memoR[i]['pow'] % MOD + memoR[i]['rSum'] + 1) % MOD\n\t\t\tans += occ * d % MOD * memoR[i]['pow'] % MOD\n\t\t\tans %= MOD\n\t\t\td += 1\n\t\tif d >= 10:\n\t\t\tcontinue\n\t\tocc = memoR[i]['lSum'] * memoR[i]['pow'] % MOD\n\t\tans += occ * (45 - sigma[d - 1]) % MOD * memoR[i]['pow'] % MOD\n\t\tans %= MOD\n\treturn ans\nt = int(input())\nMOD = 1000000007\nwhile t:\n\tt -= 1\n\t(nL, l) = input().split()\n\tnL = int(nL)\n\tl = [int(li) for li in l]\n\tl = l[::-1]\n\t(nR, r) = input().split()\n\tnR = int(nR)\n\tr = [int(ri) for ri in r]\n\tr = r[::-1]\n\tr_mod = 0\n\tpower = 1\n\tfor i in r:\n\t\tr_mod += i * power % MOD\n\t\tr_mod %= MOD\n\t\tpower *= 10\n\t\tpower %= MOD\n\tl_mod = 0\n\tpower = 1\n\tfor i in l:\n\t\tl_mod += i * power % MOD\n\t\tl_mod %= MOD\n\t\tpower *= 10\n\t\tpower %= MOD\n\tans = None\n\tif r_mod % 2:\n\t\tans = (r_mod + 1) // 2\n\t\tans %= MOD\n\t\tans *= r_mod\n\t\tans %= MOD\n\telse:\n\t\tans = r_mod // 2\n\t\tans %= MOD\n\t\tans *= (r_mod + 1) % MOD\n\t\tans %= MOD\n\tans2 = None\n\tif l_mod % 2:\n\t\tans2 = (l_mod - 1) // 2\n\t\tans2 %= MOD\n\t\tans2 *= l_mod % MOD\n\t\tans2 %= MOD\n\telse:\n\t\tans2 = l_mod // 2\n\t\tans2 %= MOD\n\t\tans2 *= (l_mod - 1) % MOD\n\t\tans2 %= MOD\n\tans -= ans2\n\tif l[0] != 0:\n\t\tl[0] -= 1\n\telse:\n\t\tfor i in range(0, nL):\n\t\t\tif l[i] == 0:\n\t\t\t\tl[i] = 9\n\t\t\telse:\n\t\t\t\tl[i] -= 1\n\t\t\t\tbreak\n\ttemp = (f(r) - f(l)) % MOD\n\tans -= temp\n\tans %= MOD\n\tprint(ans)\n",
        "slowest_solution": "t = int(input())\nM = 1000000007\ntsum = [0] * 100001\ntsum[1] = 0\ntsum[2] = 45\nfor i in range(3, 100001):\n\ttsum[i] = (45 % M * pow(100, i - 2, M) % M % M + 10 * tsum[i - 1] % M) % M\nfor _ in range(t):\n\td1 = 0\n\td2 = 0\n\t(n, s1) = map(str, input().split())\n\t(m, s2) = map(str, input().split())\n\tn = int(n)\n\tm = int(m)\n\ta1 = [0] * (n + 1)\n\ta2 = [0] * (m + 1)\n\tfor i in range(1, len(a1)):\n\t\ta1[i] = ord(s1[i - 1]) - ord('0')\n\tfor i in range(1, len(a2)):\n\t\ta2[i] = ord(s2[i - 1]) - ord('0')\n\tn1 = [0] * (n + 1)\n\tn2 = [0] * (m + 1)\n\tn1[n] = a1[n]\n\tn2[m] = a2[m]\n\ti = n - 1\n\twhile i >= 1:\n\t\tn1[i] = (n1[i + 1] % M + a1[i] % M * pow(10, n - i, M) % M % M) % M\n\t\ti = i - 1\n\ti = m - 1\n\twhile i >= 1:\n\t\tn2[i] = (n2[i + 1] % M + a2[i] % M * pow(10, m - i, M) % M % M) % M\n\t\ti = i - 1\n\ti = 0\n\tfor i in range(1, n):\n\t\tif a1[i] == 0:\n\t\t\tcontinue\n\t\tif i == 1:\n\t\t\td1 = (d1 % M + a1[i] % M * tsum[n - i] % M % M + (a1[i] - 1) * a1[i] // 2 % M * (pow(100, n - i - 1, M) % M) % M) % M\n\t\telif a1[i] < a1[i - 1]:\n\t\t\td1 = (d1 % M + a1[i] % M * tsum[n - i] % M % M + (a1[i] - 1) * a1[i] // 2 % M * (pow(100, n - i - 1, M) % M) % M) % M\n\t\telif a1[i] == a1[i - 1]:\n\t\t\td1 = ((d1 % M + a1[i] % M * tsum[n - i] % M % M + (a1[i] - 1) * a1[i] // 2 % M * (pow(100, n - i - 1, M) % M) % M) % M + a1[i - 1] % M * (n1[i + 1] + 1) % M % M % M * pow(10, n - i, M) % M % M) % M\n\t\telif a1[i] > a1[i - 1]:\n\t\t\td1 = ((d1 % M + a1[i] % M * tsum[n - i] % M % M + (a1[i] - 1) * a1[i] // 2 % M * (pow(100, n - i - 1, M) % M) % M) % M + a1[i - 1] % M * pow(100, n - i, M) % M % M) % M\n\tif a1[n - 1] <= a1[n]:\n\t\td1 = (d1 % M + a1[n - 1] % M) % M\n\tfor i in range(1, m):\n\t\tif a2[i] == 0:\n\t\t\tcontinue\n\t\tif i == 1:\n\t\t\td2 = (d2 % M + a2[i] % M * tsum[m - i] % M % M + (a2[i] - 1) * a2[i] // 2 % M * (pow(100, m - i - 1, M) % M) % M) % M\n\t\telif a2[i] < a2[i - 1]:\n\t\t\td2 = (d2 % M + a2[i] % M * tsum[m - i] % M % M + (a2[i] - 1) * a2[i] // 2 % M * (pow(100, m - i - 1, M) % M) % M) % M\n\t\telif a2[i] == a2[i - 1]:\n\t\t\td2 = ((d2 % M + a2[i] % M * tsum[m - i] % M % M + (a2[i] - 1) * a2[i] // 2 % M * (pow(100, m - i - 1, M) % M) % M) % M + a2[i - 1] % M * (n2[i + 1] + 1) % M % M % M * pow(10, m - i, M) % M % M) % M\n\t\telif a2[i] > a2[i - 1]:\n\t\t\td2 = ((d2 % M + a2[i] % M * tsum[m - i] % M % M + (a2[i] - 1) * a2[i] // 2 % M * (pow(100, m - i - 1, M) % M) % M) % M + a2[i - 1] % M * pow(100, m - i, M) % M % M) % M\n\tif a2[m - 1] <= a2[m]:\n\t\td2 = (d2 % M + a2[m - 1] % M) % M\n\tnumber = 0\n\ti = n\n\twhile i >= 2:\n\t\tif a1[i] != a1[i - 1]:\n\t\t\tnumber = (number % M + a1[i] % M * pow(10, n - i, M) % M % M) % M\n\t\ti = i - 1\n\tnumber = (number % M + a1[1] % M * pow(10, n - 1, M) % M % M) % M\n\tnow1 = (d2 % M - d1 % M + M) % M\n\tnow2 = (n2[1] % M * (n2[1] + 1) % M % M - n1[1] % M * (n1[1] + 1) % M % M + M) % M * 500000004 % M\n\tfinal = (now2 % M - now1 % M + M) % M\n\tsoln = (final % M + number % M) % M\n\tprint(soln)\n"
    },
    {
        "task_id": 404,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 7.329023838043213,
        "fastest_time": 7.329023838043213,
        "fastest_solution": "import numpy.fft as fft\n\ndef coeff(p, Max):\n\tfor i in range(19):\n\t\tif 1 << i > Max:\n\t\t\tbreak\n\tc = [0] * (1 << i + 1)\n\tfor p in p:\n\t\tc[p] = 1\n\treturn c\n\ndef invcoeff(p, Max):\n\tD = []\n\tfor i in range(Max + 1, len(p)):\n\t\tif abs(p[i]) > 1e-09:\n\t\t\tD.append(i - Max)\n\treturn D\n\ndef getdiffs(A):\n\tM = max(A)\n\tM_A = [M - a for a in A]\n\tFFT_A = fft.rfft(coeff(A, M))\n\tFFT_M_A = fft.rfft(coeff(M_A, M))\n\treturn invcoeff(fft.irfft(FFT_A * FFT_M_A), M)\nDIVS = [set() for N in range(2 * 10 ** 5)]\nfor i in range(1, 2 * 10 ** 5):\n\tfor k in range(i, 2 * 10 ** 5, i):\n\t\tDIVS[k].add(i)\n\ndef main(N, A):\n\tABS = getdiffs(A)\n\tDIV = set()\n\tfor absval in ABS:\n\t\tDIV |= DIVS[absval]\n\tfor d in range(2, 2 * 10 ** 5 + 5):\n\t\tif d not in DIV:\n\t\t\treturn d\nT = int(input().strip())\nfor _ in range(T):\n\tN = int(input().strip())\n\tA = list(map(int, input().split()[:N]))\n\tprint(main(N, A))\n",
        "slowest_solution": "import numpy.fft as fft\n\ndef coeff(p, Max):\n\tfor i in range(19):\n\t\tif 1 << i > Max:\n\t\t\tbreak\n\tc = [0] * (1 << i + 1)\n\tfor p in p:\n\t\tc[p] = 1\n\treturn c\n\ndef invcoeff(p, Max):\n\tD = []\n\tfor i in range(Max + 1, len(p)):\n\t\tif abs(p[i]) > 1e-09:\n\t\t\tD.append(i - Max)\n\treturn D\n\ndef getdiffs(A):\n\tM = max(A)\n\tM_A = [M - a for a in A]\n\tFFT_A = fft.rfft(coeff(A, M))\n\tFFT_M_A = fft.rfft(coeff(M_A, M))\n\treturn invcoeff(fft.irfft(FFT_A * FFT_M_A), M)\nDIVS = [set() for N in range(2 * 10 ** 5)]\nfor i in range(1, 2 * 10 ** 5):\n\tfor k in range(i, 2 * 10 ** 5, i):\n\t\tDIVS[k].add(i)\n\ndef main(N, A):\n\tABS = getdiffs(A)\n\tDIV = set()\n\tfor absval in ABS:\n\t\tDIV |= DIVS[absval]\n\tfor d in range(2, 2 * 10 ** 5 + 5):\n\t\tif d not in DIV:\n\t\t\treturn d\nT = int(input().strip())\nfor _ in range(T):\n\tN = int(input().strip())\n\tA = list(map(int, input().split()[:N]))\n\tprint(main(N, A))\n"
    },
    {
        "task_id": 362,
        "slowest_solution_id": 0,
        "fastest_solution_id": 5,
        "slowest_time": 2.748593807220459,
        "fastest_time": 2.4433934688568115,
        "fastest_solution": "(r, x, y, x1, y1) = map(int, input().split())\ndist = ((x1 - x) ** 2 + (y1 - y) ** 2) ** 0.5\nif dist == 0:\n\tprint(int(dist))\nelif dist < 2 * r:\n\tprint(int(1))\nelif dist % (2 * r) == 0:\n\tprint(int(dist // (2 * r)))\nelse:\n\tprint(int(dist // (2 * r) + 1))\n",
        "slowest_solution": "import math\n(r, x, y, p, q) = list(map(int, input().strip().split(' ')))\nprint(math.ceil(((p - x) ** 2 + (q - y) ** 2) ** 0.5 / (2 * r)))\n"
    },
    {
        "task_id": 392,
        "slowest_solution_id": 2,
        "fastest_solution_id": 4,
        "slowest_time": 2.7218732833862305,
        "fastest_time": 2.530832290649414,
        "fastest_solution": "n = int(input())\nans = [[0] * 26 for i in range(26)]\nalth = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(n):\n\ttemp = input()\n\tif len(temp) == 1:\n\t\tans[alth.find(temp[0])][alth.find(temp[0])] = 2\n\tfor j in range(len(temp) - 1):\n\t\tans[alth.find(temp[j])][alth.find(temp[j + 1])] = 1\ni = 0\nj = 0\nj2 = 0\nwhile True:\n\ttemp = 1\n\tfor i in range(i, 26):\n\t\ttemp = 1\n\t\tfor j in range(j2, 26):\n\t\t\tif ans[i][j] == 1:\n\t\t\t\ttemp = 0\n\t\t\t\tfor z in range(26):\n\t\t\t\t\tif ans[z][i] == 1:\n\t\t\t\t\t\ttemp = 1\n\t\t\t\t\t\tbreak\n\t\t\t\tif temp == 0:\n\t\t\t\t\tbreak\n\t\t\tj2 += 1\n\t\tif temp == 0:\n\t\t\tbreak\n\t\tj2 = 0\n\tif temp == 0:\n\t\tans[i][i] = 3\n\t\tans[j][j] = 3\n\t\tprint(alth[i] + alth[j], end='')\n\t\tz2 = j\n\t\twhile True:\n\t\t\ttemp = 0\n\t\t\tfor z3 in range(26):\n\t\t\t\tif ans[z2][z3] == 1:\n\t\t\t\t\ttemp = 1\n\t\t\t\t\tbreak\n\t\t\tif temp == 0:\n\t\t\t\tbreak\n\t\t\tprint(alth[z3], end='')\n\t\t\tans[z3][z3] = 3\n\t\t\tz2 = z3\n\telif i == 25 and j == 25:\n\t\tbreak\n\tj2 += 1\nfor i in range(26):\n\tif ans[i][i] == 2:\n\t\tprint(alth[i], end='')\n",
        "slowest_solution": "n = int(input())\nss = []\nfor i in range(n):\n\tss += [input()]\nu = [False] * 26\nuc = 0\np = [-1] * 26\nn = [-1] * 26\nfor s in ss:\n\tfor i in range(len(s)):\n\t\tif not u[ord(s[i]) - ord('a')]:\n\t\t\tuc += 1\n\t\tu[ord(s[i]) - ord('a')] = True\n\t\tif i > 0:\n\t\t\tp[ord(s[i]) - ord('a')] = ord(s[i - 1]) - ord('a')\n\t\t\tn[ord(s[i - 1]) - ord('a')] = ord(s[i]) - ord('a')\nw = ''\nwhile uc > 0:\n\tfor i in range(26):\n\t\tif u[i] and p[i] == -1:\n\t\t\tc = i\n\t\t\twhile True:\n\t\t\t\tw += chr(c + ord('a'))\n\t\t\t\tu[c] = True\n\t\t\t\tuc -= 1\n\t\t\t\tif n[c] == -1:\n\t\t\t\t\tbreak\n\t\t\t\tc = n[c]\nprint(w)\n"
    },
    {
        "task_id": 364,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.733248472213745,
        "fastest_time": 2.548643112182617,
        "fastest_solution": "import sys\nsys.setrecursionlimit(99999999)\nfrom collections import defaultdict\ngraph = defaultdict(set)\nn = int(input())\narr = list(map(int, input().split()))\nfor i in range(len(arr)):\n\tgraph[arr[i]].add(i + 2)\nparent = [-1] * (n + 1)\n\ndef bfs():\n\tfrom collections import deque\n\tq = deque()\n\tq.append(1)\n\tvisited = set()\n\twhile q:\n\t\tu = q.popleft()\n\t\tvisited.add(u)\n\t\tfor v in graph[u]:\n\t\t\tif v not in visited:\n\t\t\t\tparent[v] = u\n\t\t\t\tq.append(v)\nbfs()\npath = [n]\nv = n\nwhile v != 1:\n\tv = parent[v]\n\tpath.append(v)\npath.reverse()\nfor x in path:\n\tprint(x, end=' ')\n",
        "slowest_solution": "n = int(input())\np = list(map(int, input().split()))\nlis = []\ni = n\nwhile i != 1:\n\tlis.append(i)\n\ti = p[i - 2]\nprint(*[1] + lis[::-1])\n"
    },
    {
        "task_id": 410,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 0.9603128433227539,
        "fastest_time": 0.7309577465057373,
        "fastest_solution": "from collections import deque\nfor _ in range(int(input())):\n\t(n, m, k1, k2) = list(map(int, input().split()))\n\tarr = []\n\tfor i in range(n):\n\t\tarr.append(list(map(int, input().split())))\n\trobo1 = [[-1] * m for i in range(n)]\n\trobo2 = [[-1] * m for i in range(n)]\n\trobo1[0][0] = 0\n\trobo2[0][m - 1] = 0\n\tQ = deque([(0, 0)])\n\twhile Q:\n\t\t(i, j) = Q.popleft()\n\t\tfor x in range(max(i - k1, 0), min(i + k1 + 1, n)):\n\t\t\tt = abs(i - x)\n\t\t\tfor y in range(max(0, j - k1 + t), min(j + k1 - t + 1, m)):\n\t\t\t\tif arr[x][y] == 0 and robo1[x][y] == -1:\n\t\t\t\t\trobo1[x][y] = robo1[i][j] + 1\n\t\t\t\t\tQ.append((x, y))\n\tQ = deque([(0, m - 1)])\n\twhile Q:\n\t\t(i, j) = Q.popleft()\n\t\tfor x in range(max(i - k2, 0), min(i + k2 + 1, n)):\n\t\t\tt = abs(i - x)\n\t\t\tfor y in range(max(0, j - k2 + t), min(j + k2 - t + 1, m)):\n\t\t\t\tif arr[x][y] == 0 and robo2[x][y] == -1:\n\t\t\t\t\trobo2[x][y] = robo2[i][j] + 1\n\t\t\t\t\tQ.append((x, y))\n\tans = float('inf')\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif robo1[i][j] != -1 and robo2[i][j] != -1:\n\t\t\t\tans = min(ans, max(robo1[i][j], robo2[i][j]))\n\tprint(-1 if ans == float('inf') else ans)\n",
        "slowest_solution": "(a, b) = (0, 1)\nfor t in range(int(input())):\n\tk = [None] * 2\n\t(n, m, k[a], k[b]) = [int(i) for i in input().split()]\n\tvisited = [{(0, 0)}, {(0, m - 1)}]\n\tminmoves = [{(0, 0): 0}, {(0, m - 1): 0}]\n\tblocked = set()\n\tfor i in range(n):\n\t\trow = [int(i) for i in input().split()]\n\t\tfor j in range(m):\n\t\t\tif row[j] == 1:\n\t\t\t\tblocked.add((i, j))\n\tmovetemplate = [set(), set()]\n\tfor r in range(2):\n\t\tfor x in range(-1 * k[r], k[r] + 1):\n\t\t\tfor y in range(-1 * k[r] + abs(x), k[r] - abs(x) + 1):\n\t\t\t\tmovetemplate[r].add((x, y))\n\t\tmovetemplate[r].remove((0, 0))\n\tnow = [{(0, 0)}, {(0, m - 1)}]\n\tc = 1\n\n\tdef applymoves(r):\n\t\tnxt = set()\n\t\tfor p0 in now[r]:\n\t\t\tfor move in movetemplate[r]:\n\t\t\t\tp1 = (p0[0] + move[0], p0[1] + move[1])\n\t\t\t\tif p1[0] >= 0 and p1[0] < n and (p1[1] >= 0) and (p1[1] < m):\n\t\t\t\t\tif not p1 in visited[r] and (not p1 in blocked):\n\t\t\t\t\t\tvisited[r].add(p1)\n\t\t\t\t\t\tminmoves[r][p1] = c\n\t\t\t\t\t\tnxt.add(p1)\n\t\treturn nxt\n\tr = 0\n\twhile True:\n\t\tnow[r] = applymoves(r)\n\t\tif not (now[a] or now[b]) or visited[a] & visited[b]:\n\t\t\tbreak\n\t\tc += 1 if r == 1 else 0\n\t\tr = (r + 1) % 2\n\tif visited[a] & visited[b]:\n\t\tp = (visited[a] & visited[b]).pop()\n\t\tprint(max(minmoves[a][p], minmoves[b][p]))\n\telse:\n\t\tprint(-1)\n"
    },
    {
        "task_id": 406,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.6657779216766357,
        "fastest_time": 2.583364963531494,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n\ndef FindMinimum(Ans):\n\tMinimum = float('inf')\n\tkey = -1\n\tfor (i, j) in Ans.items():\n\t\tif len(j) < Minimum:\n\t\t\tkey = i\n\t\t\tMinimum = len(j)\n\treturn key\nfrom collections import defaultdict\nfor _ in range(int(input())):\n\t(N, K) = map(int, input().split())\n\tcount = 0\n\tAns = {}\n\tfor i in range(N):\n\t\tx = list((x for x in range(1, N + 1)))\n\t\tAns[i + 1] = x\n\tfor i in range(K):\n\t\tX = list(map(int, input().split()))\n\t\tfor i in range(N):\n\t\t\tAns[X[i]] = set(Ans[X[i]]) & set(X[i + 1:])\n\tCounter = defaultdict(lambda : 0)\n\tfor i in Ans.values():\n\t\tfor j in i:\n\t\t\tCounter[j] += 1\n\tOutDegree = defaultdict(lambda : 0)\n\tInDegree = defaultdict(lambda : 0)\n\twhile len(Ans.keys()) > 0:\n\t\tT = FindMinimum(Ans)\n\t\tfor (i, j) in Ans.items():\n\t\t\tif len(j) == len(Ans[T]) and i != j:\n\t\t\t\tMin1 = float('inf')\n\t\t\t\tfor k in j:\n\t\t\t\t\tif Counter[k] < Min1:\n\t\t\t\t\t\tMin1 = Counter[k]\n\t\t\t\tMin2 = float('inf')\n\t\t\t\tfor z in Ans[T]:\n\t\t\t\t\tif Counter[z] < Min2:\n\t\t\t\t\t\tMin2 = Counter[z]\n\t\t\t\tif Min1 >= Min2:\n\t\t\t\t\tT = i\n\t\tFLAG = 0\n\t\tMin = float('inf')\n\t\tindex = -1\n\t\tfor i in Ans[T]:\n\t\t\tif Counter[i] < Min:\n\t\t\t\tMin = Counter[i]\n\t\t\t\tindex = i\n\t\tif index != -1:\n\t\t\tOutDegree[T] = index\n\t\t\tInDegree[index] = 1\n\t\t\tval = index\n\t\t\tFLAG = 1\n\t\t\tfor i in Ans[T]:\n\t\t\t\tCounter[i] -= 1\n\t\t\tdel Ans[T]\n\t\tif FLAG == 0:\n\t\t\tOutDegree[T] = 0\n\t\t\tfor i in Ans[T]:\n\t\t\t\tCounter[i] -= 1\n\t\t\tdel Ans[T]\n\t\telse:\n\t\t\tfor (i, j) in Ans.items():\n\t\t\t\tif val in j:\n\t\t\t\t\tCounter[val] = -1\n\t\t\t\t\tj.remove(val)\n\tcount = 0\n\tfor i in range(1, N + 1):\n\t\tif OutDegree[i] == 0:\n\t\t\tcount += 1\n\tprint(count)\n\tfor i in range(1, N + 1):\n\t\tprint(OutDegree[i], end=' ')\n\tprint()\n",
        "slowest_solution": "def bpm(u, match, seen, n, graph):\n\tfor j in range(n):\n\t\tif graph[u][j] == 1 and seen[j] == False:\n\t\t\tseen[j] = True\n\t\t\tif match[j] == -1 or bpm(match[j], match, seen, n, graph):\n\t\t\t\tmatch[j] = u\n\t\t\t\treturn True\n\treturn False\n\ndef solve():\n\t(n, k) = [int(i) for i in input().split()]\n\tvalid_points = [[1 for i in range(n)] for j in range(n)]\n\tfor i in range(n):\n\t\tvalid_points[i][i] = 0\n\tfor i in range(k):\n\t\tperm = [int(d) - 1 for d in input().split()]\n\t\tfor j in range(1, n):\n\t\t\tfor r in range(j - 1, -1, -1):\n\t\t\t\tvalid_points[perm[j]][perm[r]] = 0\n\tresult = 0\n\tmatch = [-1] * n\n\tfor i in range(n):\n\t\tseen = [False] * n\n\t\tif bpm(i, match, seen, n, valid_points):\n\t\t\tresult += 1\n\tprint(n - result)\n\tfinal_ans = [0] * n\n\tfor i in range(n):\n\t\tif match[i] != -1:\n\t\t\tfinal_ans[match[i]] = i + 1\n\tfor i in final_ans:\n\t\tprint(i, end=' ')\n\tprint()\nt = int(input())\nwhile t > 0:\n\tsolve()\n\tt -= 1\n"
    },
    {
        "task_id": 385,
        "slowest_solution_id": 0,
        "fastest_solution_id": 5,
        "slowest_time": 2.711191415786743,
        "fastest_time": 2.5465869903564453,
        "fastest_solution": "import heapq\niter = int(input())\nfor i in range(iter):\n\tn = int(input())\n\ta = list(map(int, input().split(' ')))\n\tb = list(map(int, input().split(' ')))\n\tm = input()\n\tx = list(map(int, input().split(' ')))\n\trazor_sizes = {}\n\tfor i in x:\n\t\trazor_sizes[i] = razor_sizes.get(i, 0) + 1\n\theap = []\n\theapq.heapify(heap)\n\tans = 1\n\tfor i in range(n):\n\t\tex = 0\n\t\twhile len(heap):\n\t\t\tval = heapq.heappop(heap)\n\t\t\tif val < b[i]:\n\t\t\t\tif razor_sizes.get(val, 0) == 0:\n\t\t\t\t\tans = 0\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\trazor_sizes[val] -= 1\n\t\t\tif val == b[i]:\n\t\t\t\tex = 1\n\t\t\t\theapq.heappush(heap, val)\n\t\t\t\tbreak\n\t\t\tif val > b[i]:\n\t\t\t\theapq.heappush(heap, val)\n\t\t\t\tbreak\n\t\tif ans == 0:\n\t\t\tbreak\n\t\tif a[i] < b[i]:\n\t\t\tans = 0\n\t\telif a[i] > b[i] and (not ex):\n\t\t\theapq.heappush(heap, b[i])\n\twhile len(heap):\n\t\tval = heapq.heappop(heap)\n\t\tif razor_sizes.get(val, 0) == 0:\n\t\t\tans = 0\n\t\t\tbreak\n\t\telse:\n\t\t\trazor_sizes[val] -= 1\n\tif ans == 0:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n",
        "slowest_solution": "import sys\n\ndef solve():\n\tinp = sys.stdin.readline\n\tn = int(inp())\n\ta = list(map(int, inp().split()))\n\tb = list(map(int, inp().split()))\n\tst = [(int(1000000000.0 + 7), n)]\n\tnext = [None] * n\n\tfor i in range(n - 1, -1, -1):\n\t\tv = b[i]\n\t\twhile st[-1][0] <= v:\n\t\t\tst.pop()\n\t\tnext[i] = st[-1][1]\n\t\tst.append((v, i))\n\tm = int(inp())\n\thave = dict()\n\tfor v in map(int, inp().split()):\n\t\thave[v] = have.get(v, 0) + 1\n\tneed = dict()\n\tlast = dict()\n\tfor i in range(n):\n\t\tif a[i] < b[i]:\n\t\t\tprint('NO')\n\t\t\treturn\n\t\tif a[i] == b[i]:\n\t\t\tcontinue\n\t\tv = b[i]\n\t\tval = last.get(v, None)\n\t\tif val is None:\n\t\t\tneed[v] = 1\n\t\telif next[val] < i:\n\t\t\tneed[v] += 1\n\t\tlast[v] = i\n\tfor (k, v) in need.items():\n\t\tif have.get(k, 0) < v:\n\t\t\tprint('NO')\n\t\t\treturn\n\tprint('YES')\n\ndef main():\n\tfor i in range(int(sys.stdin.readline())):\n\t\tsolve()\nmain()\n"
    },
    {
        "task_id": 417,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.449322462081909,
        "fastest_time": 2.449322462081909,
        "fastest_solution": "import sys\nimport copy\ninput = sys.stdin.readline\nn = int(input())\nP = [list(map(int, input().split())) for i in range(n)]\nSET_X = set()\nSET_Y = set()\nfor (x, y) in P:\n\tSET_X.add(x)\n\tSET_Y.add(y)\nCX = sorted(SET_X)\nCY = sorted(SET_Y)\nLEN = len(CX)\nMAX = len(CX) - 1\nDICT_X = {x: i for (i, x) in enumerate(CX)}\nDICT_Y = {x: i for (i, x) in enumerate(CY)}\nfor i in range(n):\n\tP[i] = [DICT_X[P[i][0]], DICT_Y[P[i][1]]]\ncheck = [0] * len(CX)\nBIT = [0] * (LEN + 1)\n\ndef update(v, w):\n\twhile v <= LEN:\n\t\tBIT[v] += w\n\t\tv += v & -v\n\ndef getvalue(v):\n\tANS = 0\n\twhile v != 0:\n\t\tANS += BIT[v]\n\t\tv -= v & -v\n\treturn ANS\nLIST_Y = [[] for i in range(len(CY))]\nfor (x, y) in P:\n\tLIST_Y[y].append(x)\nfor i in range(len(CY)):\n\tLIST_Y[i].sort()\nANS = 0\nfor y in range(len(CY) - 1, -1, -1):\n\tfor x in LIST_Y[y]:\n\t\tif check[x] == 0:\n\t\t\tcheck[x] = 1\n\t\t\tupdate(x + 1, 1)\n\tANS += getvalue(LIST_Y[y][0] + 1) * (getvalue(MAX + 1) - getvalue(LIST_Y[y][0] + 1) + 1)\n\tfor i in range(1, len(LIST_Y[y])):\n\t\tANS += (getvalue(LIST_Y[y][i] + 1) - getvalue(LIST_Y[y][i - 1] + 1)) * (getvalue(MAX + 1) - getvalue(LIST_Y[y][i] + 1) + 1)\nprint(ANS)\n",
        "slowest_solution": "import sys\nimport copy\ninput = sys.stdin.readline\nn = int(input())\nP = [list(map(int, input().split())) for i in range(n)]\nSET_X = set()\nSET_Y = set()\nfor (x, y) in P:\n\tSET_X.add(x)\n\tSET_Y.add(y)\nCX = sorted(SET_X)\nCY = sorted(SET_Y)\nLEN = len(CX)\nMAX = len(CX) - 1\nDICT_X = {x: i for (i, x) in enumerate(CX)}\nDICT_Y = {x: i for (i, x) in enumerate(CY)}\nfor i in range(n):\n\tP[i] = [DICT_X[P[i][0]], DICT_Y[P[i][1]]]\ncheck = [0] * len(CX)\nBIT = [0] * (LEN + 1)\n\ndef update(v, w):\n\twhile v <= LEN:\n\t\tBIT[v] += w\n\t\tv += v & -v\n\ndef getvalue(v):\n\tANS = 0\n\twhile v != 0:\n\t\tANS += BIT[v]\n\t\tv -= v & -v\n\treturn ANS\nLIST_Y = [[] for i in range(len(CY))]\nfor (x, y) in P:\n\tLIST_Y[y].append(x)\nfor i in range(len(CY)):\n\tLIST_Y[i].sort()\nANS = 0\nfor y in range(len(CY) - 1, -1, -1):\n\tfor x in LIST_Y[y]:\n\t\tif check[x] == 0:\n\t\t\tcheck[x] = 1\n\t\t\tupdate(x + 1, 1)\n\tANS += getvalue(LIST_Y[y][0] + 1) * (getvalue(MAX + 1) - getvalue(LIST_Y[y][0] + 1) + 1)\n\tfor i in range(1, len(LIST_Y[y])):\n\t\tANS += (getvalue(LIST_Y[y][i] + 1) - getvalue(LIST_Y[y][i - 1] + 1)) * (getvalue(MAX + 1) - getvalue(LIST_Y[y][i] + 1) + 1)\nprint(ANS)\n"
    },
    {
        "task_id": 376,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 2.666893243789673,
        "fastest_time": 2.6015803813934326,
        "fastest_solution": "k = int(input())\nif k == 2:\n\tfor _ in range(int(input())):\n\t\tn = int(input())\n\t\td = dict()\n\t\ts = ''\n\t\td[1] = '1'\n\t\td[2] = '01'\n\t\td[3] = '001'\n\t\td[4] = '0001'\n\t\td[8] = '01101001'\n\t\td[9] = '100111010'\n\t\td[10] = '0111000101'\n\t\td[11] = '01000111010'\n\t\td[5] = '01001'\n\t\td[6] = '001001'\n\t\td[7] = '0010110'\n\t\td[12] = '000000001101'\n\t\td[13] = '0101010100101'\n\t\td[14] = '10110100100011'\n\t\twhile n >= 14:\n\t\t\ts += '01101001'\n\t\t\tn -= 8\n\t\ts = d[n] + s\n\t\tif n == 1:\n\t\t\tprint(1)\n\t\telif n == 2:\n\t\t\tprint(3)\n\t\telif n == 4:\n\t\t\tprint(2)\n\t\telif n == 5:\n\t\t\tprint(3)\n\t\telif n == 3:\n\t\t\tprint(4)\n\t\telif n % 4 == 1 or n % 4 == 2:\n\t\t\tprint(1)\n\t\telse:\n\t\t\tprint(0)\n\t\tprint(s)\nelif k == 1:\n\tfor _ in range(int(input())):\n\t\tn = int(input())\n\t\tans = ['0'] * (n + 1)\n\t\ts = 0\n\t\tsu = n * (n + 1) // 2\n\t\tt = n * (n + 1) // 4\n\t\tif n == 2:\n\t\t\tans = ['0', '1']\n\t\telse:\n\t\t\tfor i in range(n, -1, -1):\n\t\t\t\ts += i\n\t\t\t\tans[i] = '1'\n\t\t\t\tif t - s == 1:\n\t\t\t\t\tans[1] = '1'\n\t\t\t\t\tbreak\n\t\t\t\telif t - s < i and ans[t - s] == '0':\n\t\t\t\t\tans[t - s] = '1'\n\t\t\t\t\tbreak\n\t\t\tans = ans[1:]\n\t\tif su % 2 == 0:\n\t\t\tprint(0)\n\t\telse:\n\t\t\tprint(1)\n\t\tprint(''.join(ans))\nelif k == 3:\n\tfor _ in range(int(input())):\n\t\tn = int(input())\n\t\td = dict()\n\t\td[1] = '1'\n\t\td[2] = '01'\n\t\td[3] = '001'\n\t\td[4] = '0001'\n\t\td[5] = '00001'\n\t\td[6] = '011110'\n\t\td[7] = '0001110'\n\t\td[11] = '00001101001'\n\t\td[12] = '001011100110'\n\t\td[13] = '0000111011010'\n\t\td[14] = '01011001101001'\n\t\td[15] = '001111010111100'\n\t\td[16] = '0110100110010110'\n\t\td[17] = '10010110111110010'\n\t\td[18] = '010011010101011010'\n\t\td[8] = '00110110'\n\t\td[9] = '011010110'\n\t\td[10] = '1111111010'\n\t\td[19] = '1100110110100111100'\n\t\td[20] = '01011111110111111000'\n\t\td[21] = '001010011111111010010'\n\t\td[22] = '0001000111111101111000'\n\t\td[23] = '10001111101111110111000'\n\t\td[24] = '101011110110111110111000'\n\t\td[25] = '0001111011111111111110000'\n\t\td[26] = '01111111001101111111101000'\n\t\td[27] = '011101101111111011111110000'\n\t\ts = ''\n\t\twhile n >= 28:\n\t\t\tn -= 16\n\t\t\ts += '0110100110010110'\n\t\ts = d[n] + s\n\t\tif n == 1:\n\t\t\tprint(1)\n\t\telif n == 2:\n\t\t\tprint(7)\n\t\telif n == 3:\n\t\t\tprint(18)\n\t\telif n == 8:\n\t\t\tprint(4)\n\t\telif n == 9:\n\t\t\tprint(5)\n\t\telif n == 4:\n\t\t\tprint(28)\n\t\telif n == 5:\n\t\t\tprint(25)\n\t\telif n == 6:\n\t\t\tprint(7)\n\t\telif n == 7:\n\t\t\tprint(26)\n\t\telif n == 10:\n\t\t\tprint(1)\n\t\telif n == 11:\n\t\t\tprint(12)\n\t\telif n % 4 == 1 or n % 4 == 2:\n\t\t\tprint(1)\n\t\telse:\n\t\t\tprint(0)\n\t\tprint(s)\nelse:\n\tfor _ in range(int(input())):\n\t\tn = int(input())\n\t\td = dict()\n\t\td[1] = '1'\n\t\td[2] = '01'\n\t\td[3] = '001'\n\t\td[4] = '0001'\n\t\td[5] = '00001'\n\t\td[6] = '000001'\n\t\td[7] = '0000001'\n\t\td[8] = '00101110'\n\t\td[9] = '000001110'\n\t\td[10] = '0101001001'\n\t\td[11] = '00000101001'\n\t\td[12] = '001101010110'\n\t\td[13] = '0010110101001'\n\t\td[20] = '00001010110111011100'\n\t\td[21] = '000000000100100100011'\n\t\td[22] = '1101001111011111110100'\n\t\td[23] = '00001000100110111101100'\n\t\td[24] = '000010011110110111110100'\n\t\td[25] = '0101110101111110111111000'\n\t\td[26] = '00010100000100010000110101'\n\t\td[14] = '00000001111010'\n\t\td[15] = '011110001010110'\n\t\td[16] = '0000111000001110'\n\t\td[17] = '00101000011111100'\n\t\td[18] = '000000110100001110'\n\t\td[19] = '1000010010110111100'\n\t\td[27] = '001111000000011110111111000'\n\t\td[28] = '0001011111000101111011111000'\n\t\td[29] = '01010100010001011111010101010'\n\t\td[30] = '010110010011011011111111011000'\n\t\td[31] = '1111111111110100000010000101011'\n\t\td[32] = '01101001100101101001011001101001'\n\t\td[50] = '11111111111111111111111111111111101101010011100100'\n\t\td[51] = '111111111111111111110001010111000111010101010101001'\n\t\td[52] = '1111111111111111111101010000001000010101011001000111'\n\t\td[53] = '11111111111111111111111111111110001101011010100101001'\n\t\td[54] = '111111111111111111111101000110000001001101010101010101'\n\t\td[55] = '1111111111111111111111010100110101110100110101010101010'\n\t\td[56] = '00000001000001000011110111111111011111111111111110000000'\n\t\td[57] = '010001011101010111010111110111111111011111111111110000000'\n\t\td[58] = '0010111101100111110111111111111111111111111011111110000000'\n\t\td[59] = '00000101000100010111010111111111111111111111101111110000000'\n\t\td[60] = '000100010101010000110101111111111111111111111111011110000000'\n\t\td[61] = '1110100011011010101010110010111100111110011011111011011010000'\n\t\td[33] = '111111111101110101000011110101010'\n\t\td[34] = '1111101111111011111010101111100010'\n\t\td[35] = '11111111110101010011110100101101010'\n\t\td[36] = '111111111111011110000100000101000111'\n\t\td[37] = '1111111110101111111111101001101000101'\n\t\td[38] = '11111111111111010001100001010110010101'\n\t\td[39] = '111111111111111001010100010111010100110'\n\t\td[40] = '1111111111111101010110100001000101000111'\n\t\td[41] = '11111111111111110001010101100100010111010'\n\t\td[45] = '111111111111111111101011011111111001101100100'\n\t\td[46] = '1111111111111111110001100000010000010111010101'\n\t\td[47] = '11111111111111111101010100100001000101010110110'\n\t\td[48] = '111111111111111111011101000100010101100110010101'\n\t\td[49] = '1111111111111111111101010101000001110100010111010'\n\t\td[42] = '111111111111111111101101111111111001101000'\n\t\td[43] = '1111111111111111010000010000000001111001110'\n\t\td[44] = '11111111111111111000001001010001010011010101'\n\t\ts = ''\n\t\twhile n >= 62:\n\t\t\tn -= 32\n\t\t\ts += '01101001100101101001011001101001'\n\t\ts = d[n] + s\n\t\tif n == 1:\n\t\t\tprint(1)\n\t\telif n == 2:\n\t\t\tprint(15)\n\t\telif n == 3:\n\t\t\tprint(64)\n\t\telif n == 4:\n\t\t\tprint(158)\n\t\telif n == 10:\n\t\t\tprint(13)\n\t\telif n == 11:\n\t\t\tprint(92)\n\t\telif n == 12:\n\t\t\tprint(30)\n\t\telif n == 13:\n\t\t\tprint(47)\n\t\telif n == 5:\n\t\t\tprint(271)\n\t\telif n == 6:\n\t\t\tprint(317)\n\t\telif n == 7:\n\t\t\tprint(126)\n\t\telif n == 8:\n\t\t\tprint(34)\n\t\telif n == 9:\n\t\t\tprint(253)\n\t\telif n == 14:\n\t\t\tprint(31)\n\t\telif n == 15:\n\t\t\tprint(2)\n\t\telif n == 16:\n\t\t\tprint(0)\n\t\telif n == 17:\n\t\t\tprint(1)\n\t\telif n == 23:\n\t\t\tprint(0)\n\t\telif n == 24:\n\t\t\tprint(0)\n\t\telif n == 25:\n\t\t\tprint(1)\n\t\telif n == 26:\n\t\t\tprint(5)\n\t\telif n == 27:\n\t\t\tprint(0)\n\t\telif n == 28:\n\t\t\tprint(0)\n\t\telif n == 18:\n\t\t\tprint(13)\n\t\telif n == 19:\n\t\t\tprint(0)\n\t\telif n == 20:\n\t\t\tprint(0)\n\t\telif n == 21:\n\t\t\tprint(9)\n\t\telif n == 22:\n\t\t\tprint(1)\n\t\telif n == 29:\n\t\t\tprint(5)\n\t\telif n % 4 == 1 or n % 4 == 2:\n\t\t\tprint(1)\n\t\telse:\n\t\t\tprint(0)\n\t\tprint(s)\n",
        "slowest_solution": "try:\n\tk = int(input())\n\tfor i in range(int(input())):\n\t\tn = int(input())\n\t\tif k == 1:\n\t\t\tmn = 0\n\t\t\tif n % 4 == 1 or n % 4 == 2:\n\t\t\t\tmn = 1\n\t\t\ts1 = '1'\n\t\t\ts2 = '01'\n\t\t\ts3 = '001'\n\t\t\ts4 = '1001'\n\t\t\ts = ''\n\t\t\tprint(mn)\n\t\t\tif n == 1:\n\t\t\t\tprint(s1)\n\t\t\telif n == 2:\n\t\t\t\tprint(s2)\n\t\t\telif n == 3:\n\t\t\t\tprint(s3)\n\t\t\telif n == 4:\n\t\t\t\tprint(s4)\n\t\t\telse:\n\t\t\t\tj = n\n\t\t\t\twhile j >= 4:\n\t\t\t\t\ts += s4\n\t\t\t\t\tj -= 4\n\t\t\t\tif j == 1:\n\t\t\t\t\ts1 += s\n\t\t\t\t\tprint(s1)\n\t\t\t\telif j == 2:\n\t\t\t\t\ts2 += s\n\t\t\t\t\tprint(s2)\n\t\t\t\telif j == 3:\n\t\t\t\t\ts3 += s\n\t\t\t\t\tprint(s3)\n\t\t\t\telif j == 0:\n\t\t\t\t\tprint(s)\n\t\tif k == 2:\n\t\t\tmn = 0\n\t\t\ts = ''\n\t\t\ts1 = '1'\n\t\t\ts2 = '01'\n\t\t\ts3 = '001'\n\t\t\ts4 = '0001'\n\t\t\ts5 = '01001'\n\t\t\ts6 = '001001'\n\t\t\ts7 = '0010110'\n\t\t\ts8 = '01101001'\n\t\t\ts9 = '100111010'\n\t\t\ts10 = '0111000101'\n\t\t\ts11 = '01000111010'\n\t\t\ts12 = '000000001101'\n\t\t\ts13 = '0101010100101'\n\t\t\ts14 = '10110100100011'\n\t\t\tif n == 1:\n\t\t\t\tmn = 1\n\t\t\t\tprint(mn)\n\t\t\t\tprint(s1)\n\t\t\telif n == 2:\n\t\t\t\tmn = 3\n\t\t\t\tprint(mn)\n\t\t\t\tprint(s2)\n\t\t\telif n == 3:\n\t\t\t\tmn = 4\n\t\t\t\tprint(mn)\n\t\t\t\tprint(s3)\n\t\t\telif n == 4:\n\t\t\t\tmn = 2\n\t\t\t\tprint(mn)\n\t\t\t\tprint(s4)\n\t\t\telif n == 5:\n\t\t\t\tmn = 3\n\t\t\t\tprint(mn)\n\t\t\t\tprint(s5)\n\t\t\telif n == 6:\n\t\t\t\tmn = 1\n\t\t\t\tprint(mn)\n\t\t\t\tprint(s6)\n\t\t\telse:\n\t\t\t\tif n % 4 == 1 or n % 4 == 2:\n\t\t\t\t\tmn = 1\n\t\t\t\telse:\n\t\t\t\t\tmn = 0\n\t\t\t\tprint(mn)\n\t\t\t\tif n == 7:\n\t\t\t\t\tprint(s7)\n\t\t\t\telif n == 8:\n\t\t\t\t\tprint(s8)\n\t\t\t\telif n == 9:\n\t\t\t\t\tprint(s9)\n\t\t\t\telif n == 10:\n\t\t\t\t\tprint(s10)\n\t\t\t\telif n == 11:\n\t\t\t\t\tprint(s11)\n\t\t\t\telif n == 12:\n\t\t\t\t\tprint(s12)\n\t\t\t\telif n == 13:\n\t\t\t\t\tprint(s13)\n\t\t\t\telif n == 14:\n\t\t\t\t\tprint(s14)\n\t\t\t\telse:\n\t\t\t\t\tj = n\n\t\t\t\t\twhile j > 14:\n\t\t\t\t\t\ts += '01101001'\n\t\t\t\t\t\tj -= 8\n\t\t\t\t\tif j == 1:\n\t\t\t\t\t\ts1 += s\n\t\t\t\t\t\tprint(s1)\n\t\t\t\t\telif j == 2:\n\t\t\t\t\t\ts2 += s\n\t\t\t\t\t\tprint(s2)\n\t\t\t\t\telif j == 3:\n\t\t\t\t\t\ts3 += s\n\t\t\t\t\t\tprint(s3)\n\t\t\t\t\telif j == 4:\n\t\t\t\t\t\ts4 += s\n\t\t\t\t\t\tprint(s4)\n\t\t\t\t\telif j == 5:\n\t\t\t\t\t\ts5 += s\n\t\t\t\t\t\tprint(s5)\n\t\t\t\t\telif j == 6:\n\t\t\t\t\t\ts6 += s\n\t\t\t\t\t\tprint(s6)\n\t\t\t\t\telif j == 7:\n\t\t\t\t\t\ts7 += s\n\t\t\t\t\t\tprint(s7)\n\t\t\t\t\telif j == 8:\n\t\t\t\t\t\ts8 += s\n\t\t\t\t\t\tprint(s8)\n\t\t\t\t\telif j == 9:\n\t\t\t\t\t\ts9 += s\n\t\t\t\t\t\tprint(s9)\n\t\t\t\t\telif j == 10:\n\t\t\t\t\t\ts10 += s\n\t\t\t\t\t\tprint(s10)\n\t\t\t\t\telif j == 11:\n\t\t\t\t\t\ts11 += s\n\t\t\t\t\t\tprint(s11)\n\t\t\t\t\telif j == 12:\n\t\t\t\t\t\ts12 += s\n\t\t\t\t\t\tprint(s12)\n\t\t\t\t\telif j == 13:\n\t\t\t\t\t\ts13 += s\n\t\t\t\t\t\tprint(s13)\n\t\t\t\t\telif j == 14:\n\t\t\t\t\t\ts14 += s\n\t\t\t\t\t\tprint(s14)\n\t\tif k == 3:\n\t\t\tmn = 0\n\t\t\ts = ''\n\t\t\ts1 = '1'\n\t\t\ts2 = '01'\n\t\t\ts3 = '001'\n\t\t\ts4 = '0001'\n\t\t\ts5 = '00001'\n\t\t\ts6 = '011110'\n\t\t\ts7 = '0001110'\n\t\t\ts8 = '00110110'\n\t\t\ts9 = '011010110'\n\t\t\ts10 = '1111111010'\n\t\t\ts11 = '00001101001'\n\t\t\ts12 = '001011100110'\n\t\t\ts13 = '0000111011010'\n\t\t\ts14 = '01011001101001'\n\t\t\ts15 = '001111010111100'\n\t\t\ts16 = '0110100110010110'\n\t\t\ts17 = '10010110111110010'\n\t\t\ts18 = '010011010101011010'\n\t\t\ts19 = '1100110110100111100'\n\t\t\ts20 = '01011111110111111000'\n\t\t\ts21 = '001010011111111010010'\n\t\t\ts22 = '0001000111111101111000'\n\t\t\ts23 = '10001111101111110111000'\n\t\t\ts24 = '101011110110111110111000'\n\t\t\ts25 = '0001111011111111111110000'\n\t\t\ts26 = '01111111001101111111101000'\n\t\t\ts27 = '011101101111111011111110000'\n\t\t\tif n == 1:\n\t\t\t\tprint(1)\n\t\t\t\tprint(s1)\n\t\t\telif n == 2:\n\t\t\t\tprint(7)\n\t\t\t\tprint(s2)\n\t\t\telif n == 3:\n\t\t\t\tprint(18)\n\t\t\t\tprint(s3)\n\t\t\telif n == 4:\n\t\t\t\tprint(28)\n\t\t\t\tprint(s4)\n\t\t\telif n == 5:\n\t\t\t\tprint(25)\n\t\t\t\tprint(s5)\n\t\t\telif n == 6:\n\t\t\t\tprint(7)\n\t\t\t\tprint(s6)\n\t\t\telif n == 7:\n\t\t\t\tprint(26)\n\t\t\t\tprint(s7)\n\t\t\telif n == 8:\n\t\t\t\tprint(4)\n\t\t\t\tprint(s8)\n\t\t\telif n == 9:\n\t\t\t\tprint(5)\n\t\t\t\tprint(s9)\n\t\t\telif n == 10:\n\t\t\t\tprint(1)\n\t\t\t\tprint(s10)\n\t\t\telif n == 11:\n\t\t\t\tprint(12)\n\t\t\t\tprint(s11)\n\t\t\telif n == 12:\n\t\t\t\tprint(0)\n\t\t\t\tprint(s12)\n\t\t\telse:\n\t\t\t\tif n % 4 == 1 or n % 4 == 2:\n\t\t\t\t\tmn = 1\n\t\t\t\telse:\n\t\t\t\t\tmn = 0\n\t\t\t\tprint(mn)\n\t\t\t\tif n == 13:\n\t\t\t\t\tprint(s13)\n\t\t\t\telif n == 14:\n\t\t\t\t\tprint(s14)\n\t\t\t\telif n == 15:\n\t\t\t\t\tprint(s15)\n\t\t\t\telif n == 16:\n\t\t\t\t\tprint(s16)\n\t\t\t\telif n == 17:\n\t\t\t\t\tprint(s17)\n\t\t\t\telif n == 18:\n\t\t\t\t\tprint(s18)\n\t\t\t\telif n == 19:\n\t\t\t\t\tprint(s19)\n\t\t\t\telif n == 20:\n\t\t\t\t\tprint(s20)\n\t\t\t\telif n == 21:\n\t\t\t\t\tprint(s21)\n\t\t\t\telif n == 22:\n\t\t\t\t\tprint(s22)\n\t\t\t\telif n == 23:\n\t\t\t\t\tprint(s23)\n\t\t\t\telif n == 24:\n\t\t\t\t\tprint(s24)\n\t\t\t\telif n == 25:\n\t\t\t\t\tprint(s25)\n\t\t\t\telif n == 26:\n\t\t\t\t\tprint(s26)\n\t\t\t\telif n == 27:\n\t\t\t\t\tprint(s27)\n\t\t\t\telse:\n\t\t\t\t\tj = n\n\t\t\t\t\twhile j > 27:\n\t\t\t\t\t\ts += '0110100110010110'\n\t\t\t\t\t\tj -= 16\n\t\t\t\t\tif j == 1:\n\t\t\t\t\t\ts1 += s\n\t\t\t\t\t\tprint(s1)\n\t\t\t\t\telif j == 2:\n\t\t\t\t\t\ts2 += s\n\t\t\t\t\t\tprint(s2)\n\t\t\t\t\telif j == 3:\n\t\t\t\t\t\ts3 += s\n\t\t\t\t\t\tprint(s3)\n\t\t\t\t\telif j == 4:\n\t\t\t\t\t\ts4 += s\n\t\t\t\t\t\tprint(s4)\n\t\t\t\t\telif j == 5:\n\t\t\t\t\t\ts5 += s\n\t\t\t\t\t\tprint(s5)\n\t\t\t\t\telif j == 6:\n\t\t\t\t\t\ts6 += s\n\t\t\t\t\t\tprint(s6)\n\t\t\t\t\telif j == 7:\n\t\t\t\t\t\ts7 += s\n\t\t\t\t\t\tprint(s7)\n\t\t\t\t\telif j == 8:\n\t\t\t\t\t\ts8 += s\n\t\t\t\t\t\tprint(s8)\n\t\t\t\t\telif j == 9:\n\t\t\t\t\t\ts9 += s\n\t\t\t\t\t\tprint(s9)\n\t\t\t\t\telif j == 10:\n\t\t\t\t\t\ts10 += s\n\t\t\t\t\t\tprint(s10)\n\t\t\t\t\telif j == 11:\n\t\t\t\t\t\ts11 += s\n\t\t\t\t\t\tprint(s11)\n\t\t\t\t\telif j == 12:\n\t\t\t\t\t\ts12 += s\n\t\t\t\t\t\tprint(s12)\n\t\t\t\t\telif j == 13:\n\t\t\t\t\t\ts13 += s\n\t\t\t\t\t\tprint(s13)\n\t\t\t\t\telif j == 14:\n\t\t\t\t\t\ts14 += s\n\t\t\t\t\t\tprint(s14)\n\t\t\t\t\telif j == 15:\n\t\t\t\t\t\ts15 += s\n\t\t\t\t\t\tprint(s15)\n\t\t\t\t\telif j == 16:\n\t\t\t\t\t\ts16 += s\n\t\t\t\t\t\tprint(s16)\n\t\t\t\t\telif j == 17:\n\t\t\t\t\t\ts17 += s\n\t\t\t\t\t\tprint(s17)\n\t\t\t\t\telif j == 18:\n\t\t\t\t\t\ts18 += s\n\t\t\t\t\t\tprint(s18)\n\t\t\t\t\telif j == 19:\n\t\t\t\t\t\ts19 += s\n\t\t\t\t\t\tprint(s19)\n\t\t\t\t\telif j == 20:\n\t\t\t\t\t\ts20 += s\n\t\t\t\t\t\tprint(s20)\n\t\t\t\t\telif j == 21:\n\t\t\t\t\t\ts21 += s\n\t\t\t\t\t\tprint(s21)\n\t\t\t\t\telif j == 22:\n\t\t\t\t\t\ts22 += s\n\t\t\t\t\t\tprint(s22)\n\t\t\t\t\telif j == 23:\n\t\t\t\t\t\ts23 += s\n\t\t\t\t\t\tprint(s23)\n\t\t\t\t\telif j == 24:\n\t\t\t\t\t\ts24 += s\n\t\t\t\t\t\tprint(s24)\n\t\t\t\t\telif j == 25:\n\t\t\t\t\t\ts25 += s\n\t\t\t\t\t\tprint(s25)\n\t\t\t\t\telif j == 26:\n\t\t\t\t\t\ts26 += s\n\t\t\t\t\t\tprint(s26)\n\t\t\t\t\telif j == 27:\n\t\t\t\t\t\ts27 += s\n\t\t\t\t\t\tprint(s27)\n\t\tif k == 4:\n\t\t\tmn = 0\n\t\t\ts = ''\n\t\t\ts1 = '1'\n\t\t\ts2 = '01'\n\t\t\ts3 = '001'\n\t\t\ts4 = '0001'\n\t\t\ts5 = '00001'\n\t\t\ts6 = '000001'\n\t\t\ts7 = '0000001'\n\t\t\ts8 = '00101110'\n\t\t\ts9 = '000001110'\n\t\t\ts10 = '0101001001'\n\t\t\ts11 = '00000101001'\n\t\t\ts12 = '001101010110'\n\t\t\ts13 = '0010110101001'\n\t\t\ts14 = '00000001111010'\n\t\t\ts15 = '011110001010110'\n\t\t\ts16 = '0000111000001110'\n\t\t\ts17 = '00101000011111100'\n\t\t\ts18 = '000000110100001110'\n\t\t\ts19 = '1000010010110111100'\n\t\t\ts20 = '00001010110111011100'\n\t\t\ts21 = '000000000100100100011'\n\t\t\ts22 = '1101001111011111110100'\n\t\t\ts23 = '00001000100110111101100'\n\t\t\ts24 = '000010011110110111110100'\n\t\t\ts25 = '0101110101111110111111000'\n\t\t\ts26 = '00010100000100010000110101'\n\t\t\ts27 = '001111000000011110111111000'\n\t\t\ts28 = '0001011111000101111011111000'\n\t\t\ts29 = '01010100010001011111010101010'\n\t\t\ts30 = '010110010011011011111111011000'\n\t\t\ts31 = '1111111111110100000010000101011'\n\t\t\ts32 = '01101001100101101001011001101001'\n\t\t\ts33 = '111111111101110101000011110101010'\n\t\t\ts34 = '1111101111111011111010101111100010'\n\t\t\ts35 = '11111111110101010011110100101101010'\n\t\t\ts36 = '111111111111011110000100000101000111'\n\t\t\ts37 = '1111111110101111111111101001101000101'\n\t\t\ts38 = '11111111111111010001100001010110010101'\n\t\t\ts39 = '111111111111111001010100010111010100110'\n\t\t\ts40 = '1111111111111101010110100001000101000111'\n\t\t\ts41 = '11111111111111110001010101100100010111010'\n\t\t\ts42 = '111111111111111111101101111111111001101000'\n\t\t\ts43 = '1111111111111111010000010000000001111001110'\n\t\t\ts44 = '11111111111111111000001001010001010011010101'\n\t\t\ts45 = '111111111111111111101011011111111001101100100'\n\t\t\ts46 = '1111111111111111110001100000010000010111010101'\n\t\t\ts47 = '11111111111111111101010100100001000101010110110'\n\t\t\ts48 = '111111111111111111011101000100010101100110010101'\n\t\t\ts49 = '1111111111111111111101010101000001110100010111010'\n\t\t\ts50 = '11111111111111111111111111111111101101010011100100'\n\t\t\ts51 = '111111111111111111110001010111000111010101010101001'\n\t\t\ts52 = '1111111111111111111101010000001000010101011001000111'\n\t\t\ts53 = '11111111111111111111111111111110001101011010100101001'\n\t\t\ts54 = '111111111111111111111101000110000001001101010101010101'\n\t\t\ts55 = '1111111111111111111111010100110101110100110101010101010'\n\t\t\ts56 = '00000001000001000011110111111111011111111111111110000000'\n\t\t\ts57 = '010001011101010111010111110111111111011111111111110000000'\n\t\t\ts58 = '0010111101100111110111111111111111111111111011111110000000'\n\t\t\ts59 = '00000101000100010111010111111111111111111111101111110000000'\n\t\t\ts60 = '000100010101010000110101111111111111111111111111011110000000'\n\t\t\ts61 = '1110100011011010101010110010111100111110011011111011011010000'\n\t\t\tif n == 1:\n\t\t\t\tprint(1)\n\t\t\t\tprint(s1)\n\t\t\telif n == 2:\n\t\t\t\tprint(15)\n\t\t\t\tprint(s2)\n\t\t\telif n == 3:\n\t\t\t\tprint(64)\n\t\t\t\tprint(s3)\n\t\t\telif n == 4:\n\t\t\t\tprint(158)\n\t\t\t\tprint(s4)\n\t\t\telif n == 5:\n\t\t\t\tprint(271)\n\t\t\t\tprint(s5)\n\t\t\telif n == 6:\n\t\t\t\tprint(317)\n\t\t\t\tprint(s6)\n\t\t\telif n == 7:\n\t\t\t\tprint(126)\n\t\t\t\tprint(s7)\n\t\t\telif n == 8:\n\t\t\t\tprint(34)\n\t\t\t\tprint(s8)\n\t\t\telif n == 9:\n\t\t\t\tprint(253)\n\t\t\t\tprint(s9)\n\t\t\telif n == 10:\n\t\t\t\tprint(13)\n\t\t\t\tprint(s10)\n\t\t\telif n == 11:\n\t\t\t\tprint(92)\n\t\t\t\tprint(s11)\n\t\t\telif n == 12:\n\t\t\t\tprint(30)\n\t\t\t\tprint(s12)\n\t\t\telif n == 13:\n\t\t\t\tprint(47)\n\t\t\t\tprint(s13)\n\t\t\telif n == 14:\n\t\t\t\tprint(31)\n\t\t\t\tprint(s14)\n\t\t\telif n == 15:\n\t\t\t\tprint(2)\n\t\t\t\tprint(s15)\n\t\t\telif n == 16:\n\t\t\t\tprint(0)\n\t\t\t\tprint(s16)\n\t\t\telif n == 17:\n\t\t\t\tprint(1)\n\t\t\t\tprint(s17)\n\t\t\telif n == 18:\n\t\t\t\tprint(13)\n\t\t\t\tprint(s18)\n\t\t\telif n == 19:\n\t\t\t\tprint(0)\n\t\t\t\tprint(s19)\n\t\t\telif n == 20:\n\t\t\t\tprint(0)\n\t\t\t\tprint(s20)\n\t\t\telif n == 21:\n\t\t\t\tprint(9)\n\t\t\t\tprint(s21)\n\t\t\telif n == 22:\n\t\t\t\tprint(1)\n\t\t\t\tprint(s22)\n\t\t\telif n == 23:\n\t\t\t\tprint(0)\n\t\t\t\tprint(s23)\n\t\t\telif n == 24:\n\t\t\t\tprint(0)\n\t\t\t\tprint(s24)\n\t\t\telif n == 25:\n\t\t\t\tprint(1)\n\t\t\t\tprint(s25)\n\t\t\telif n == 26:\n\t\t\t\tprint(5)\n\t\t\t\tprint(s26)\n\t\t\telif n == 27:\n\t\t\t\tprint(0)\n\t\t\t\tprint(s27)\n\t\t\telif n == 28:\n\t\t\t\tprint(0)\n\t\t\t\tprint(s28)\n\t\t\telif n == 29:\n\t\t\t\tprint(5)\n\t\t\t\tprint(s29)\n\t\t\telif n == 30:\n\t\t\t\tprint(1)\n\t\t\t\tprint(s30)\n\t\t\telse:\n\t\t\t\tif n % 4 == 1 or n % 4 == 2:\n\t\t\t\t\tmn = 1\n\t\t\t\telse:\n\t\t\t\t\tmn = 0\n\t\t\t\tprint(mn)\n\t\t\t\tif n == 31:\n\t\t\t\t\tprint(s31)\n\t\t\t\telif n == 32:\n\t\t\t\t\tprint(s32)\n\t\t\t\telif n == 33:\n\t\t\t\t\tprint(s33)\n\t\t\t\telif n == 34:\n\t\t\t\t\tprint(s34)\n\t\t\t\telif n == 35:\n\t\t\t\t\tprint(s35)\n\t\t\t\telif n == 36:\n\t\t\t\t\tprint(s36)\n\t\t\t\telif n == 37:\n\t\t\t\t\tprint(s37)\n\t\t\t\telif n == 38:\n\t\t\t\t\tprint(s38)\n\t\t\t\telif n == 39:\n\t\t\t\t\tprint(s39)\n\t\t\t\telif n == 40:\n\t\t\t\t\tprint(s40)\n\t\t\t\telif n == 41:\n\t\t\t\t\tprint(s41)\n\t\t\t\telif n == 42:\n\t\t\t\t\tprint(s42)\n\t\t\t\telif n == 43:\n\t\t\t\t\tprint(s43)\n\t\t\t\telif n == 44:\n\t\t\t\t\tprint(s44)\n\t\t\t\telif n == 45:\n\t\t\t\t\tprint(s45)\n\t\t\t\telif n == 46:\n\t\t\t\t\tprint(s46)\n\t\t\t\telif n == 47:\n\t\t\t\t\tprint(s47)\n\t\t\t\telif n == 48:\n\t\t\t\t\tprint(s48)\n\t\t\t\telif n == 49:\n\t\t\t\t\tprint(s49)\n\t\t\t\telif n == 50:\n\t\t\t\t\tprint(s50)\n\t\t\t\telif n == 51:\n\t\t\t\t\tprint(s51)\n\t\t\t\telif n == 52:\n\t\t\t\t\tprint(s52)\n\t\t\t\telif n == 53:\n\t\t\t\t\tprint(s53)\n\t\t\t\telif n == 54:\n\t\t\t\t\tprint(s54)\n\t\t\t\telif n == 55:\n\t\t\t\t\tprint(s55)\n\t\t\t\telif n == 56:\n\t\t\t\t\tprint(s56)\n\t\t\t\telif n == 57:\n\t\t\t\t\tprint(s57)\n\t\t\t\telif n == 58:\n\t\t\t\t\tprint(s58)\n\t\t\t\telif n == 59:\n\t\t\t\t\tprint(s59)\n\t\t\t\telif n == 60:\n\t\t\t\t\tprint(s60)\n\t\t\t\telif n == 61:\n\t\t\t\t\tprint(s61)\n\t\t\t\telse:\n\t\t\t\t\tj = n\n\t\t\t\t\twhile j > 61:\n\t\t\t\t\t\ts += s32\n\t\t\t\t\t\tj -= 32\n\t\t\t\t\tif j == 1:\n\t\t\t\t\t\ts1 += s\n\t\t\t\t\t\tprint(s1)\n\t\t\t\t\telif j == 2:\n\t\t\t\t\t\ts2 += s\n\t\t\t\t\t\tprint(s2)\n\t\t\t\t\telif j == 3:\n\t\t\t\t\t\ts3 += s\n\t\t\t\t\t\tprint(s3)\n\t\t\t\t\telif j == 4:\n\t\t\t\t\t\ts4 += s\n\t\t\t\t\t\tprint(s4)\n\t\t\t\t\telif j == 5:\n\t\t\t\t\t\ts5 += s\n\t\t\t\t\t\tprint(s5)\n\t\t\t\t\telif j == 6:\n\t\t\t\t\t\ts6 += s\n\t\t\t\t\t\tprint(s6)\n\t\t\t\t\telif j == 7:\n\t\t\t\t\t\ts7 += s\n\t\t\t\t\t\tprint(s7)\n\t\t\t\t\telif j == 8:\n\t\t\t\t\t\ts8 += s\n\t\t\t\t\t\tprint(s8)\n\t\t\t\t\telif j == 9:\n\t\t\t\t\t\ts9 += s\n\t\t\t\t\t\tprint(s9)\n\t\t\t\t\telif j == 10:\n\t\t\t\t\t\ts10 += s\n\t\t\t\t\t\tprint(s10)\n\t\t\t\t\telif j == 11:\n\t\t\t\t\t\ts11 += s\n\t\t\t\t\t\tprint(s11)\n\t\t\t\t\telif j == 12:\n\t\t\t\t\t\ts12 += s\n\t\t\t\t\t\tprint(s12)\n\t\t\t\t\telif j == 13:\n\t\t\t\t\t\ts13 += s\n\t\t\t\t\t\tprint(s13)\n\t\t\t\t\telif j == 14:\n\t\t\t\t\t\ts14 += s\n\t\t\t\t\t\tprint(s14)\n\t\t\t\t\telif j == 15:\n\t\t\t\t\t\ts15 += s\n\t\t\t\t\t\tprint(s15)\n\t\t\t\t\telif j == 16:\n\t\t\t\t\t\ts16 += s\n\t\t\t\t\t\tprint(s16)\n\t\t\t\t\telif j == 17:\n\t\t\t\t\t\ts17 += s\n\t\t\t\t\t\tprint(s17)\n\t\t\t\t\telif j == 18:\n\t\t\t\t\t\ts18 += s\n\t\t\t\t\t\tprint(s18)\n\t\t\t\t\telif j == 19:\n\t\t\t\t\t\ts19 += s\n\t\t\t\t\t\tprint(s19)\n\t\t\t\t\telif j == 20:\n\t\t\t\t\t\ts20 += s\n\t\t\t\t\t\tprint(s20)\n\t\t\t\t\telif j == 21:\n\t\t\t\t\t\ts21 += s\n\t\t\t\t\t\tprint(s21)\n\t\t\t\t\telif j == 22:\n\t\t\t\t\t\ts22 += s\n\t\t\t\t\t\tprint(s22)\n\t\t\t\t\telif j == 23:\n\t\t\t\t\t\ts23 += s\n\t\t\t\t\t\tprint(s23)\n\t\t\t\t\telif j == 24:\n\t\t\t\t\t\ts24 += s\n\t\t\t\t\t\tprint(s24)\n\t\t\t\t\telif j == 25:\n\t\t\t\t\t\ts25 += s\n\t\t\t\t\t\tprint(s25)\n\t\t\t\t\telif j == 26:\n\t\t\t\t\t\ts26 += s\n\t\t\t\t\t\tprint(s26)\n\t\t\t\t\telif j == 27:\n\t\t\t\t\t\ts27 += s\n\t\t\t\t\t\tprint(s27)\n\t\t\t\t\telif j == 28:\n\t\t\t\t\t\ts28 += s\n\t\t\t\t\t\tprint(s28)\n\t\t\t\t\telif j == 29:\n\t\t\t\t\t\ts29 += s\n\t\t\t\t\t\tprint(s29)\n\t\t\t\t\telif j == 30:\n\t\t\t\t\t\ts30 += s\n\t\t\t\t\t\tprint(s30)\n\t\t\t\t\telif j == 31:\n\t\t\t\t\t\ts31 += s\n\t\t\t\t\t\tprint(s31)\n\t\t\t\t\telif j == 32:\n\t\t\t\t\t\ts32 += s\n\t\t\t\t\t\tprint(s32)\n\t\t\t\t\telif j == 33:\n\t\t\t\t\t\ts33 += s\n\t\t\t\t\t\tprint(s33)\n\t\t\t\t\telif j == 34:\n\t\t\t\t\t\ts34 += s\n\t\t\t\t\t\tprint(s34)\n\t\t\t\t\telif j == 35:\n\t\t\t\t\t\ts35 += s\n\t\t\t\t\t\tprint(s35)\n\t\t\t\t\telif j == 36:\n\t\t\t\t\t\ts36 += s\n\t\t\t\t\t\tprint(s36)\n\t\t\t\t\telif j == 37:\n\t\t\t\t\t\ts37 += s\n\t\t\t\t\t\tprint(s37)\n\t\t\t\t\telif j == 38:\n\t\t\t\t\t\ts38 += s\n\t\t\t\t\t\tprint(s38)\n\t\t\t\t\telif j == 39:\n\t\t\t\t\t\ts39 += s\n\t\t\t\t\t\tprint(s39)\n\t\t\t\t\telif j == 40:\n\t\t\t\t\t\ts40 += s\n\t\t\t\t\t\tprint(s40)\n\t\t\t\t\telif j == 41:\n\t\t\t\t\t\ts41 += s\n\t\t\t\t\t\tprint(s41)\n\t\t\t\t\telif j == 42:\n\t\t\t\t\t\ts42 += s\n\t\t\t\t\t\tprint(s42)\n\t\t\t\t\telif j == 43:\n\t\t\t\t\t\ts43 += s\n\t\t\t\t\t\tprint(s43)\n\t\t\t\t\telif j == 44:\n\t\t\t\t\t\ts44 += s\n\t\t\t\t\t\tprint(s44)\n\t\t\t\t\telif j == 45:\n\t\t\t\t\t\ts45 += s\n\t\t\t\t\t\tprint(s45)\n\t\t\t\t\telif j == 46:\n\t\t\t\t\t\ts46 += s\n\t\t\t\t\t\tprint(s46)\n\t\t\t\t\telif j == 47:\n\t\t\t\t\t\ts47 += s\n\t\t\t\t\t\tprint(s47)\n\t\t\t\t\telif j == 48:\n\t\t\t\t\t\ts48 += s\n\t\t\t\t\t\tprint(s48)\n\t\t\t\t\telif j == 49:\n\t\t\t\t\t\ts49 += s\n\t\t\t\t\t\tprint(s49)\n\t\t\t\t\telif j == 50:\n\t\t\t\t\t\ts50 += s\n\t\t\t\t\t\tprint(s50)\n\t\t\t\t\telif j == 51:\n\t\t\t\t\t\ts51 += s\n\t\t\t\t\t\tprint(s51)\n\t\t\t\t\telif j == 52:\n\t\t\t\t\t\ts52 += s\n\t\t\t\t\t\tprint(s52)\n\t\t\t\t\telif j == 53:\n\t\t\t\t\t\ts53 += s\n\t\t\t\t\t\tprint(s53)\n\t\t\t\t\telif j == 54:\n\t\t\t\t\t\ts54 += s\n\t\t\t\t\t\tprint(s54)\n\t\t\t\t\telif j == 55:\n\t\t\t\t\t\ts55 += s\n\t\t\t\t\t\tprint(s55)\n\t\t\t\t\telif j == 56:\n\t\t\t\t\t\ts56 += s\n\t\t\t\t\t\tprint(s56)\n\t\t\t\t\telif j == 57:\n\t\t\t\t\t\ts57 += s\n\t\t\t\t\t\tprint(s57)\n\t\t\t\t\telif j == 58:\n\t\t\t\t\t\ts58 += s\n\t\t\t\t\t\tprint(s58)\n\t\t\t\t\telif j == 59:\n\t\t\t\t\t\ts59 += s\n\t\t\t\t\t\tprint(s59)\n\t\t\t\t\telif j == 60:\n\t\t\t\t\t\ts60 += s\n\t\t\t\t\t\tprint(s60)\n\t\t\t\t\telif j == 61:\n\t\t\t\t\t\ts61 += s\n\t\t\t\t\t\tprint(s61)\nexcept:\n\tpass\n"
    },
    {
        "task_id": 401,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 2.5696630477905273,
        "fastest_time": 2.5165226459503174,
        "fastest_solution": "from collections import defaultdict, deque\n\ndef main():\n\t(n, m) = map(int, input().split())\n\tcap = [None] * (m + 1)\n\tsame_cap = defaultdict(list)\n\tq = deque()\n\n\tdef apply_cap(a, c):\n\t\tif cap[a] is not None:\n\t\t\treturn cap[a] == c\n\t\tq.append((a, c))\n\t\twhile q:\n\t\t\tb = q.pop()\n\t\t\tif b[1] == c:\n\t\t\t\tif cap[b[0]] is None:\n\t\t\t\t\tcap[b[0]] = c\n\t\t\t\t\tq.extend(same_cap[b[0]])\n\t\t\t\t\tsame_cap[b[0]] = []\n\t\t\t\telif cap[b[0]] != c:\n\t\t\t\t\treturn False\n\t\treturn True\n\n\tdef same(a, b):\n\t\tsame_cap[b].append((a, True))\n\t\tsame_cap[a].append((b, False))\n\t\tif cap[a] == False:\n\t\t\treturn apply_cap(b, False)\n\t\tif cap[b] == True:\n\t\t\treturn apply_cap(a, True)\n\t\treturn True\n\n\tdef process(p, c):\n\t\tlp = p[0]\n\t\tlc = c[0]\n\t\tfor i in range(1, min(lp, lc) + 1):\n\t\t\tif p[i] > c[i]:\n\t\t\t\treturn apply_cap(p[i], True) and apply_cap(c[i], False)\n\t\t\tif p[i] < c[i]:\n\t\t\t\treturn same(p[i], c[i])\n\t\treturn lp <= lc\n\tp = list(map(int, input().split()))\n\tfor i in range(n - 1):\n\t\tc = list(map(int, input().split()))\n\t\tif not process(p, c):\n\t\t\tprint('No')\n\t\t\tbreak\n\t\tp = c\n\telse:\n\t\tprint('Yes')\n\t\tres = []\n\t\tfor (i, b) in enumerate(cap):\n\t\t\tif b:\n\t\t\t\tres.append(i)\n\t\tprint(len(res))\n\t\tprint(' '.join(map(str, res)))\nmain()\n",
        "slowest_solution": "import math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\nthreading.stack_size(10 ** 8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass TreeNode:\n\n\tdef __init__(self, k, v):\n\t\tself.key = k\n\t\tself.value = v\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.parent = None\n\t\tself.height = 1\n\t\tself.num_left = 1\n\t\tself.num_total = 1\n\nclass AvlTree:\n\n\tdef __init__(self):\n\t\tself._tree = None\n\n\tdef add(self, k, v):\n\t\tif not self._tree:\n\t\t\tself._tree = TreeNode(k, v)\n\t\t\treturn\n\t\tnode = self._add(k, v)\n\t\tif node:\n\t\t\tself._rebalance(node)\n\n\tdef _add(self, k, v):\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tif node.left:\n\t\t\t\t\tnode = node.left\n\t\t\t\telse:\n\t\t\t\t\tnode.left = TreeNode(k, v)\n\t\t\t\t\tnode.left.parent = node\n\t\t\t\t\treturn node.left\n\t\t\telif node.key < k:\n\t\t\t\tif node.right:\n\t\t\t\t\tnode = node.right\n\t\t\t\telse:\n\t\t\t\t\tnode.right = TreeNode(k, v)\n\t\t\t\t\tnode.right.parent = node\n\t\t\t\t\treturn node.right\n\t\t\telse:\n\t\t\t\tnode.value = v\n\t\t\t\treturn\n\n\t@staticmethod\n\tdef get_height(x):\n\t\treturn x.height if x else 0\n\n\t@staticmethod\n\tdef get_num_total(x):\n\t\treturn x.num_total if x else 0\n\n\tdef _rebalance(self, node):\n\t\tn = node\n\t\twhile n:\n\t\t\tlh = self.get_height(n.left)\n\t\t\trh = self.get_height(n.right)\n\t\t\tn.height = max(lh, rh) + 1\n\t\t\tbalance_factor = lh - rh\n\t\t\tn.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n\t\t\tn.num_left = 1 + self.get_num_total(n.left)\n\t\t\tif balance_factor > 1:\n\t\t\t\tif self.get_height(n.left.left) < self.get_height(n.left.right):\n\t\t\t\t\tself._rotate_left(n.left)\n\t\t\t\tself._rotate_right(n)\n\t\t\telif balance_factor < -1:\n\t\t\t\tif self.get_height(n.right.right) < self.get_height(n.right.left):\n\t\t\t\t\tself._rotate_right(n.right)\n\t\t\t\tself._rotate_left(n)\n\t\t\telse:\n\t\t\t\tn = n.parent\n\n\tdef _remove_one(self, node):\n\t\treplacement = node.left or node.right\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = replacement\n\t\t\telse:\n\t\t\t\tnode.parent.right = replacement\n\t\t\treplacement.parent = node.parent\n\t\t\tnode.parent = None\n\t\telse:\n\t\t\tself._tree = replacement\n\t\t\treplacement.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\t\tnode.parent = None\n\t\tself._rebalance(replacement)\n\n\tdef _remove_leaf(self, node):\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = None\n\t\t\telse:\n\t\t\t\tnode.parent.right = None\n\t\t\tself._rebalance(node.parent)\n\t\telse:\n\t\t\tself._tree = None\n\t\tnode.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\n\tdef remove(self, k):\n\t\tnode = self._get_node(k)\n\t\tif not node:\n\t\t\treturn\n\t\tif AvlTree._is_leaf(node):\n\t\t\tself._remove_leaf(node)\n\t\t\treturn\n\t\tif node.left and node.right:\n\t\t\tnxt = AvlTree._get_next(node)\n\t\t\tnode.key = nxt.key\n\t\t\tnode.value = nxt.value\n\t\t\tif self._is_leaf(nxt):\n\t\t\t\tself._remove_leaf(nxt)\n\t\t\telse:\n\t\t\t\tself._remove_one(nxt)\n\t\t\tself._rebalance(node)\n\t\telse:\n\t\t\tself._remove_one(node)\n\n\tdef get(self, k):\n\t\tnode = self._get_node(k)\n\t\treturn node.value if node else -1\n\n\tdef _get_node(self, k):\n\t\tif not self._tree:\n\t\t\treturn None\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tnode = node.left\n\t\t\telif node.key < k:\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn node\n\t\treturn None\n\n\tdef get_at(self, pos):\n\t\tx = pos + 1\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif x < node.num_left:\n\t\t\t\tnode = node.left\n\t\t\telif node.num_left < x:\n\t\t\t\tx -= node.num_left\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn (node.key, node.value)\n\t\traise IndexError('Out of ranges')\n\n\t@staticmethod\n\tdef _is_left(node):\n\t\treturn node.parent.left and node.parent.left == node\n\n\t@staticmethod\n\tdef _is_leaf(node):\n\t\treturn node.left is None and node.right is None\n\n\tdef _rotate_right(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.left\n\t\t\tnode.left.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.left\n\t\t\tnode.left.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.left\n\t\t\tnode.left.parent = node.parent\n\t\tbk = node.left.right\n\t\tnode.left.right = node\n\t\tnode.parent = node.left\n\t\tnode.left = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\tdef _rotate_left(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.right\n\t\t\tnode.right.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.right\n\t\t\tnode.right.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.right\n\t\t\tnode.right.parent = node.parent\n\t\tbk = node.right.left\n\t\tnode.right.left = node\n\t\tnode.parent = node.right\n\t\tnode.right = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\t@staticmethod\n\tdef _get_next(node):\n\t\tif not node.right:\n\t\t\treturn node.parent\n\t\tn = node.right\n\t\twhile n.left:\n\t\t\tn = n.left\n\t\treturn n\n\nclass SegmentTree1:\n\n\tdef __init__(self, data, default=2 ** 51, func=lambda a, b: a & b):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass SegmentTree:\n\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass Factorial:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorials = [1, 1]\n\t\tself.invModulos = [0, 1]\n\t\tself.invFactorial_ = [1, 1]\n\n\tdef calc(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.factorials):\n\t\t\treturn self.factorials[n]\n\t\tnextArr = [0] * (n + 1 - len(self.factorials))\n\t\tinitialI = len(self.factorials)\n\t\tprev = self.factorials[-1]\n\t\tm = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * i % m\n\t\tself.factorials += nextArr\n\t\treturn self.factorials[n]\n\n\tdef inv(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n^(-1)')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tp = self.MOD\n\t\tpi = n % p\n\t\tif pi < len(self.invModulos):\n\t\t\treturn self.invModulos[pi]\n\t\tnextArr = [0] * (n + 1 - len(self.invModulos))\n\t\tinitialI = len(self.invModulos)\n\t\tfor i in range(initialI, min(p, n + 1)):\n\t\t\tnext = -self.invModulos[p % i] * (p // i) % p\n\t\t\tself.invModulos.append(next)\n\t\treturn self.invModulos[pi]\n\n\tdef invFactorial(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate (n^(-1))!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.invFactorial_):\n\t\t\treturn self.invFactorial_[n]\n\t\tself.inv(n)\n\t\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\n\t\tinitialI = len(self.invFactorial_)\n\t\tprev = self.invFactorial_[-1]\n\t\tp = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\n\t\tself.invFactorial_ += nextArr\n\t\treturn self.invFactorial_[n]\n\nclass Combination:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorial = Factorial(MOD)\n\n\tdef ncr(self, n, k):\n\t\tif k < 0 or n < k:\n\t\t\treturn 0\n\t\tk = min(k, n - k)\n\t\tf = self.factorial\n\t\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n\tif a == 1 or n == 0:\n\t\treturn 1\n\tif n % 2 == 0:\n\t\ts = powm(a, n // 2, m)\n\t\treturn s * s % m\n\telse:\n\t\treturn a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n\tzipped_pairs = zip(list2, list1)\n\tz = [x for (_, x) in sorted(zipped_pairs)]\n\treturn z\n\ndef product(l):\n\tpor = 1\n\tfor i in range(len(l)):\n\t\tpor *= l[i]\n\treturn por\n\ndef binarySearchCount(arr, n, key):\n\tleft = 0\n\tright = n - 1\n\tcount = 0\n\twhile left <= right:\n\t\tmid = int((right + left) / 2)\n\t\tif arr[mid] < key:\n\t\t\tcount = mid + 1\n\t\t\tleft = mid + 1\n\t\telse:\n\t\t\tright = mid - 1\n\treturn count\n\ndef countdig(n):\n\tc = 0\n\twhile n > 0:\n\t\tn //= 10\n\t\tc += 1\n\treturn c\n\ndef binary(x, length):\n\ty = bin(x)[2:]\n\treturn y if len(y) >= length else '0' * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n\tl = 0\n\tr = n - 1\n\tleftGreater = n\n\twhile l <= r:\n\t\tm = int(l + (r - l) / 2)\n\t\tif arr[m] >= k:\n\t\t\tleftGreater = m\n\t\t\tr = m - 1\n\t\telse:\n\t\t\tl = m + 1\n\treturn n - leftGreater\n(n, m) = map(int, input().split())\nl = []\nfor i in range(n):\n\tl.append(list(map(int, input().split())))\nc = [0] * (m + 1)\nans = []\nf = 0\ngraph = defaultdict(list)\nfor i in range(n - 1):\n\tfor j in range(1, int(l[i][0]) + 1):\n\t\tif j == int(l[i + 1][0]) and int(l[i + 1][0]) < int(l[i][0]):\n\t\t\tif c[l[i + 1][j]] > c[l[i][j]]:\n\t\t\t\tif c[l[i][j]] == 0:\n\t\t\t\t\tc[l[i][j]] = 1\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tf = 1\n\t\t\t\t\tbreak\n\t\t\tif l[i][j] >= l[i + 1][j] and c[l[i][j]] <= c[l[i + 1][j]]:\n\t\t\t\tif c[l[i][j]] == 0:\n\t\t\t\t\tc[l[i][j]] = 1\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tf = 1\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tgraph[l[i + 1][j]].append(l[i][j])\n\t\t\t\tbreak\n\t\telif c[l[i + 1][j]] > c[l[i][j]]:\n\t\t\tif c[l[i][j]] == 0:\n\t\t\t\tc[l[i][j]] = 1\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\telif l[i][j] > l[i + 1][j] and c[l[i][j]] <= c[l[i + 1][j]]:\n\t\t\tif c[l[i][j]] == 0:\n\t\t\t\tc[l[i][j]] = 1\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\telif l[i][j] < l[i + 1][j] or c[l[i][j]] > c[l[i + 1][j]]:\n\t\t\tgraph[l[i + 1][j]].append(l[i][j])\n\t\t\tbreak\n\tif f == 1:\n\t\tbreak\nif f == 1:\n\tprint('No')\n\tsys.exit(0)\nf = 0\nvisited = [False] * (m + 1)\n\ndef dfs(v, t):\n\tstack = []\n\tstack.append((v, t))\n\twhile len(stack) > 0:\n\t\t(v, t) = stack.pop()\n\t\tc[v] = max(t, c[v])\n\t\tvisited[v] = True\n\t\tfor i in graph[v]:\n\t\t\tc[i] = max(c[i], c[v])\n\t\t\tif visited[i] == False:\n\t\t\t\tstack.append((i, c[v]))\nfor i in range(1, m + 1):\n\tif visited[i] == False and c[i] == 1:\n\t\tdfs(i, c[i])\nfor i in range(1, m + 1):\n\tif c[i] == 1:\n\t\tans.append(i)\nfor i in range(n - 1):\n\tfor j in range(1, int(l[i][0]) + 1):\n\t\tif j == int(l[i + 1][0]) and int(l[i + 1][0]) < int(l[i][0]):\n\t\t\tif c[l[i + 1][j]] > c[l[i][j]]:\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\t\tif l[i][j] >= l[i + 1][j] and c[l[i][j]] <= c[l[i + 1][j]]:\n\t\t\t\tf = 1\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tbreak\n\t\tif c[l[i + 1][j]] > c[l[i][j]]:\n\t\t\tf = 1\n\t\t\tbreak\n\t\telif l[i][j] > l[i + 1][j] and c[l[i][j]] <= c[l[i + 1][j]]:\n\t\t\tf = 1\n\t\t\tbreak\n\t\telif l[i][j] < l[i + 1][j] or c[l[i][j]] > c[l[i + 1][j]]:\n\t\t\tbreak\nif f == 1:\n\tprint('No')\nelse:\n\tprint('Yes')\n\tprint(len(ans))\n\tprint(*ans)\n"
    },
    {
        "task_id": 424,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 0.001009225845336914,
        "fastest_time": 0.0,
        "fastest_solution": "def check_concatenated_sum(n, r):\n\treturn abs(n) == sum((int(e * r) for e in str(abs(n)) if r))\n",
        "slowest_solution": "def check_concatenated_sum(num, l):\n\treturn sum([int(x * l) for x in str(abs(num))]) == abs(num) if l > 0 else False\n"
    },
    {
        "task_id": 370,
        "slowest_solution_id": 4,
        "fastest_solution_id": 6,
        "slowest_time": 2.739304542541504,
        "fastest_time": 2.5195882320404053,
        "fastest_solution": "from collections import defaultdict\nimport math as m\nt = int(input())\nfor k in range(t):\n\t(x, y) = map(int, input().split())\n\tans = -1\n\tif y % x != 0:\n\t\tprint(-1)\n\telse:\n\t\tfor i in range(61, 0, -1):\n\t\t\tif x * (2 ** i - 1) <= y:\n\t\t\t\ty = y - x * (2 ** i - 1)\n\t\t\t\tans += 1\n\t\t\t\tans += i\n\t\tif y == 0:\n\t\t\tprint(ans)\n\t\telse:\n\t\t\tprint(-1)\n",
        "slowest_solution": "import sys\nt = int(input())\nfor i in range(t):\n\t(x, y) = map(int, input().split())\n\tif y % x != 0:\n\t\tprint(-1)\n\t\tcontinue\n\ta = y // x + 1\n\tif a % 2 == 1:\n\t\ta += 1\n\t\tj = 2\n\telse:\n\t\tj = 1\n\tb = '{0:0b}'.format(a)\n\tans = sys.maxsize\n\twhile j <= len(b):\n\t\tif b.count('1') == j:\n\t\t\td = j - 1\n\t\t\tind = b.index('1')\n\t\t\twhile ind != -1:\n\t\t\t\td += len(b) - ind - 1\n\t\t\t\ttry:\n\t\t\t\t\tind = b.index('1', ind + 1)\n\t\t\t\texcept ValueError:\n\t\t\t\t\tbreak\n\t\t\tif d < ans:\n\t\t\t\tans = d\n\t\tj += 2\n\t\ta += 2\n\t\tb = '{0:0b}'.format(a)\n\tif ans != sys.maxsize:\n\t\tprint(ans)\n\telse:\n\t\tprint(-1)\n"
    },
    {
        "task_id": 371,
        "slowest_solution_id": 2,
        "fastest_solution_id": 6,
        "slowest_time": 2.708599805831909,
        "fastest_time": 2.521589517593384,
        "fastest_solution": "for _ in range(int(input())):\n\t(N, K) = map(int, input().split())\n\tA = list(map(int, input().split()))\n\tlist1 = [0] * K\n\tfor i in A:\n\t\ta = i % K\n\t\tlist1[a] += 1\n\tans = 1\n\tfor i in range(K // 2 + 1):\n\t\tif i == 0 or i == K / 2:\n\t\t\tans *= list1[i] + 1\n\t\telse:\n\t\t\tans *= 2 ** list1[i] + 2 ** list1[K - i] - 1\n\tprint(ans % (10 ** 9 + 7))\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef inp():\n\treturn int(input())\n\ndef inlt():\n\treturn list(map(int, input().split()))\n\ndef insr():\n\treturn input().strip()\n\ndef invr():\n\treturn map(int, input().split())\n\ndef outp(n):\n\tsys.stdout.write(str(n) + '\\n')\n\ndef outlt(lst):\n\tsys.stdout.write(' '.join(map(str, lst)) + '\\n')\n\ndef outplt(lst):\n\tsys.stdout.write('\\n'.join(map(str, lst)))\n\ndef outpltlt(lst):\n\tsys.stdout.write('\\n'.join(map(str, (' '.join(map(str, a)) for a in lst))))\n\ndef solve(N, K, A):\n\tan = 1\n\trem = [0] * K\n\tfor a in A:\n\t\trem[a % K] += 1\n\tfor x in range(K // 2 + 1):\n\t\tif 2 * x in [0, K]:\n\t\t\tan = an * (rem[x] + 1) % mod\n\t\telse:\n\t\t\tan = an * (pow(2, rem[x], mod) + pow(2, rem[K - x], mod) - 1) % mod\n\treturn an\nmod = 10 ** 9 + 7\nans = []\nfor _ in range(inp()):\n\t(N, K) = inlt()\n\tA = invr()\n\tans.append(solve(N, K, A))\noutplt(ans)\n"
    },
    {
        "task_id": 394,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6446757316589355,
        "fastest_time": 2.6446757316589355,
        "fastest_solution": "from sys import stdin, stdout\nimport math\n\ndef update(bit, n, pos, v):\n\tpos += 1\n\twhile pos <= n:\n\t\tbit[pos] += v\n\t\tpos += -pos & pos\n\treturn\n\ndef getsum(bit, i):\n\tsu = 0\n\twhile i > 0:\n\t\tsu += bit[i]\n\t\ti -= -i & i\n\treturn su\n\ndef main():\n\ttry:\n\t\t(n, nQ) = In()\n\t\tbit = [0] * (n + 1)\n\t\tl = list(In())\n\t\ttask = []\n\t\tfor i in range(n - 1):\n\t\t\ttask.append([min(l[i], l[i + 1]), 1, i])\n\t\t\ttask.append([max(l[i], l[i + 1]), 3, i])\n\t\tQ = []\n\t\tans = [0 for x in range(nQ)]\n\t\tfor q in range(nQ):\n\t\t\t(l, r, y) = In()\n\t\t\tl -= 1\n\t\t\tr -= 1\n\t\t\tQ.append([l, r])\n\t\t\ttask.append([y, 2, q])\n\t\ttask.sort(key=lambda x: [x[0], x[1]])\n\t\tfor x in task:\n\t\t\tif x[1] == 1:\n\t\t\t\tupdate(bit, n, x[2], 1)\n\t\t\telif x[1] == 3:\n\t\t\t\tupdate(bit, n, x[2], -1)\n\t\t\telse:\n\t\t\t\tans[x[2]] = getsum(bit, Q[x[2]][1]) - getsum(bit, Q[x[2]][0])\n\t\tfor x in ans:\n\t\t\tprint(x)\n\texcept:\n\t\tpass\n\ndef add(a, b, c):\n\tres = a + b\n\tif res >= c:\n\t\treturn res - c\n\telse:\n\t\treturn res\n\ndef mod(a, b, c):\n\tres = a * b\n\tif res >= c:\n\t\treturn res % c\n\telse:\n\t\treturn res\n\ndef gcd(a, b):\n\twhile b:\n\t\t(a, b) = (b, a % b)\n\treturn a\n\ndef lcm(a, b):\n\tw = a // gcd(a, b)\n\treturn w * b\n\ndef expo(a, b):\n\t(x, y) = (1, a)\n\twhile b > 0:\n\t\tif b & 1:\n\t\t\tx = x * y\n\t\ty = y * y\n\t\tb >>= 1\n\treturn x\n\ndef power(a, b, m):\n\t(x, y) = (1,)\n\twhile b > 0:\n\t\tif b & 1:\n\t\t\tx = mod(x, y, m)\n\t\ty = mod(y, y, m)\n\t\tb >>= 1\n\treturn x\n\ndef L():\n\treturn list(map(int, stdin.readline().split()))\n\ndef In():\n\treturn map(int, stdin.readline().split())\n\ndef I():\n\treturn int(stdin.readline())\nP = 1000000007\nfor _ in range(I()):\n\tmain()\n",
        "slowest_solution": "from sys import stdin, stdout\nimport math\n\ndef update(bit, n, pos, v):\n\tpos += 1\n\twhile pos <= n:\n\t\tbit[pos] += v\n\t\tpos += -pos & pos\n\treturn\n\ndef getsum(bit, i):\n\tsu = 0\n\twhile i > 0:\n\t\tsu += bit[i]\n\t\ti -= -i & i\n\treturn su\n\ndef main():\n\ttry:\n\t\t(n, nQ) = In()\n\t\tbit = [0] * (n + 1)\n\t\tl = list(In())\n\t\ttask = []\n\t\tfor i in range(n - 1):\n\t\t\ttask.append([min(l[i], l[i + 1]), 1, i])\n\t\t\ttask.append([max(l[i], l[i + 1]), 3, i])\n\t\tQ = []\n\t\tans = [0 for x in range(nQ)]\n\t\tfor q in range(nQ):\n\t\t\t(l, r, y) = In()\n\t\t\tl -= 1\n\t\t\tr -= 1\n\t\t\tQ.append([l, r])\n\t\t\ttask.append([y, 2, q])\n\t\ttask.sort(key=lambda x: [x[0], x[1]])\n\t\tfor x in task:\n\t\t\tif x[1] == 1:\n\t\t\t\tupdate(bit, n, x[2], 1)\n\t\t\telif x[1] == 3:\n\t\t\t\tupdate(bit, n, x[2], -1)\n\t\t\telse:\n\t\t\t\tans[x[2]] = getsum(bit, Q[x[2]][1]) - getsum(bit, Q[x[2]][0])\n\t\tfor x in ans:\n\t\t\tprint(x)\n\texcept:\n\t\tpass\n\ndef add(a, b, c):\n\tres = a + b\n\tif res >= c:\n\t\treturn res - c\n\telse:\n\t\treturn res\n\ndef mod(a, b, c):\n\tres = a * b\n\tif res >= c:\n\t\treturn res % c\n\telse:\n\t\treturn res\n\ndef gcd(a, b):\n\twhile b:\n\t\t(a, b) = (b, a % b)\n\treturn a\n\ndef lcm(a, b):\n\tw = a // gcd(a, b)\n\treturn w * b\n\ndef expo(a, b):\n\t(x, y) = (1, a)\n\twhile b > 0:\n\t\tif b & 1:\n\t\t\tx = x * y\n\t\ty = y * y\n\t\tb >>= 1\n\treturn x\n\ndef power(a, b, m):\n\t(x, y) = (1,)\n\twhile b > 0:\n\t\tif b & 1:\n\t\t\tx = mod(x, y, m)\n\t\ty = mod(y, y, m)\n\t\tb >>= 1\n\treturn x\n\ndef L():\n\treturn list(map(int, stdin.readline().split()))\n\ndef In():\n\treturn map(int, stdin.readline().split())\n\ndef I():\n\treturn int(stdin.readline())\nP = 1000000007\nfor _ in range(I()):\n\tmain()\n"
    },
    {
        "task_id": 373,
        "slowest_solution_id": 1,
        "fastest_solution_id": 3,
        "slowest_time": 2.684023857116699,
        "fastest_time": 2.52217960357666,
        "fastest_solution": "a = input()\nb = list(map(int, a))\ni = len(b)\npq = 0\nwhile b[i - 1] == 0:\n\ti -= 1\nfor j in range(i):\n\tif b[j] == b[i - 1 - j]:\n\t\tcontinue\n\telse:\n\t\tpq += 1\n\t\tbreak\nif pq > 0:\n\tprint('NO')\nelse:\n\tprint('YES')\n",
        "slowest_solution": "def isQuasiPalindrome(x):\n\twhile x % 10 == 0:\n\t\tx //= 10\n\ts = str(x)\n\treturn s == s[::-1]\nx = int(input())\nprint('YES' if isQuasiPalindrome(x) else 'NO')\n"
    },
    {
        "task_id": 429,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 0.001001596450805664,
        "fastest_time": 0.0,
        "fastest_solution": "def sc(strng):\n\tseen = set(strng)\n\treturn ''.join((a for a in strng if a.swapcase() in seen))\n",
        "slowest_solution": "def sc(s):\n\treturn ''.join([e for e in s if {1: e.upper() in s, 0: e.lower() in s}[e.islower()]])\n"
    },
    {
        "task_id": 375,
        "slowest_solution_id": 4,
        "fastest_solution_id": 8,
        "slowest_time": 2.698166608810425,
        "fastest_time": 2.48173451423645,
        "fastest_solution": "import sys\nfrom math import sqrt\n\ndef countSolutions(a, b, c, d):\n\tsols = set()\n\tfor x in range(1, c + 1):\n\t\tD = b ** 2 - 4 * (x ** 2 - a * x)\n\t\tif D < 0:\n\t\t\tcontinue\n\t\tdisc = sqrt(D)\n\t\tif disc == round(disc):\n\t\t\tdisc = int(disc)\n\t\telse:\n\t\t\tcontinue\n\t\tif (b - disc) % 2 != 0:\n\t\t\tcontinue\n\t\tys = ((b + disc) // 2, (b - disc) // 2)\n\t\tfor y in ys:\n\t\t\tif 1 <= y <= d:\n\t\t\t\tsols.add((x, y))\n\treturn len(sols)\nq = int(input().strip())\nfor a0 in range(q):\n\t(a, b, c, d) = input().strip().split(' ')\n\t(a, b, c, d) = [int(a), int(b), int(c), int(d)]\n\tresult = countSolutions(a, b, c, d)\n\tprint(result)\n",
        "slowest_solution": "from math import sqrt, trunc\n\ndef countSolutions(a, b, c, d):\n\tcount = 0\n\tfor y in range(1, d + 1):\n\t\tdisc = a * a - 4 * y * y + 4 * y * b\n\t\tif disc >= 0 and sqrt(disc).is_integer():\n\t\t\tx1 = round((a + sqrt(disc)) / 2)\n\t\t\tx2 = round((a - sqrt(disc)) / 2)\n\t\t\tif 1 <= x1 <= c:\n\t\t\t\tcount += 1\n\t\t\tif 1 <= x2 <= c and x1 != x2:\n\t\t\t\tcount += 1\n\treturn count\nq = int(input().strip())\nfor a0 in range(q):\n\t(a, b, c, d) = input().strip().split(' ')\n\t(a, b, c, d) = [int(a), int(b), int(c), int(d)]\n\tresult = countSolutions(a, b, c, d)\n\tprint(result)\n"
    },
    {
        "task_id": 415,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.5541832447052,
        "fastest_time": 2.4706811904907227,
        "fastest_solution": "import bisect\nimport math\n\ndef find_possible(vec, t):\n\tif len(vec) == 1:\n\t\treturn [(vec[0], 0)]\n\tp1 = find_possible(vec[:len(vec) // 2], t)\n\tp2 = find_possible(vec[len(vec) // 2:], t)\n\ti1 = 0\n\ti1t = 0\n\ti2 = 0\n\ti2t = 0\n\tmin_bribe_1 = math.inf\n\tmin_bribe_2 = math.inf\n\trv = []\n\twhile i1 < len(p1) and i2 < len(p2):\n\t\tif p1[i1][0] < p2[i2][0]:\n\t\t\twhile i2t < len(p2) and p2[i2t][0] <= p1[i1][0] + t:\n\t\t\t\tmin_bribe_2 = min(min_bribe_2, p2[i2t][1] + 1)\n\t\t\t\ti2t += 1\n\t\t\tmin_bribe_1 = min(min_bribe_1, p1[i1][1])\n\t\t\tif min_bribe_2 < math.inf:\n\t\t\t\trv.append((p1[i1][0], p1[i1][1] + min_bribe_2))\n\t\t\ti1 += 1\n\t\telse:\n\t\t\tassert p1[i1][0] > p2[i2][0]\n\t\t\twhile i1t < len(p1) and p1[i1t][0] <= p2[i2][0] + t:\n\t\t\t\tmin_bribe_1 = min(min_bribe_1, p1[i1t][1] + 1)\n\t\t\t\ti1t += 1\n\t\t\tmin_bribe_2 = min(min_bribe_2, p2[i2][1])\n\t\t\tif min_bribe_1 < math.inf:\n\t\t\t\trv.append((p2[i2][0], p2[i2][1] + min_bribe_1))\n\t\t\ti2 += 1\n\tif i1 < len(p1):\n\t\tassert min_bribe_2 == 0\n\t\trv.extend(p1[i1:])\n\tif i2 < len(p2):\n\t\tassert min_bribe_1 == 0\n\t\trv.extend(p2[i2:])\n\treturn rv\nfor _ in range(int(input())):\n\t(__, t) = [int(x) for x in input().split()]\n\tx = [int(x) for x in input().split()]\n\tans = find_possible(x, t)\n\ti = bisect.bisect_left(ans, (x[0] + 1, 0))\n\tif i == 0 or ans[i - 1][0] != x[0]:\n\t\tprint(-1)\n\telse:\n\t\tprint(ans[i - 1][1])\n",
        "slowest_solution": "import bisect\nimport math\n\ndef find_possible(vec, t):\n\tif len(vec) == 1:\n\t\treturn [(vec[0], 0)]\n\tassert len(vec) % 2 == 0\n\tp1 = find_possible(vec[:len(vec) // 2], t)\n\tp2 = find_possible(vec[len(vec) // 2:], t)\n\ti1 = 0\n\ti1t = 0\n\ti2 = 0\n\ti2t = 0\n\tmin_bribe_1 = math.inf\n\tmin_bribe_2 = math.inf\n\trv = []\n\twhile i1 < len(p1) and i2 < len(p2):\n\t\tif p1[i1][0] <= p2[i2][0]:\n\t\t\twhile i2t < len(p2) and p2[i2t][0] <= p1[i1][0] + t:\n\t\t\t\tmin_bribe_2 = min(min_bribe_2, p2[i2t][1] + 1)\n\t\t\t\ti2t += 1\n\t\t\tmin_bribe_1 = min(min_bribe_1, p1[i1][1])\n\t\tif p1[i1][0] >= p2[i2][0]:\n\t\t\twhile i1t < len(p1) and p1[i1t][0] <= p2[i2][0] + t:\n\t\t\t\tmin_bribe_1 = min(min_bribe_1, p1[i1t][1] + 1)\n\t\t\t\ti1t += 1\n\t\t\tmin_bribe_2 = min(min_bribe_2, p2[i2][1])\n\t\tif p1[i1][0] < p2[i2][0]:\n\t\t\tif min_bribe_2 < math.inf:\n\t\t\t\trv.append((p1[i1][0], p1[i1][1] + min_bribe_2))\n\t\t\ti1 += 1\n\t\telif p1[i1][0] > p2[i2][0]:\n\t\t\tif min_bribe_1 < math.inf:\n\t\t\t\trv.append((p2[i2][0], p2[i2][1] + min_bribe_1))\n\t\t\ti2 += 1\n\t\telse:\n\t\t\tmin_val = min(p1[i1][1] + min_bribe_2, p2[i2][1] + min_bribe_1)\n\t\t\tif min_val < math.inf:\n\t\t\t\trv.append((p1[i1][0], min_val))\n\t\t\ti1 += 1\n\t\t\ti2 += 1\n\tif i1 < len(p1):\n\t\tassert min_bribe_2 == 0\n\t\trv.extend(p1[i1:])\n\tif i2 < len(p2):\n\t\tassert min_bribe_1 == 0\n\t\trv.extend(p2[i2:])\n\treturn rv\nfor _ in range(int(input())):\n\t(h, t) = [int(x) for x in input().split()]\n\tx = [int(x) for x in input().split()]\n\tassert len(x) == 2 ** h\n\tus = x[0]\n\tbribe = 0\n\tfor i in range(h):\n\t\tothers = x[2 ** i:2 ** (i + 1)]\n\t\tmx = max(others)\n\t\tif mx < us:\n\t\t\tcontinue\n\t\tif mx <= us + t:\n\t\t\tbribe += 1\n\t\t\tcontinue\n\t\tif mx > us + t * (i + 1):\n\t\t\tbribe = -1\n\t\t\tbreak\n\t\tpossibles = find_possible(others, t)\n\t\tp1 = bisect.bisect_left(possibles, (us, 0))\n\t\tp2 = bisect.bisect_right(possibles, (us + t, math.inf))\n\t\tif p1 > 0:\n\t\t\tans1 = min((b for (__, b) in possibles[:p1]))\n\t\telse:\n\t\t\tans1 = math.inf\n\t\tif p2 > p1:\n\t\t\tans2 = min((b + 1 for (__, b) in possibles[p1:p2]))\n\t\telse:\n\t\t\tans2 = math.inf\n\t\tans = min(ans1, ans2)\n\t\tif ans == math.inf:\n\t\t\tbribe = -1\n\t\t\tbreak\n\t\tbribe += ans\n\tprint(bribe)\n"
    },
    {
        "task_id": 408,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 3.035183906555176,
        "fastest_time": 2.5062220096588135,
        "fastest_solution": "def find(arr, n, ele):\n\tl = 0\n\tr = n - 1\n\tmid = (l + r) // 2\n\twhile l != r:\n\t\tcur_ele = arr[mid]\n\t\tif cur_ele == ele:\n\t\t\tbreak\n\t\telif cur_ele > ele:\n\t\t\tr = mid - 1\n\t\t\tmid = (l + r) // 2\n\t\telse:\n\t\t\tl = mid + 1\n\t\t\tmid = (l + r) // 2\n\treturn mid\n\ndef pr_sum(bit, n, index):\n\tans = 0\n\twhile index:\n\t\tans += bit[index]\n\t\tindex -= index & -index\n\treturn ans\n\ndef update(bit, n, index):\n\twhile index <= n:\n\t\tbit[index] += 1\n\t\tindex += index & -index\n\treturn bit\nn = int(input())\nlst = [0] * n\nfor i in range(n):\n\ta = list(map(int, input().split()))\n\tlst[i] = a\nlst.sort(key=lambda x: x[0])\nf = [0] * n\ni = 0\nfor pair in lst:\n\tf[i] = pair[1]\n\ti += 1\narray = f\nn = len(array)\nsr_arr = sorted(array)\nin_arr = [0] * n\ni = 0\nfor ele in array:\n\tindex = find(sr_arr, n, ele)\n\tin_arr[i] = index + 1\n\ti += 1\nbit = [0] * (n + 1)\ninv_cnt = 0\nfor ele in reversed(in_arr):\n\tinv_cnt += pr_sum(bit, n, ele)\n\tbit = update(bit, n, ele)\nprint(inv_cnt)\n",
        "slowest_solution": "def construct(arr, n):\n\tBITTree = [0] * (n + 1)\n\tfor i in range(n):\n\t\tupdatebit(BITTree, n, i, arr[i])\n\treturn BITTree\n\ndef updatebit(BITTree, n, i, v):\n\ti += 1\n\twhile i <= n:\n\t\tBITTree[i] += v\n\t\ti += i & -i\n\ndef getsum(BITTree, i):\n\ts = 0\n\ti = i + 1\n\twhile i > 0:\n\t\ts += BITTree[i]\n\t\ti -= i & -i\n\treturn s\n\ndef getsum2(BITTree, l, r):\n\treturn getsum(BITTree, r) - getsum(BITTree, l - 1)\nn = int(input())\nfemales = []\nmales = []\nall_ = []\nfor _ in range(n):\n\t(a, b) = map(int, input().split())\n\tfemales.append(b)\n\tmales.append(a)\n\tall_.append((a, b))\nmales.sort()\nfemales.sort()\nm = {}\nf = {}\nfor i in range(n):\n\tm[males[i]] = i + 1\n\tf[females[i]] = i + 1\nline = {}\nfor i in range(n):\n\tx = m[all_[i][0]]\n\ty = f[all_[i][1]]\n\tline[x] = y\nans = 0\nbit = [0] * (100000 + 2)\nbit = construct(bit, 100000 + 2)\nfor i in range(n, 0, -1):\n\tx = line[i]\n\tans += getsum(bit, x)\n\tupdatebit(bit, 100000 + 2, x, 1)\nprint(ans)\n"
    },
    {
        "task_id": 378,
        "slowest_solution_id": 1,
        "fastest_solution_id": 7,
        "slowest_time": 2.778477907180786,
        "fastest_time": 2.4660394191741943,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef solution(arr, brr, n, m):\n\tarr.sort()\n\tbrr.sort()\n\tres = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif abs(arr[i] - brr[j]) <= 1:\n\t\t\t\tres += 1\n\t\t\t\tbrr[j] = 1000\n\t\t\t\tbreak\n\twrite(res)\n\ndef main():\n\tn = r_int()\n\tarr = r_array()\n\tm = r_int()\n\tbrr = r_array()\n\tsolution(arr, brr, n, m)\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\n\ndef input():\n\treturn sys.stdin.readline().rstrip('\\r\\n')\n\ndef write(*args, end='\\n'):\n\tfor x in args:\n\t\tsys.stdout.write(str(x) + ' ')\n\tsys.stdout.write(end)\n\ndef r_array():\n\treturn [int(x) for x in input().split()]\n\ndef r_int():\n\treturn int(input())\nmain()\n",
        "slowest_solution": "n = int(input())\na = list(map(int, input().split()))\nm = int(input())\nb = list(map(int, input().split()))\na.sort()\nb.sort()\nfor i in range(n):\n\tfor j in range(m):\n\t\tif a[i] - 1 <= b[j] <= a[i] + 1:\n\t\t\ta[i] = -3\n\t\t\tb[j] = -3\n\t\t\tbreak\nprint(a.count(-3))\n"
    },
    {
        "task_id": 379,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 2.701502561569214,
        "fastest_time": 2.4683339595794678,
        "fastest_solution": "t = int(input())\nfor tc in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tprint(a.index(min(a)) + 1)\n",
        "slowest_solution": "T = int(input())\nfor i in range(T):\n\tn = int(input())\n\tA = list(map(int, input().split()))\n\tprint(A.index(min(A)) + 1)\n"
    },
    {
        "task_id": 390,
        "slowest_solution_id": 0,
        "fastest_solution_id": 5,
        "slowest_time": 2.6862666606903076,
        "fastest_time": 2.498832941055298,
        "fastest_solution": "import sys\nimport io, os\ninput = sys.stdin.readline\nINF = 10 ** 18\n\ndef main():\n\t(h, w, k) = map(int, input().split())\n\tC = [input().rstrip() for i in range(h)]\n\t(x1, y1, x2, y2) = map(int, input().split())\n\t(x1, y1, x2, y2) = (x1 - 1, y1 - 1, x2 - 1, y2 - 1)\n\tfrom collections import deque\n\tq = deque()\n\tq.append((x1, y1))\n\tdist = [[INF] * w for i in range(h)]\n\tdist[x1][y1] = 0\n\twhile q:\n\t\t(x, y) = q.popleft()\n\t\tif x == x2 and y == y2:\n\t\t\tprint(dist[x][y])\n\t\t\texit()\n\t\tfor (dx, dy) in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n\t\t\tfor i in range(1, k + 1):\n\t\t\t\t(nx, ny) = (x + dx * i, y + dy * i)\n\t\t\t\tif nx < 0 or h <= nx:\n\t\t\t\t\tbreak\n\t\t\t\tif ny < 0 or w <= ny:\n\t\t\t\t\tbreak\n\t\t\t\tif C[nx][ny] == '#':\n\t\t\t\t\tbreak\n\t\t\t\tif dist[nx][ny] <= dist[x][y]:\n\t\t\t\t\tbreak\n\t\t\t\tif dist[nx][ny] == dist[x][y] + 1:\n\t\t\t\t\tcontinue\n\t\t\t\tdist[nx][ny] = dist[x][y] + 1\n\t\t\t\tq.append((nx, ny))\n\tprint(-1)\nmain()\n",
        "slowest_solution": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / 10 ** 15\nmod = 10 ** 9 + 7\n\ndef LI():\n\treturn [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_():\n\treturn [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef LF():\n\treturn [float(x) for x in sys.stdin.readline().split()]\n\ndef LS():\n\treturn sys.stdin.readline().split()\n\ndef I():\n\treturn int(sys.stdin.readline())\n\ndef F():\n\treturn float(sys.stdin.readline())\n\ndef S():\n\treturn input()\n\ndef pf(s):\n\treturn print(s, flush=True)\n\ndef main():\n\t(n, m, k) = LI()\n\ta = [[-1] * (m + 2)]\n\ta += [[-1] + [inf if c == '.' else -1 for c in S()] + [-1] for _ in range(n)]\n\ta += [[-1] * (m + 2)]\n\t(x1, y1, x2, y2) = LI()\n\ta[x1][y1] = 0\n\tq = [(x1, y1)]\n\tqi = 0\n\tdy = [-1, 1, 0, 0]\n\tdx = [0, 0, -1, 1]\n\twhile qi < len(q):\n\t\t(x, y) = q[qi]\n\t\tqi += 1\n\t\tnd = a[x][y] + 1\n\t\tfor di in range(4):\n\t\t\tfor j in range(1, k + 1):\n\t\t\t\tny = y + dy[di] * j\n\t\t\t\tnx = x + dx[di] * j\n\t\t\t\tif a[nx][ny] > nd:\n\t\t\t\t\tif ny == y2 and nx == x2:\n\t\t\t\t\t\treturn nd\n\t\t\t\t\ta[nx][ny] = nd\n\t\t\t\t\tq.append((nx, ny))\n\t\t\t\telif a[nx][ny] < nd:\n\t\t\t\t\tbreak\n\tif a[x2][y2] < inf:\n\t\treturn a[x2][y2]\n\treturn -1\nprint(main())\n"
    },
    {
        "task_id": 437,
        "slowest_solution_id": 7,
        "fastest_solution_id": 0,
        "slowest_time": 0.0007574558258056641,
        "fastest_time": 0.0,
        "fastest_solution": "def array_manip(array):\n\treturn [min([a for a in array[i + 1:] if a > array[i]], default=-1) for i in range(len(array))]\n",
        "slowest_solution": "class BinaryTree:\n\n\tdef __init__(self, value, left=None, right=None, parent=None):\n\t\tself.value = value\n\t\tself.left = left\n\t\tself.right = right\n\t\tself.parent = parent\n\n\tdef __str__(self):\n\t\tif self.left or self.right:\n\t\t\ts = '(' + str(self.value)\n\t\t\tsl = self.left or '#'\n\t\t\tsr = self.right or '#'\n\t\t\tfor l in str(sl).split('\\n'):\n\t\t\t\ts += '\\n  ' + l\n\t\t\tfor l in str(sr).split('\\n'):\n\t\t\t\ts += '\\n  ' + l\n\t\t\treturn s + ')'\n\t\telse:\n\t\t\treturn f'{self.value}'\n\n\tdef add(self, val):\n\t\tif val < self.value:\n\t\t\tif self.left:\n\t\t\t\treturn self.left.add(val)\n\t\t\telse:\n\t\t\t\tself.left = BinaryTree(val, parent=self)\n\t\t\t\treturn self.left\n\t\telif val > self.value:\n\t\t\tif self.right:\n\t\t\t\treturn self.right.add(val)\n\t\t\telse:\n\t\t\t\tself.right = BinaryTree(val, parent=self)\n\t\t\t\treturn self.right\n\t\telif val == self.value:\n\t\t\treturn self\n\n\tdef leftmost(self):\n\t\tx = self\n\t\twhile x.left:\n\t\t\tx = x.left\n\t\treturn x\n\n\tdef nxt(self):\n\t\tif self.right:\n\t\t\treturn self.right.leftmost().value\n\t\telse:\n\t\t\tx = self.parent\n\t\t\twhile x and x.value < self.value:\n\t\t\t\tx = x.parent\n\t\t\tif x:\n\t\t\t\treturn x.value\n\t\treturn -1\n\ndef array_manip(array):\n\tif not array:\n\t\treturn []\n\tresult = []\n\tb = BinaryTree(array[-1])\n\tfor item in reversed(array):\n\t\tresult.append(b.add(item).nxt())\n\treturn result[::-1]\n"
    },
    {
        "task_id": 427,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.603290319442749,
        "fastest_time": 2.5573792457580566,
        "fastest_solution": "(n, Q) = map(int, input().strip().split())\ns = input()\nd = 1\nfor q in range(Q):\n\tarr = [0] * 10\n\t(l, r) = map(int, input().strip().split())\n\tsu = ''\n\tfor i in range(l - 1, r):\n\t\tsu += s[i]\n\tsu = list(su)\n\ti = 0\n\td = 1\n\tll = 0\n\twhile i < len(su) and i >= 0:\n\t\tif su[i].isdigit():\n\t\t\tarr[int(su[i])] += 1\n\t\t\tif su[i] == '0':\n\t\t\t\tsu = su[:i] + su[i + 1:]\n\t\t\t\tif d == 1:\n\t\t\t\t\ti -= 1\n\t\t\telse:\n\t\t\t\tsu[i] = str(int(su[i]) - 1)\n\t\t\tif d == 1:\n\t\t\t\ti += 1\n\t\t\telse:\n\t\t\t\ti -= 1\n\t\t\tll = 0\n\t\telse:\n\t\t\tif su[i] == '>' or su[i] == '<':\n\t\t\t\tif d == 1 and i != 0 and (ll == 1):\n\t\t\t\t\tif su[i - 1] == '>' or su[i - 1] == '<':\n\t\t\t\t\t\tsu = su[:i - 1] + su[i:]\n\t\t\t\t\t\ti -= 1\n\t\t\t\tif d == 0 and i != n - 1 and (ll == 1):\n\t\t\t\t\tif su[i + 1] == '>' or su[i + 1] == '<' or su[i + 1] == '-1':\n\t\t\t\t\t\tsu = su[:i + 1] + su[i + 2:]\n\t\t\t\tif su[i] == '>':\n\t\t\t\t\td = 1\n\t\t\t\telse:\n\t\t\t\t\td = 0\n\t\t\tif d == 0:\n\t\t\t\ti -= 1\n\t\t\telse:\n\t\t\t\ti += 1\n\t\t\tll = 1\n\tprint(*arr)\n",
        "slowest_solution": "(n, q) = map(int, input().split())\ns = input()\nfor _ in range(q):\n\t(l, r) = map(int, input().split())\n\tt = list(s[l - 1:r])\n\t(p, d) = (0, 1)\n\tres = [0] * 10\n\twhile 0 <= p < len(t):\n\t\tif '0' <= t[p] <= '9':\n\t\t\tk = int(t[p])\n\t\t\tres[k] += 1\n\t\t\tif k > 0:\n\t\t\t\tt[p] = str(k - 1)\n\t\t\t\tp += d\n\t\t\telse:\n\t\t\t\tt.pop(p)\n\t\t\t\tif d == -1:\n\t\t\t\t\tp += d\n\t\telse:\n\t\t\td = -1 if t[p] == '<' else 1\n\t\t\tif 0 <= p + d < len(t) and (not '0' <= t[p + d] <= '9'):\n\t\t\t\tt.pop(p)\n\t\t\t\tif d == -1:\n\t\t\t\t\tp += d\n\t\t\telse:\n\t\t\t\tp += d\n\tprint(*res)\n"
    },
    {
        "task_id": 431,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.6302852630615234,
        "fastest_time": 2.574526071548462,
        "fastest_solution": "import math\nfrom collections import defaultdict\nd = defaultdict()\nf = defaultdict()\n\ndef factor(n):\n\ttry:\n\t\tif f[n] != []:\n\t\t\tA = f[n]\n\t\t\treturn A\n\texcept:\n\t\tA = []\n\t\tif n == 1:\n\t\t\treturn []\n\t\telse:\n\t\t\tfor i in range(1, int(math.ceil(pow(n, 0.5)))):\n\t\t\t\tif n % i == 0:\n\t\t\t\t\tA.append(i)\n\t\t\t\t\tA.append(n // i)\n\t\t\tif pow(n, 0.5) % 1 == 0:\n\t\t\t\tA.append(int(pow(n, 0.5)))\n\t\t\tA.remove(1)\n\t\t\tf[n] = A\n\t\t\treturn A\n(n, k) = [int(x) for x in input().split()]\na = []\nif n > 100:\n\ta = [int(x) for x in input().split()]\n\tee = defaultdict()\n\tee[a[n - 1]] = [n - 1, n - 1]\n\ti = n - 2\n\trr = 1\n\tmax1 = n\n\tmin1 = n - 1\n\twhile i >= 0:\n\t\tif a[i] > k:\n\t\t\tmax1 = i\n\t\t\tif a[i] == 1:\n\t\t\t\tg = [1]\n\t\t\telse:\n\t\t\t\tg = factor(a[i] - k)\n\t\t\t\tmin = n\n\t\t\t\tfor j in g:\n\t\t\t\t\tif a[i] % j == k:\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tif ee[j] != []:\n\t\t\t\t\t\t\t\tx = ee[j][0]\n\t\t\t\t\t\t\t\tif x < min:\n\t\t\t\t\t\t\t\t\tmin = x\n\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\tt = 0\n\t\t\t\tee[a[i]] = [i, min - 1]\n\t\telif a[i] < k:\n\t\t\tee[a[i]] = [i, n - 1]\n\t\telse:\n\t\t\tee[a[i]] = [i, max1 - 1]\n\t\tif ee[a[i]][1] > min1:\n\t\t\trr = rr + min1 - ee[a[i]][0] + 1\n\t\telse:\n\t\t\tmin1 = ee[a[i]][1]\n\t\t\trr = rr + min1 - ee[a[i]][0] + 1\n\t\ti = i - 1\nelse:\n\ta = [int(x) for x in input().split()]\n\ts = [0] * n\n\ti = n - 2\n\ts[n - 1] = n - 1\n\trr = 1\n\tmin2 = n - 1\n\twhile i >= 0:\n\t\tj = i + 1\n\t\twhile j <= min2 and a[i] % a[j] != k:\n\t\t\tj = j + 1\n\t\tj = j - 1\n\t\tif j < min2:\n\t\t\tmin2 = j\n\t\ts[i] = j\n\t\trr = rr + s[i] - i + 1\n\t\ti = i - 1\nprint(rr)\n",
        "slowest_solution": "(n, k) = list(map(int, input().split()))\narr = list(map(int, input().split()))\ns = 1\nmax_num = arr[0]\nprev = -1\nindex_map = {}\nindex_map[arr[0]] = 0\nfor i in range(1, n):\n\tif arr[i] <= k:\n\t\ts += i - prev\n\telse:\n\t\tfor j in range(max_num // arr[i] + 1):\n\t\t\tif arr[i] * j + k in index_map:\n\t\t\t\tprev = max(prev, index_map[arr[i] * j + k])\n\t\ts += i - prev\n\tindex_map[arr[i]] = i\n\tmax_num = max(max_num, arr[i])\nprint(s)\n"
    },
    {
        "task_id": 438,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.629390239715576,
        "fastest_time": 2.629390239715576,
        "fastest_solution": "import math\n\ndef ok(xa, ya):\n\t(x, y) = (xb - xa, yb - ya)\n\td = math.gcd(abs(xc), abs(yc))\n\tif xc == 0 and yc == 0:\n\t\treturn x == 0 and y == 0\n\tif xc == 0:\n\t\treturn x % yc == 0 and y % yc == 0\n\tif yc == 0:\n\t\treturn x % xc == 0 and y % xc == 0\n\tif x % d != 0 or y % d != 0:\n\t\treturn 0\n\t(a, b, c1, c2) = (xc // d, yc // d, x // d, -y // d)\n\tif a == 0 and b == 0:\n\t\treturn c1 == 0 and c2 == 0\n\tif (c1 * b + c2 * a) % (a * a + b * b) != 0:\n\t\treturn 0\n\tyy = (c1 * b + c2 * a) / (a * a + b * b)\n\tif a == 0:\n\t\treturn (c2 - a * yy) % b == 0\n\telse:\n\t\treturn (c1 - b * yy) % a == 0\n(xa, ya) = map(int, input().split())\n(xb, yb) = map(int, input().split())\n(xc, yc) = map(int, input().split())\nif ok(xa, ya) or ok(-ya, xa) or ok(-xa, -ya) or ok(ya, -xa):\n\tprint('YES')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "import math\n\ndef ok(xa, ya):\n\t(x, y) = (xb - xa, yb - ya)\n\td = math.gcd(abs(xc), abs(yc))\n\tif xc == 0 and yc == 0:\n\t\treturn x == 0 and y == 0\n\tif xc == 0:\n\t\treturn x % yc == 0 and y % yc == 0\n\tif yc == 0:\n\t\treturn x % xc == 0 and y % xc == 0\n\tif x % d != 0 or y % d != 0:\n\t\treturn 0\n\t(a, b, c1, c2) = (xc // d, yc // d, x // d, -y // d)\n\tif a == 0 and b == 0:\n\t\treturn c1 == 0 and c2 == 0\n\tif (c1 * b + c2 * a) % (a * a + b * b) != 0:\n\t\treturn 0\n\tyy = (c1 * b + c2 * a) / (a * a + b * b)\n\tif a == 0:\n\t\treturn (c2 - a * yy) % b == 0\n\telse:\n\t\treturn (c1 - b * yy) % a == 0\n(xa, ya) = map(int, input().split())\n(xb, yb) = map(int, input().split())\n(xc, yc) = map(int, input().split())\nif ok(xa, ya) or ok(-ya, xa) or ok(-xa, -ya) or ok(ya, -xa):\n\tprint('YES')\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 386,
        "slowest_solution_id": 2,
        "fastest_solution_id": 7,
        "slowest_time": 2.6797375679016113,
        "fastest_time": 2.5149316787719727,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\t(n, s) = input().split()\n\tc = [0, s == 'Dee']\n\tfor _ in range(int(n)):\n\t\tb = input()\n\t\tc[b[0] == '1'] += b.count(b[0])\n\tprint(('Dee', 'Dum')[c[0] < c[1]])\n",
        "slowest_solution": "for i in range(int(input())):\n\t(n, s) = input().split(' ')\n\tn = int(n)\n\tdee = 0\n\tdum = 0\n\tfor j in range(n):\n\t\tx = input()\n\t\txl = [i for i in x]\n\t\tif x[0] == '0':\n\t\t\tdee += xl.count('0')\n\t\telse:\n\t\t\tdum += xl.count('1')\n\tif s == 'Dee':\n\t\tif dee == dum or dee < dum:\n\t\t\tprint('Dum')\n\t\telse:\n\t\t\tprint('Dee')\n\telif dee == dum or dum < dee:\n\t\tprint('Dee')\n\telse:\n\t\tprint('Dum')\n"
    },
    {
        "task_id": 389,
        "slowest_solution_id": 3,
        "fastest_solution_id": 6,
        "slowest_time": 2.672105550765991,
        "fastest_time": 2.452350378036499,
        "fastest_solution": "import sys\nimport math\ninput = sys.stdin.readline\nmod = 998244353\n\ndef power(num, ex):\n\t(pw, res) = (num, 1)\n\twhile ex:\n\t\tif ex & 1:\n\t\t\tres = res * pw\n\t\tpw = pw * pw\n\t\tex >>= 1\n\treturn res\n\ndef power_with_modulo(num, ex):\n\t(pw, res) = (num % mod, 1)\n\twhile ex:\n\t\tif ex & 1:\n\t\t\tres = res * pw % mod\n\t\tpw = pw * pw % mod\n\t\tex >>= 1\n\treturn res\nt = int(input())\nfor _ in range(t):\n\t(n, k, x) = map(int, input().split())\n\ts = str(input())\n\tans = ''\n\ti = n - 1\n\tx -= 1\n\twhile i >= 0:\n\t\tif s[i] == 'a':\n\t\t\tans += 'a'\n\t\t\ti -= 1\n\t\telse:\n\t\t\tj = i\n\t\t\twhile j >= 0 and s[j] == '*':\n\t\t\t\tj -= 1\n\t\t\tcnt = x % ((i - j) * k + 1)\n\t\t\tx //= (i - j) * k + 1\n\t\t\tans += 'b' * cnt\n\t\t\ti = j\n\tprint(''.join(ans[::-1]))\n",
        "slowest_solution": "import sys\nfrom typing import Deque\n\ndef input():\n\treturn sys.stdin.readline().rstrip()\nDXY = [(0, -1), (1, 0), (0, 1), (-1, 0)]\nmod = 998244353\ninf = 1 << 64\n\ndef ceil(x, y):\n\treturn (x + y - 1) // y\nfrom collections import deque\n\ndef slv():\n\t(n, k, X) = map(int, input().split())\n\tS = input()\n\tcnt = 0\n\ta = deque([])\n\tfor i in range(n):\n\t\tif S[i] != '*':\n\t\t\tif cnt > 0:\n\t\t\t\ta.append(k * cnt + 1)\n\t\t\tcnt = 0\n\t\telse:\n\t\t\tcnt += 1\n\t\tif i == n - 1 and cnt > 0:\n\t\t\ta.append(k * cnt + 1)\n\ttotal = 1\n\tb = deque([])\n\twhile total <= X and a:\n\t\tv = a.pop()\n\t\tb.appendleft(v)\n\t\ttotal *= v\n\ta = deque([1] * len(a))\n\tc = deque([])\n\tfor e in b:\n\t\ttotal //= e\n\t\tord = ceil(X, total)\n\t\tc.append(ord)\n\t\tX -= (ord - 1) * total\n\twhile c:\n\t\ta.append(c.popleft())\n\tstring = []\n\t(cnt, itr) = (0, 0)\n\tfor i in range(len(S)):\n\t\tif S[i] == 'a':\n\t\t\tstring.append('a')\n\t\telif i + 1 == len(S) or S[i + 1] == 'a':\n\t\t\tstring.append('b' * (a[itr] - 1))\n\t\t\titr += 1\n\tprint(''.join(string))\n\treturn\n\ndef main():\n\tt = int(input())\n\tfor i in range(t):\n\t\tslv()\n\treturn 0\nmain()\n"
    },
    {
        "task_id": 441,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7043511867523193,
        "fastest_time": 2.7043511867523193,
        "fastest_solution": "import random\ncache = {}\n\ndef popcount(n):\n\tres = 0\n\twhile n:\n\t\tres += 1\n\t\tn &= n - 1\n\treturn res\n\ndef solve(n, k):\n\tif k == 0:\n\t\treturn 0\n\tif k == 1:\n\t\treturn popcount(n) & 1\n\tif k % 2 == 1:\n\t\tt = solve(n, k - 1)\n\t\tx = popcount(k - 1 ^ n + k - 1) & 1\n\t\treturn t + x\n\tif (n, k) in cache:\n\t\treturn cache[n, k]\n\tif n % 2 == 0:\n\t\tone_cell = 2\n\t\tzero_cell = 0\n\t\tcnt1 = solve(n // 2, k // 2)\n\t\tcnt0 = k // 2 - cnt1\n\telse:\n\t\tone_cell = 0\n\t\tzero_cell = 1\n\t\tcnt1 = solve(n // 2, k // 2) + solve(n // 2 + 1, k // 2)\n\t\tcnt0 = k - cnt1\n\tres = one_cell * cnt1 + zero_cell * cnt0\n\tcache[n, k] = res\n\treturn res\nt = int(input())\nfor _ in range(t):\n\tcache.clear()\n\t(n, k) = map(int, input().split())\n\tprint(solve(n, k))\n",
        "slowest_solution": "import random\ncache = {}\n\ndef popcount(n):\n\tres = 0\n\twhile n:\n\t\tres += 1\n\t\tn &= n - 1\n\treturn res\n\ndef solve(n, k):\n\tif k == 0:\n\t\treturn 0\n\tif k == 1:\n\t\treturn popcount(n) & 1\n\tif k % 2 == 1:\n\t\tt = solve(n, k - 1)\n\t\tx = popcount(k - 1 ^ n + k - 1) & 1\n\t\treturn t + x\n\tif (n, k) in cache:\n\t\treturn cache[n, k]\n\tif n % 2 == 0:\n\t\tone_cell = 2\n\t\tzero_cell = 0\n\t\tcnt1 = solve(n // 2, k // 2)\n\t\tcnt0 = k // 2 - cnt1\n\telse:\n\t\tone_cell = 0\n\t\tzero_cell = 1\n\t\tcnt1 = solve(n // 2, k // 2) + solve(n // 2 + 1, k // 2)\n\t\tcnt0 = k - cnt1\n\tres = one_cell * cnt1 + zero_cell * cnt0\n\tcache[n, k] = res\n\treturn res\nt = int(input())\nfor _ in range(t):\n\tcache.clear()\n\t(n, k) = map(int, input().split())\n\tprint(solve(n, k))\n"
    },
    {
        "task_id": 435,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 2.6058363914489746,
        "fastest_time": 2.6049249172210693,
        "fastest_solution": "import sys\n\ndef cross(o, a, b):\n\treturn (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\nN = int(input())\nA = [None] * N\nfor i in range(N):\n\t(x, y) = map(int, sys.stdin.readline().split())\n\tA[i] = (x, y - x * x)\nA.sort()\nupper = []\nfor p in reversed(A):\n\twhile len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n\t\tupper.pop()\n\tupper.append(p)\nwhile len(upper) >= 2 and upper[-1][0] == upper[-2][0]:\n\tupper.pop()\nprint(len(upper) - 1)\n",
        "slowest_solution": "n = int(input())\nrows = [input().split() for _ in range(n)]\nrows = [(int(x), int(y)) for (x, y) in rows]\npoints = {}\nfor (x, y) in rows:\n\tif x in points:\n\t\tpoints[x] = max(y, points[x])\n\telse:\n\t\tpoints[x] = y\npoints = sorted(points.items(), key=lambda point: point[0])\n\ndef above(p, p1, p2):\n\t(x, y) = p\n\t(x1, y1) = p1\n\t(x2, y2) = p2\n\tx_2 = x ** 2\n\tx12 = x1 ** 2\n\tx22 = x2 ** 2\n\tx2_x1 = x2 - x1\n\teq_b = y2 - y1 - x22 + x12\n\tterm_y = y * x2_x1\n\tterm_x2 = x_2 * x2_x1\n\tterm_x = x * eq_b\n\tterm_c = (y1 - x12) * x2_x1 - x1 * eq_b\n\treturn term_y >= term_x2 + term_x + term_c\nUs = []\nfor (i, p) in enumerate(points):\n\twhile len(Us) >= 2:\n\t\t(p1, p2) = Us[-2:]\n\t\tif above(p, p1, p2):\n\t\t\tUs.pop()\n\t\telse:\n\t\t\tbreak\n\tUs.append(p)\nout = len(Us) - 1\nprint(out)\n"
    },
    {
        "task_id": 397,
        "slowest_solution_id": 2,
        "fastest_solution_id": 5,
        "slowest_time": 2.6840479373931885,
        "fastest_time": 2.5017430782318115,
        "fastest_solution": "rd = lambda : map(int, input().split())\n(n, m) = rd()\nd = {}\n\ndef f(x):\n\td[x] = d.get(x, 0) + 1\nuf = [i for i in range(n)]\n\ndef find(i):\n\tp = uf[i]\n\tif i == p:\n\t\treturn p\n\telse:\n\t\tuf[i] = find(p)\n\t\treturn uf[i]\nfor _ in range(m):\n\t(u, v) = sorted(rd())\n\tu -= 1\n\tv -= 1\n\tf(u)\n\tf(v)\n\tuf[find(v)] = find(u)\nr = [1] * n\nfor i in range(n):\n\tr[find(i)] &= d.get(i, 0) == 2\nprint(sum((i == uf[i] for i in range(n))) + sum(r) - n)\n",
        "slowest_solution": "from collections import defaultdict\n(V, E) = input().split()\n(V, E) = (int(V), int(E))\nG = defaultdict(set)\nfor _ in range(E):\n\t(v1, v2) = input().split()\n\t(v1, v2) = (int(v1), int(v2))\n\tG[v1].add(v2)\n\tG[v2].add(v1)\ncycle_cnt = 0\nvisited = set()\nfor v in G:\n\tif v in visited:\n\t\tcontinue\n\tstack = [v]\n\tpath = []\n\twhile stack:\n\t\tnode = stack.pop()\n\t\tif node in visited:\n\t\t\tcontinue\n\t\tvisited.add(node)\n\t\tpath.append(node)\n\t\tstack.extend(G[node])\n\tok = True\n\tfor node in path:\n\t\tif len(G[node]) != 2:\n\t\t\tok = False\n\t\t\tbreak\n\tcycle_cnt += ok\nprint(cycle_cnt)\n"
    },
    {
        "task_id": 425,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 2.668370008468628,
        "fastest_time": 2.553255319595337,
        "fastest_solution": "from math import sqrt\n\nclass vector:\n\n\tdef __init__(self, _x=0, _y=0):\n\t\tself.x = _x\n\t\tself.y = _y\n\n\tdef len(self):\n\t\treturn sqrt(self.x ** 2 + self.y ** 2)\n\n\tdef len_sq(self):\n\t\treturn self.x ** 2 + self.y ** 2\n\n\tdef __mul__(self, other):\n\t\tif type(self) == type(other):\n\t\t\treturn self.x * other.x + self.y * other.y\n\t\treturn vector(self.x * other, self.y * other)\n\n\tdef __mod__(self, other):\n\t\treturn self.x * other.y - self.y * other.x\n\n\tdef normed(self):\n\t\tlength = self.len()\n\t\treturn vector(self.x / length, self.y / length)\n\n\tdef normate(self):\n\t\tself = self.normed()\n\n\tdef __str__(self):\n\t\treturn '(' + str(self.x) + ', ' + str(self.y) + ')'\n\n\tdef __add__(self, other):\n\t\treturn vector(self.x + other.x, self.y + other.y)\n\n\tdef __sub__(self, other):\n\t\treturn vector(self.x - other.x, self.y - other.y)\n\n\tdef __eq__(self, other):\n\t\treturn self.x == other.x and self.y == other.y\n\n\tdef rot(self):\n\t\treturn vector(self.y, -self.x)\n\nclass line:\n\n\tdef __init__(self, a=0, b=0, c=0):\n\t\tself.a = a\n\t\tself.b = b\n\t\tself.c = c\n\n\tdef intersect(self, other):\n\t\td = self.a * other.b - self.b * other.a\n\t\tdx = self.c * other.b - self.b * other.c\n\t\tdy = self.a * other.c - self.c * other.a\n\t\treturn vector(dx / d, dy / d)\n\n\tdef fake(self, other):\n\t\td = self.a * other.b - self.b * other.a\n\t\treturn d\n\n\tdef __str__(self):\n\t\treturn str(self.a) + '*x + ' + str(self.b) + '*y = ' + str(self.c)\n\ndef line_pt(A, B):\n\td = (A - B).rot()\n\treturn line(d.x, d.y, d * A)\n\nclass circle:\n\n\tdef __init__(self, O=vector(0, 0), r=0):\n\t\tself.O = O\n\t\tself.r = r\n\n\tdef intersect(self, other):\n\t\tO1 = self.O\n\t\tO2 = other.O\n\t\tr1 = self.r\n\t\tr2 = other.r\n\t\tif O1 == O2:\n\t\t\treturn []\n\t\tif (O1 - O2).len_sq() > r1 ** 2 + r2 ** 2 + 2 * r1 * r2:\n\t\t\treturn []\n\t\trad_line = line(2 * (O2.x - O1.x), 2 * (O2.y - O1.y), r1 ** 2 - O1.len_sq() - r2 ** 2 + O2.len_sq())\n\t\tcentral = line_pt(O1, O2)\n\t\tM = rad_line.intersect(central)\n\t\tif (O1 - O2).len_sq() == r1 ** 2 + r2 ** 2 + 2 * r1 * r2:\n\t\t\treturn [M]\n\t\td = (O2 - O1).normed().rot()\n\t\tif r1 ** 2 - (O1 - M).len_sq() < 0:\n\t\t\treturn []\n\t\td = d * sqrt(r1 ** 2 - (O1 - M).len_sq())\n\t\treturn [M + d, M - d]\n\n\tdef fake(self, other):\n\t\tO1 = self.O\n\t\tO2 = other.O\n\t\tr1 = self.r\n\t\tr2 = other.r\n\t\tif O1 == O2:\n\t\t\treturn 1\n\t\tif (O1 - O2).len_sq() > r1 ** 2 + r2 ** 2 + 2 * r1 * r2:\n\t\t\treturn 1\n\t\trad_line = line(2 * (O2.x - O1.x), 2 * (O2.y - O1.y), r1 ** 2 - O1.len_sq() - r2 ** 2 + O2.len_sq())\n\t\tcentral = line_pt(O1, O2)\n\t\treturn rad_line.fake(central)\nn = int(input())\narr = []\nm = 1\nfor i in range(n):\n\t(x, y, r) = map(int, input().split())\n\tarr.append(circle(vector(x, y), r))\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\tm *= arr[i].fake(arr[j])\nfor i in range(n):\n\tarr[i].O = arr[i].O * m\n\tarr[i].r = arr[i].r * m\ns = set()\nV = 0\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\ttmp = arr[i].intersect(arr[j])\n\t\tfor e in tmp:\n\t\t\ts.add((round(e.x, 6), round(e.y, 6)))\nV += len(s)\nE = 0\npar = [i for i in range(n)]\n\ndef get_par(v):\n\tif par[v] != v:\n\t\tpar[v] = get_par(par[v])\n\treturn par[v]\n\ndef unite(v, u):\n\tpar[get_par(v)] = get_par(u)\nfor i in range(n):\n\ts = set()\n\tfor j in range(n):\n\t\ttmp = arr[i].intersect(arr[j])\n\t\tif len(tmp):\n\t\t\tunite(i, j)\n\t\tfor e in tmp:\n\t\t\ts.add((round(e.x), round(e.y)))\n\tE += len(s)\nprint(E - V + 1 + len({get_par(i) for i in range(n)}))\n",
        "slowest_solution": "from decimal import *\ngetcontext().prec = 40\neps = Decimal('1e-10')\n\nclass Circle:\n\n\tdef __init__(self, x, y, r):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.r = r\n\n\tdef contains(self, c):\n\t\tdd = (self.x - c.x) ** 2 + (self.y - c.y) ** 2\n\t\treturn dd < (self.r - c.r) ** 2 and self.r > c.r\n\n\tdef in_touches(self, c):\n\t\tdd = (self.x - c.x) ** 2 + (self.y - c.y) ** 2\n\t\treturn dd == (self.r - c.r) ** 2 and self.r > c.r\n\n\tdef ex_touches(self, c):\n\t\tdd = (self.x - c.x) ** 2 + (self.y - c.y) ** 2\n\t\treturn dd == (self.r + c.r) ** 2\n\n\tdef intersects(self, c):\n\t\tdd = (self.x - c.x) ** 2 + (self.y - c.y) ** 2\n\t\treturn (self.r - c.r) ** 2 < dd < (self.r + c.r) ** 2\n\n\tdef not_intersects(self, c):\n\t\tdd = (self.x - c.x) ** 2 + (self.y - c.y) ** 2\n\t\treturn dd > (self.r + c.r) ** 2\n\n\tdef get_intersections(self, c):\n\t\t(x1, y1, r1, x2, y2, r2) = map(Decimal, [self.x, self.y, self.r, c.x, c.y, c.r])\n\t\tRR = (x1 - x2) ** 2 + (y1 - y2) ** 2\n\t\trx1 = (x1 + x2) / 2 + (r1 ** 2 - r2 ** 2) / (2 * RR) * (x2 - x1) + (2 * (r1 ** 2 + r2 ** 2) / RR - (r1 ** 2 - r2 ** 2) ** 2 / RR ** 2 - 1).sqrt() / 2 * (y2 - y1)\n\t\try1 = (y1 + y2) / 2 + (r1 ** 2 - r2 ** 2) / (2 * RR) * (y2 - y1) + (2 * (r1 ** 2 + r2 ** 2) / RR - (r1 ** 2 - r2 ** 2) ** 2 / RR ** 2 - 1).sqrt() / 2 * (x1 - x2)\n\t\trx2 = (x1 + x2) / 2 + (r1 ** 2 - r2 ** 2) / (2 * RR) * (x2 - x1) - (2 * (r1 ** 2 + r2 ** 2) / RR - (r1 ** 2 - r2 ** 2) ** 2 / RR ** 2 - 1).sqrt() / 2 * (y2 - y1)\n\t\try2 = (y1 + y2) / 2 + (r1 ** 2 - r2 ** 2) / (2 * RR) * (y2 - y1) - (2 * (r1 ** 2 + r2 ** 2) / RR - (r1 ** 2 - r2 ** 2) ** 2 / RR ** 2 - 1).sqrt() / 2 * (x1 - x2)\n\t\treturn {(rx1, ry1), (rx2, ry2)}\n\n\tdef is_on(self, p):\n\t\treturn abs((self.x - p[0]) ** 2 + (self.y - p[1]) ** 2 - self.r ** 2) < eps\n\n\tdef __repr__(self):\n\t\treturn '(%s, %s, %s)' % (self.x, self.y, self.r)\n\ndef count_regions(n, circles):\n\tif n == 1:\n\t\treturn 2\n\tif n == 2:\n\t\treturn 3 + circles[0].intersects(circles[1])\n\tif n == 3:\n\t\t(c0, c1, c2) = circles\n\t\tif c0.not_intersects(c1):\n\t\t\tif c0.intersects(c2):\n\t\t\t\treturn 5 + c1.intersects(c2)\n\t\t\telif c0.ex_touches(c2) or c2.not_intersects(c0):\n\t\t\t\treturn 4 + c1.intersects(c2)\n\t\t\telif c0.contains(c2) or c0.in_touches(c2):\n\t\t\t\treturn 4\n\t\telif c0.contains(c1):\n\t\t\tif c0.in_touches(c2) or c0.contains(c2):\n\t\t\t\treturn 4 + c1.intersects(c2)\n\t\t\telif c0.ex_touches(c2) or c0.not_intersects(c2):\n\t\t\t\treturn 4\n\t\t\telif c0.intersects(c2):\n\t\t\t\treturn 5 + c1.intersects(c2)\n\t\telif c0.in_touches(c1):\n\t\t\tif c0.in_touches(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\treturn 6\n\t\t\t\telif c1.ex_touches(c2):\n\t\t\t\t\treturn 5\n\t\t\t\telse:\n\t\t\t\t\treturn 4\n\t\t\telif c0.not_intersects(c2) or c0.ex_touches(c2):\n\t\t\t\treturn 4\n\t\t\telif c0.contains(c2):\n\t\t\t\treturn 4 + c1.intersects(c2)\n\t\t\telif c0.intersects(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\tc0_x_c2 = c0.get_intersections(c2)\n\t\t\t\t\treturn 6 + all((not c1.is_on(p) for p in c0_x_c2))\n\t\t\t\telse:\n\t\t\t\t\treturn 5 + (c1.ex_touches(c2) or c2.in_touches(c1))\n\t\telif c0.ex_touches(c1):\n\t\t\tif c0.in_touches(c2) or c0.contains(c2):\n\t\t\t\treturn 4\n\t\t\telif c0.ex_touches(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\treturn 6\n\t\t\t\telif c1.ex_touches(c2):\n\t\t\t\t\treturn 5\n\t\t\t\telse:\n\t\t\t\t\treturn 4\n\t\t\telif c0.not_intersects(c2):\n\t\t\t\treturn 4 + c1.intersects(c2)\n\t\t\telif c0.intersects(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\tc0_x_c1 = c0.get_intersections(c1)\n\t\t\t\t\treturn 7 + all((not c2.is_on(p) for p in c0_x_c1))\n\t\t\t\telif c1.ex_touches(c2):\n\t\t\t\t\treturn 6\n\t\t\t\telse:\n\t\t\t\t\treturn 5\n\t\telif c0.intersects(c1):\n\t\t\tif c0.not_intersects(c2):\n\t\t\t\treturn 5 + c1.intersects(c2)\n\t\t\telif c0.contains(c2):\n\t\t\t\treturn 5 + c1.intersects(c2)\n\t\t\telif c0.in_touches(c2) or c0.ex_touches(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\tc0_x_c2 = c0.get_intersections(c2)\n\t\t\t\t\treturn 6 + all((not c1.is_on(p) for p in c0_x_c2))\n\t\t\t\telse:\n\t\t\t\t\treturn 5 + (c1.in_touches(c2) or c1.ex_touches(c2))\n\t\t\telif c0.intersects(c2):\n\t\t\t\tc0_x_c1 = c0.get_intersections(c1)\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\tif all((not c2.is_on(p) for p in c0_x_c1)):\n\t\t\t\t\t\treturn 8\n\t\t\t\t\telif all((c2.is_on(p) for p in c0_x_c1)):\n\t\t\t\t\t\treturn 6\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn 7\n\t\t\t\telif c1.in_touches(c2) or c1.ex_touches(c2) or c2.in_touches(c1):\n\t\t\t\t\treturn 7 - any((c2.is_on(p) for p in c0_x_c1))\n\t\t\t\telse:\n\t\t\t\t\treturn 6\n\t\treturn 4\n\treturn 0\n\ndef main():\n\tn = int(input())\n\tcircles = [tuple(map(int, input().split())) for c in range(n)]\n\tcircles.sort(key=lambda c: (-c[2], c[0], c[1]))\n\tcircles = [Circle(*u) for u in circles]\n\tprint(count_regions(n, circles))\nmain()\n"
    },
    {
        "task_id": 398,
        "slowest_solution_id": 7,
        "fastest_solution_id": 3,
        "slowest_time": 2.6933979988098145,
        "fastest_time": 2.486694812774658,
        "fastest_solution": "T = int(input())\nfor _ in range(T):\n\t(n, m) = map(int, input().split())\n\tprint((n - 1) * 9 + m)\n",
        "slowest_solution": "n = int(input())\nfor i in range(0, n):\n\t(k, x) = input().split()\n\tk = int(k)\n\tx = int(x)\n\tprint(f'{x + (k - 1) * 9}')\n"
    },
    {
        "task_id": 426,
        "slowest_solution_id": 5,
        "fastest_solution_id": 1,
        "slowest_time": 2.7463266849517822,
        "fastest_time": 2.5328922271728516,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n\ndef main():\n\tN = int(input())\n\tLR = [list(map(int, input().split())) for _ in range(N)]\n\tA = [None] * (2 * N + 1)\n\tfor (i, (l, r)) in enumerate(LR):\n\t\tA[l] = i\n\t\tA[r] = i\n\tgraph = [[] for _ in range(N)]\n\tnum_of_edge = 0\n\tq = []\n\tfor n in range(1, 2 * N + 1):\n\t\tp = A[n]\n\t\tif LR[p][0] == n:\n\t\t\tq.append(p)\n\t\telse:\n\t\t\ttmp = []\n\t\t\twhile True:\n\t\t\t\tnp = q.pop()\n\t\t\t\tif np == p:\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\ttmp.append(np)\n\t\t\twhile tmp:\n\t\t\t\tnp = tmp.pop()\n\t\t\t\tq.append(np)\n\t\t\t\tnum_of_edge += 1\n\t\t\t\tgraph[np].append(p)\n\t\t\t\tgraph[p].append(np)\n\t\t\tif num_of_edge > N:\n\t\t\t\treturn False\n\tif num_of_edge != N - 1:\n\t\treturn False\n\tq = [0]\n\tchecked = [False] * N\n\tchecked[0] = True\n\twhile q:\n\t\tqq = []\n\t\tfor p in q:\n\t\t\tfor np in graph[p]:\n\t\t\t\tif not checked[np]:\n\t\t\t\t\tchecked[np] = True\n\t\t\t\t\tqq.append(np)\n\t\tq = qq\n\tfor p in range(N):\n\t\tif not checked[p]:\n\t\t\treturn False\n\treturn True\nprint('YES' if main() else 'NO')\n",
        "slowest_solution": "import sys\nfrom array import array\nfrom typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\n\nclass UnionFind(object):\n\t__slots__ = ['nodes']\n\n\tdef __init__(self, n: int):\n\t\tself.nodes = [-1] * n\n\n\tdef size(self, x: int) -> int:\n\t\treturn -self.nodes[self.find(x)]\n\n\tdef find(self, x: int) -> int:\n\t\tif self.nodes[x] < 0:\n\t\t\treturn x\n\t\telse:\n\t\t\tself.nodes[x] = self.find(self.nodes[x])\n\t\t\treturn self.nodes[x]\n\n\tdef unite(self, x: int, y: int) -> bool:\n\t\t(root_x, root_y, nodes) = (self.find(x), self.find(y), self.nodes)\n\t\tif root_x != root_y:\n\t\t\tif nodes[root_x] > nodes[root_y]:\n\t\t\t\t(root_x, root_y) = (root_y, root_x)\n\t\t\tnodes[root_x] += nodes[root_y]\n\t\t\tnodes[root_y] = root_x\n\t\treturn root_x != root_y\n\ndef main():\n\tfrom heapq import heappush, heappop\n\tn = int(input())\n\t(seg_l, seg_r) = ([0] * n, [0] * n)\n\tfor (i, (l, r)) in enumerate((map(int, input().split()) for _ in range(n))):\n\t\tseg_l[i] = l\n\t\tseg_r[i] = r\n\torder = sorted(range(n), key=lambda i: seg_l[i])\n\thq: List[Tuple[int, int]] = []\n\tedge_cnt = 0\n\tuf = UnionFind(n)\n\tfor i in order:\n\t\twhile hq and hq[0][0] < seg_l[i]:\n\t\t\theappop(hq)\n\t\ttmp = []\n\t\twhile hq and hq[0][0] < seg_r[i]:\n\t\t\tuf.unite(i, hq[0][1])\n\t\t\tedge_cnt += 1\n\t\t\ttmp.append(heappop(hq))\n\t\t\tif edge_cnt >= n:\n\t\t\t\tprint('NO')\n\t\t\t\texit()\n\t\twhile tmp:\n\t\t\theappush(hq, tmp.pop())\n\t\theappush(hq, (seg_r[i], i))\n\tif edge_cnt == n - 1 and uf.size(0) == n:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nmain()\n"
    },
    {
        "task_id": 399,
        "slowest_solution_id": 7,
        "fastest_solution_id": 8,
        "slowest_time": 2.702852249145508,
        "fastest_time": 2.4396767616271973,
        "fastest_solution": "T = int(input())\nfor q in range(T):\n\tTT = 0\n\ttt = 2\n\tn = int(input())\n\tarr = input().split()\n\tarr = list(map(int, arr))\n\tfin = 0\n\tarr.sort()\n\tfor i in range(tt, n):\n\t\tfin = -((i - 1) * arr[i]) + fin\n\t\tTT = arr[i - 2] + TT\n\t\tfin = TT + fin\n\tprint(fin)\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\td = list(map(int, input().split()))\n\td.sort()\n\tans = d[-1] - d[0]\n\tfor i in range(n):\n\t\tans += (n - i - i - 1) * d[i]\n\tprint(ans)\n"
    },
    {
        "task_id": 400,
        "slowest_solution_id": 7,
        "fastest_solution_id": 5,
        "slowest_time": 2.754164457321167,
        "fastest_time": 2.4925265312194824,
        "fastest_solution": "def R(i, j):\n\tif i < n:\n\t\tsmas[j][i] = 1\n\t\tp = False\n\t\tif mas[j][i + 1] == '.':\n\t\t\tif mas[j][i + 3] == '.' and smas[j][i + 3] == 0:\n\t\t\t\tp = p or R(i + 3, j)\n\t\t\tif j > 0 and mas[j - 1][i + 1] == '.' and (mas[j - 1][i + 3] == '.') and (smas[j - 1][i + 3] == 0):\n\t\t\t\tp = p or R(i + 3, j - 1)\n\t\t\tif j < 2 and mas[j + 1][i + 1] == '.' and (mas[j + 1][i + 3] == '.') and (smas[j + 1][i + 3] == 0):\n\t\t\t\tp = p or R(i + 3, j + 1)\n\t\treturn p\n\telse:\n\t\treturn True\nt = int(input())\nfor l in range(t):\n\t(n, k) = map(int, input().split(' '))\n\ts = 0\n\ts1 = input() + '.....'\n\tif s1[0] == 's':\n\t\ts = 0\n\ts2 = input() + '.....'\n\tif s2[0] == 's':\n\t\ts = 1\n\ts3 = input() + '.....'\n\tif s3[0] == 's':\n\t\ts = 2\n\tmas = []\n\tmas.append(list(s1))\n\tmas.append(list(s2))\n\tmas.append(list(s3))\n\tsmas = []\n\tsmas.append([0] * (n + 5))\n\tsmas.append([0] * (n + 5))\n\tsmas.append([0] * (n + 5))\n\tprint('YES') if R(0, s) else print('NO')\n",
        "slowest_solution": "import sys\nfrom collections import deque\nread = lambda : list(map(int, sys.stdin.readline().split()))\n(t,) = read()\nfor _ in range(t):\n\t(n, k) = read()\n\tr = [list(sys.stdin.readline().strip() + '...') for _ in range(3)]\n\tfor x in range(n):\n\t\tfor y in range(3):\n\t\t\tif r[y][x] == 's' and r[y][x + 1] in '.s':\n\t\t\t\tfor y2 in range(3):\n\t\t\t\t\tif abs(y - y2) <= 1 and r[y2][x + 1] in '.s':\n\t\t\t\t\t\tif r[y2][x + 2] in '.s' and r[y2][x + 3] in '.s':\n\t\t\t\t\t\t\tr[y2][x + 3] = 's'\n\tif any((r[y][x] == 's' for y in range(3) for x in range(n - 1, n + 3))):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 402,
        "slowest_solution_id": 7,
        "fastest_solution_id": 8,
        "slowest_time": 2.7249107360839844,
        "fastest_time": 2.5213170051574707,
        "fastest_solution": "for i in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tchildren = 0\n\tanswer = 0\n\ta.sort()\n\tfor i in a:\n\t\tchildren = i + children\n\t\tif children > n - 1:\n\t\t\tbreak\n\t\tanswer = answer + 1\n\tprint(answer)\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\tn = list(map(int, input().split()))\n\tp = [int(ele) for ele in input().strip().split()]\n\tp.sort()\n\ts = 0\n\tc = 0\n\tfor i in range(n[0]):\n\t\ts += p[i]\n\t\tif s < n[0]:\n\t\t\tc += 1\n\t\telse:\n\t\t\tbreak\n\tprint(c)\n"
    },
    {
        "task_id": 403,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 2.7684128284454346,
        "fastest_time": 2.5114636421203613,
        "fastest_solution": "__author__ = 'User'\n(n, m) = list(map(int, input().split()))\ncat = [0] + list(map(int, input().split()))\narr = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n\t(a, b) = list(map(int, input().split()))\n\tarr[a].append(b)\n\tarr[b].append(a)\ncounter = [0] * n\nc = 0\ni = 0\nqueue = [(1, 0)]\nwhile i < len(queue):\n\tj = 0\n\tif len(arr[queue[i][0]]) == 1 and queue[i][1] == arr[queue[i][0]][0]:\n\t\tc += 1\n\telse:\n\t\tfor j in arr[queue[i][0]]:\n\t\t\tif j != queue[i][1]:\n\t\t\t\tif cat[j] != 0:\n\t\t\t\t\tcat[j] += cat[queue[i][0]]\n\t\t\t\tif cat[j] <= m:\n\t\t\t\t\tqueue.append((j, queue[i][0]))\n\ti += 1\nprint(c)\n",
        "slowest_solution": "import itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\ndef solve(cats, edges, n, m):\n\tconnected = collections.defaultdict(set)\n\tfor (a, b) in edges:\n\t\tconnected[a].add(b)\n\t\tconnected[b].add(a)\n\n\tdef connected_to(v, visited):\n\t\treturn connected[v] - visited\n\tcats = {i: cat for (i, cat) in enumerate(cats, 1)}\n\tstates = {(1, cats[1])}\n\tvisited = {1}\n\tcount = 0\n\twhile states:\n\t\tnext_states = set()\n\t\tfor (s, cat_count) in states:\n\t\t\tchildren = connected_to(s, visited)\n\t\t\tvisited |= children\n\t\t\tif not children:\n\t\t\t\tcount += 1\n\t\t\tfor x in children:\n\t\t\t\tif cats[x]:\n\t\t\t\t\tnext_cat_count = cat_count + cats[x]\n\t\t\t\telse:\n\t\t\t\t\tnext_cat_count = 0\n\t\t\t\tif next_cat_count <= m:\n\t\t\t\t\tnewstate = (x, next_cat_count)\n\t\t\t\t\tnext_states.add(newstate)\n\t\tstates = next_states\n\treturn count\n\ndef print_stderr(*args, **kwargs):\n\tprint(*args, file=sys.stderr, **kwargs)\n\ndef main():\n\t[n, m] = [int(i) for i in input().strip().split()]\n\tcats = [int(i) for i in input().strip().split()]\n\tassert len(cats) == n\n\tedges = [tuple((int(i) for i in input().strip().split())) for _ in range(n - 1)]\n\tresult = solve(cats, edges, n, m)\n\tprint(result)\nmain()\n"
    },
    {
        "task_id": 405,
        "slowest_solution_id": 6,
        "fastest_solution_id": 3,
        "slowest_time": 2.7264184951782227,
        "fastest_time": 2.514960765838623,
        "fastest_solution": "from sys import stdin, stdout\n(input, print) = (stdin.readline, stdout.write)\n\ndef main(input=input, print=print, map=map, int=int, float=float, range=range, sum=sum, str=str, list=list):\n\t(n, m, k) = map(int, input().split())\n\ta = [-float('inf')] + list(map(int, input().split())) + [-float('inf')]\n\tans = sum((a[q] <= k < a[q + 1] for q in range(n + 1)))\n\tanswer = []\n\tfor _ in range(m):\n\t\td = list(map(int, input().split()))\n\t\tif d[0] == 0:\n\t\t\tanswer.append(str(ans))\n\t\telse:\n\t\t\t(q, x) = (d[1], d[2])\n\t\t\tif a[q - 1] > k and a[q + 1] > k and (a[q] + x > k >= a[q]):\n\t\t\t\tans -= 1\n\t\t\telif a[q - 1] <= k and a[q + 1] <= k and (a[q] + x > k >= a[q]):\n\t\t\t\tans += 1\n\t\t\ta[q] += x\n\tprint('\\n'.join(answer))\nmain()\n",
        "slowest_solution": "class Alice:\n\n\tdef __init__(self, hair, l):\n\t\tself.head = []\n\t\tself.long_hairs = set()\n\t\tself.l = l\n\t\tself.roots = 0\n\t\tfor (p, d) in enumerate(hair):\n\t\t\tself.grow_initial_hair(p, d)\n\n\tdef grow_initial_hair(self, p, d):\n\t\tself.head.append(d)\n\t\tif self.l < d:\n\t\t\tif p - 1 not in self.long_hairs:\n\t\t\t\tself.roots += 1\n\t\t\tself.long_hairs.add(p)\n\n\tdef grow_hair(self, p, d):\n\t\thair_before = self.head[p]\n\t\tself.head[p] += d\n\t\tif hair_before <= self.l < self.head[p]:\n\t\t\tself.long_hairs.add(p)\n\t\t\tis_right_long = p + 1 in self.long_hairs\n\t\t\tis_left_long = p - 1 in self.long_hairs\n\t\t\tif not is_left_long and (not is_right_long):\n\t\t\t\tself.roots += 1\n\t\t\telif is_left_long and is_right_long:\n\t\t\t\tself.roots -= 1\n\n\tdef cut(self):\n\t\treturn self.roots\n\ndef main():\n\t(n, m, l) = map(int, input().split())\n\tinitial_hair = map(int, input().split())\n\talice = Alice(initial_hair, l)\n\tfor _ in range(m):\n\t\trequest = input()\n\t\tif request == '0':\n\t\t\tprint(alice.cut())\n\t\telse:\n\t\t\t(t, p, d) = map(int, request.split())\n\t\t\talice.grow_hair(p - 1, d)\nmain()\n"
    },
    {
        "task_id": 418,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 2.7234585285186768,
        "fastest_time": 2.4991445541381836,
        "fastest_solution": "import sys\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\nn = int(input())\ncs = [0] * (n + 1)\nps = [0] * (n + 1)\nchildren = [[] for _ in range(n + 1)]\nfor i in range(1, n + 1):\n\t(p, c) = map(int, input().split())\n\tps[i] = p\n\tchildren[p].append(i)\n\tcs[i] = c\n\ndef sortDescendants(v):\n\tresult = []\n\tpos = cs[v]\n\tfor child in children[v]:\n\t\tresult += sortDescendants(child)\n\tif len(result) < pos:\n\t\tprint('NO')\n\t\tsys.exit()\n\tresult.insert(pos, v)\n\treturn result\nroot = children[0][0]\norder = sortDescendants(root)\na = [0] * n\nfor (i, v) in enumerate(order):\n\ta[v - 1] = i + 1\nprint('YES')\nprint(*a)\n",
        "slowest_solution": "n = int(input())\nadj_list = [[] for i in range(n + 1)]\nc = [None]\nfor i in range(1, n + 1):\n\t(p_i, c_i) = map(int, input().split())\n\tc.append(c_i)\n\tadj_list[p_i].append(i)\nsizes = [None for i in range(n + 1)]\nvalues = [None for i in range(n + 1)]\n\ndef size(v):\n\tsizes[v] = 1\n\tfor i in adj_list[v]:\n\t\tsize(i)\n\t\tsizes[v] += sizes[i]\nsize(adj_list[0][0])\n\ndef get_ans(v):\n\tif len(adj_list[v]) == 0:\n\t\tif c[v] != 0:\n\t\t\treturn None\n\t\treturn [[1, v]]\n\tinsert_at = c[v]\n\tmerged_list = []\n\tcurrent_size = 0\n\tfor child in adj_list[v]:\n\t\tans = get_ans(child)\n\t\tif ans == None:\n\t\t\treturn None\n\t\tmerged_list += [[x[0] + current_size, x[1]] for x in ans]\n\t\tcurrent_size += sizes[child]\n\tif insert_at > len(merged_list) or insert_at < 0:\n\t\treturn None\n\tnew_list = merged_list[:insert_at]\n\tnew_list.append([insert_at + 1, v])\n\tnew_list += [[x[0] + 1, x[1]] for x in merged_list[insert_at:]]\n\treturn new_list\nx = get_ans(adj_list[0][0])\nif x == None:\n\tprint('NO')\nelse:\n\tprint('YES')\n\tx.sort(key=lambda i: i[1])\n\tx = [str(a[0]) for a in x]\n\tprint(' '.join(x))\n"
    },
    {
        "task_id": 449,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.580892324447632,
        "fastest_time": 2.580892324447632,
        "fastest_solution": "import math\nfrom collections import Counter\nn = int(input())\ng = [0 for i in range(n + 1)]\nprefix_xor = g.copy()\n\ndef in_range(d, k):\n\tif (2 * k - d * d + d) % (2 * d) != 0:\n\t\treturn -1\n\tx = (2 * k - d * d + d) / (2 * d)\n\treturn int(x) if x > 0 else -1\n\ndef mex(arr):\n\tcounter = Counter()\n\tfor i in arr:\n\t\tcounter[i] += 1\n\tfor i in range(0, len(arr) + 1):\n\t\tif counter[i] == 0:\n\t\t\treturn i\n\ndef find_move(arr):\n\tfor i in range(0, len(arr)):\n\t\tif arr[i] == 0:\n\t\t\treturn i\n\treturn -1\nif n < 3:\n\tprint(-1)\n\texit(0)\nfor i in range(3, n + 1):\n\tfor_range = range(2, int(math.sqrt(2 * i)) + 1)\n\tfilter_range = [l for l in for_range if in_range(l, i) > 0]\n\tbranches = [prefix_xor[in_range(d, i) + d - 1] ^ prefix_xor[in_range(d, i) - 1] for d in filter_range]\n\tg[i] = mex(branches)\n\tprefix_xor[i] = prefix_xor[i - 1] ^ g[i]\n\tif i == n:\n\t\tprint(-1 if g[i] == 0 else filter_range[find_move(branches)])\n",
        "slowest_solution": "import math\nfrom collections import Counter\nn = int(input())\ng = [0 for i in range(n + 1)]\nprefix_xor = g.copy()\n\ndef in_range(d, k):\n\tif (2 * k - d * d + d) % (2 * d) != 0:\n\t\treturn -1\n\tx = (2 * k - d * d + d) / (2 * d)\n\treturn int(x) if x > 0 else -1\n\ndef mex(arr):\n\tcounter = Counter()\n\tfor i in arr:\n\t\tcounter[i] += 1\n\tfor i in range(0, len(arr) + 1):\n\t\tif counter[i] == 0:\n\t\t\treturn i\n\ndef find_move(arr):\n\tfor i in range(0, len(arr)):\n\t\tif arr[i] == 0:\n\t\t\treturn i\n\treturn -1\nif n < 3:\n\tprint(-1)\n\texit(0)\nfor i in range(3, n + 1):\n\tfor_range = range(2, int(math.sqrt(2 * i)) + 1)\n\tfilter_range = [l for l in for_range if in_range(l, i) > 0]\n\tbranches = [prefix_xor[in_range(d, i) + d - 1] ^ prefix_xor[in_range(d, i) - 1] for d in filter_range]\n\tg[i] = mex(branches)\n\tprefix_xor[i] = prefix_xor[i - 1] ^ g[i]\n\tif i == n:\n\t\tprint(-1 if g[i] == 0 else filter_range[find_move(branches)])\n"
    },
    {
        "task_id": 411,
        "slowest_solution_id": 5,
        "fastest_solution_id": 6,
        "slowest_time": 2.8287153244018555,
        "fastest_time": 2.506993055343628,
        "fastest_solution": "from decimal import *\n(x, y, z) = input().split()\nx = Decimal(x)\ny = Decimal(y)\nz = Decimal(z)\ncal1 = lambda x, y, z: y ** z * Decimal.log10(x)\ncal2 = lambda x, y, z: y * z * Decimal.log10(x)\n(ans, v) = ('x^y^z', cal1(x, y, z))\nif cal1(x, z, y) > v:\n\t(ans, v) = ('x^z^y', cal1(x, z, y))\nif cal2(x, y, z) > v:\n\t(ans, v) = ('(x^y)^z', cal2(x, y, z))\nif cal2(x, z, y) > v:\n\t(ans, v) = ('(x^z)^y', cal2(x, z, y))\nif cal1(y, x, z) > v:\n\t(ans, v) = ('y^x^z', cal1(y, x, z))\nif cal1(y, z, x) > v:\n\t(ans, v) = ('y^z^x', cal1(y, z, x))\nif cal2(y, x, z) > v:\n\t(ans, v) = ('(y^x)^z', cal2(y, x, z))\nif cal2(y, z, x) > v:\n\t(ans, v) = ('(y^z)^x', cal2(y, z, x))\nif cal1(z, x, y) > v:\n\t(ans, v) = ('z^x^y', cal1(z, x, y))\nif cal1(z, y, x) > v:\n\t(ans, v) = ('z^y^x', cal1(z, y, x))\nif cal2(z, x, y) > v:\n\t(ans, v) = ('(z^x)^y', cal2(z, x, y))\nif cal2(z, y, x) > v:\n\t(ans, v) = ('(z^y)^x', cal2(z, y, x))\nprint(ans)\n",
        "slowest_solution": "from decimal import *\nfrom math import log\ngetcontext().prec = 500\n(x, y, z) = map(Decimal, input().split())\n(a, l) = ([], [])\nl.append('')\nl.append('x^y^z')\nl.append('x^z^y')\nl.append('(x^y)^z')\nl.append('(x^z)^y')\nl.append('y^x^z')\nl.append('y^z^x')\nl.append('(y^x)^z')\nl.append('(y^z)^x')\nl.append('z^x^y')\nl.append('z^y^x')\nl.append('(z^x)^y')\nl.append('(z^y)^x')\na = [Decimal(0) for i in range(13)]\na[1] = Decimal(log(x)) * y ** z\na[2] = Decimal(log(x)) * z ** y\na[3] = Decimal(log(x)) * (z * y)\na[4] = a[3]\na[5] = Decimal(log(y)) * x ** z\na[6] = Decimal(log(y)) * z ** x\na[7] = Decimal(log(y)) * (x * z)\na[8] = a[7]\na[9] = Decimal(log(z)) * x ** y\na[10] = Decimal(log(z)) * y ** x\na[11] = Decimal(log(z)) * (x * y)\na[12] = a[11]\nmx = Decimal(-10 ** 999)\npos = 0\nfor i in range(1, 13):\n\tif a[i] > mx:\n\t\tpos = i\n\t\tmx = a[i]\nprint(l[pos])\n"
    },
    {
        "task_id": 412,
        "slowest_solution_id": 5,
        "fastest_solution_id": 1,
        "slowest_time": 2.7751989364624023,
        "fastest_time": 2.528137683868408,
        "fastest_solution": "def main():\n\tcases = int(input())\n\tfor i in range(cases):\n\t\t(left, right) = list(map(int, str(input()).split(' ')))\n\t\tres = left\n\t\tfor j in range(65):\n\t\t\tif 1 << j & left == 0:\n\t\t\t\tif res | 1 << j > right:\n\t\t\t\t\tbreak\n\t\t\t\tres |= 1 << j\n\t\tprint(res)\nmain()\n",
        "slowest_solution": "for i in range(int(input())):\n\t(m, n) = map(int, input().split())\n\twhile m | m + 1 <= n:\n\t\tm |= m + 1\n\tprint(m)\n"
    },
    {
        "task_id": 444,
        "slowest_solution_id": 2,
        "fastest_solution_id": 4,
        "slowest_time": 2.682659149169922,
        "fastest_time": 2.564807891845703,
        "fastest_solution": "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n\ndef add(a, b):\n\treturn (a % mod + b % mod) % mod\n\ndef mul(a, b):\n\treturn a % mod * (b % mod) % mod\n\ndef solve(i):\n\tif i == n:\n\t\treturn 0\n\tif dp[i] != -1:\n\t\treturn dp[i]\n\tm = nind[i] - i\n\tx = mul(mul(m, m + 1), 500000004)\n\tx = mul(x, a[i])\n\tv = mul(mul(m, a[i]), n - nind[i])\n\tval = add(add(x, v), solve(nind[i]))\n\tdp[i] = val\n\treturn val\n\ndef answer():\n\ts = []\n\tfor i in range(n):\n\t\twhile len(s) and a[s[-1]] < a[i]:\n\t\t\tnind[s[-1]] = i\n\t\t\ts.pop()\n\t\ts.append(i)\n\tans = 0\n\tfor i in range(n):\n\t\tans = add(ans, solve(i))\n\treturn ans\nfor T in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tnind = [n] * n\n\tdp = [-1] * n\n\tprint(answer())\n",
        "slowest_solution": "import sys\nimport bisect\ninput = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nsys.setrecursionlimit(10 ** 6)\nflsh = lambda : sys.stdout.flush()\nsa = lambda : input()\nsb = lambda : int(input())\nsc = lambda : input().split()\nsd = lambda : list(map(int, input().split()))\nse = lambda : float(input())\nsf = lambda : list(input())\nmod = 10 ** 9 + 7\n\ndef hnbhai():\n\tn = sb()\n\ta = sd()\n\tright = []\n\ts = []\n\tpre = [0] * (n + 1)\n\tfor i in range(1, n + 1):\n\t\tpre[i] = n - i + 1\n\t\tpre[i] += pre[i - 1]\n\t\tpre[i] %= mod\n\tfor i in range(n - 1, -1, -1):\n\t\twhile len(s) > 0 and a[s[-1]] < a[i]:\n\t\t\ts.pop()\n\t\tif len(s) == 0:\n\t\t\tright.append(n)\n\t\telse:\n\t\t\tright.append(s[-1])\n\t\ts.append(i)\n\tright.reverse()\n\tans = [0] * (n + 1)\n\tfor i in range(n - 1, -1, -1):\n\t\tans[i] = a[i] * (pre[right[i]] - pre[i])\n\t\tans[i] += ans[right[i]]\n\t\tans[i] %= mod\n\tprint(sum(ans) % mod)\nfor _ in range(sb()):\n\thnbhai()\n"
    },
    {
        "task_id": 434,
        "slowest_solution_id": 5,
        "fastest_solution_id": 1,
        "slowest_time": 2.733476161956787,
        "fastest_time": 2.573472023010254,
        "fastest_solution": "import random, math, sys\nfrom copy import deepcopy as dc\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter\ninput = sys.stdin.readline\n\ndef solution(li):\n\tn = len(li)\n\tco = n * (n - 1) * (n - 2) / 6\n\tfor i in range(len(li)):\n\t\t(x, y) = li[i]\n\t\tma = {}\n\t\tfor j in range(i + 1, n):\n\t\t\t(x1, y1) = li[j]\n\t\t\tif x1 - x == 0:\n\t\t\t\tslope = 1e309\n\t\t\telse:\n\t\t\t\tslope = (y1 - y) / (x1 - x)\n\t\t\tif slope not in ma:\n\t\t\t\tma[slope] = 0\n\t\t\tco -= ma[slope]\n\t\t\tma[slope] += 1\n\treturn int(co)\n\ndef input_test():\n\tli1 = []\n\tfor _ in range(int(input())):\n\t\tli = list(map(int, input().strip().split(' ')))\n\t\tli1.append(li)\n\tout = solution(li1)\n\tprint(out)\n\ndef test():\n\tpass\ninput_test()\n",
        "slowest_solution": "import math\nn = int(input())\n\ndef nc2(n):\n\treturn n * (n - 1) // 2\npoints = []\nans = 0\nfor i in range(n):\n\tpoints.append(list(map(int, input().split())))\nfor i in range(n):\n\tdct = {}\n\tfor j in range(i + 1, n):\n\t\tif i == j:\n\t\t\tcontinue\n\t\ta = points[i][1] - points[j][1]\n\t\tb = points[i][0] - points[j][0]\n\t\tx = math.gcd(a, b)\n\t\ta //= x\n\t\tb //= x\n\t\tif b < 0 or (b == 0 and a < 0):\n\t\t\ta *= -1\n\t\t\tb *= -1\n\t\ts = str(a) + '/' + str(b)\n\t\tif s in dct:\n\t\t\tdct[s] += 1\n\t\telse:\n\t\t\tdct[s] = 1\n\tans += nc2(n - i - 1)\n\tfor k in dct:\n\t\tans -= nc2(dct[k])\nprint(ans)\n"
    },
    {
        "task_id": 458,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.7093045711517334,
        "fastest_time": 2.5144588947296143,
        "fastest_solution": "size = 1001\nlose = [(0, 0)] * (size + 1)\nnumbers = list(range(1, size + 1))\nidx = 1\nfor idx in range(1, size + 1):\n\tif len(numbers) == 0:\n\t\tbreak\n\tx = numbers.pop(0)\n\ty = x + idx\n\tif y <= size:\n\t\tnumbers.remove(y)\n\tlose[idx] = (x, y)\n\ndef winner(x, y):\n\tmx = min(x, y)\n\tmy = max(x, y)\n\tdelta = my - mx\n\tif mx == lose[delta][0] and my == lose[delta][1]:\n\t\treturn 'Bob'\n\telse:\n\t\treturn 'Alice'\ntc = int(input())\nfor t in range(tc):\n\t(m, n, p, q) = list(map(int, input().split(' ')))\n\tx = m - p\n\ty = n - q\n\tprint(winner(x, y))\n",
        "slowest_solution": "import sys\n\ndef solve(m, n):\n\tmapXY = [[-1 for j in range(n + 1)] for i in range(m + 1)]\n\tfails = [(1, 2), (3, 5), (4, 7), (6, 10), (8, 13), (9, 15), (11, 18), (12, 20), (14, 23), (16, 26), (17, 28), (19, 31), (21, 34), (22, 36), (24, 39), (25, 41), (27, 44), (29, 47), (30, 49), (32, 52), (33, 54), (35, 57), (37, 60), (38, 62), (40, 65), (42, 68), (43, 70), (45, 73), (46, 75), (48, 78), (50, 81), (51, 83), (53, 86), (55, 89), (56, 91), (58, 94), (59, 96), (61, 99), (63, 102), (64, 104), (66, 107), (67, 109), (69, 112), (71, 115), (72, 117), (74, 120), (76, 123), (77, 125), (79, 128), (80, 130), (82, 133), (84, 136), (85, 138), (87, 141), (88, 143), (90, 146), (92, 149), (93, 151), (95, 154), (97, 157), (98, 159), (100, 162), (101, 164), (103, 167), (105, 170), (106, 172), (108, 175), (110, 178), (111, 180), (113, 183), (114, 185), (116, 188), (118, 191), (119, 193), (121, 196), (122, 198), (124, 201), (126, 204), (127, 206), (129, 209), (131, 212), (132, 214), (134, 217), (135, 219), (137, 222), (139, 225), (140, 227), (142, 230), (144, 233), (145, 235), (147, 238), (148, 240), (150, 243), (152, 246), (153, 248), (155, 251), (156, 253), (158, 256), (160, 259), (161, 261), (163, 264), (165, 267), (166, 269), (168, 272), (169, 274), (171, 277), (173, 280), (174, 282), (176, 285), (177, 287), (179, 290), (181, 293), (182, 295), (184, 298), (186, 301), (187, 303), (189, 306), (190, 308), (192, 311), (194, 314), (195, 316), (197, 319), (199, 322), (200, 324), (202, 327), (203, 329), (205, 332), (207, 335), (208, 337), (210, 340), (211, 342), (213, 345), (215, 348), (216, 350), (218, 353), (220, 356), (221, 358), (223, 361), (224, 363), (226, 366), (228, 369), (229, 371), (231, 374), (232, 376), (234, 379), (236, 382), (237, 384), (239, 387), (241, 390), (242, 392), (244, 395), (245, 397), (247, 400), (249, 403), (250, 405), (252, 408), (254, 411), (255, 413), (257, 416), (258, 418), (260, 421), (262, 424), (263, 426), (265, 429), (266, 431), (268, 434), (270, 437), (271, 439), (273, 442), (275, 445), (276, 447), (278, 450), (279, 452), (281, 455), (283, 458), (284, 460), (286, 463), (288, 466), (289, 468), (291, 471), (292, 473), (294, 476), (296, 479), (297, 481), (299, 484), (300, 486), (302, 489), (304, 492), (305, 494), (307, 497), (309, 500), (310, 502), (312, 505), (313, 507), (315, 510), (317, 513), (318, 515), (320, 518), (321, 520), (323, 523), (325, 526), (326, 528), (328, 531), (330, 534), (331, 536), (333, 539), (334, 541), (336, 544), (338, 547), (339, 549), (341, 552), (343, 555), (344, 557), (346, 560), (347, 562), (349, 565), (351, 568), (352, 570), (354, 573), (355, 575), (357, 578), (359, 581), (360, 583), (362, 586), (364, 589), (365, 591), (367, 594), (368, 596), (370, 599), (372, 602), (373, 604), (375, 607), (377, 610), (378, 612), (380, 615), (381, 617), (383, 620), (385, 623), (386, 625), (388, 628), (389, 630), (391, 633), (393, 636), (394, 638), (396, 641), (398, 644), (399, 646), (401, 649), (402, 651), (404, 654), (406, 657), (407, 659), (409, 662), (410, 664), (412, 667), (414, 670), (415, 672), (417, 675), (419, 678), (420, 680), (422, 683), (423, 685), (425, 688), (427, 691), (428, 693), (430, 696), (432, 699), (433, 701), (435, 704), (436, 706), (438, 709), (440, 712), (441, 714), (443, 717), (444, 719), (446, 722), (448, 725), (449, 727), (451, 730), (453, 733), (454, 735), (456, 738), (457, 740), (459, 743), (461, 746), (462, 748), (464, 751), (465, 753), (467, 756), (469, 759), (470, 761), (472, 764), (474, 767), (475, 769), (477, 772), (478, 774), (480, 777), (482, 780), (483, 782), (485, 785), (487, 788), (488, 790), (490, 793), (491, 795), (493, 798), (495, 801), (496, 803), (498, 806), (499, 808), (501, 811), (503, 814), (504, 816), (506, 819), (508, 822), (509, 824), (511, 827), (512, 829), (514, 832), (516, 835), (517, 837), (519, 840), (521, 843), (522, 845), (524, 848), (525, 850), (527, 853), (529, 856), (530, 858), (532, 861), (533, 863), (535, 866), (537, 869), (538, 871), (540, 874), (542, 877), (543, 879), (545, 882), (546, 884), (548, 887), (550, 890), (551, 892), (553, 895), (554, 897), (556, 900), (558, 903), (559, 905), (561, 908), (563, 911), (564, 913), (566, 916), (567, 918), (569, 921), (571, 924), (572, 926), (574, 929), (576, 932), (577, 934), (579, 937), (580, 939), (582, 942), (584, 945), (585, 947), (587, 950), (588, 952), (590, 955), (592, 958), (593, 960), (595, 963), (597, 966), (598, 968), (600, 971), (601, 973), (603, 976), (605, 979), (606, 981), (608, 984), (609, 986), (611, 989), (613, 992), (614, 994), (616, 997), (618, 1000)]\n\tfor (x, y) in fails:\n\t\tmapXY[x][y] = mapXY[y][x] = 0\n\treturn mapXY\n\ndef workOn(count):\n\tmatrix = solve(1000, 1000)\n\tfor i in range(int(count)):\n\t\tval = sys.stdin.readline().strip().split(' ')\n\t\tm = int(val[0])\n\t\tn = int(val[1])\n\t\tp = int(val[2])\n\t\tq = int(val[3])\n\t\tm -= p\n\t\tn -= q\n\t\tif matrix[m][n] == 0:\n\t\t\tprint('Bob')\n\t\telse:\n\t\t\tprint('Alice')\nworkOn(int(sys.stdin.readline()))\n"
    },
    {
        "task_id": 414,
        "slowest_solution_id": 4,
        "fastest_solution_id": 1,
        "slowest_time": 2.706251859664917,
        "fastest_time": 2.4937024116516113,
        "fastest_solution": "def isPalin(s):\n\treturn s == s[::-1]\nfor _ in range(int(input())):\n\ts = input()\n\t(i, j) = (0, len(s) - 1)\n\tans = 'NO'\n\twhile i < j:\n\t\tif s[i] == s[j]:\n\t\t\ti += 1\n\t\t\tj -= 1\n\t\telse:\n\t\t\tif isPalin(s[i + 1:j + 1]):\n\t\t\t\tans = 'YES'\n\t\t\telif isPalin(s[i:j]):\n\t\t\t\tans = 'YES'\n\t\t\tbreak\n\tif i >= j:\n\t\tans = 'YES'\n\tprint(ans)\n",
        "slowest_solution": "def palindrome(ch):\n\tt = False\n\tif ch == ch[::-1]:\n\t\tt = True\n\treturn t\n\ndef deel(ch, i):\n\tgh = ch[:i] + ch[i + 1:]\n\treturn gh\nfor i in range(int(input())):\n\tch = input()\n\tf = 0\n\tfor j in range(len(ch)):\n\t\tgh = deel(ch, j)\n\t\tif palindrome(gh):\n\t\t\tf = 1\n\t\t\tprint('YES')\n\t\t\tbreak\n\tif f == 0:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 462,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6771650314331055,
        "fastest_time": 2.6771650314331055,
        "fastest_solution": "import sys\n\ndef update(bit, idx, val):\n\twhile idx < len(bit):\n\t\tbit[idx] += val\n\t\tidx += idx & -idx\n\ndef sumb(bit, idx):\n\tans = 0\n\twhile idx > 0:\n\t\tans += bit[idx]\n\t\tidx -= idx & -idx\n\treturn ans\n\ndef input():\n\treturn sys.stdin.readline().strip()\n\ndef mi():\n\treturn int(input())\n\ndef MI():\n\treturn map(int, input().split())\n\ndef LMI():\n\treturn list(MI())\n(n, m) = MI()\ns = []\nprot = []\nprot1 = []\nquery = []\nfor _ in range(m):\n\ta = input().split()\n\tif a[0] == 'P':\n\t\t(b, c) = (int(a[1]), int(a[2]))\n\t\ts += [b, c]\n\t\tprot.append([b, c])\n\t\tprot1.append([b, c])\n\t\tquery.append([a[0], b, c])\n\telif a[0] == 'M':\n\t\t(b, c) = (int(a[1]), int(a[2]))\n\t\t[d, e] = prot1[b - 1]\n\t\ts += [d + c, e + c]\n\t\tprot1[b - 1] = [d + c, e + c]\n\t\tquery.append([a[0], b - 1, c])\n\telse:\n\t\tb = int(a[1])\n\t\ts += [b]\n\t\tquery.append([a[0], b, 0])\ns.sort()\nd = {}\ncur = 1\nfor i in s:\n\tif i not in d:\n\t\td[i] = cur\n\t\tcur += 1\nbit = [0] * (cur + 10)\nfor (i, j, k) in query:\n\tif i == 'P':\n\t\tupdate(bit, d[j], 1)\n\t\tupdate(bit, d[k] + 1, -1)\n\telif i == 'M':\n\t\t[b, c] = prot[j]\n\t\tupdate(bit, d[b], -1)\n\t\tupdate(bit, d[c] + 1, 1)\n\t\tupdate(bit, d[b + k], 1)\n\t\tupdate(bit, d[c + k] + 1, -1)\n\t\tprot[j] = [b + k, c + k]\n\telse:\n\t\tprint(sumb(bit, d[j]))\n",
        "slowest_solution": "import sys\n\ndef update(bit, idx, val):\n\twhile idx < len(bit):\n\t\tbit[idx] += val\n\t\tidx += idx & -idx\n\ndef sumb(bit, idx):\n\tans = 0\n\twhile idx > 0:\n\t\tans += bit[idx]\n\t\tidx -= idx & -idx\n\treturn ans\n\ndef input():\n\treturn sys.stdin.readline().strip()\n\ndef mi():\n\treturn int(input())\n\ndef MI():\n\treturn map(int, input().split())\n\ndef LMI():\n\treturn list(MI())\n(n, m) = MI()\ns = []\nprot = []\nprot1 = []\nquery = []\nfor _ in range(m):\n\ta = input().split()\n\tif a[0] == 'P':\n\t\t(b, c) = (int(a[1]), int(a[2]))\n\t\ts += [b, c]\n\t\tprot.append([b, c])\n\t\tprot1.append([b, c])\n\t\tquery.append([a[0], b, c])\n\telif a[0] == 'M':\n\t\t(b, c) = (int(a[1]), int(a[2]))\n\t\t[d, e] = prot1[b - 1]\n\t\ts += [d + c, e + c]\n\t\tprot1[b - 1] = [d + c, e + c]\n\t\tquery.append([a[0], b - 1, c])\n\telse:\n\t\tb = int(a[1])\n\t\ts += [b]\n\t\tquery.append([a[0], b, 0])\ns.sort()\nd = {}\ncur = 1\nfor i in s:\n\tif i not in d:\n\t\td[i] = cur\n\t\tcur += 1\nbit = [0] * (cur + 10)\nfor (i, j, k) in query:\n\tif i == 'P':\n\t\tupdate(bit, d[j], 1)\n\t\tupdate(bit, d[k] + 1, -1)\n\telif i == 'M':\n\t\t[b, c] = prot[j]\n\t\tupdate(bit, d[b], -1)\n\t\tupdate(bit, d[c] + 1, 1)\n\t\tupdate(bit, d[b + k], 1)\n\t\tupdate(bit, d[c + k] + 1, -1)\n\t\tprot[j] = [b + k, c + k]\n\telse:\n\t\tprint(sumb(bit, d[j]))\n"
    },
    {
        "task_id": 446,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 2.67252254486084,
        "fastest_time": 2.5440378189086914,
        "fastest_solution": "t = int(input())\nwhile t:\n\tn = int(input())\n\tA = list(map(int, input().split()))\n\tS = input()\n\tif A[0] == -1:\n\t\tmin = 0\n\t\tmax = 9999999999\n\telse:\n\t\tmin = A[0]\n\t\tmax = A[0]\n\tans = 'YES'\n\tfor i in range(1, n):\n\t\tif A[i] == -1:\n\t\t\tif S[i - 1] == '<':\n\t\t\t\tmin = min + 1\n\t\t\t\tmax = 9999999999\n\t\t\telif S[i - 1] == '>':\n\t\t\t\tmin = 0\n\t\t\t\tmax = max - 1\n\t\telif S[i - 1] == '<':\n\t\t\tif A[i] >= min + 1:\n\t\t\t\tmin = A[i]\n\t\t\t\tmax = A[i]\n\t\t\telse:\n\t\t\t\tans = 'NO'\n\t\t\t\tbreak\n\t\telif S[i - 1] == '>':\n\t\t\tif A[i] <= max - 1:\n\t\t\t\tmin = A[i]\n\t\t\t\tmax = A[i]\n\t\t\telse:\n\t\t\t\tans = 'NO'\n\t\t\t\tbreak\n\t\telif min <= A[i] <= max:\n\t\t\tmin = A[i]\n\t\t\tmax = A[i]\n\t\telse:\n\t\t\tans = 'NO'\n\t\t\tbreak\n\t\tif min > max:\n\t\t\tans = 'NO'\n\t\t\tbreak\n\tprint(ans)\n\tt -= 1\n",
        "slowest_solution": "t = int(input(''))\nimport math\nfor v in range(t):\n\tn = int(input(''))\n\ta = list(map(int, input('').split(' ')))\n\ts = input('')\n\tb = []\n\tres = True\n\tfor i in range(n):\n\t\tif a[i] != -1:\n\t\t\tb.append([a[i], a[i]])\n\t\telse:\n\t\t\tb.append([0, math.inf])\n\tfor i in range(n - 1):\n\t\tif s[i] == '>':\n\t\t\tif a[i + 1] == -1:\n\t\t\t\tb[i + 1][0] = 0\n\t\t\t\tb[i + 1][1] = b[i][1] - 1\n\t\t\telif a[i + 1] >= b[i][1]:\n\t\t\t\tres = False\n\t\t\t\tbreak\n\t\tif s[i] == '<':\n\t\t\tif a[i + 1] == -1:\n\t\t\t\tb[i + 1][0] = b[i][0] + 1\n\t\t\t\tb[i + 1][1] = math.inf\n\t\t\telif a[i + 1] <= b[i][0]:\n\t\t\t\tres = False\n\t\t\t\tbreak\n\t\tif s[i] == '=':\n\t\t\tif a[i + 1] == -1:\n\t\t\t\tb[i + 1][0] = b[i][0]\n\t\t\t\tb[i + 1][1] = b[i][1]\n\t\t\telif a[i + 1] < b[i][0] or a[i + 1] > b[i][1]:\n\t\t\t\tres = False\n\t\t\t\tbreak\n\t\tif b[i + 1][1] < b[i + 1][0] or b[i + 1][1] < 0:\n\t\t\tres = False\n\t\t\tbreak\n\tif res:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 416,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 2.6783676147460938,
        "fastest_time": 2.493084669113159,
        "fastest_solution": "modulo = 1000000007\nn = int(input())\nchar_count = [0] * 256\ns = input()\nfor i in range(n):\n\tchar_count[ord(s[i])] += 1\nmax_char_count = max(char_count)\nnum_max_char = 0\nfor i in range(256):\n\tif char_count[i] == max_char_count:\n\t\tnum_max_char += 1\nprint(pow(num_max_char, n) % modulo)\n",
        "slowest_solution": "n = int(input())\ns = input()\na = [0] * 300\nfor i in s:\n\ta[ord(i)] += 1\nprint(a.count(max(a)) ** len(s) % (10 ** 9 + 7))\n"
    },
    {
        "task_id": 419,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 2.7704594135284424,
        "fastest_time": 2.5013980865478516,
        "fastest_solution": "import sys\ntry:\n\tsys.stdin = open('in.in', 'r')\nexcept:\n\tpass\nn = int(input())\na = list(map(lambda x: abs(int(x)), input().split()))\na.sort()\nl = 0\nans = 0\nfor r in range(n):\n\twhile l < r and a[l] * 2 < a[r]:\n\t\tl += 1\n\tans += r - l\nprint(ans)\n",
        "slowest_solution": "import math\n\ndef read_task():\n\tn = int(input())\n\ttask = [abs(int(x)) for x in input().split()]\n\treturn task\n\ndef resolve(task):\n\ta = sorted(task)\n\ta.append(float('+inf'))\n\tcount = 0\n\tj = 0\n\tfor i in range(len(a) - 2):\n\t\twhile a[j + 1] <= 2 * a[i]:\n\t\t\tj += 1\n\t\tif j > i:\n\t\t\tcount += j - i\n\treturn count\n\ndef print_solution(solution):\n\tprint(solution)\n\ndef main():\n\ttask = read_task()\n\tsolution = resolve(task)\n\tprint_solution(solution)\nmain()\n"
    },
    {
        "task_id": 460,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.7452003955841064,
        "fastest_time": 2.690495014190674,
        "fastest_solution": "import sys\nn = int(input()) + 1\na = [0] + list(map(int, input().split()))\nmod7 = [x % 7 for x in a]\ndp = [[0] * n for _ in range(n)]\nmaxnum = [0] * (10 ** 5 + 10)\nans = 0\nfor i in range(n):\n\tmaxmod = [0] * 7\n\tfor j in range(n):\n\t\tmaxnum[a[j]] = 0\n\tfor j in range(i):\n\t\tmaxnum[a[j]] = max(maxnum[a[j]], dp[j][i])\n\t\tmaxmod[mod7[j]] = max(maxmod[mod7[j]], dp[j][i])\n\tfor j in range(i + 1, n):\n\t\tdp[i][j] = max(maxnum[a[j] - 1], maxnum[a[j] + 1], maxmod[mod7[j]], dp[0][i]) + 1\n\t\tmaxnum[a[j]] = max(maxnum[a[j]], dp[i][j])\n\t\tmaxmod[mod7[j]] = max(maxmod[mod7[j]], dp[i][j])\n\t\tans = max(ans, dp[i][j])\nprint(ans)\n",
        "slowest_solution": "import sys\n\ndef solve():\n\tn = int(sys.stdin.readline())\n\ta = [0] + [int(i) for i in sys.stdin.readline().split()]\n\tdp = [[0] * (n + 1) for i in range(n + 1)]\n\tans = 0\n\tmaxnum = [0] * (10 ** 5 + 2)\n\tmaxmod = [0] * 7\n\tfor y in range(n + 1):\n\t\tmaxmod = [0] * 7\n\t\tfor ai in a:\n\t\t\tmaxnum[ai] = 0\n\t\tfor i in range(y):\n\t\t\tmaxmod[a[i] % 7] = max(maxmod[a[i] % 7], dp[i][y])\n\t\t\tmaxnum[a[i]] = max(maxnum[a[i]], dp[i][y])\n\t\tfor x in range(y + 1, n + 1):\n\t\t\tdp[x][y] = max(maxmod[a[x] % 7], maxnum[a[x] + 1], maxnum[a[x] - 1], dp[0][y]) + 1\n\t\t\tdp[y][x] = dp[x][y]\n\t\t\tmaxmod[a[x] % 7] = max(maxmod[a[x] % 7], dp[x][y])\n\t\t\tmaxnum[a[x]] = max(maxnum[a[x]], dp[x][y])\n\t\t\tans = max(ans, dp[x][y])\n\tprint(ans)\nsolve()\n"
    },
    {
        "task_id": 420,
        "slowest_solution_id": 9,
        "fastest_solution_id": 7,
        "slowest_time": 2.7301268577575684,
        "fastest_time": 2.4664599895477295,
        "fastest_solution": "T = int(input())\nfor T in range(T):\n\tn = int(input())\n\tG = [[] for i in range(50)]\n\tf = [0] * 50\n\tfor i in range(n):\n\t\t(L, R, w) = map(int, input().split(' '))\n\t\tG[R] += [[L, w]]\n\tfor i in range(49):\n\t\tf[i] = max([f[j] + w for (j, w) in G[i]] + [0])\n\t\tif i:\n\t\t\tf[i] = max(f[i], f[i - 1])\n\tprint(f[48])\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tdp = [[0 for i in range(49)] for j in range(49)]\n\tfor i in range(n):\n\t\t(s, e, c) = map(int, input().split())\n\t\tdp[s][e] = max(dp[s][e], c)\n\tc = [0] * 49\n\tfor i in range(49):\n\t\tc[i] = 0\n\t\tfor j in range(i):\n\t\t\tc[i] = max(c[i], c[j] + dp[j][i])\n\tc.sort()\n\tprint(c[-1])\n"
    },
    {
        "task_id": 422,
        "slowest_solution_id": 9,
        "fastest_solution_id": 7,
        "slowest_time": 2.685976028442383,
        "fastest_time": 2.5458524227142334,
        "fastest_solution": "import sys\nMOD = 1000000007\n\ndef towerColoring(n):\n\te = pow(3, n, MOD - 1)\n\treturn pow(3, e, MOD)\nn = int(input().strip())\nresult = towerColoring(n)\nprint(result)\n",
        "slowest_solution": "import sys\nMOD = 10 ** 9 + 7\n\ndef pow3mod(n, mod):\n\tres = 1\n\ttmul = 3\n\twhile n > 0:\n\t\tif n % 2 == 1:\n\t\t\tres = res * tmul % mod\n\t\ttmul = tmul * tmul % mod\n\t\tn //= 2\n\treturn res\n\ndef towerColoring(n):\n\tpw = pow3mod(n, MOD - 1)\n\treturn pow3mod(pw, MOD)\nn = int(input().strip())\nresult = towerColoring(n)\nprint(result)\n"
    },
    {
        "task_id": 461,
        "slowest_solution_id": 2,
        "fastest_solution_id": 1,
        "slowest_time": 2.6438815593719482,
        "fastest_time": 2.537912368774414,
        "fastest_solution": "import sys, os\nif os.environ['USERNAME'] == 'kissz':\n\tinp = open('in3.txt', 'r').readline\n\n\tdef debug(*args):\n\t\tprint(*args, file=sys.stderr)\nelse:\n\tinp = sys.stdin.readline\n\n\tdef debug(*args):\n\t\tpass\n\ndef getp(i):\n\tL = []\n\twhile parent[i] >= 0:\n\t\tL += [i]\n\t\ti = parent[i]\n\tfor j in L:\n\t\tparent[j] = i\n\treturn i\n(n, m) = map(int, inp().split())\nneighbors = [set() for _ in range(n)]\nG = [[] for _ in range(n)]\nE = []\nxors = 0\nfor _ in range(m):\n\t(u, v, w) = map(int, inp().split())\n\tneighbors[u - 1].add(v - 1)\n\tneighbors[v - 1].add(u - 1)\n\tE += [(w, v - 1, u - 1)]\n\txors ^= w\ns = 0\nparent = [-1] * n\nk = n * (n - 1) // 2 - m\nnodes = set(range(n))\nconn = 0\nfor p in range(n):\n\tif p not in nodes:\n\t\tcontinue\n\tnodes.remove(p)\n\tQ = [p]\n\twhile Q:\n\t\ti = Q.pop()\n\t\tnew_nodes = set()\n\t\tfor j in nodes:\n\t\t\tif j not in neighbors[i]:\n\t\t\t\tparent[j] = p\n\t\t\t\tG[i].append((j, True))\n\t\t\t\tG[j].append((i, True))\n\t\t\t\tnew_nodes.add(j)\n\t\t\t\tconn += 1\n\t\t\t\tdebug(i, j, 0)\n\t\t\t\tk -= 1\n\t\t\t\tQ.append(j)\n\t\tnodes -= new_nodes\ndebug(parent)\nif conn < n - 1 or k == 0:\n\tE.sort()\n\tfor (w, u, v) in E:\n\t\tpu = getp(u)\n\t\tpv = getp(v)\n\t\tif pu != pv:\n\t\t\ts += w\n\t\t\tparent[pu] = pv\n\t\t\tG[u].append((v, False))\n\t\t\tG[v].append((u, False))\n\t\t\tconn += 1\n\t\t\tdebug(u, v, w)\n\t\telif k == 0 and w < xors:\n\t\t\tQ = [(u, False)]\n\t\t\tseen = [False] * n\n\t\t\tseen[u] = True\n\t\t\twhile Q:\n\t\t\t\t(i, new) = Q.pop()\n\t\t\t\tfor (j, new_edge) in G[i]:\n\t\t\t\t\tif not seen[j]:\n\t\t\t\t\t\tseen[j] = True\n\t\t\t\t\t\tnew_edge |= new\n\t\t\t\t\t\tif j == v:\n\t\t\t\t\t\t\tQ = []\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tQ.append((j, new_edge))\n\t\t\tif new_edge:\n\t\t\t\ts += w\n\t\t\t\tdebug('corr ', u, v, w)\n\t\t\t\tk += 1\n\t\tif conn >= n - 1 and (k > 0 or w > xors):\n\t\t\tbreak\nif k == 0:\n\ts += xors\n\tdebug('no corr ', xors)\nprint(s)\n",
        "slowest_solution": "import sys\nfrom sys import stdin\nfrom collections import deque\n\ndef uf_find(n, p):\n\tufl = []\n\twhile p[n] != n:\n\t\tufl.append(n)\n\t\tn = p[n]\n\tfor i in ufl:\n\t\tp[i] = n\n\treturn n\n\ndef uf_union(a, b, p, rank):\n\tap = uf_find(a, p)\n\tbp = uf_find(b, p)\n\tif ap == bp:\n\t\treturn True\n\telse:\n\t\tif rank[ap] > rank[bp]:\n\t\t\tp[bp] = ap\n\t\telif rank[ap] < rank[bp]:\n\t\t\tp[ap] = bp\n\t\telse:\n\t\t\tp[bp] = ap\n\t\t\trank[ap] += 1\n\t\treturn False\n(n, m) = map(int, stdin.readline().split())\nif n <= 1000:\n\tlis = [[0] * n for i in range(n)]\n\twuv = []\n\tXOR = 0\n\tfor i in range(m):\n\t\t(u, v, w) = map(int, stdin.readline().split())\n\t\tu -= 1\n\t\tv -= 1\n\t\twuv.append((w, u, v))\n\t\tlis[u][v] = lis[v][u] = w\n\t\tXOR ^= w\n\twuv.sort()\n\tp = [i for i in range(n)]\n\trank = [0] * n\n\tedge = []\n\tflag = False\n\tfor i in range(n):\n\t\tfor j in range(i):\n\t\t\tif lis[i][j] == 0:\n\t\t\t\tif uf_union(i, j, p, rank):\n\t\t\t\t\tflag = True\n\t\t\t\telse:\n\t\t\t\t\tedge.append((i, j, 0))\n\tnans = 0\n\tfor (w, u, v) in wuv:\n\t\tif uf_union(u, v, p, rank):\n\t\t\tpass\n\t\telse:\n\t\t\tnans += w\n\t\t\tedge.append((u, v, w))\n\tif flag:\n\t\tprint(nans)\n\t\tsys.exit()\n\tp = [i for i in range(n)]\n\trank = [0] * n\n\tfor (i, j, w) in edge:\n\t\tif w > 0:\n\t\t\tuf_union(i, j, p, rank)\n\tnplus = XOR\n\tfor (w, u, v) in wuv:\n\t\tif uf_find(u, p) != uf_find(v, p):\n\t\t\tnplus = min(nplus, w)\n\t\t\tbreak\n\t\telif w > nplus:\n\t\t\tbreak\n\tprint(nans + nplus)\nelse:\n\tlis = [[] for i in range(n)]\n\twuv = []\n\tfor i in range(m):\n\t\t(u, v, w) = map(int, stdin.readline().split())\n\t\tu -= 1\n\t\tv -= 1\n\t\twuv.append((w, u, v))\n\t\tlis[u].append((v, w))\n\t\tlis[v].append((u, w))\n\table = [True] * n\n\tp = [i for i in range(n)]\n\trank = [0] * n\n\tfor st in range(n):\n\t\tif not able[st]:\n\t\t\tcontinue\n\t\tblock = [0] * n\n\t\tcnt = 0\n\t\table[st] = False\n\t\tq = deque([st])\n\t\twhile q:\n\t\t\twhile q:\n\t\t\t\tnv = q.popleft()\n\t\t\t\tcnt += 1\n\t\t\t\tfor (u, w) in lis[nv]:\n\t\t\t\t\tif able[u] and block[u] == cnt - 1:\n\t\t\t\t\t\tblock[u] = cnt\n\t\t\tfor i in range(n):\n\t\t\t\tif able[i] and block[i] != cnt:\n\t\t\t\t\tuf_union(i, st, p, rank)\n\t\t\t\t\table[i] = False\n\t\t\t\t\tq.append(i)\n\twuv.sort()\n\tans = 0\n\tfor (w, u, v) in wuv:\n\t\tif not uf_union(u, v, p, rank):\n\t\t\tans += w\n\tprint(ans)\n"
    },
    {
        "task_id": 428,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.692913293838501,
        "fastest_time": 2.519110918045044,
        "fastest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\tl = [int(i) for i in input().split()]\n\ts = []\n\tc = 0\n\tfor i in l:\n\t\tif s == []:\n\t\t\ts.append(i)\n\t\telif i != s[-1]:\n\t\t\tc += 1\n\t\t\ts.pop()\n\t\telse:\n\t\t\ts.append(i)\n\twhile len(s) > 1:\n\t\ttop = s[-1]\n\t\ts.pop(-1)\n\t\tif top == s[-1]:\n\t\t\ts.pop()\n\t\t\ts.append(0)\n\t\telse:\n\t\t\tc += 1\n\t\t\ts.pop()\n\tprint(c)\n",
        "slowest_solution": "t = int(input())\n\ndef fun(st):\n\tst = st.replace(' ', '')\n\tcount = 0\n\twhile len(st) > 3:\n\t\tflag = 0\n\t\tif '01' in st:\n\t\t\tst = st.replace('01', '', 1)\n\t\t\tcount += 1\n\t\t\tflag += 1\n\t\tif '10' in st:\n\t\t\tst = st.replace('10', '', 1)\n\t\t\tcount += 1\n\t\t\tflag += 1\n\t\tif flag == 0:\n\t\t\tbreak\n\tif '0' in st and '1' in st:\n\t\tcount += 1\n\telif '1' in st:\n\t\tcount += len(st) // 3\n\tprint(count)\nfor _ in range(t):\n\tn = int(input())\n\tst = input()\n\tst = st.replace(' ', '')\n\tfun(st)\n"
    },
    {
        "task_id": 430,
        "slowest_solution_id": 8,
        "fastest_solution_id": 6,
        "slowest_time": 2.7511346340179443,
        "fastest_time": 2.4860548973083496,
        "fastest_solution": "t = int(input())\nwhile t:\n\tt -= 1\n\t(n, q) = list(map(int, input().split()))\n\tinnersums = []\n\tfor i in range(n):\n\t\ttemp = list(map(int, input().split()))\n\t\tinnersums.append([0])\n\t\tfor j in range(temp[0]):\n\t\t\tinnersums[i].append(innersums[i][-1] + temp[j + 1])\n\tb = []\n\tsemicircumferences = [0]\n\toutersum = [0]\n\tfor i in range(n):\n\t\tb.append(list(map(int, input().split())))\n\t\tb[i][0] -= 1\n\t\tb[i][1] -= 1\n\t\toutersum.append(outersum[-1] + b[i][-1])\n\t\tif i > 0:\n\t\t\tsemicircumferences.append(min(abs(innersums[i][b[i][0]] - innersums[i][b[i - 1][1]]), innersums[i][-1] - abs(innersums[i][b[i][0]] - innersums[i][b[i - 1][1]])))\n\tsemicircumferences[0] = min(abs(innersums[0][b[0][0]] - innersums[0][b[-1][1]]), innersums[0][-1] - abs(innersums[0][b[0][0]] - innersums[0][b[-1][1]]))\n\toutersum2 = [semicircumferences[0]]\n\tfor i in range(1, n):\n\t\toutersum2.append(outersum2[-1] + semicircumferences[i])\n\twhile q:\n\t\tq -= 1\n\t\t(v1, c1, v2, c2) = list(map(int, input().split()))\n\t\t(v1, c1, v2, c2) = (v1 - 1, c1 - 1, v2 - 1, c2 - 1)\n\t\tif c2 < c1:\n\t\t\t(c1, v1, c2, v2) = (c2, v2, c1, v1)\n\t\tprint(min(outersum[c2] - outersum[c1] + outersum2[c2 - 1] - outersum2[c1] + min(abs(innersums[c2][v2] - innersums[c2][b[c2 - 1][1]]), innersums[c2][-1] - abs(innersums[c2][v2] - innersums[c2][b[c2 - 1][1]])) + min(abs(innersums[c1][v1] - innersums[c1][b[c1][0]]), innersums[c1][-1] - abs(innersums[c1][v1] - innersums[c1][b[c1][0]])), outersum[-1] - (outersum[c2] - outersum[c1]) + outersum2[-1] - (outersum2[c2 - 1] - outersum2[c1]) - semicircumferences[c1] - semicircumferences[c2] + min(abs(innersums[c2][v2] - innersums[c2][b[c2][0]]), innersums[c2][-1] - abs(innersums[c2][v2] - innersums[c2][b[c2][0]])) + min(abs(innersums[c1][v1] - innersums[c1][b[c1 - 1][1]]), innersums[c1][-1] - abs(innersums[c1][v1] - innersums[c1][b[c1 - 1][1]]))))\n",
        "slowest_solution": "from itertools import accumulate\n\ndef read_test():\n\t(N, nQ) = list(map(int, input().strip().split()))\n\t(A, W, WC, Q) = ([], [], [], [])\n\tfor _ in range(N):\n\t\tw = list(map(int, input().strip().split()))\n\t\tA.append(w[0])\n\t\tW.append(w[1:])\n\tfor _ in range(N):\n\t\t(v1, v2, w) = list(map(int, input().strip().split()))\n\t\t(v1, v2) = (v1 - 1, v2 - 1)\n\t\tWC.append((v1, v2, w))\n\tfor _ in range(nQ):\n\t\t(v1, c1, v2, c2) = list(map(int, input().strip().split()))\n\t\t(v1, c1, v2, c2) = (v1 - 1, c1 - 1, v2 - 1, c2 - 1)\n\t\tQ.append((v1, c1, v2, c2))\n\treturn (N, A, W, WC, Q)\n\ndef solve(N, A, W, WC, Q):\n\tsum_sc = list(map(sum, W))\n\tp_sum_sc = [list(accumulate(W[i])) for i in range(N)]\n\n\tdef small_dist(c, x, y):\n\t\t(x, y) = (min(x, y), max(x, y))\n\t\tc1 = (p_sum_sc[c][y - 1] if y > 0 else 0) - (p_sum_sc[c][x - 1] if x > 0 else 0)\n\t\tc2 = sum_sc[c] - c1\n\t\treturn min(c1, c2)\n\tw_bc = list(map(lambda x: x[2], WC))\n\tsum_bc = sum(w_bc)\n\tp_sum_bc = list(accumulate(w_bc))\n\tv_in = [WC[i - 1][1] for i in range(N)]\n\tv_out = [WC[i][0] for i in range(N)]\n\ttrav_sc = [small_dist(i, v_in[i], v_out[i]) for i in range(N)]\n\tsum_trav_sc = sum(trav_sc)\n\tp_sum_trav_sc = list(accumulate(trav_sc))\n\n\tdef big_dist(x, y):\n\t\tif x == y:\n\t\t\treturn sum_bc\n\t\telif x < y:\n\t\t\treturn (p_sum_bc[y - 1] if y > 0 else 0) - (p_sum_bc[x - 1] if x > 0 else 0)\n\t\telse:\n\t\t\treturn sum_bc - big_dist(y, x)\n\n\tdef trav_dist(x, y):\n\t\tif x == y:\n\t\t\treturn 0\n\t\telif x < y:\n\t\t\treturn p_sum_trav_sc[y - 1] - p_sum_trav_sc[x]\n\t\telse:\n\t\t\treturn sum_trav_sc - trav_dist(y, x) - trav_sc[y] - trav_sc[x]\n\tfor (v1, c1, v2, c2) in Q:\n\t\tif c1 == c2:\n\t\t\tcost1 = small_dist(c1, v1, v2)\n\t\t\tcost2 = sum_bc + sum_trav_sc - trav_sc[c1] + small_dist(c1, v1, v_in[c1]) + small_dist(c1, v2, v_out[c1])\n\t\t\tcost3 = sum_bc + sum_trav_sc - trav_sc[c1] + small_dist(c1, v1, v_out[c1]) + small_dist(c1, v2, v_in[c1])\n\t\t\tcost = min(cost1, cost2, cost3)\n\t\t\tprint(cost)\n\t\t\tcontinue\n\t\tif c1 > c2:\n\t\t\t(v1, c1, v2, c2) = (v1, c1, v2, c2)\n\t\tcost1 = small_dist(c1, v1, v_out[c1]) + small_dist(c2, v2, v_in[c2]) + big_dist(c1, c2) + trav_dist(c1, c2)\n\t\tcost2 = small_dist(c1, v1, v_in[c1]) + small_dist(c2, v2, v_out[c2]) + big_dist(c2, c1) + trav_dist(c2, c1)\n\t\tprint(min(cost1, cost2))\nT = int(input())\nfor _ in range(T):\n\t(N, A, W, WC, Q) = read_test()\n\tsolve(N, A, W, WC, Q)\n"
    },
    {
        "task_id": 432,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.7083539962768555,
        "fastest_time": 2.5259482860565186,
        "fastest_solution": "nwords = list(map(int, input().split()))\nn = nwords[0]\nm = nwords[1]\npoland_ball = {}\ncommon = []\ncommon_len = 0\nfor i in range(n):\n\tword = input()\n\tpoland_ball[word] = 0\nfor i in range(m):\n\tword = input()\n\tif word in poland_ball.keys():\n\t\tcommon.append(word)\n\t\tcommon_len += 1\nfor i in range(common_len):\n\tif i % 2 == 0:\n\t\tcommon_len -= 1\n\t\tm -= 1\n\telse:\n\t\tcommon_len -= 1\n\t\tn -= 1\n\tif common_len <= 0:\n\t\tbreak\nif n > m:\n\tprint('YES')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "poland = {}\nline = input().split(' ')\npolandCount = int(line[0])\nenemyCount = int(line[1])\nfor i in range(polandCount):\n\tpoland[input()] = 1\nunique = 0\nfor i in range(enemyCount):\n\tif poland.get(input()) == None:\n\t\tunique += 1\nsame = enemyCount - unique\nuniquePol = polandCount - same\nif uniquePol > unique:\n\tprint('YES')\nelif uniquePol < unique:\n\tprint('NO')\nelif same % 2 == 0:\n\tprint('NO')\nelse:\n\tprint('YES')\n"
    },
    {
        "task_id": 433,
        "slowest_solution_id": 7,
        "fastest_solution_id": 4,
        "slowest_time": 2.723515033721924,
        "fastest_time": 2.539747953414917,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tp = 0\n\tq = 0\n\tmod = 1000000007\n\tn = int(input())\n\tlst = input().split(' ')\n\tdata = [int(i) for i in lst]\n\tdata.sort()\n\tfor i in range(n):\n\t\tp = 2 * p + data[i] % mod\n\t\tq = 2 * q + data[n - i - 1] % mod\n\tresult = (q - p) % mod\n\tprint(result)\n",
        "slowest_solution": "t = int(input())\nmod = 10 ** 9 + 7\nfor i in range(t):\n\tn = int(input())\n\tn1 = [int(x) for x in input().split()]\n\tn1.sort()\n\t(mi, ma) = (0, 0)\n\tfor i in range(n):\n\t\tmi = (2 * mi + n1[i]) % mod\n\t\tma = (2 * ma + n1[n - i - 1]) % mod\n\t\tdi = ma - mi\n\tprint((mod + di) % mod)\n"
    },
    {
        "task_id": 436,
        "slowest_solution_id": 7,
        "fastest_solution_id": 4,
        "slowest_time": 2.7261605262756348,
        "fastest_time": 2.5210824012756348,
        "fastest_solution": "import sys\nimport os.path\nif os.path.exists('input_file.txt'):\n\tsys.stdin = open('input_file.txt', 'r')\n\tsys.stdout = open('output_file.txt', 'w')\nn = int(input())\na = list(map(int, input().split()))\ns = input()\nm = 0\nf = 1\nfor i in range(n):\n\tm = max(m, a[i])\n\tif m > i + 1:\n\t\tif s[i] != '1':\n\t\t\tf = 0\n\t\t\tbreak\nif f:\n\tprint('YES')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "from itertools import groupby\nn = int(input())\nnums = [int(i) for i in input().split()]\ncopy = list(nums)\npos = input()\npos = [''.join(g) for (k, g) in groupby(pos) if k != '#']\ncur_pos = 0\nfor i in pos:\n\tif i[0] == '1':\n\t\tnums[cur_pos:cur_pos + len(i) + 1] = sorted(nums[cur_pos:cur_pos + len(i) + 1])\n\tcur_pos += len(i)\nif sorted(copy) == nums:\n\tprint('YES')\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 471,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.6436896324157715,
        "fastest_time": 2.56115984916687,
        "fastest_solution": "(n, q) = map(int, input().split())\ngraph = [set() for _ in range(n)]\nstart = [4294967295] * n\nfor _ in range(q):\n\t(i, j, x) = map(int, input().split())\n\ti -= 1\n\tj -= 1\n\tgraph[i].add(j)\n\tgraph[j].add(i)\n\tstart[i] &= x\n\tstart[j] &= x\nfor i in range(n):\n\tif i in graph[i]:\n\t\tcontinue\n\tval = start[i]\n\tfor j in graph[i]:\n\t\tval &= start[j]\n\tstart[i] ^= val\nprint(*start)\n",
        "slowest_solution": "(n, q) = map(int, input().strip().split())\nqs = [[] for _ in range(n)]\nrefers_self = [False for _ in range(n)]\nfor _ in range(q):\n\t(i, j, x) = map(int, input().strip().split())\n\tif i == j:\n\t\trefers_self[i - 1] = True\n\tqs[i - 1].append((j - 1, x))\n\tqs[j - 1].append((i - 1, x))\na = []\nfor i in range(n):\n\tif qs[i]:\n\t\tans = (2 << 32) - 1\n\t\tfor (j, x) in qs[i]:\n\t\t\tans = ans & x\n\t\ta.append(ans)\n\telse:\n\t\ta.append(0)\nfor i in range(n):\n\tif refers_self[i]:\n\t\tcontinue\n\tans = (2 << 32) - 1\n\tfor (j, x) in qs[i]:\n\t\tans = ans & a[j]\n\ta[i] = a[i] - (a[i] & ans)\nprint(*a)\n"
    },
    {
        "task_id": 483,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 0.00263214111328125,
        "fastest_time": 0.0,
        "fastest_solution": "def interpreter(tape):\n\t(data, pointer, output) = ([0], 0, '')\n\tfor command in tape:\n\t\tif command == '>':\n\t\t\tpointer += 1\n\t\telif command == '<':\n\t\t\tpointer -= 1\n\t\telif command == '+' and is_valid(pointer, data):\n\t\t\tdata[pointer] = (data[pointer] + 1) % 256\n\t\telif command == '-' and is_valid(pointer, data):\n\t\t\tdata[pointer] = (data[pointer] - 1) % 256\n\t\telif command == '/' and is_valid(pointer, data):\n\t\t\tdata[pointer] = 0\n\t\telif command == '!':\n\t\t\tdata.append(0)\n\t\telif command == '*' and is_valid(pointer, data):\n\t\t\toutput += chr(data[pointer])\n\t\telif command == '*':\n\t\t\toutput += chr(0)\n\treturn output\n\ndef is_valid(pointer, data):\n\treturn pointer >= 0 and pointer < len(data)\n",
        "slowest_solution": "interpreter = lambda tape: (lambda l: ([[0 for l['mem'][l['p']] in [(l['mem'][l['p']] + 1) % 256]] if i == '+' and l['p'] in l['mem'].keys() else [0 for l['p'] in [l['p'] - 1]] if i == '<' else [0 for l['p'] in [l['p'] + 1]] if i == '>' else [0 for l['mem'][l['p']] in [(255 + l['mem'][l['p']]) % 256]] if i == '-' and l['p'] in l['mem'].keys() else [0 for l['mem'][l['p']] in [0]] if i == '/' else [0 for l['out'] in [l['out'] + chr(l['mem'].get(l['p'], 0))]] if i == '*' else [0 for l['mem'][max(l['mem'].keys()) + 1] in [0]] if i == '!' else None for i in tape], l['out'])[1])({'mem': {0: 0}, 'p': 0, 'out': ''})\n"
    },
    {
        "task_id": 443,
        "slowest_solution_id": 9,
        "fastest_solution_id": 2,
        "slowest_time": 2.691157817840576,
        "fastest_time": 2.520294189453125,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nfrom math import log2, log, ceil\n\ndef swaparr(arr, a, b):\n\ttemp = arr[a]\n\tarr[a] = arr[b]\n\tarr[b] = temp\n\ndef gcd(a, b):\n\tif a == 0:\n\t\treturn b\n\treturn gcd(b % a, a)\n\ndef nCr(n, k):\n\tif k > n - k:\n\t\tk = n - k\n\tres = 1\n\tfor i in range(k):\n\t\tres = res * (n - i)\n\t\tres = res / (i + 1)\n\treturn res\n\ndef upper_bound(a, x, lo=0):\n\thi = len(a)\n\twhile lo < hi:\n\t\tmid = (lo + hi) // 2\n\t\tif a[mid] < x:\n\t\t\tlo = mid + 1\n\t\telse:\n\t\t\thi = mid\n\treturn lo\n\ndef primefs(n):\n\tprimes = {}\n\twhile n % 2 == 0:\n\t\tprimes[2] = primes.get(2, 0) + 1\n\t\tn = n // 2\n\tfor i in range(3, int(n ** 0.5) + 2, 2):\n\t\twhile n % i == 0:\n\t\t\tprimes[i] = primes.get(i, 0) + 1\n\t\t\tn = n // i\n\tif n > 2:\n\t\tprimes[n] = primes.get(n, 0) + 1\n\treturn primes\n\ndef power(x, y, p):\n\tres = 1\n\tx = x % p\n\tif x == 0:\n\t\treturn 0\n\twhile y > 0:\n\t\tif y & 1 == 1:\n\t\t\tres = res * x % p\n\t\ty = y >> 1\n\t\tx = x * x % p\n\treturn res\n\ndef swap(a, b):\n\ttemp = a\n\ta = b\n\tb = temp\n\treturn (a, b)\n\ndef find(x, link):\n\twhile x != link[x]:\n\t\tx = link[x]\n\treturn x\n\ndef union(x, y, link, size):\n\tx = find(x, link)\n\ty = find(y, link)\n\tif size[x] < size[y]:\n\t\t(x, y) = swap(x, y)\n\tif x != y:\n\t\tsize[x] += size[y]\n\t\tlink[y] = x\n\ndef sieve(n):\n\tprime = [True for i in range(n + 1)]\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\treturn prime\nMAXN = int(1000000.0 + 5)\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom collections import Counter\n\ndef find_parent(parent, i):\n\tif parent[i] == -1:\n\t\treturn i\n\tif parent[i] != -1:\n\t\treturn find_parent(parent, parent[i])\n(n, m) = map(int, input().split())\nparent = [-1] * n\ncnt = 0\nfor i in range(m):\n\t(u, v) = map(int, input().split())\n\txroot = find_parent(parent, u - 1)\n\tyroot = find_parent(parent, v - 1)\n\tif xroot != yroot:\n\t\tcnt += 1\n\t\tparent[xroot] = yroot\nprint(2 ** cnt)\n",
        "slowest_solution": "(n, m) = map(int, input().split())\nr = [[] for i in range(n)]\nmk = [0] * n\nc = 0\n\ndef dfs(x):\n\tglobal c\n\tmk[x] = 1\n\tc += 1\n\tfor i in range(len(r[x])):\n\t\tif mk[r[x][i]] == 0:\n\t\t\tdfs(r[x][i])\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\ta -= 1\n\tb -= 1\n\tr[a].append(b)\n\tr[b].append(a)\njj = 1\nfor i in range(n):\n\tif mk[i] == 0:\n\t\tdfs(i)\n\t\tjj = jj * 2 ** (c - 1)\n\t\tc = 0\nprint(jj)\n"
    },
    {
        "task_id": 440,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 2.7004668712615967,
        "fastest_time": 2.497422218322754,
        "fastest_solution": "(n, m) = list(map(int, input().strip().split()))\ncups = list(map(int, input().strip().split()))\nfull_coffe = sum(cups)\nif full_coffe < m:\n\tprint('-1')\n\texit()\nelif full_coffe == m:\n\tprint(len(cups))\n\texit()\ncups.sort(reverse=True)\n\ndef check_day(day):\n\tif day == 0:\n\t\treturn False\n\tdone = 0\n\tfor (idx, c) in enumerate(cups):\n\t\tdone += max(0, c - idx // day)\n\treturn done >= m\nlower = 0\nupper = n\nwhile upper - lower > 1:\n\tmiddle = lower + (upper - lower) // 2\n\tif check_day(middle):\n\t\tupper = middle\n\telse:\n\t\tlower = middle\nprint(upper)\n",
        "slowest_solution": "(n, m) = list(map(int, input().split()))\na = list(map(int, input().split()))\nans = 1\nsu = sum(a)\na.sort(reverse=True)\ns = [0] * n\ns[0] = a[0]\nfor i in range(1, n):\n\ts[i] = s[i - 1] + a[i]\n\ndef pos(d):\n\ti = d\n\twhile i <= n:\n\t\tk = i // d\n\t\tneg = k * i - k * (k + 1) // 2 * d\n\t\tif s[i - 1] - neg >= m:\n\t\t\treturn True\n\t\ti += 1\n\treturn False\nif su < m:\n\tans = -1\n\tprint(ans)\nelse:\n\tfirst = 0\n\tlast = n\n\twhile first < last - 1:\n\t\tmidpoint = (first + last) // 2\n\t\tif pos(midpoint):\n\t\t\tlast = midpoint\n\t\telse:\n\t\t\tfirst = midpoint\n\tprint(last)\n"
    },
    {
        "task_id": 451,
        "slowest_solution_id": 1,
        "fastest_solution_id": 3,
        "slowest_time": 2.6905126571655273,
        "fastest_time": 2.533849000930786,
        "fastest_solution": "f = lambda : map(int, input().split())\nm = 1000000007\n(d, n) = f()\nt = list(f())\np = [[] for i in range(n)]\nfor j in range(n - 1):\n\t(u, v) = f()\n\tu -= 1\n\tv -= 1\n\tp[u].append(v)\n\tp[v].append(u)\n\ndef g(u, x, a, b, q):\n\tk = 1\n\tfor v in p[u]:\n\t\tif a < t[v] <= b or (t[v] == a and v > q):\n\t\t\tif v != x:\n\t\t\t\tk += k * g(v, u, a, b, q) % m\n\treturn k\ns = 0\nfor q in range(n):\n\ta = t[q]\n\tb = a + d\n\ts += g(q, -1, a, b, q)\nprint(s % m)\n",
        "slowest_solution": "(d, n) = map(int, input().split())\na = list(map(int, input().split()))\nmas = [[] for _ in range(n + 1)]\nMOD = 1000000007\nfor _ in range(n - 1):\n\t(u, v) = map(int, input().split())\n\tmas[u].append(v)\n\tmas[v].append(u)\nk = 0\n\ndef dfs(nomer, mas, tyt_yge_bili, f, nach):\n\tglobal k\n\tf[nomer] = 1\n\ttyt_yge_bili[nomer] = True\n\tfor j in mas[nomer]:\n\t\tif tyt_yge_bili[j] != True:\n\t\t\tif (a[j - 1] >= a[nach - 1] and a[j - 1] <= a[nach - 1] + d) and (a[j - 1] != a[nach - 1] or j >= nach):\n\t\t\t\tdfs(j, mas, tyt_yge_bili, f, nach)\n\t\t\t\tf[nomer] = f[nomer] * (f[j] + 1) % MOD\nrez = 0\nfor z in range(1, n + 1):\n\tf = []\n\ttyt_yge_bili = []\n\tfor _ in range(n + 1):\n\t\tf.append(0)\n\t\ttyt_yge_bili.append(0)\n\tdfs(z, mas, tyt_yge_bili, f, z)\n\trez = (rez + f[z]) % MOD\nprint(rez)\n"
    },
    {
        "task_id": 439,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 2.7352957725524902,
        "fastest_time": 2.5214684009552,
        "fastest_solution": "from collections import Counter\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tif a == [a[0]] * n:\n\t\tif a[0] == 0:\n\t\t\tprint(1)\n\t\telse:\n\t\t\tprint(2)\n\telse:\n\t\t(xor_dict, xor, ans) = ({}, 0, 0)\n\t\tcnt = 0\n\t\tfor i in range(n):\n\t\t\txor = xor ^ a[i]\n\t\t\ttry:\n\t\t\t\txor_dict[xor] += 1\n\t\t\texcept:\n\t\t\t\txor_dict[xor] = 1\n\t\t\t\tcnt += 1\n\t\t(ans, total) = (max(ans, cnt), xor)\n\t\tfor i in range(n - 1):\n\t\t\txor = xor ^ a[i]\n\t\t\ttry:\n\t\t\t\txor_dict[xor] += 1\n\t\t\texcept:\n\t\t\t\txor_dict[xor] = 1\n\t\t\tif xor_dict[xor] == 1:\n\t\t\t\tcnt += 1\n\t\t\tpref = xor ^ total\n\t\t\tif xor_dict[pref] == 1:\n\t\t\t\tcnt -= 1\n\t\t\txor_dict[pref] -= 1\n\t\t\tans = max(ans, cnt)\n\t\tprint(ans)\n",
        "slowest_solution": "from collections import defaultdict\nfrom collections import Counter\nfrom collections import deque\nimport math\nfor _ in range(int(input())):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tprefix = [arr[0]]\n\tfreq = defaultdict(int)\n\tfreq[prefix[0]] += 1\n\tfor i in range(1, n):\n\t\tprefix.append(prefix[-1] ^ arr[i])\n\t\tfreq[prefix[i]] += 1\n\tx = prefix[-1]\n\tmx = ans = len(freq)\n\tfor i in range(n):\n\t\tfreq[prefix[i]] -= 1\n\t\tif not freq[prefix[i]]:\n\t\t\tans -= 1\n\t\tx ^= arr[i]\n\t\tif not freq[x]:\n\t\t\tans += 1\n\t\tfreq[x] += 1\n\t\tmx = max(ans, mx)\n\tprint(mx)\n"
    },
    {
        "task_id": 465,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7335050106048584,
        "fastest_time": 2.7335050106048584,
        "fastest_solution": "from math import gcd, ceil\nfor _ in range(int(input())):\n\t(a, b, q) = map(int, input().split())\n\tm = a * b // gcd(a, b)\n\tn = max(a, b)\n\tfor _ in range(q):\n\t\t(l, r) = map(int, input().split())\n\t\tprint(r - l - ((r // m - l // m + 1) * n - min(n, l % m) - max(0, n - r % m - 1)) + 1)\n",
        "slowest_solution": "from math import gcd, ceil\nfor _ in range(int(input())):\n\t(a, b, q) = map(int, input().split())\n\tm = a * b // gcd(a, b)\n\tn = max(a, b)\n\tfor _ in range(q):\n\t\t(l, r) = map(int, input().split())\n\t\tprint(r - l - ((r // m - l // m + 1) * n - min(n, l % m) - max(0, n - r % m - 1)) + 1)\n"
    },
    {
        "task_id": 442,
        "slowest_solution_id": 2,
        "fastest_solution_id": 5,
        "slowest_time": 2.723007917404175,
        "fastest_time": 2.529747247695923,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tarr = [int(i) for i in input()]\n\tif n % 2 == 0:\n\t\teven = 0\n\t\tfor i in range(1, n, 2):\n\t\t\tif arr[i] % 2 == 0:\n\t\t\t\teven += 1\n\t\tif even > 0:\n\t\t\tprint(2)\n\t\telse:\n\t\t\tprint(1)\n\telse:\n\t\todd = 0\n\t\tfor i in range(0, n, 2):\n\t\t\tif arr[i] % 2 != 0:\n\t\t\t\todd += 1\n\t\tif odd > 0:\n\t\t\tprint(1)\n\t\telse:\n\t\t\tprint(2)\n",
        "slowest_solution": "def If_Even(Str):\n\tn = len(Str)\n\tEven = False\n\tfor i in range(int(n / 2)):\n\t\tif int(Str[2 * i + 1]) % 2 == 0:\n\t\t\tEven = True\n\tif Even == True:\n\t\treturn 2\n\telse:\n\t\treturn 1\n\ndef If_Odd(Str):\n\tn = len(Str)\n\tOdd = False\n\tfor i in range(int(n / 2) + 1):\n\t\tif int(Str[2 * i]) % 2 == 1:\n\t\t\tOdd = True\n\tif Odd == True:\n\t\treturn 1\n\telse:\n\t\treturn 2\n\ndef Who_wins(Str):\n\tif len(Str) % 2 == 0:\n\t\treturn If_Even(Str)\n\telse:\n\t\treturn If_Odd(Str)\ntrials = int(input())\nfor i in range(trials):\n\tinput('')\n\tStr = input('')\n\tprint(Who_wins(Str))\n"
    },
    {
        "task_id": 445,
        "slowest_solution_id": 5,
        "fastest_solution_id": 7,
        "slowest_time": 2.6776182651519775,
        "fastest_time": 2.484375476837158,
        "fastest_solution": "import sys\nmsg = sys.stdin.readlines()\nfor i in msg[1:]:\n\t(a, b) = i.split()\n\tx = int(a)\n\ty = int(b)\n\tif y / x == y // x:\n\t\tprint(1, y // x)\n\telse:\n\t\tprint(0, 0)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef solve():\n\t(x, y) = map(int, input().split())\n\tif x > y:\n\t\tprint('0 0')\n\t\treturn\n\tif y % x == 0:\n\t\tprint(f'1 {y // x}')\n\telse:\n\t\tprint('0 0')\nT = int(input())\nfor _ in range(T):\n\tsolve()\n"
    },
    {
        "task_id": 466,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.718406915664673,
        "fastest_time": 2.6324656009674072,
        "fastest_solution": "import sys\n\ndef modInverse(x, y, mod):\n\tres = 1\n\tx = x % mod\n\twhile y > 0:\n\t\tif y & 1:\n\t\t\tres = res * x % mod\n\t\ty = y // 2\n\t\tx = x * x % mod\n\treturn res\n\ndef isEqual(a, b):\n\tfor i in range(len(a)):\n\t\tif a[i] != b[i]:\n\t\t\treturn False\n\treturn True\n(m, n) = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\ns = [0, 0]\nfor x in arr:\n\ts[0] = s[0] + x\n\ts[1] = s[1] + x * x\nif n == 1:\n\tprint(arr[0], 0)\n\tsys.exit()\nif n == m:\n\tprint('0 1')\n\tsys.exit()\narr.sort()\nfor i in range(1, n):\n\td = arr[i] - arr[0]\n\tx = (s[0] - n * (n - 1) // 2 * d + m) % m * modInverse(n, m - 2, m) % m\n\tSum = (n * x * x + n * (n - 1) * d * x + n * (n - 1) * (2 * n - 1) // 6 * d * d) % m\n\tif Sum == s[1] % m:\n\t\tb = [x]\n\t\tfor j in range(1, n):\n\t\t\tb.append((b[j - 1] + d) % m)\n\t\tb.sort()\n\t\tif isEqual(arr, b):\n\t\t\tprint(x, d)\n\t\t\tsys.exit()\nprint('-1')\n",
        "slowest_solution": "def solve(n, m, a):\n\tif n == 0:\n\t\treturn (0, 1)\n\tif n == 1:\n\t\treturn (a[0], 1)\n\td = (a[1] - a[0]) % m\n\tif d < 0:\n\t\td += m\n\tst = set(a)\n\tcnt = 0\n\tfor v in a:\n\t\tcnt += (v + d) % m in st\n\tcnt = n - cnt\n\td = d * pow(cnt, m - 2, m) % m\n\tnow = a[0]\n\twhile (now + m - d) % m in st:\n\t\tnow = (now + m - d) % m\n\tfor i in range(n):\n\t\tif (now + i * d) % m not in st:\n\t\t\treturn (-1, -1)\n\treturn (now, d)\n(m, n) = map(int, input().split())\na = list(map(int, input().split()))\nif n * 2 > m:\n\tst = set(a)\n\tb = [i for i in range(m) if i not in st]\n\t(f, d) = solve(len(b), m, b)\n\tf = (f + d * (m - n)) % m\nelse:\n\t(f, d) = solve(n, m, a)\nif f < 0 or d < 0:\n\tprint(-1)\nelse:\n\tprint(f, d)\n"
    },
    {
        "task_id": 487,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.692650079727173,
        "fastest_time": 2.648519515991211,
        "fastest_solution": "n = int(input())\nh = [int(q) - 1 for q in input().split()]\nu = [set([int(q) - 1 for q in input().split()][1:]) for i in range(n)]\nt = 1000000000.0\n\ndef g():\n\tfor i in p:\n\t\tif h[i] == k and (not v[i]):\n\t\t\treturn i\nfor k in range(3):\n\tp = list(range(n))\n\td = -1\n\tv = [q.copy() for q in u]\n\twhile p:\n\t\ti = g()\n\t\twhile i != None:\n\t\t\td += 1\n\t\t\tp.remove(i)\n\t\t\tfor q in v:\n\t\t\t\tq.discard(i)\n\t\t\ti = g()\n\t\tk = (k + 1) % 3\n\t\td += 1\n\tt = min(d, t)\nprint(t)\n",
        "slowest_solution": "from collections import *\nread_line = lambda : [int(i) for i in input().split(' ')]\nn = read_line()[0]\ncs = [c - 1 for c in read_line()]\ng = [[] for v in range(n)]\nparent_cnt = [0] * n\nfor v in range(n):\n\tparents = read_line()\n\tparent_cnt[v] = len(parents) - 1\n\tfor i in range(1, len(parents)):\n\t\tg[parents[i] - 1].append(v)\n\ndef work(x):\n\tpcnt = list(parent_cnt)\n\tqs = [deque((v for v in range(n) if cs[v] == c and pcnt[v] == 0)) for c in range(3)]\n\tans = 0\n\twhile True:\n\t\twhile qs[x]:\n\t\t\tv = qs[x].popleft()\n\t\t\tans += 1\n\t\t\tfor w in g[v]:\n\t\t\t\tpcnt[w] -= 1\n\t\t\t\tif pcnt[w] == 0:\n\t\t\t\t\tqs[cs[w]].append(w)\n\t\tif qs[0] or qs[1] or qs[2]:\n\t\t\tans += 1\n\t\t\tx = (x + 1) % 3\n\t\telse:\n\t\t\tbreak\n\treturn ans\nprint(min((work(i) for i in range(3))))\n"
    },
    {
        "task_id": 491,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7304465770721436,
        "fastest_time": 2.7304465770721436,
        "fastest_solution": "n = int(input())\nif n & 1:\n\tprint(-1)\nelse:\n\t(D, R) = ([False] * 10 ** 6, [0] * 10 ** 6)\n\t(i, j) = (0, 0)\n\twhile True:\n\t\tD[j] = True\n\t\tR[i] = j\n\t\ti += 1\n\t\tif not D[j + n >> 1]:\n\t\t\tj = j + n >> 1\n\t\telif not D[j >> 1]:\n\t\t\tj = j >> 1\n\t\telse:\n\t\t\tbreak\n\tprint(' '.join((str(R[i]) for i in range(n, -1, -1))))\n",
        "slowest_solution": "n = int(input())\nif n & 1:\n\tprint(-1)\nelse:\n\t(D, R) = ([False] * 10 ** 6, [0] * 10 ** 6)\n\t(i, j) = (0, 0)\n\twhile True:\n\t\tD[j] = True\n\t\tR[i] = j\n\t\ti += 1\n\t\tif not D[j + n >> 1]:\n\t\t\tj = j + n >> 1\n\t\telif not D[j >> 1]:\n\t\t\tj = j >> 1\n\t\telse:\n\t\t\tbreak\n\tprint(' '.join((str(R[i]) for i in range(n, -1, -1))))\n"
    },
    {
        "task_id": 481,
        "slowest_solution_id": 2,
        "fastest_solution_id": 1,
        "slowest_time": 2.6911165714263916,
        "fastest_time": 2.5910019874572754,
        "fastest_solution": "n = int(input())\nip = list(map(int, input().split()))\nip2 = []\nfor i in range(n - 1):\n\tif ip[i + 1] > ip[i]:\n\t\tip2.append((ip[i], 'a'))\n\t\tip2.append((ip[i + 1], 'b'))\n\telse:\n\t\tip2.append((ip[i + 1], 'a'))\n\t\tip2.append((ip[i], 'b'))\nip2 = sorted(ip2, key=lambda x: (x[0], x[1]))\nm = 0\nc = 0\nl = 0\nfor i in range(len(ip2)):\n\t(a, b) = ip2[i]\n\tif a == l:\n\t\tif b == 'a':\n\t\t\tc += 1\n\t\telse:\n\t\t\tc -= 1\n\telse:\n\t\tif c > m:\n\t\t\tm = c\n\t\tif b == 'a':\n\t\t\tc += 1\n\t\telse:\n\t\t\tc -= 1\n\t\tl = a\nprint(m)\n",
        "slowest_solution": "def f(n):\n\ts = list(map(int, input().split()))\n\tlow = []\n\thigh = []\n\tfor i in range(n - 1):\n\t\tlow.append(min(s[i], s[i + 1]))\n\t\thigh.append(max(s[i], s[i + 1]))\n\tlow.sort()\n\thigh.sort()\n\tcurr = mx = 0\n\ti = j = 0\n\tn -= 1\n\twhile i < n and j < n:\n\t\tif low[i] < high[j]:\n\t\t\ti += 1\n\t\t\tcurr += 1\n\t\telse:\n\t\t\tj += 1\n\t\t\tcurr -= 1\n\t\tmx = max(mx, curr)\n\treturn mx\nn = int(input())\nprint(f(n))\n"
    },
    {
        "task_id": 495,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 0.10297799110412598,
        "fastest_time": 0.0,
        "fastest_solution": "import math\n\ndef gta(limit, *args):\n\treturn sum_up(limit, make_pattern(limit, *args))\n\ndef binomial_coeff(n, k):\n\treturn math.factorial(n) / math.factorial(n - k)\n\ndef sum_up(limit, items):\n\ttotal = 0\n\tfor i in range(1, limit + 1):\n\t\tcombin = binomial_coeff(len(items), i)\n\t\tratio = len(items) / float(i)\n\t\tfor element in items:\n\t\t\ttotal += element * (combin / ratio)\n\treturn total\n\ndef make_pattern(limit, *args):\n\tseen = set()\n\tpattern = []\n\titems = list(map(str, args))\n\tk = 0\n\twhile len(pattern) < limit:\n\t\tfor i in range(len(items)):\n\t\t\ttry:\n\t\t\t\tv = items[i][k]\n\t\t\texcept IndexError:\n\t\t\t\tpass\n\t\t\tif v not in seen:\n\t\t\t\tseen.add(v)\n\t\t\t\tpattern.append(int(v))\n\t\t\t\tif len(pattern) == limit:\n\t\t\t\t\tbreak\n\t\tk += 1\n\treturn pattern\n",
        "slowest_solution": "import itertools\n\ndef gta(limit, *args):\n\tx = max((len(str(l)) for l in args))\n\ty = ''\n\tfor i in range(x):\n\t\tfor ix in args:\n\t\t\ttry:\n\t\t\t\tif str(ix)[i] in y:\n\t\t\t\t\tcontinue\n\t\t\t\ty += str(ix)[i]\n\t\t\texcept:\n\t\t\t\tpass\n\tans = 0\n\tfor i in range(1, limit + 1):\n\t\tfor xc in itertools.permutations(y[:limit], i):\n\t\t\tans += sum([sum(map(int, xc))])\n\treturn ans\n"
    },
    {
        "task_id": 478,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 2.627854108810425,
        "fastest_time": 2.5350122451782227,
        "fastest_solution": "def read_data():\n\tn = int(input())\n\tps = list(map(int, input().split()))\n\treturn (n, ps)\n\ndef solve(n, ps):\n\tps = [p - 1 for p in ps]\n\tcycles = [0] * n\n\troots = []\n\thas_odd_cycle = False\n\tfor i in range(n):\n\t\tif cycles[i] > 0:\n\t\t\tcontinue\n\t\tq = ps[i]\n\t\tcycle = 1\n\t\twhile q != i:\n\t\t\tcycle += 1\n\t\t\tq = ps[q]\n\t\tif cycle & 1:\n\t\t\thas_odd_cycle = True\n\t\tcycles[i] = cycle\n\t\troots.append(i)\n\t\tq = ps[i]\n\t\twhile q != i:\n\t\t\tcycles[q] = cycle\n\t\t\tq = ps[q]\n\tmincycle = min(cycles)\n\tif mincycle > 2:\n\t\treturn (False, [])\n\tif mincycle == 1:\n\t\tp = cycles.index(1)\n\t\treturn (True, [(p, i) for i in range(n) if i != p])\n\tif has_odd_cycle:\n\t\treturn (False, [])\n\tp = cycles.index(2)\n\tq = ps[p]\n\tedges = [(p, q)]\n\tfor root in roots:\n\t\tif root == p or root == q:\n\t\t\tcontinue\n\t\tedges.append((p, root))\n\t\tr = ps[root]\n\t\tedges.append((q, r))\n\t\tr = ps[r]\n\t\twhile r != root:\n\t\t\tedges.append((p, r))\n\t\t\tr = ps[r]\n\t\t\tedges.append((q, r))\n\t\t\tr = ps[r]\n\treturn (True, edges)\n(n, ps) = read_data()\n(is_possible, edges) = solve(n, ps)\nif is_possible:\n\tprint('YES')\n\tfor (a, b) in edges:\n\t\tprint(a + 1, b + 1)\nelse:\n\tprint('NO')\n",
        "slowest_solution": "n = int(input())\na = [0] + list(map(int, input().split()))\nvis = [False] * (n + 1)\nlp = []\nfor i in range(1, n + 1):\n\tif vis[i]:\n\t\tcontinue\n\tcur = i\n\tq = []\n\twhile not vis[cur]:\n\t\tvis[cur] = True\n\t\tq.append(cur)\n\t\tcur = a[cur]\n\tlp.append(q)\nlp.sort(key=len)\nres = []\n\ndef solve2():\n\tres.append(tuple(lp[0]))\n\tfor q in lp[1:]:\n\t\tif len(q) % 2 == 1:\n\t\t\tprint('NO')\n\t\t\texit()\n\t\tfor i in range(len(q)):\n\t\t\tres.append((lp[0][i % 2], q[i]))\n\ndef solve1():\n\tfor i in range(1, n + 1):\n\t\tif i == lp[0][0]:\n\t\t\tcontinue\n\t\tres.append((lp[0][0], i))\nif len(lp[0]) >= 3:\n\tprint('NO')\n\texit()\nif len(lp[0]) >= 2:\n\tsolve2()\nelse:\n\tsolve1()\nprint('YES')\nfor (u, v) in res:\n\tprint(u, v)\n"
    },
    {
        "task_id": 485,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.6859841346740723,
        "fastest_time": 2.5199594497680664,
        "fastest_solution": "n = int(input())\nl = [int(i) for i in input().split()]\nstack = []\nans = [0] * n\nleft = [-1] * n\nright = [n] * n\nfor i in range(n):\n\twhile stack != [] and l[i] <= l[stack[-1]]:\n\t\tstack.pop()\n\tif stack != []:\n\t\tleft[i] = stack[-1]\n\tstack.append(i)\nstack = []\nfor i in range(n - 1, -1, -1):\n\twhile stack != [] and l[i] <= l[stack[-1]]:\n\t\tstack.pop()\n\tif stack != []:\n\t\tright[i] = stack[-1]\n\tstack.append(i)\nfor i in range(n):\n\tk = right[i] - left[i] - 1\n\tans[k - 1] = max(ans[k - 1], l[i])\nfor i in range(n - 2, -1, -1):\n\tans[i] = max(ans[i], ans[i + 1])\nprint(*ans)\n",
        "slowest_solution": "from sys import stdin, stdout\n\ndef input():\n\treturn stdin.readline().strip()\n\ndef print(x, end='\\n'):\n\tstdout.write(str(x) + end)\n(n, lst) = (int(input()), list(map(int, input().split())))\n(nse, pse, stk, ans) = ([n for i in range(n)], [-1 for i in range(n)], [], [0 for i in range(n + 1)])\nfor i in range(n):\n\twhile stk and lst[stk[-1]] > lst[i]:\n\t\tnse[stk.pop()] = i\n\tstk.append(i)\nstk.clear()\nfor i in range(n - 1, -1, -1):\n\twhile stk and lst[stk[-1]] > lst[i]:\n\t\tpse[stk.pop()] = i\n\tstk.append(i)\nfor i in range(n):\n\tans[nse[i] - pse[i] - 1] = max(lst[i], ans[nse[i] - pse[i] - 1])\nmnow = ans[n]\nfor i in range(n, -1, -1):\n\tmnow = max(mnow, ans[i])\n\tans[i] = mnow\nprint(' '.join(map(str, ans[1:])))\n"
    },
    {
        "task_id": 493,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.562591552734375,
        "fastest_time": 2.562591552734375,
        "fastest_solution": "for _ in range(int(input())):\n\ts = input().strip()\n\ta = []\n\tlast = 0\n\tfor i in range(len(s)):\n\t\tif s[i] == 'P':\n\t\t\ta.append(i - last)\n\t\t\tlast = i + 1\n\tx = 0\n\ta = a[::-1]\n\tfor v in a[::2]:\n\t\tx ^= v % 3\n\tprint('Yes' if x else 'No')\n",
        "slowest_solution": "for _ in range(int(input())):\n\ts = input().strip()\n\ta = []\n\tlast = 0\n\tfor i in range(len(s)):\n\t\tif s[i] == 'P':\n\t\t\ta.append(i - last)\n\t\t\tlast = i + 1\n\tx = 0\n\ta = a[::-1]\n\tfor v in a[::2]:\n\t\tx ^= v % 3\n\tprint('Yes' if x else 'No')\n"
    },
    {
        "task_id": 450,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.6940252780914307,
        "fastest_time": 2.498248338699341,
        "fastest_solution": "(a, b, m, r0) = map(int, input().split())\nnumbers = {}\ncounter = 0\nperiod = 0\nr = r0\nwhile True:\n\tr1 = (a * r + b) % m\n\tcounter += 1\n\tif r1 in numbers:\n\t\tperiod = counter - numbers[r1]\n\t\tbreak\n\telse:\n\t\tnumbers[r1] = counter\n\t\tr = r1\nprint(period)\n",
        "slowest_solution": "import sys\n(a, b, m, x) = tuple(map(int, input().split()))\nz = [0] * (m + 1)\ncnt = 1\nz[x] = cnt\nwhile True:\n\tcnt += 1\n\tx = (x * a + b) % m\n\tif z[x] > 0:\n\t\tprint(str(cnt - z[x]))\n\t\tsys.exit(0)\n\tz[x] = cnt\n"
    },
    {
        "task_id": 447,
        "slowest_solution_id": 7,
        "fastest_solution_id": 9,
        "slowest_time": 2.722707509994507,
        "fastest_time": 2.53631591796875,
        "fastest_solution": "from collections import defaultdict as dd, deque as dq, Counter as c\nfrom math import factorial as f, ceil, gcd, sqrt\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\td = dd(lambda : 0)\n\tp = dd(lambda : 0)\n\tans = float('inf')\n\tif a % b != 0:\n\t\tprint(a)\n\telse:\n\t\tco = 0\n\t\twhile b % 2 == 0:\n\t\t\td[2] += 1\n\t\t\tb //= 2\n\t\ttemp = b\n\t\tfor i in range(3, int(sqrt(temp)) + 1, 2):\n\t\t\tif b % i == 0:\n\t\t\t\tco = 0\n\t\t\t\twhile b % i == 0:\n\t\t\t\t\td[i] += 1\n\t\t\t\t\tb //= i\n\t\tif b > 2:\n\t\t\td[b] = 1\n\t\ttemp = a\n\t\tfor i in d:\n\t\t\twhile temp % i == 0:\n\t\t\t\tp[i] += 1\n\t\t\t\ttemp //= i\n\t\t\tans = min(ans, i ** (p[i] - d[i] + 1))\n\t\tprint(a // ans)\n",
        "slowest_solution": "from sys import stdin, gettrace\nif gettrace():\n\tinputi = input\nelse:\n\n\tdef input():\n\t\treturn next(stdin)[:-1]\n\n\tdef inputi():\n\t\treturn stdin.buffer.readline()\n\ndef solve():\n\t(p, q) = map(int, inputi().split())\n\tif p % q != 0:\n\t\tprint(p)\n\t\treturn\n\tqf = {}\n\tqr = q\n\ti = 2\n\twhile i * i <= qr:\n\t\twhile qr % i == 0:\n\t\t\tqf[i] = qf.get(i, 0) + 1\n\t\t\tqr //= i\n\t\ti += 1\n\tif qr != 1:\n\t\tqf[qr] = 1\n\tpf = {}\n\tpr = p\n\tfor f in qf.keys():\n\t\tpf[f] = 0\n\t\twhile pr % f == 0:\n\t\t\tpf[f] += 1\n\t\t\tpr //= f\n\tbest = 0\n\tfor f in qf.keys():\n\t\tbest = max(p // f ** (pf[f] - qf[f] + 1), best)\n\tprint(best)\n\ndef main():\n\tt = int(inputi())\n\tfor _ in range(t):\n\t\tsolve()\nmain()\n"
    },
    {
        "task_id": 453,
        "slowest_solution_id": 7,
        "fastest_solution_id": 3,
        "slowest_time": 2.7374513149261475,
        "fastest_time": 2.5189502239227295,
        "fastest_solution": "def dp(ind, max_covered):\n\tmax_covered = min(m, max_covered)\n\tif ind not in cache:\n\t\tcache[ind] = {}\n\td = cache[ind]\n\tif max_covered in d:\n\t\treturn d[max_covered]\n\tans = blah(ind, max_covered)\n\td[max_covered] = ans\n\treturn ans\n\nclass Node:\n\n\tdef __init__(self, key, val, next=None):\n\t\tself.key = key\n\t\tself.val = val\n\t\tself.next = next\n\ndef blah(ind, max_covered):\n\t(x, s) = antenna[ind]\n\tif max_covered >= m:\n\t\treturn 0\n\tif ind == len(antenna) - 1:\n\t\tif max_covered < x - s - 1:\n\t\t\tleft_needed = x - s - (max_covered + 1)\n\t\t\tright_needed = max(m - (x + s), 0)\n\t\t\tans = max(left_needed, right_needed)\n\t\t\treturn ans\n\t\telse:\n\t\t\tright_boundary = max(max_covered, x + s)\n\t\t\tans = max(0, m - right_boundary)\n\t\t\treturn ans\n\tif max_covered < x - s - 1:\n\t\tnum_needed = x - s - (max_covered + 1)\n\t\tnew_boundary = min(x + s + num_needed, m)\n\t\tuse_i = num_needed + dp(ind + 1, new_boundary)\n\t\tdont_use_i = dp(ind + 1, max_covered)\n\t\treturn min(use_i, dont_use_i)\n\telse:\n\t\tnew_boundary = min(max(max_covered, x + s), m)\n\t\tans = dp(ind + 1, new_boundary)\n\t\treturn ans\nimport sys\ncache = {}\n(n, m) = [int(x) for x in sys.stdin.readline().split(' ')]\nantenna = []\nfor i in range(n):\n\t(x, s) = [int(x) for x in sys.stdin.readline().split(' ')]\n\tantenna.append((x, s))\nantenna.sort(key=lambda a: a[0])\nprint(dp(0, 0))\n",
        "slowest_solution": "import os\nimport sys\n\ndef solve(xs, m):\n\txs = [(0, 0)] + xs\n\tdp = [0] * (m + 1)\n\tfor i in range(1, m + 1):\n\t\tdp[i] = dp[i - 1] + 1\n\t\tfor (idx, (x, s)) in enumerate(xs):\n\t\t\tif x - s <= i <= x + s:\n\t\t\t\tdp[i] = dp[i - 1]\n\t\t\t\tbreak\n\t\t\tif x + s < i:\n\t\t\t\tc = i - x - s\n\t\t\t\tdp[i] = min(c + dp[max(x - c - s - 1, 0)], dp[i])\n\treturn dp[-1]\n\ndef pp(input):\n\t(n, m) = list(map(int, input().split()))\n\txs = [tuple(map(int, input().split())) for _ in range(n)]\n\tprint(solve(xs, m))\nif 'paalto' in os.getcwd():\n\tfrom string_source import string_source\n\tpp(string_source('2 50\\n20 0\\n3 1\\n'))\n\tpp(string_source('3 595\\n43 2\\n300 4\\n554 10\\n'))\n\tpp(string_source('1 1\\n1 1\\n'))\n\tpp(string_source('5 240\\n13 0\\n50 25\\n60 5\\n155 70\\n165 70\\n'))\nelse:\n\tpp(sys.stdin.readline)\n"
    },
    {
        "task_id": 463,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 2.7071900367736816,
        "fastest_time": 2.570990562438965,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ta = input()\n\tif k == n:\n\t\tk -= 1\n\t(num, ret) = (sum((x == '1' for x in a[:k + 1])), 0)\n\tfor i in range(n):\n\t\tif a[i] == '1':\n\t\t\tret += 2 * num - 1\n\t\tif a[i] == '1':\n\t\t\tnum -= 1\n\t\tif i + k + 1 < n and a[i + k + 1] == '1':\n\t\t\tnum += 1\n\t(x, y) = (ret, n * n)\n\twhile x > 0 and y > 0:\n\t\tif x >= y:\n\t\t\tx %= y\n\t\telse:\n\t\t\ty %= x\n\t(num, den) = (ret // (x + y), n * n // (x + y))\n\tprint(str(num) + '/' + str(den))\n",
        "slowest_solution": "from fractions import *\nT = int(input())\nfor t in range(T):\n\t(N, K) = map(int, input().split())\n\tS = input()\n\tones = 0\n\tans = 0\n\tfor i in range(N):\n\t\tif S[i] == '1':\n\t\t\tans += ones * 2 + 1\n\t\t\tones += 1\n\t\tif i >= K and S[i - K] == '1':\n\t\t\tones -= 1\n\tans = Fraction(ans, N * N)\n\tprint('%d/%d' % (ans.numerator, ans.denominator))\n"
    },
    {
        "task_id": 457,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.711801052093506,
        "fastest_time": 2.5009796619415283,
        "fastest_solution": "(m, n) = list(map(int, input().split()))\nt = [set([i for i in list(map(int, input().split()))[1:]]) for _ in range(m)]\nfor i in range(m - 1):\n\tfor j in range(i + 1, m):\n\t\tif len(t[i] & t[j]) == 0:\n\t\t\tprint('impossible')\n\t\t\tbreak\n\telse:\n\t\tcontinue\n\tbreak\nelse:\n\tprint('possible')\n",
        "slowest_solution": "import sys, math, queue, bisect\nMOD = 10 ** 9 + 7\nsys.setrecursionlimit(1000000)\n(m, n) = map(int, input().split())\ns = [None for i in range(m)]\nfor i in range(m):\n\tx = list(map(int, input().split()))\n\ts[i] = set(x[1:])\nfor i in range(m):\n\tfor j in range(m):\n\t\tif s[i] & s[j] == set():\n\t\t\tprint('impossible')\n\t\t\texit()\nprint('possible')\n"
    },
    {
        "task_id": 452,
        "slowest_solution_id": 7,
        "fastest_solution_id": 4,
        "slowest_time": 2.7150254249572754,
        "fastest_time": 2.4773061275482178,
        "fastest_solution": "for _ in range(int(input())):\n\tN = int(input())\n\tA = input().strip()\n\tevens = sorted(A[:N:2])\n\todds = sorted(A[1:N:2])\n\tif evens == odds:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "testcase = int(input())\nfor _ in range(testcase):\n\tN = int(input())\n\tarr = input()\n\teven_str = list(arr[::2])\n\todd_str = list(arr[1::2])\n\teven_str.sort()\n\todd_str.sort()\n\tif even_str == odd_str:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 454,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.745842456817627,
        "fastest_time": 2.5144412517547607,
        "fastest_solution": "t = int(input())\nfor z in range(t):\n\tn = int(input())\n\ti = 0\n\twhile n >= 2 ** i:\n\t\ti += 1\n\tif i == 1:\n\t\tprint(1)\n\telif n - 2 ** (i - 1) + 1 > 2 ** (i - 2):\n\t\tprint(n - 2 ** (i - 1) + 1)\n\telse:\n\t\tprint(2 ** (i - 2))\n",
        "slowest_solution": "import math\nfor _ in range(int(input())):\n\tn = int(input())\n\tp = int(math.log2(n))\n\tif n - 2 ** p + 1 >= 2 ** (p - 1):\n\t\tprint(n - 2 ** p + 1)\n\telse:\n\t\tprint(2 ** (p - 1))\n"
    },
    {
        "task_id": 455,
        "slowest_solution_id": 5,
        "fastest_solution_id": 2,
        "slowest_time": 2.6655125617980957,
        "fastest_time": 2.536149501800537,
        "fastest_solution": "x = int(input())\n\ndef cal(n, c, arr):\n\tt = [0] * n\n\tfor i in range(n):\n\t\tt[i] = t[i - 1] + arr[i] - c\n\tp = []\n\tfor i in range(n):\n\t\tre = 0\n\t\tk = 1\n\t\tfor j in range(i, n):\n\t\t\torg = arr[j] >> k\n\t\t\tre += org\n\t\t\tk += 1\n\t\t\tif k >= 30:\n\t\t\t\tbreak\n\t\tp.append(re)\n\tres = max(p[0], t[-1])\n\tfor i in range(n - 1):\n\t\tres = max(res, t[i] + p[i + 1])\n\treturn res\nfor jj in range(x):\n\t(n, c) = [int(i) for i in input().split(' ')]\n\tarr = [int(i) for i in input().split(' ')]\n\tprint(cal(n, c, arr))\n",
        "slowest_solution": "import itertools\nMAX = 29\nPOW = [2 ** (i + 1) for i in range(MAX)]\n\ndef calc(g):\n\treturn -k * g + s[g] + sum((a[g + i] // POW[i] for i in range(min(n - g, MAX))))\nfor _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\ts = list(itertools.accumulate(a, initial=0))\n\tprint(max((calc(g) for g in range(0, n + 1))))\n"
    },
    {
        "task_id": 502,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.639970302581787,
        "fastest_time": 2.639970302581787,
        "fastest_solution": "import sys\nimport numpy as np\n\ndef mpow_mod(M, k, mod):\n\tret = np.identity(M.shape[0], dtype=np.int64)\n\twhile k > 0:\n\t\tif k & 1:\n\t\t\tret = ret.dot(M)\n\t\t\tret %= mod\n\t\tM = M.dot(M)\n\t\tM %= mod\n\t\tk >>= 1\n\treturn ret\n\ndef lap(M):\n\tn = M.shape[0]\n\tL = np.zeros((n, n), dtype=np.int64)\n\tL[range(n), range(n)] = np.sum(M, 0)\n\tL -= M\n\treturn L\n\ndef int_array(m):\n\tret = np.array([int(x) for x in m.flat], dtype=object)\n\tret = ret.reshape(m.shape)\n\treturn ret\n\ndef mred(m):\n\tn = m.shape[0]\n\tret = m[1:, 1:]\n\tfor i in range(n - 1):\n\t\tfor j in range(n - 1):\n\t\t\tret[i, j] = m[0, 0] * m[i + 1, j + 1] - m[i + 1, 0] * m[0, j + 1]\n\treturn ret\n\ndef det(m):\n\ta = 1\n\twhile m.shape[0] > 1:\n\t\tb = m[0, 0]\n\t\tif a == 0:\n\t\t\treturn 0\n\t\tm = mred(m) // a\n\t\ta = b\n\treturn m[0, 0]\n\ndef solve(M, k, x):\n\tn = M.shape[0]\n\tI = np.identity(n, dtype=np.int64)\n\tM0 = np.vstack((np.hstack((M, I)), np.hstack((I * 0, I))))\n\tM1 = mpow_mod(M0, k + 1, x)[:n, n:]\n\tM1[range(n), range(n)] = 0\n\tif n == 1:\n\t\treturn 1\n\tif n == 2:\n\t\treturn M1[0, 1]\n\tL = lap(M1)[1:, 1:]\n\treturn det(int_array(L))\nf = sys.stdin\n(n, m, x, k) = map(int, f.readline().split())\nM = np.zeros((n, n), dtype=np.int64)\nfor i in range(m):\n\t(a, b) = map(int, f.readline().split())\n\tM[a - 1, b - 1] = M[b - 1, a - 1] = 1\nprint(solve(M, k, x))\n",
        "slowest_solution": "import sys\nimport numpy as np\n\ndef mpow_mod(M, k, mod):\n\tret = np.identity(M.shape[0], dtype=np.int64)\n\twhile k > 0:\n\t\tif k & 1:\n\t\t\tret = ret.dot(M)\n\t\t\tret %= mod\n\t\tM = M.dot(M)\n\t\tM %= mod\n\t\tk >>= 1\n\treturn ret\n\ndef lap(M):\n\tn = M.shape[0]\n\tL = np.zeros((n, n), dtype=np.int64)\n\tL[range(n), range(n)] = np.sum(M, 0)\n\tL -= M\n\treturn L\n\ndef int_array(m):\n\tret = np.array([int(x) for x in m.flat], dtype=object)\n\tret = ret.reshape(m.shape)\n\treturn ret\n\ndef mred(m):\n\tn = m.shape[0]\n\tret = m[1:, 1:]\n\tfor i in range(n - 1):\n\t\tfor j in range(n - 1):\n\t\t\tret[i, j] = m[0, 0] * m[i + 1, j + 1] - m[i + 1, 0] * m[0, j + 1]\n\treturn ret\n\ndef det(m):\n\ta = 1\n\twhile m.shape[0] > 1:\n\t\tb = m[0, 0]\n\t\tif a == 0:\n\t\t\treturn 0\n\t\tm = mred(m) // a\n\t\ta = b\n\treturn m[0, 0]\n\ndef solve(M, k, x):\n\tn = M.shape[0]\n\tI = np.identity(n, dtype=np.int64)\n\tM0 = np.vstack((np.hstack((M, I)), np.hstack((I * 0, I))))\n\tM1 = mpow_mod(M0, k + 1, x)[:n, n:]\n\tM1[range(n), range(n)] = 0\n\tif n == 1:\n\t\treturn 1\n\tif n == 2:\n\t\treturn M1[0, 1]\n\tL = lap(M1)[1:, 1:]\n\treturn det(int_array(L))\nf = sys.stdin\n(n, m, x, k) = map(int, f.readline().split())\nM = np.zeros((n, n), dtype=np.int64)\nfor i in range(m):\n\t(a, b) = map(int, f.readline().split())\n\tM[a - 1, b - 1] = M[b - 1, a - 1] = 1\nprint(solve(M, k, x))\n"
    },
    {
        "task_id": 456,
        "slowest_solution_id": 8,
        "fastest_solution_id": 9,
        "slowest_time": 2.7085437774658203,
        "fastest_time": 2.5308783054351807,
        "fastest_solution": "p = int(input())\nt = ''\nfor _ in range(p):\n\tx = input().split()\n\tif x[0] == '+':\n\t\tt = t[:int(x[1])] + x[2] + t[int(x[1]):]\n\telif x[0] == '?':\n\t\tprint(t[int(x[1]) - 1:int(x[2]) + int(x[1]) - 1])\n",
        "slowest_solution": "n = int(input())\nl = []\nfor i in range(n):\n\tz = input().split()\n\tl.append(z)\nS = ''\nfor i in l:\n\tif i[0] == '+':\n\t\tZ = S[0:int(i[1])]\n\t\tz1 = S[int(i[1]):len(S)]\n\t\tz2 = Z + i[2] + z1\n\t\tS = z2\n\telif i[0] == '?':\n\t\tz3 = S[int(i[1]) - 1:int(i[2]) + int(i[1]) - 1]\n\t\tprint(z3)\n"
    },
    {
        "task_id": 506,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6430041790008545,
        "fastest_time": 2.6430041790008545,
        "fastest_solution": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\n(h, w) = map(int, input().split())\nd = w + 2\nb = [0] * (w + 2)\nfor i in range(h):\n\tb += [0] + [int(j == 'X') for j in input()] + [0]\nb += [0] * (w + 2)\nco = sum(b)\nt = 10 ** 10\nfor i in range(1, h + 1):\n\tf = 0\n\tfor j in range(w + 2):\n\t\tf += b[i * d + j]\n\t\tif b[i * d + j] == 0 and f:\n\t\t\tt = min(t, (f - 1) // 2)\n\t\t\tf = 0\nfor j in range(1, w + 1):\n\tf = 0\n\tfor i in range(h + 2):\n\t\tf += b[i * d + j]\n\t\tif b[i * d + j] == 0 and f:\n\t\t\tt = min(t, (f - 1) // 2)\n\t\t\tf = 0\ncoo = 0\nans = [-1] * (w + 2) * (h + 2)\nstack = []\nfor i in range(h + 2):\n\tfor j in range(w + 2):\n\t\tif b[i * d + j] == 0:\n\t\t\tstack.append(i * d + j)\n\t\t\tans[i * d + j] = 0\ndij = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\nfor ij in stack:\n\t(i, j) = divmod(ij, d)\n\tfor (x, y) in dij:\n\t\tif 0 <= i + x < h + 2 and 0 <= j + y < w + 2:\n\t\t\tif ans[(i + x) * d + j + y] == -1:\n\t\t\t\tans[(i + x) * d + j + y] = ans[i * d + j] + 1\n\t\t\t\tif ans[(i + x) * d + j + y] > t:\n\t\t\t\t\tcoo += 1\n\t\t\t\tstack.append((i + x) * d + (j + y))\nif coo * 6 < co and t == 1:\n\tt -= 1\nprint(t)\nfor i in range(1, h + 1):\n\tprint(''.join(['.X'[int(t < j)] for j in ans[i * d + 1:i * d + w + 1]]))\n",
        "slowest_solution": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\n(h, w) = map(int, input().split())\nd = w + 2\nb = [0] * (w + 2)\nfor i in range(h):\n\tb += [0] + [int(j == 'X') for j in input()] + [0]\nb += [0] * (w + 2)\nco = sum(b)\nt = 10 ** 10\nfor i in range(1, h + 1):\n\tf = 0\n\tfor j in range(w + 2):\n\t\tf += b[i * d + j]\n\t\tif b[i * d + j] == 0 and f:\n\t\t\tt = min(t, (f - 1) // 2)\n\t\t\tf = 0\nfor j in range(1, w + 1):\n\tf = 0\n\tfor i in range(h + 2):\n\t\tf += b[i * d + j]\n\t\tif b[i * d + j] == 0 and f:\n\t\t\tt = min(t, (f - 1) // 2)\n\t\t\tf = 0\ncoo = 0\nans = [-1] * (w + 2) * (h + 2)\nstack = []\nfor i in range(h + 2):\n\tfor j in range(w + 2):\n\t\tif b[i * d + j] == 0:\n\t\t\tstack.append(i * d + j)\n\t\t\tans[i * d + j] = 0\ndij = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\nfor ij in stack:\n\t(i, j) = divmod(ij, d)\n\tfor (x, y) in dij:\n\t\tif 0 <= i + x < h + 2 and 0 <= j + y < w + 2:\n\t\t\tif ans[(i + x) * d + j + y] == -1:\n\t\t\t\tans[(i + x) * d + j + y] = ans[i * d + j] + 1\n\t\t\t\tif ans[(i + x) * d + j + y] > t:\n\t\t\t\t\tcoo += 1\n\t\t\t\tstack.append((i + x) * d + (j + y))\nif coo * 6 < co and t == 1:\n\tt -= 1\nprint(t)\nfor i in range(1, h + 1):\n\tprint(''.join(['.X'[int(t < j)] for j in ans[i * d + 1:i * d + w + 1]]))\n"
    },
    {
        "task_id": 464,
        "slowest_solution_id": 9,
        "fastest_solution_id": 1,
        "slowest_time": 2.7546942234039307,
        "fastest_time": 2.5040204524993896,
        "fastest_solution": "n = int(input())\nl = input()\nr = input()\nif n == 1:\n\tprint(r)\nelif l[0] == '0':\n\tprint('1' * n)\nelif r[-1] == '0' and int(l, 2) + 1 < int(r, 2):\n\tprint(r[:-1] + '1')\nelse:\n\tprint(r)\n",
        "slowest_solution": "from sys import stdin, stdout\nfrom collections import defaultdict\nimport math\n\ndef main():\n\tn = int(stdin.readline())\n\tl = stdin.readline().strip()\n\tr = stdin.readline().strip()\n\tif r[0] == '1' and l[0] == '0':\n\t\tans = '1' * n\n\t\tstdout.write(ans + '\\n')\n\t\treturn\n\tif r[-1] == '1':\n\t\tstdout.write(r + '\\n')\n\t\treturn\n\tis_plus = False\n\tpre_plus = False\n\tfor i in range(1, n):\n\t\tif not pre_plus and r[i] == '1' and (l[i] == '0'):\n\t\t\tpre_plus = True\n\t\telif pre_plus and r[i] == '1':\n\t\t\tis_plus = True\n\t\t\tbreak\n\tif not is_plus:\n\t\tif l[-2:] == '00' and r[-2:] == '10':\n\t\t\tis_plus = True\n\tif is_plus:\n\t\tstdout.write(r[:-1] + '1\\n')\n\telse:\n\t\tstdout.write(r + '\\n')\nmain()\n"
    },
    {
        "task_id": 467,
        "slowest_solution_id": 0,
        "fastest_solution_id": 5,
        "slowest_time": 2.8019473552703857,
        "fastest_time": 2.512446165084839,
        "fastest_solution": "import numpy as np\n(n, q) = map(int, input().split())\nA = list(map(int, input().split()))\nxor = [A[0]]\nfor i in range(1, n):\n\txor.append(xor[i - 1] ^ A[i])\nxor = np.array(xor)\nfor i in range(q):\n\t(ii, index, x) = map(int, input().split())\n\tif ii == 1:\n\t\ty = A[index - 1] ^ x\n\t\tA[index - 1] = x\n\t\txor[index - 1:] ^= y\n\telse:\n\t\tprint(np.count_nonzero(xor[:index] == x))\n",
        "slowest_solution": "gstart = [0 for i in range(1000)]\ngend = [0 for i in range(1000)]\ngxor = [0 for i in range(1000)]\ngid = [0 for i in range(10 ** 6 + 100)]\ngcnt = [{} for j in range(1000)]\nps = [0 for i in range(10 ** 5 + 10)]\n\ndef buildSqrtDecomp(n):\n\tgsize = 1\n\twhile gsize * gsize < n:\n\t\tgsize += 1\n\tng = 0\n\tfor i in range(0, n, gsize):\n\t\tgstart[ng] = i\n\t\tgend[ng] = i + gsize - 1\n\t\tng += 1\n\tgend[ng - 1] = n - 1\n\tfor g in range(ng):\n\t\tgxor[g] = 0\n\t\tfor i in range(gstart[g], gend[g] + 1):\n\t\t\tif ps[i] in gcnt[g]:\n\t\t\t\tgcnt[g][ps[i]] += 1\n\t\t\telse:\n\t\t\t\tgcnt[g][ps[i]] = 1\n\t\t\tgid[i] = g\n\treturn gsize\n(n, q) = [int(c) for c in input().split()]\narr = [int(i) for i in input().split()]\ncurrXor = 0\nfor i in range(len(arr)):\n\tcurrXor ^= arr[i]\n\tps[i] = currXor\ngsize = buildSqrtDecomp(n)\nfor _ in range(q):\n\t(op, i, x) = [int(c) for c in input().split()]\n\tif op == 1:\n\t\ti -= 1\n\t\tblock_number = gid[i]\n\t\tc = arr[i] ^ x\n\t\tarr[i] = x\n\t\tfor j in range(i, gend[block_number] + 1):\n\t\t\tgcnt[block_number][ps[j]] -= 1\n\t\t\tps[j] ^= c\n\t\t\tif ps[j] in gcnt[block_number]:\n\t\t\t\tgcnt[block_number][ps[j]] += 1\n\t\t\telse:\n\t\t\t\tgcnt[block_number][ps[j]] = 1\n\t\tfor j in range(gid[i] + 1, gsize + 1):\n\t\t\tgxor[j] ^= c\n\telse:\n\t\ti -= 1\n\t\tblock_number = gid[i]\n\t\tans = 0\n\t\tfor j in range(gstart[block_number], i + 1):\n\t\t\tif ps[j] ^ gxor[block_number] == x:\n\t\t\t\tans += 1\n\t\tfor j in range(0, block_number):\n\t\t\tif x ^ gxor[j] in gcnt[j]:\n\t\t\t\tans += gcnt[j][x ^ gxor[j]]\n\t\tprint(ans)\n"
    },
    {
        "task_id": 468,
        "slowest_solution_id": 9,
        "fastest_solution_id": 3,
        "slowest_time": 2.72963547706604,
        "fastest_time": 2.5436623096466064,
        "fastest_solution": "mod = 998244353\n(n, p) = map(int, input().split())\nr = pow(2, -1, mod)\nx = pow(p, -1, mod)\nm = 0\na = 1\nprint(r, end=' ')\nfor i in range(n - 1):\n\tm += pow(x, i, mod)\n\ta = x * a % mod\n\tr += a * pow(2, -1, mod) * m + pow(a, 2, mod) * pow(2, -1, mod)\n\tr = r % mod\n\tprint(r, end=' ')\n",
        "slowest_solution": "def mod_inv(a, MOD):\n\treturn pow(a, MOD - 2, MOD)\n(N, P) = map(int, input().split())\nMOD = 998244353\ndp = [0] * (N + 1)\ndp2 = [0] * (N + 1)\ndp[1] = dp2[1] = mod_inv(2, MOD)\ninv2 = mod_inv(2, MOD)\nfor i in range(2, N + 1):\n\ty = pow(P, i - 1, MOD)\n\ty = mod_inv(y, MOD)\n\tval = (dp[i - 1] + pow(y, 2, MOD) * inv2 % MOD + y * dp2[i - 1] % MOD) % MOD\n\tdp[i] = val\n\tdp2[i] = (dp2[i - 1] + y * inv2 % MOD) % MOD\nfor i in range(1, N + 1):\n\tprint(dp[i], end=' ')\n"
    },
    {
        "task_id": 488,
        "slowest_solution_id": 4,
        "fastest_solution_id": 4,
        "slowest_time": 2.6946098804473877,
        "fastest_time": 2.6946098804473877,
        "fastest_solution": "n = int(input())\nif n <= 5:\n\tprint(-1)\nelse:\n\tprint(1, 2)\n\tprint(1, 3)\n\tprint(1, 4)\n\tprint(2, 5)\n\tprint(2, 6)\n\tfor i in range(7, n + 1):\n\t\tprint(1, i)\nfor i in range(2, n + 1):\n\tprint(1, i)\n",
        "slowest_solution": "n = int(input())\nif n <= 5:\n\tprint(-1)\nelse:\n\tprint(1, 2)\n\tprint(1, 3)\n\tprint(1, 4)\n\tprint(2, 5)\n\tprint(2, 6)\n\tfor i in range(7, n + 1):\n\t\tprint(1, i)\nfor i in range(2, n + 1):\n\tprint(1, i)\n"
    },
    {
        "task_id": 470,
        "slowest_solution_id": 9,
        "fastest_solution_id": 7,
        "slowest_time": 2.691450834274292,
        "fastest_time": 2.5058250427246094,
        "fastest_solution": "def res(n, k, a):\n\tans = 0\n\tfor i in range(n):\n\t\tans += a[i] // k\n\t\ta[i] %= k\n\ta.sort()\n\ti = 0\n\tj = n - 1\n\twhile i < j:\n\t\tif a[i] + a[j] >= k:\n\t\t\tans += 1\n\t\t\tj -= 1\n\t\ti += 1\n\treturn ans\nt = int(input())\nfor _ in range(t):\n\t(n, k) = map(int, input().split())\n\ta = [int(x) for x in input().split()]\n\tprint(res(n, k, a))\n",
        "slowest_solution": "from sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n\t(n, k) = map(int, input().split(' '))\n\ta = list(map(int, input().split(' ')))\n\tans = sum((_ // k for _ in a))\n\tm = [_ % k for _ in a]\n\tm.sort()\n\t(x, y) = (0, n - 1)\n\twhile x < y:\n\t\tif m[x] + m[y] >= k:\n\t\t\tans += 1\n\t\t\tx += 1\n\t\t\ty -= 1\n\t\telse:\n\t\t\tx += 1\n\tprint(ans)\n"
    },
    {
        "task_id": 477,
        "slowest_solution_id": 4,
        "fastest_solution_id": 6,
        "slowest_time": 2.703207015991211,
        "fastest_time": 2.4995968341827393,
        "fastest_solution": "def simulate(b, n1, m2, h, x1):\n\tneed = 0\n\tlimit = b[0] - 1 + 2 * h\n\tif limit > x1:\n\t\treturn False\n\tfor i in range(1, n1):\n\t\tif limit + 2 * h <= x1:\n\t\t\tlimit += 2 * h\n\t\telse:\n\t\t\tlimit = b[i] - 1 + 2 * h\n\t\t\tneed += 1\n\treturn need < m2\nfor _ in range(int(input())):\n\t(n1, m2, h) = map(int, input().split())\n\tb = []\n\tfor _ in range(n1):\n\t\t(ai, bi) = map(int, input().split())\n\t\tb.append(bi)\n\tb.sort(reverse=True)\n\t(low, high) = (0, 20 ** 25)\n\twhile low < high:\n\t\tmid = (low + high) // 2\n\t\tif simulate(b, n1, m2, h, mid):\n\t\t\thigh = mid\n\t\telse:\n\t\t\tlow = mid + 1\n\tprint(low)\n",
        "slowest_solution": "def funSim(b, n, m, h, x):\n\tnd = 0\n\tmaap = b[0] - 1 + 2 * h\n\tif maap > x:\n\t\treturn False\n\tfor i in range(1, n):\n\t\tif maap + 2 * h <= x:\n\t\t\tmaap += 2 * h\n\t\telse:\n\t\t\tmaap = b[i] - 1 + 2 * h\n\t\t\tnd += 1\n\treturn nd < m\nfor _ in range(int(input())):\n\t(n, m, h) = map(int, input().split())\n\tb = []\n\tfor _ in range(n):\n\t\t(ai, bi) = map(int, input().split())\n\t\tb.append(bi)\n\tb.sort(reverse=True)\n\t(loww, highh) = (0, 10 ** 15)\n\twhile loww < highh:\n\t\tmid = (loww + highh) // 2\n\t\tif funSim(b, n, m, h, mid):\n\t\t\thighh = mid\n\t\telse:\n\t\t\tloww = mid + 1\n\tprint(loww)\n"
    },
    {
        "task_id": 472,
        "slowest_solution_id": 8,
        "fastest_solution_id": 6,
        "slowest_time": 2.717769145965576,
        "fastest_time": 2.5079452991485596,
        "fastest_solution": "from collections import defaultdict\nfor _ in range(int(input())):\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\td = defaultdict(lambda : 0)\n\tfor i in A:\n\t\tz = str(bin(i))\n\t\td[len(z)] += 1\n\tc = 0\n\tfor i in d:\n\t\tc += d[i] * (d[i] - 1) // 2\n\tprint(c)\n",
        "slowest_solution": "from collections import Counter\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = []\n\tfor i in range(n):\n\t\tb.append(len(bin(a[i])[2:]))\n\tc = Counter(b)\n\tres = 0\n\tfor x in c.values():\n\t\tres += x * (x - 1) // 2\n\tprint(res)\n"
    },
    {
        "task_id": 473,
        "slowest_solution_id": 8,
        "fastest_solution_id": 6,
        "slowest_time": 2.7046773433685303,
        "fastest_time": 2.5387232303619385,
        "fastest_solution": "from itertools import permutations\nn = int(input())\n(p1, _, p2, _, p3, _, p4) = ([input() for _ in range(n)], input(), [input() for _ in range(n)], input(), [input() for _ in range(n)], input(), [input() for _ in range(n)])\n\ndef count(a, b, c, d):\n\tboard = [a[i] + b[i] for i in range(n)] + [c[i] + d[i] for i in range(n)]\n\tres = 0\n\tfor i in range(2 * n):\n\t\tfor j in range(2 * n):\n\t\t\tclr = '1' if (i + j) % 2 == 0 else '0'\n\t\t\tres += board[i][j] != clr\n\treturn res\nprint(min((count(*p) for p in permutations([p1, p2, p3, p4]))))\n",
        "slowest_solution": "from itertools import permutations\n\ndef min_cnt(a_):\n\n\tdef foo(abracadabra, f):\n\t\tflag = f\n\t\tcnt = 0\n\t\tfor i in abracadabra:\n\t\t\tic = i[:]\n\t\t\tfor x in range(len(i)):\n\t\t\t\tflag = not flag\n\t\t\t\tif flag == i[x]:\n\t\t\t\t\tcnt += 1\n\t\t\t\t\tic[x] = not ic[x]\n\t\t\tflag = not ic[0]\n\t\treturn cnt\n\treturn min(foo(a_, True), foo(a_, False))\n\ndef concat(a, b, c, d):\n\tabcd = []\n\tfor x in (zip(a, b), zip(c, d)):\n\t\tx_ = []\n\t\tfor (i, j) in x:\n\t\t\tx_.append(i + j)\n\t\tabcd += x_\n\treturn abcd\nn = int(input())\n(a, b, c, d) = [list(filter(None, [[y == '1' for y in input()] for x in range(n + (z != 3))])) for z in range(4)]\nm = float('inf')\nr = None\nfor (a, b, c, d) in permutations([a, b, c, d]):\n\tmp = m\n\tm = min(m, min_cnt(concat(a, b, c, d)))\n\tif m != mp:\n\t\tr = concat(a, b, c, d)\nprint(m)\n"
    },
    {
        "task_id": 474,
        "slowest_solution_id": 8,
        "fastest_solution_id": 6,
        "slowest_time": 2.699188709259033,
        "fastest_time": 2.49832820892334,
        "fastest_solution": "mod = int(1000000000.0 + 7)\n\ndef expo(b, e):\n\tans = 1\n\twhile e:\n\t\tif e & 1:\n\t\t\tans = ans * b % mod\n\t\t\te -= 1\n\t\telse:\n\t\t\tb = b ** 2 % mod\n\t\t\te = e >> 1\n\treturn int(ans)\nt = int(input())\nwhile t:\n\t(n, k, m) = map(int, input().strip().split())\n\tif m & 1:\n\t\tden = expo(n, (m + 1) // 2)\n\t\tnum = expo(n - 1, (m + 1) // 2)\n\t\tinvden = expo(den, mod - 2) % mod\n\t\tans = (den - num + mod) % mod * invden % mod\n\telse:\n\t\tden = expo(n, m // 2) * (k + n) % mod % mod\n\t\tnum = expo(n - 1, m // 2) * ((k + n - 1) % mod) % mod\n\t\tinvden = expo(den, mod - 2) % mod\n\t\tans = (den - num + mod) % mod * invden % mod\n\tprint(int(ans))\n\tt -= 1\n",
        "slowest_solution": "import math\nfor t1 in range(int(input())):\n\tpo = 10 ** 9 + 7\n\t(n, k, m) = map(int, input().split())\n\tif m % 2 == 0:\n\t\td = m - 1\n\telse:\n\t\td = m\n\tif m % 2 == 1:\n\t\ttemp = int((m + 2) / 2)\n\t\ta1 = pow(n, temp, po)\n\t\tp1 = a1 - pow(n - 1, temp, po)\n\t\tq1 = a1 % po\n\telse:\n\t\ta1 = pow(n, m // 2, po)\n\t\ta2 = pow(n - 1, m // 2, po)\n\t\ta3 = n + k\n\t\tp1 = ((a1 - a2) * a3 + a2) % po\n\t\tq1 = a1 * a3 % po\n\tdivi = math.gcd(p1, q1)\n\tp = p1 // divi\n\tq = q1 // divi\n\tprint(pow(q, po - 2, po) * p % po)\n"
    },
    {
        "task_id": 475,
        "slowest_solution_id": 7,
        "fastest_solution_id": 4,
        "slowest_time": 2.756863832473755,
        "fastest_time": 2.4969775676727295,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tplyr = []\n\tfor _ in range(n):\n\t\tk = list(map(int, input().split(' ')))\n\t\tval = len(k[1:])\n\t\tp = {}\n\t\tfor i in k[1:]:\n\t\t\tp.setdefault(i, 0)\n\t\t\tx = p[i]\n\t\t\tp[i] = x + 1\n\t\th = set(p.keys())\n\t\twhile len(h) > 3:\n\t\t\tif len(h) == 4:\n\t\t\t\tval += 1\n\t\t\telif len(h) == 5:\n\t\t\t\tval += 2\n\t\t\telif len(h) == 6:\n\t\t\t\tval += 4\n\t\t\tp = {k1: v1 - 1 for (k1, v1) in p.items() if v1 - 1 > 0}\n\t\t\th = set(p.keys())\n\t\tplyr.append(val)\n\ta = max(plyr)\n\tif plyr.count(a) > 1:\n\t\tprint('tie')\n\telif plyr.index(a) == 0:\n\t\tprint('chef')\n\telse:\n\t\tprint(plyr.index(a) + 1)\n",
        "slowest_solution": "def get_score(arr):\n\tarr.sort()\n\treturn 3 * arr[0] + 2 * arr[1] + 2 * arr[2] + arr[3] + arr[4] + arr[5]\n\ndef count_types(arr):\n\tout = {x: 0 for x in range(1, 7)}\n\tfor i in range(len(arr)):\n\t\tif i and arr[i] in out:\n\t\t\tout[arr[i]] += 1\n\treturn [out[x] for x in range(1, 7)]\n\ndef solve(data):\n\tscores = {}\n\tfor i in range(len(data)):\n\t\tif not i:\n\t\t\tchef_score = get_score(count_types(data[i]))\n\t\telse:\n\t\t\tscore = get_score(count_types(data[i]))\n\t\t\tscores.setdefault(score, []).append(i + 1)\n\tif scores:\n\t\thighest_non_chef = max(scores.keys())\n\telse:\n\t\thighest_non_chef = 0\n\tif chef_score > highest_non_chef:\n\t\treturn 'chef'\n\tscores.setdefault(chef_score, []).append(1)\n\tif len(scores[highest_non_chef]) > 1:\n\t\treturn 'tie'\n\treturn str(scores[highest_non_chef][0])\nT = int(input().strip())\nfor tc in range(T):\n\tN = int(input().strip())\n\tdata = []\n\tfor n in range(N):\n\t\tdata.append([int(x) for x in input().strip().split(' ')])\n\tprint(solve(data))\n"
    },
    {
        "task_id": 486,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 2.697078227996826,
        "fastest_time": 2.4961628913879395,
        "fastest_solution": "n = int(input())\ngraph = [[] for i in range(n)]\nedges = []\nfor i in range(n - 1):\n\t(a, b) = map(int, input().split())\n\tgraph[a - 1].append(b - 1)\n\tgraph[b - 1].append(a - 1)\n\tedges.append((a - 1, b - 1))\ncolors = list(map(int, input().split()))\n\ndef check(root):\n\tmk = {}\n\tmk[root] = 1\n\n\tdef dfs(v, value):\n\t\tres = True\n\t\tmk[v] = 1\n\t\tfor w in graph[v]:\n\t\t\tif w not in mk:\n\t\t\t\tif colors[w] != value:\n\t\t\t\t\treturn False\n\t\t\t\tres &= dfs(w, value)\n\t\treturn res\n\tfor x in graph[root]:\n\t\tif not dfs(x, colors[x]):\n\t\t\treturn False\n\treturn True\nfor (a, b) in edges:\n\tif colors[a] != colors[b]:\n\t\tif check(a):\n\t\t\tprint('YES')\n\t\t\tprint(a + 1)\n\t\telif check(b):\n\t\t\tprint('YES')\n\t\t\tprint(b + 1)\n\t\telse:\n\t\t\tprint('NO')\n\t\texit()\nprint('YES')\nprint(1)\n",
        "slowest_solution": "import math\nfrom collections import defaultdict\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nii = lambda : int(input())\nlmii = lambda : list(map(int, input().split()))\nslmii = lambda : sorted(map(int, input().split()))\nli = lambda : list(input())\nmii = lambda : map(int, input().split())\nmsi = lambda : map(str, input().split())\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\ndef lcm(a, b):\n\treturn a * b // gcd(a, b)\n\ndef main():\n\tn = ii()\n\tadj = defaultdict(list)\n\tfor i in range(n - 1):\n\t\t(x, y) = mii()\n\t\tadj[x].append(y)\n\t\tadj[y].append(x)\n\tcol = lmii()\n\tans = []\n\tif len(set(col)) == 1:\n\t\tprint('YES')\n\t\tprint(1)\n\telse:\n\t\tfor i in adj:\n\t\t\tfor j in adj[i]:\n\t\t\t\tif col[i - 1] != col[j - 1]:\n\t\t\t\t\tans.append([i, j])\n\t\tif len(ans) == 2:\n\t\t\tprint('YES')\n\t\t\tprint(ans[0][0])\n\t\telse:\n\t\t\ts = {ans[0][1], ans[0][0]}\n\t\t\tfor i in ans:\n\t\t\t\ts.intersection_update({i[0], i[1]})\n\t\t\tif len(s) == 1:\n\t\t\t\tprint('YES')\n\t\t\t\tprint(s.pop())\n\t\t\telse:\n\t\t\t\tprint('NO')\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n"
    },
    {
        "task_id": 480,
        "slowest_solution_id": 7,
        "fastest_solution_id": 5,
        "slowest_time": 2.7013049125671387,
        "fastest_time": 2.568964719772339,
        "fastest_solution": "(n, d) = map(int, input().split())\narr = list(map(int, input().split()))\nans = 0\nl = 0\nr = 0\nb = {}\nwhile l <= r and r < len(arr):\n\tif r - l < 2:\n\t\tr += 1\n\t\tcontinue\n\tif arr[r] - arr[l] > d:\n\t\tl += 1\n\t\tcontinue\n\tif r not in b:\n\t\tb[r] = l\n\telse:\n\t\tb[r] = min(b[r], l)\n\tif r != len(arr) - 1:\n\t\tr += 1\n\telse:\n\t\tl += 1\nfor (v, k) in b.items():\n\tif v - k < 2:\n\t\tcontinue\n\tans += (v - k) * (v - k - 1) // 2\nprint(ans)\n",
        "slowest_solution": "from collections import deque\n(n, d) = [int(i) for i in input().split()]\nx = [int(i) for i in input().split()]\nans = 0\nD = deque()\nfor i in range(n):\n\tD.append(x[i])\n\tif D[-1] - D[0] <= d and len(D) >= 3:\n\t\tans += (len(D) - 1) * (len(D) - 2) // 2\n\twhile D[-1] - D[0] > d:\n\t\tD.popleft()\n\t\tif D[-1] - D[0] <= d:\n\t\t\tans += (len(D) - 1) * (len(D) - 2) // 2\nprint(ans)\n"
    },
    {
        "task_id": 482,
        "slowest_solution_id": 7,
        "fastest_solution_id": 5,
        "slowest_time": 2.6739978790283203,
        "fastest_time": 2.5149452686309814,
        "fastest_solution": "n = int(input().strip())\na = {}\ntemp = {}\n\ndef decom(i):\n\tif i == 0:\n\t\treturn 0\n\tif i == 1:\n\t\treturn 1\n\tif i in a.keys():\n\t\treturn a[i]\n\tif i in temp:\n\t\treturn decom(i - lower(i)[0]) + lower(i)[1]\n\telse:\n\t\ttemp[i] = 0\n\t\tk = min(decom(i - lower(i)[0]) + lower(i)[1], decom(upper(i)[0] - i) + upper(i)[1])\n\t\ta[i] = k\n\t\treturn k\n\ndef upper(i):\n\td = 1\n\tn = 1\n\twhile d < i:\n\t\td = d * 10 + 1\n\t\tn += 1\n\treturn (d, n)\n\ndef lower(i):\n\tif (upper(i)[0] - 1) // 10 == 0:\n\t\treturn (1, 1)\n\treturn ((upper(i)[0] - 1) // 10, upper(i)[1] - 1)\nprint(decom(n))\n",
        "slowest_solution": "n = int(input())\ndp = {}\n\ndef calc(x):\n\tif 0 == x:\n\t\treturn 0\n\tif x in dp.keys():\n\t\treturn dp[x]\n\tl = len(str(x))\n\tu = 10 ** l // 9\n\tif x < u:\n\t\tu = u // 10\n\t\tl -= 1\n\tv = u * 10 + 1\n\tu1 = calc(x % u) + x // u * l\n\tu2 = calc((v - x) % u) + (l + 1) + (v - x) // u * l\n\tres = min(u1, u2)\n\tdp[x] = res\n\treturn res\nprint(calc(n))\n"
    },
    {
        "task_id": 484,
        "slowest_solution_id": 6,
        "fastest_solution_id": 7,
        "slowest_time": 2.7586848735809326,
        "fastest_time": 2.5367658138275146,
        "fastest_solution": "a = int(input())\nlist = list(map(int, input().split()))\ns = sum(list)\nif s % 3 != 0 or a < 3:\n\tprint(0)\nelse:\n\tnum = 0\n\tanswer = 0\n\tss = 0\n\tfor i in range(a - 1):\n\t\tss += list[i]\n\t\tif ss == s * 2 / 3:\n\t\t\tanswer += num\n\t\tif ss == s / 3:\n\t\t\tnum += 1\n\tprint(answer)\n",
        "slowest_solution": "n = int(input())\nnum = input()\nlist = [int(x) for x in num.split()]\ntol = sum(list)\ns = 0\nt = 0\nw = 0\nif tol % 3 != 0:\n\tprint(0)\nelse:\n\tc = int(tol / 3)\n\tfor i in range(n - 1):\n\t\ts += list[i]\n\t\tif s == 2 * c and 0 < i:\n\t\t\tw += t\n\t\tif s == c and i < n - 2:\n\t\t\tt += 1\n\tprint(w)\n"
    },
    {
        "task_id": 525,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.834455728530884,
        "fastest_time": 2.834455728530884,
        "fastest_solution": "def insertion_sort(a):\n\tfor i in range(0, len(a) - 1):\n\t\tj = i\n\t\twhile a[j] > a[j + 1] and j >= 0:\n\t\t\ttemp = a[j]\n\t\t\ta[j] = a[j + 1]\n\t\t\ta[j + 1] = temp\n\t\t\tj -= 1\n\treturn a\n\ndef merge_lists(a, b):\n\tfinal_list = []\n\tpos_a = 0\n\tpos_b = 0\n\twhile pos_a + pos_b < len(a) + len(b):\n\t\tif pos_a < len(a) and pos_b < len(b) and (a[pos_a] <= b[pos_b]):\n\t\t\tfinal_list.append(a[pos_a])\n\t\t\tpos_a += 1\n\t\telif pos_a < len(a) and pos_b < len(b) and (a[pos_a] > b[pos_b]):\n\t\t\tfinal_list.append(b[pos_b])\n\t\t\tpos_b += 1\n\t\telif pos_a == len(a) and pos_b < len(b):\n\t\t\tfinal_list.append(b[pos_b])\n\t\t\tpos_b += 1\n\t\telif pos_a < len(a) and pos_b == len(b):\n\t\t\tfinal_list.append(a[pos_a])\n\t\t\tpos_a += 1\n\t\telse:\n\t\t\tprint('error')\n\treturn final_list\n\ndef merge_sort(a):\n\tif len(a) < 10:\n\t\treturn insertion_sort(a)\n\telse:\n\t\treturn merge_lists(merge_sort(a[0:len(a) // 2]), merge_sort(a[len(a) // 2:len(a)]))\n\ndef bitize(x):\n\tL = []\n\twhile x > 0:\n\t\tL.append(x % 2)\n\t\tx //= 2\n\tif not L:\n\t\tL.append(0)\n\treturn L\n\ndef pow_mod(a, b, m):\n\tb_bits = bitize(b)\n\ta_powers = [0 for x in b_bits]\n\ta_powers[0] = a % m\n\tif b_bits[0]:\n\t\ttotal = a % m\n\telse:\n\t\ttotal = 1\n\tfor i in range(1, len(b_bits)):\n\t\ta_powers[i] = a_powers[i - 1] * a_powers[i - 1] % m\n\t\tif b_bits[i]:\n\t\t\ttotal *= a_powers[i]\n\t\t\ttotal %= m\n\treturn total % m\n\ndef evaluateP(b, a, mod):\n\teval = 0\n\tx = 1\n\tfor i in range(0, len(b)):\n\t\teval += b[i] * x % mod\n\t\tx *= a\n\t\tx %= mod\n\treturn eval % mod\n\ndef evaluateQ(a, a_i, mod):\n\teval = 1\n\tfor i in range(0, len(a)):\n\t\tif a_i - a[i] != 0:\n\t\t\teval *= a_i - a[i]\n\t\t\teval %= mod\n\treturn eval % mod\n\ndef rationalSums(n, a, b):\n\tmod = pow(10, 9) + 7\n\tneg_one = pow_mod(mod - 1, mod - 2, mod)\n\tC = [0 for x in range(0, len(a))]\n\tfor i in range(0, len(a)):\n\t\tif (len(a) + 1) % 2:\n\t\t\tC[i] = neg_one * evaluateP(b, mod - a[i], mod) * pow_mod(evaluateQ(a, a[i], mod), mod - 2, mod) % mod\n\t\telse:\n\t\t\tC[i] = evaluateP(b, mod - a[i], mod) * pow_mod(evaluateQ(a, a[i], mod), mod - 2, mod) % mod\n\tinverses = [1 for _ in range(0, 5001)]\n\tsum_of_inverses = [0 for _ in range(-1, 5001)]\n\tfor i in range(1, 5001):\n\t\tinverses[i] = pow_mod(i, mod - 2, mod)\n\t\tif i > 1:\n\t\t\tsum_of_inverses[i] = (sum_of_inverses[i - 1] + inverses[i]) % mod\n\t\telse:\n\t\t\tsum_of_inverses[1] = 1\n\ts = 0\n\tfor j in range(0, len(a)):\n\t\ts += C[j] * (sum_of_inverses[a[len(a) - 1]] - sum_of_inverses[a[j]])\n\t\ts %= mod\n\treturn s\nn = int(input().strip())\na = list(map(int, input().strip().split(' ')))\nb = list(map(int, input().strip().split(' ')))\nresult = rationalSums(n, merge_sort(a), b)\nprint(result)\n",
        "slowest_solution": "def insertion_sort(a):\n\tfor i in range(0, len(a) - 1):\n\t\tj = i\n\t\twhile a[j] > a[j + 1] and j >= 0:\n\t\t\ttemp = a[j]\n\t\t\ta[j] = a[j + 1]\n\t\t\ta[j + 1] = temp\n\t\t\tj -= 1\n\treturn a\n\ndef merge_lists(a, b):\n\tfinal_list = []\n\tpos_a = 0\n\tpos_b = 0\n\twhile pos_a + pos_b < len(a) + len(b):\n\t\tif pos_a < len(a) and pos_b < len(b) and (a[pos_a] <= b[pos_b]):\n\t\t\tfinal_list.append(a[pos_a])\n\t\t\tpos_a += 1\n\t\telif pos_a < len(a) and pos_b < len(b) and (a[pos_a] > b[pos_b]):\n\t\t\tfinal_list.append(b[pos_b])\n\t\t\tpos_b += 1\n\t\telif pos_a == len(a) and pos_b < len(b):\n\t\t\tfinal_list.append(b[pos_b])\n\t\t\tpos_b += 1\n\t\telif pos_a < len(a) and pos_b == len(b):\n\t\t\tfinal_list.append(a[pos_a])\n\t\t\tpos_a += 1\n\t\telse:\n\t\t\tprint('error')\n\treturn final_list\n\ndef merge_sort(a):\n\tif len(a) < 10:\n\t\treturn insertion_sort(a)\n\telse:\n\t\treturn merge_lists(merge_sort(a[0:len(a) // 2]), merge_sort(a[len(a) // 2:len(a)]))\n\ndef bitize(x):\n\tL = []\n\twhile x > 0:\n\t\tL.append(x % 2)\n\t\tx //= 2\n\tif not L:\n\t\tL.append(0)\n\treturn L\n\ndef pow_mod(a, b, m):\n\tb_bits = bitize(b)\n\ta_powers = [0 for x in b_bits]\n\ta_powers[0] = a % m\n\tif b_bits[0]:\n\t\ttotal = a % m\n\telse:\n\t\ttotal = 1\n\tfor i in range(1, len(b_bits)):\n\t\ta_powers[i] = a_powers[i - 1] * a_powers[i - 1] % m\n\t\tif b_bits[i]:\n\t\t\ttotal *= a_powers[i]\n\t\t\ttotal %= m\n\treturn total % m\n\ndef evaluateP(b, a, mod):\n\teval = 0\n\tx = 1\n\tfor i in range(0, len(b)):\n\t\teval += b[i] * x % mod\n\t\tx *= a\n\t\tx %= mod\n\treturn eval % mod\n\ndef evaluateQ(a, a_i, mod):\n\teval = 1\n\tfor i in range(0, len(a)):\n\t\tif a_i - a[i] != 0:\n\t\t\teval *= a_i - a[i]\n\t\t\teval %= mod\n\treturn eval % mod\n\ndef rationalSums(n, a, b):\n\tmod = pow(10, 9) + 7\n\tneg_one = pow_mod(mod - 1, mod - 2, mod)\n\tC = [0 for x in range(0, len(a))]\n\tfor i in range(0, len(a)):\n\t\tif (len(a) + 1) % 2:\n\t\t\tC[i] = neg_one * evaluateP(b, mod - a[i], mod) * pow_mod(evaluateQ(a, a[i], mod), mod - 2, mod) % mod\n\t\telse:\n\t\t\tC[i] = evaluateP(b, mod - a[i], mod) * pow_mod(evaluateQ(a, a[i], mod), mod - 2, mod) % mod\n\tinverses = [1 for _ in range(0, 5001)]\n\tsum_of_inverses = [0 for _ in range(-1, 5001)]\n\tfor i in range(1, 5001):\n\t\tinverses[i] = pow_mod(i, mod - 2, mod)\n\t\tif i > 1:\n\t\t\tsum_of_inverses[i] = (sum_of_inverses[i - 1] + inverses[i]) % mod\n\t\telse:\n\t\t\tsum_of_inverses[1] = 1\n\ts = 0\n\tfor j in range(0, len(a)):\n\t\ts += C[j] * (sum_of_inverses[a[len(a) - 1]] - sum_of_inverses[a[j]])\n\t\ts %= mod\n\treturn s\nn = int(input().strip())\na = list(map(int, input().strip().split(' ')))\nb = list(map(int, input().strip().split(' ')))\nresult = rationalSums(n, merge_sort(a), b)\nprint(result)\n"
    },
    {
        "task_id": 513,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 3.13789701461792,
        "fastest_time": 2.982518196105957,
        "fastest_solution": "from sys import stdin\nfrom math import gcd\n\ndef main():\n\tinput()\n\tl = stdin.read().splitlines()\n\td = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n\tfor i in range(4, 100001):\n\t\tfor j in range(i, 100001, i):\n\t\t\td[j] += 1.0\n\tfor (i, s) in enumerate(l):\n\t\t(a, b, c) = map(int, s.split())\n\t\tk = gcd(b, c)\n\t\tab = d[gcd(a, b)]\n\t\tac = d[gcd(a, c)]\n\t\tbc = d[k]\n\t\tabc = d[gcd(a, k)]\n\t\tasz = d[a] - ab - ac + abc\n\t\tbsz = d[b] - bc - ab + abc\n\t\tcsz = d[c] - ac - bc + abc\n\t\tabsz = ab - abc\n\t\tbcsz = bc - abc\n\t\tacsz = ac - abc\n\t\tl[i] = '%d' % (asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[c] + bcsz * (bcsz + 1.0) * d[a] + acsz * (acsz + 1.0) * d[b]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n\tprint('\\n'.join(map(str, l)))\nmain()\n",
        "slowest_solution": "N = 100001\nfac = [0 for i in range(N)]\nfor i in range(1, N):\n\tfor j in range(i, N, i):\n\t\tfac[j] += 1\n\ndef gcd(a, b):\n\tif a < b:\n\t\t(a, b) = (b, a)\n\twhile b > 0:\n\t\t(a, b) = (b, a % b)\n\treturn a\n\ndef ctt(A, B, C):\n\tla = fac[A]\n\tlb = fac[B]\n\tlc = fac[C]\n\tab = gcd(A, B)\n\tac = gcd(A, C)\n\tbc = gcd(B, C)\n\tabc = gcd(ab, C)\n\tdupabc = fac[abc]\n\tdupac = fac[ac] - dupabc\n\tdupbc = fac[bc] - dupabc\n\tdupab = fac[ab] - dupabc\n\tlax = la - dupabc - dupab - dupac\n\tlbx = lb - dupabc - dupab - dupbc\n\tlcx = lc - dupabc - dupac - dupbc\n\tctx = lax * lbx * lcx\n\tctx += lax * lbx * (lc - lcx)\n\tctx += lax * lcx * (lb - lbx)\n\tctx += lcx * lbx * (la - lax)\n\tctx += lax * ((lb - lbx) * (lc - lcx) - (dupabc + dupbc) * (dupabc + dupbc - 1) / 2)\n\tctx += lbx * ((la - lax) * (lc - lcx) - (dupabc + dupac) * (dupabc + dupac - 1) / 2)\n\tctx += lcx * ((la - lax) * (lb - lbx) - (dupabc + dupab) * (dupabc + dupab - 1) / 2)\n\tctx += dupab * dupac * dupbc\n\tctx += dupab * dupac * (dupab + dupac + 2) / 2\n\tctx += dupab * dupbc * (dupab + dupbc + 2) / 2\n\tctx += dupbc * dupac * (dupbc + dupac + 2) / 2\n\tctx += dupabc * (dupab * dupac + dupab * dupbc + dupbc * dupac)\n\tctx += dupabc * (dupab * (dupab + 1) + (dupbc + 1) * dupbc + (dupac + 1) * dupac) / 2\n\tctx += (dupabc + 1) * dupabc * (dupab + dupac + dupbc) / 2\n\tctx += dupabc * dupabc + dupabc * (dupabc - 1) * (dupabc - 2) / 6\n\treturn int(ctx)\nn = int(input())\nfor _ in range(n):\n\t(a, b, c) = map(int, input().split())\n\tprint(ctt(a, b, c))\nexit()\n"
    },
    {
        "task_id": 489,
        "slowest_solution_id": 8,
        "fastest_solution_id": 9,
        "slowest_time": 2.7595701217651367,
        "fastest_time": 2.5433857440948486,
        "fastest_solution": "import sys\nimport threading\nfrom collections import defaultdict\nadj = defaultdict(list)\nn = int(input())\nfor _ in range(n - 1):\n\t(x, y, b) = list(map(int, input().split()))\n\tadj[x].append((y, b))\n\tadj[y].append((x, b))\n\ndef fun(node, par, li):\n\ty = 0\n\tdam = 1\n\tfor (ch, b) in adj[node]:\n\t\tif ch == par:\n\t\t\tdam = b\n\t\telse:\n\t\t\ty |= fun(ch, node, li)\n\tif y == 0 and dam == 2:\n\t\tli.append(node)\n\t\ty = 1\n\treturn y\n\ndef main():\n\tli = []\n\tfun(1, 0, li)\n\tprint(len(li))\n\tif li:\n\t\tprint(' '.join(map(str, li)))\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()\n",
        "slowest_solution": "import sys\nfrom math import sqrt, gcd, ceil, log\nfrom collections import defaultdict, Counter, deque\ninput = sys.stdin.readline\nread = lambda : list(map(int, input().strip().split()))\nsys.setrecursionlimit(200000)\n\ndef main():\n\tn = int(input())\n\tadj = defaultdict(list)\n\tproblem = set()\n\tfor i in range(n - 1):\n\t\t(x, y, t) = read()\n\t\tadj[x].append(y)\n\t\tadj[y].append(x)\n\t\tif t == 2:\n\t\t\tproblem.add((x, y))\n\tparent = defaultdict(int)\n\torder = []\n\n\tdef dfs():\n\t\tstk = [(1, 0)]\n\t\twhile stk:\n\t\t\t(node, par) = stk.pop()\n\t\t\torder.append(node)\n\t\t\tparent[node] = par\n\t\t\tfor child in adj[node]:\n\t\t\t\tif child != par:\n\t\t\t\t\tstk.append((child, node))\n\tdfs()\n\tdic = defaultdict(int)\n\tans = []\n\tfor i in range(n - 1, -1, -1):\n\t\tchild = order[i]\n\t\tpar = parent[order[i]]\n\t\tif dic[child]:\n\t\t\tdic[par] += dic[child]\n\t\telif (child, par) in problem or (par, child) in problem:\n\t\t\tans.append(child)\n\t\t\tdic[par] += 1\n\tprint(len(ans))\n\tprint(*ans)\nmain()\n"
    },
    {
        "task_id": 490,
        "slowest_solution_id": 4,
        "fastest_solution_id": 1,
        "slowest_time": 2.6456799507141113,
        "fastest_time": 2.530447006225586,
        "fastest_solution": "(a, b, r) = list(map(int, input().split()))\nprint('Second' if r + r > min(a, b) else 'First')\n",
        "slowest_solution": "def plate_game(a_int, b_int, r_int) -> None:\n\tif 2 * r_int > min(a_int, b_int):\n\t\tprint('Second')\n\telse:\n\t\tprint('First')\n(a, b, r) = list(map(int, input().split()))\nplate_game(a, b, r)\n"
    },
    {
        "task_id": 496,
        "slowest_solution_id": 3,
        "fastest_solution_id": 2,
        "slowest_time": 2.6508800983428955,
        "fastest_time": 2.5138468742370605,
        "fastest_solution": "def gcd(a, b):\n\twhile b:\n\t\t(a, b) = (b, a % b)\n\treturn a\nfrom collections import defaultdict\nfor _ in range(int(input())):\n\ts = defaultdict(set)\n\tfor i in range(int(input())):\n\t\t(a, b, c) = map(int, input().split())\n\t\tg = gcd(a, b)\n\t\th = gcd(g, c)\n\t\ts[a / g, b / g].add((a / h, b / h, c / h))\n\tprint(max(map(len, s.values())))\n",
        "slowest_solution": "import math\nT = int(input())\nfor i in range(T):\n\tN = int(input())\n\tdicto = {}\n\tdicto2 = {}\n\tfor j in range(N):\n\t\ttemp = str(input()).split(' ')\n\t\ttemp1 = int(temp[0])\n\t\ttemp2 = int(temp[1])\n\t\ttemp3 = int(temp[2])\n\t\tb = math.gcd(math.gcd(temp1, temp2), temp3)\n\t\ttemp1 = temp1 // b\n\t\ttemp2 = temp2 // b\n\t\ttemp3 = temp3 // b\n\t\tif temp1 < 0:\n\t\t\ttemp1 = -temp1\n\t\t\ttemp2 = -temp2\n\t\t\ttemp3 = -temp3\n\t\telif temp1 == 0 and temp2 < 0:\n\t\t\ttemp2 = -temp2\n\t\t\ttemp3 = -temp3\n\t\tflag = dicto2.get((temp1, temp2, temp3), False)\n\t\tif not flag:\n\t\t\tdicto2[temp1, temp2, temp3] = True\n\t\t\ta = math.gcd(temp1, temp2)\n\t\t\ttemp1 = temp1 // a\n\t\t\ttemp2 = temp2 // a\n\t\t\tdicto[temp1, temp2] = dicto.get((temp1, temp2), 0) + 1\n\tmaxim = 0\n\tfor (k, v) in dicto.items():\n\t\tif v > maxim:\n\t\t\tmaxim = v\n\tprint(maxim)\n"
    },
    {
        "task_id": 492,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.7267494201660156,
        "fastest_time": 2.5022237300872803,
        "fastest_solution": "from collections import Counter\nm = int(input())\n\ndef solve(n: int, a: list, b: list) -> None:\n\tans = 0\n\tfor digit in range(29, -1, -1):\n\t\tt = ans | 1 << digit\n\t\tcnt_a = Counter((x & t for x in a))\n\t\tcnt_b = Counter((x & t for x in b))\n\t\tflag = True\n\t\tfor x in cnt_a.keys():\n\t\t\tif cnt_a[x] != cnt_b[x ^ t]:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\tif flag:\n\t\t\tans = t\n\tprint(ans)\nwhile m > 0:\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\tsolve(n, a, b)\n\tm -= 1\n",
        "slowest_solution": "import sys\nfrom collections import defaultdict\n\ndef input():\n\treturn sys.stdin.readline().rstrip()\n\ndef main():\n\tn = int(input())\n\tA = list(map(int, input().split()))\n\tB = list(map(int, input().split()))\n\tres = 0\n\tbit = max(max(A), max(B)).bit_length()\n\n\tdef check(res):\n\t\tcnt = defaultdict(int)\n\t\tfor x in A:\n\t\t\tcnt[x & res] += 1\n\t\tfor x in B:\n\t\t\tcnt[~x & res] -= 1\n\t\treturn all((v == 0 for v in cnt.values()))\n\tfor i in range(bit - 1, -1, -1):\n\t\tif check(res | 1 << i):\n\t\t\tres |= 1 << i\n\tprint(res)\nt = int(input())\nfor _ in range(t):\n\tmain()\n"
    },
    {
        "task_id": 500,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.693556308746338,
        "fastest_time": 2.4936773777008057,
        "fastest_solution": "(n, m, k) = map(int, input().split())\nflag = False\nwhile k > 0:\n\tk -= 1\n\t(x, y) = map(int, input().split())\n\td = min(x, n - x + 1, y, m - y + 1)\n\tif d <= 5:\n\t\tflag = True\nprint('YES' if flag else 'NO')\n",
        "slowest_solution": "(n, m, k) = [int(x) for x in input().split()]\ncanwin = False\nfor i in range(k):\n\t(x, y) = [int(x) for x in input().split()]\n\tcanwin |= x < 6 or n - x < 5\n\tcanwin |= y < 6 or m - y < 5\nprint('YES' if canwin else 'NO')\n"
    },
    {
        "task_id": 512,
        "slowest_solution_id": 2,
        "fastest_solution_id": 3,
        "slowest_time": 2.802804470062256,
        "fastest_time": 2.559605360031128,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\ts = list(map(int, input().split()))\n\tm = max(a)\n\tmi = a.index(m)\n\tdp = [0] * (n + 1)\n\tdp[mi] = 1\n\tfor i in range(mi, -1, -1):\n\t\tfor j in s:\n\t\t\tif i + j > n:\n\t\t\t\tcontinue\n\t\t\tif not dp[i + j]:\n\t\t\t\tdp[i] = 1\n\t\t\t\tbreak\n\tprint('Chef' if dp[0] else 'Garry')\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\ta = [-1] + a[::-1]\n\tmx = a.index(max(a))\n\tdp = [0] * (n + 1)\n\tfor i in range(1, n + 1):\n\t\tfor x in b:\n\t\t\tif i - x < 0:\n\t\t\t\tcontinue\n\t\t\tif i - x < mx <= i:\n\t\t\t\tdp[i] = 1\n\t\t\telse:\n\t\t\t\tdp[i] |= not dp[i - x]\n\tprint('Chef' if dp[-1] else 'Garry')\n"
    },
    {
        "task_id": 494,
        "slowest_solution_id": 4,
        "fastest_solution_id": 5,
        "slowest_time": 2.7168455123901367,
        "fastest_time": 2.4739441871643066,
        "fastest_solution": "import sys\n\ndef profit(b, s, c):\n\treturn b + s - c\nt = int(input().strip())\nfor a0 in range(t):\n\t(b, s, c) = input().strip().split(' ')\n\t(b, s, c) = [int(b), int(s), int(c)]\n\tresult = profit(b, s, c)\n\tprint(result)\n",
        "slowest_solution": "import sys\n\ndef profit(b, s, c):\n\treturn b + s - c\nt = int(input().strip())\nfor a0 in range(t):\n\t(b, s, c) = input().strip().split(' ')\n\t(b, s, c) = [int(b), int(s), int(c)]\n\tresult = profit(b, s, c)\n\tprint(result)\n"
    },
    {
        "task_id": 497,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 2.7633769512176514,
        "fastest_time": 2.5111424922943115,
        "fastest_solution": "def maxsubsum(n, l):\n\tmaxsum = l[0]\n\tt = l[0]\n\tfor i in range(1, n):\n\t\tt = t + l[i]\n\t\tif maxsum < t:\n\t\t\tmaxsum = t\n\tif maxsum < 0:\n\t\tmaxsum = 0\n\treturn maxsum\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tr = list(map(int, input().rstrip().split()))\n\tm = int(input())\n\tb = list(map(int, input().rstrip().split()))\n\tm1 = maxsubsum(n, r)\n\tm2 = maxsubsum(m, b)\n\tprint(m1 + m2)\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\tr = list(map(int, input().split()))\n\tm = int(input())\n\tb = list(map(int, input().split()))\n\n\tdef maxarr(arr):\n\t\tsum = 0\n\t\tmsum = 0\n\t\tfor i in range(len(arr)):\n\t\t\tsum += arr[i]\n\t\t\tif sum > msum:\n\t\t\t\tmsum = sum\n\t\treturn msum\n\tprint(maxarr(r) + maxarr(b))\n"
    },
    {
        "task_id": 504,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 2.9455361366271973,
        "fastest_time": 2.520975112915039,
        "fastest_solution": "MOD = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n\tn = int(input()) - 1\n\tmx = int((2 * n) ** 0.5)\n\tif mx * (mx + 1) > 2 * n:\n\t\tmx -= 1\n\t(mx_pow, val) = ([], mx)\n\tfor i in range(5):\n\t\tmx_pow += [val]\n\t\tval *= mx\n\tpow_4 = mx * (mx + 1) * (2 * mx + 1) * (3 * mx_pow[1] + 3 * mx - 1) // 30\n\tpow_3 = (mx * (mx + 1) // 2) ** 2\n\tpow_2 = mx * (mx + 1) * (2 * mx + 1) // 6\n\tpow_1 = mx * (mx + 1) // 2\n\tans = (-pow_4 - 2 * pow_3 + (2 * n + 1) * pow_2 + 2 * (n + 1) * pow_1) // 4\n\tans = int(ans)\n\tprint(ans % MOD)\n",
        "slowest_solution": "from bisect import bisect_right\nfrom collections import Counter\na = [n * (n + 1) // 2 for n in range(1, 10 ** 5)]\nprev = [a[0]]\nfor i in a[1:]:\n\tprev.append(prev[-1] + i)\nsums = [1]\ni = 1\ncurr = 2\nwhile i < 10 ** 9 + 1:\n\ti += curr\n\tsums.append(sums[-1] + i * i)\n\tcurr += 1\n\ndef solve():\n\tn = int(input())\n\tindex = bisect_right(a, n)\n\tindex -= 1\n\trem = n - a[index]\n\tres = 0\n\tmod = 10 ** 9 + 7\n\tres -= sums[index]\n\tres += prev[index] * n\n\tprint(res % mod)\ntry:\n\tfor tc in range(int(input())):\n\t\tsolve()\nexcept:\n\tpass\n"
    },
    {
        "task_id": 498,
        "slowest_solution_id": 9,
        "fastest_solution_id": 8,
        "slowest_time": 2.7837839126586914,
        "fastest_time": 2.5494790077209473,
        "fastest_solution": "tn = int(input())\nfor _ in range(tn):\n\tk = int(input())\n\tarr = list(map(int, input().split()))\n\tif k == 1:\n\t\tif arr[0] == 1:\n\t\t\tprint('Yes')\n\t\telse:\n\t\t\tprint('No')\n\telse:\n\t\tsli = arr[-1] // 2\n\t\tfor i in range(k - 2, 0, -1):\n\t\t\tsli = (sli + arr[i]) // 2\n\t\tif sli == 1:\n\t\t\tprint('Yes')\n\t\telse:\n\t\t\tprint('No')\n",
        "slowest_solution": "def function(N, A):\n\tstem = 0.5\n\tfor a in A:\n\t\tstem = 2 * stem - a\n\t\tif stem < 0:\n\t\t\tbreak\n\tif stem == 0:\n\t\treturn 'Yes'\n\treturn 'No'\n\ndef main():\n\tT = int(input())\n\tfor _ in range(T):\n\t\tN = int(input())\n\t\tA = list(map(int, input().split(' ')))\n\t\tif N == 1:\n\t\t\tif A[0] == 1:\n\t\t\t\tprint('Yes')\n\t\t\telse:\n\t\t\t\tprint('No')\n\t\telse:\n\t\t\tval = function(N, A)\n\t\t\tprint(val)\nmain()\n"
    },
    {
        "task_id": 499,
        "slowest_solution_id": 9,
        "fastest_solution_id": 8,
        "slowest_time": 2.798448324203491,
        "fastest_time": 2.4826903343200684,
        "fastest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\tg = sum(b)\n\ts = [g]\n\tfor i in range(n):\n\t\tg = g + a[i] - b[i]\n\t\ts.append(g)\n\tprint(max(s))\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta1 = list(map(int, input().split()))\n\tb1 = list(map(int, input().split()))\n\tearn_chefland = 0\n\tearn_chefabad = 0\n\tfor i in range(n):\n\t\tearn_chefland += a1[i]\n\t\tearn_chefabad += b1[i]\n\t\tif earn_chefland > earn_chefabad:\n\t\t\tearn_chefabad = earn_chefland\n\tprint(earn_chefabad)\n"
    },
    {
        "task_id": 501,
        "slowest_solution_id": 9,
        "fastest_solution_id": 7,
        "slowest_time": 2.9985713958740234,
        "fastest_time": 2.525376081466675,
        "fastest_solution": "from collections import Counter\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tfor i in range(n + 1, n + 10000):\n\t\ts = Counter(str(i))\n\t\tif s['3'] >= 3:\n\t\t\tprint(i)\n\t\t\tbreak\n",
        "slowest_solution": "def solve(n):\n\treturn False if n.count('3') >= 3 else True\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tn += 1\n\twhile solve(str(n)):\n\t\tn += 1\n\tprint(n)\n"
    },
    {
        "task_id": 503,
        "slowest_solution_id": 9,
        "fastest_solution_id": 5,
        "slowest_time": 2.9895520210266113,
        "fastest_time": 2.5392234325408936,
        "fastest_solution": "from collections import defaultdict\nfrom itertools import product\n\ndef f(l1, l2):\n\t(a1, b1, c1) = l1\n\t(a2, b2, c2) = l2\n\tdet = a1 * b2 - a2 * b1\n\tdet1 = c1 * b2 - c2 * b1\n\tdet2 = a1 * c2 - a2 * c1\n\treturn (det1 / det, det2 / det)\n\ndef f1(l, s):\n\tif len(l) == 4:\n\t\tl = l[:3]\n\telif len(l) == 7:\n\t\tl = l[:4]\n\treturn sum(l) - s\nfor t in range(int(input())):\n\tn = int(input())\n\t(d1, d2, d3, d4) = (defaultdict(set), defaultdict(set), defaultdict(set), defaultdict(set))\n\tfor (x, y) in zip(map(float, input().split()), map(float, input().split())):\n\t\td1[1, 0, x].add((x, y))\n\t\td2[0, 1, y].add((x, y))\n\t\td3[-1, 1, y - x].add((x, y))\n\t\td4[1, 1, x + y].add((x, y))\n\td = {}\n\tfor (dct1, dct2) in ((d1, d2), (d1, d3), (d1, d4), (d2, d3), (d2, d4), (d3, d4)):\n\t\tfor (l1, l2) in product(dct1, dct2):\n\t\t\tintersec = f(l1, l2)\n\t\t\tif intersec in d:\n\t\t\t\td[intersec][0].append(len(dct2[l2]))\n\t\t\t\tif intersec in dct2[l2]:\n\t\t\t\t\td[intersec][1] = 2\n\t\t\telse:\n\t\t\t\td[intersec] = [[len(dct1[l1]), len(dct2[l2])], 2 * (intersec in dct2[l2])]\n\tprint(2 * n - max((f1(*el) for el in d.values())))\n",
        "slowest_solution": "class point:\n\n\tdef __init__(self, x, y):\n\t\tself.x = float(x)\n\t\tself.y = float(y)\n\n\tdef vertical(self):\n\t\ta = 1\n\t\tb = 0\n\t\tc = -self.x\n\t\treturn (a, b, c)\n\n\tdef horizontal(self):\n\t\ta = 0\n\t\tb = 1\n\t\tc = -self.y\n\t\treturn (a, b, c)\n\n\tdef dig1(self):\n\t\ta = 1\n\t\tb = 1\n\t\tc = -(self.x + self.y)\n\t\treturn (a, b, c)\n\n\tdef dig2(self):\n\t\ta = 1\n\t\tb = -1\n\t\tc = -self.x + self.y\n\t\treturn (a, b, c)\n\ndef intersect(p1, p2):\n\ta1 = p1[0]\n\tb1 = p1[1]\n\ta2 = p2[0]\n\tb2 = p2[1]\n\tif b1 == 0 and b2 == 0:\n\t\treturn False\n\tif b1 == 0 or b2 == 0:\n\t\treturn True\n\tif a1 / b1 == a2 / b2:\n\t\treturn False\n\telse:\n\t\treturn True\n\ndef intersectionpoint(l1, l2):\n\ta1 = l1[0]\n\tb1 = l1[1]\n\tc1 = l1[2]\n\ta2 = l2[0]\n\tb2 = l2[1]\n\tc2 = l2[2]\n\ta1b2_minus_a2b1 = a1 * b2 - a2 * b1\n\tx = (b1 * c2 - b2 * c1) / a1b2_minus_a2b1\n\ty = (c1 * a2 - c2 * a1) / a1b2_minus_a2b1\n\tif x == 0:\n\t\tx = 0\n\tif y == 0:\n\t\ty = 0\n\treturn (x, y)\n\ndef update(dct, ip, p1, p2):\n\tif dct.get(ip, 0) == 0:\n\t\tdct[ip] = {(p1.x, p1.y), (p2.x, p2.y)}\n\telse:\n\t\tdct[ip].add((p1.x, p1.y))\n\t\tdct[ip].add((p2.x, p2.y))\nt = int(input())\nfor q in range(t):\n\tn = int(input())\n\tx = list(map(int, input().split()))\n\ty = list(map(int, input().split()))\n\tdct = dict()\n\tfor i in range(len(x)):\n\t\tx1 = x[i]\n\t\ty1 = y[i]\n\t\tp1 = point(x1, y1)\n\t\tif dct.get((p1.x, p1.y), 0) == 0:\n\t\t\tdct[p1.x, p1.y] = {(p1.x, p1.y)}\n\t\tfor j in range(len(x)):\n\t\t\tif i == j:\n\t\t\t\tcontinue\n\t\t\tx2 = x[j]\n\t\t\ty2 = y[j]\n\t\t\tp2 = point(x2, y2)\n\t\t\tif intersect(p1.horizontal(), p2.vertical()):\n\t\t\t\tip = intersectionpoint(p1.horizontal(), p2.vertical())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.horizontal(), p2.dig1()):\n\t\t\t\tip = intersectionpoint(p1.horizontal(), p2.dig1())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.horizontal(), p2.dig2()):\n\t\t\t\tip = intersectionpoint(p1.horizontal(), p2.dig2())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.vertical(), p2.horizontal()):\n\t\t\t\tip = intersectionpoint(p1.vertical(), p2.horizontal())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.vertical(), p2.dig1()):\n\t\t\t\tip = intersectionpoint(p1.vertical(), p2.dig1())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.vertical(), p2.dig2()):\n\t\t\t\tip = intersectionpoint(p1.vertical(), p2.dig2())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.dig1(), p2.horizontal()):\n\t\t\t\tip = intersectionpoint(p1.dig1(), p2.horizontal())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.dig1(), p2.vertical()):\n\t\t\t\tip = intersectionpoint(p1.dig1(), p2.vertical())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.dig1(), p2.dig2()):\n\t\t\t\tip = intersectionpoint(p1.dig1(), p2.dig2())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.dig2(), p2.horizontal()):\n\t\t\t\tip = intersectionpoint(p1.dig2(), p2.horizontal())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.dig2(), p2.vertical()):\n\t\t\t\tip = intersectionpoint(p1.dig2(), p2.vertical())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\t\t\tif intersect(p1.dig2(), p2.dig1()):\n\t\t\t\tip = intersectionpoint(p1.dig2(), p2.dig1())\n\t\t\t\tupdate(dct, ip, p1, p2)\n\tmaximum = -1\n\tmaxkey = -1\n\tfor (k, v) in dct.items():\n\t\tif len(v) == maximum:\n\t\t\tif k in v:\n\t\t\t\tmaxkey = k\n\t\telif len(v) > maximum:\n\t\t\tmaximum = len(v)\n\t\t\tmaxkey = k\n\tif maxkey in dct[maxkey]:\n\t\tans = len(dct[maxkey]) - 1 + (len(x) - len(dct[maxkey])) * 2\n\telse:\n\t\tans = len(dct[maxkey]) + (len(x) - len(dct[maxkey])) * 2\n\tprint(ans)\n"
    },
    {
        "task_id": 517,
        "slowest_solution_id": 2,
        "fastest_solution_id": 1,
        "slowest_time": 4.109004735946655,
        "fastest_time": 3.612549066543579,
        "fastest_solution": "mod = 998244353\nmaxn = 10 ** 6 + 10\ninvs = [1] * maxn\nfor i in range(2, maxn):\n\tinvs[i] = (mod - mod // i * invs[mod % i]) % mod\nt = int(input())\nfor _ in range(t):\n\t(n, k) = input().split()\n\tk = int(k)\n\tif k == 0:\n\t\tprint(len(str(n)))\n\t\tcontinue\n\tpows = []\n\tfor i in range(len(n)):\n\t\ttimes = ord(n[-1 - i]) - ord('0')\n\t\tfor j in range(times):\n\t\t\tpows.append(i + 1)\n\t(ans, coef, n) = (0, 1, len(pows))\n\tfor i in range(n):\n\t\tans += pows[n - 1 - i] * coef\n\t\tcoef = coef * (k + i) * invs[i + 1] % mod\n\tprint(ans % mod)\n",
        "slowest_solution": "mod = 998244353\nmxn = 200000\nfact = [1] * mxn\ninv = [0] * mxn\ninv[1] = 1\nfor i in range(2, mxn):\n\tfact[i] = fact[i - 1] * i % mod\n\tinv[i] = pow(fact[i], mod - 2, mod)\nfor _ in range(int(input())):\n\t(s, k) = input().split()\n\tk = int(k)\n\tif k == 0:\n\t\tprint(len(s) % mod)\n\t\tcontinue\n\ti = len(s) - 1\n\ta = []\n\tpos = 0\n\tp = 0\n\twhile i >= 0:\n\t\tp += 1\n\t\td = int(s[i])\n\t\twhile d > 0:\n\t\t\tpos += p\n\t\t\ta.append(pos)\n\t\t\td -= 1\n\t\ti -= 1\n\tn = len(a)\n\tif k == 1:\n\t\tprint(a[n - 1] % mod)\n\t\tcontinue\n\ta = a[::-1]\n\tk -= 1\n\tans = a[0]\n\t(nu, de) = (k, 1)\n\tfor i in range(1, n):\n\t\tans = (ans + mod + a[i] * nu * inv[de]) % mod\n\t\tnu *= k + i\n\t\tnu %= mod\n\t\tde += 1\n\tprint(ans % mod)\n"
    },
    {
        "task_id": 537,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.052004814147949,
        "fastest_time": 3.052004814147949,
        "fastest_solution": "def throw(m, n, k, s):\n\tif k > s + m*n:\n\t\treturn 0\n\tif (m, s) in D:\n\t\treturn D[(m, s)]\n\tif m == 0:\n\t\tif s == k:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\tr = 0\n\tfor i in range(1, n + 1):\n\t\tif i + s <= k:\n\t\t\tr += throw(m - 1, n, k, s + i)\n\tD[(m, s)] = float(r)\n\treturn float(r)\n\t\n\nfor _ in range(eval(input())):\n\tD = {}\n\tm, n, k = list(map(int, input().split()))\n\tans = throw(m, n, k, 0)/n**m\n\tif ans == 0:\n\t\tprint(\"0.000 0\")\n\telse:\n\t\tc = 0\n\t\twhile ans < 1:\n\t\t\tans *= 10\n\t\t\tc += 1\n\t\tprint(\"{0:.3f}\".format(ans), c)\n",
        "slowest_solution": "def throw(m, n, k, s):\n\tif k > s + m*n:\n\t\treturn 0\n\tif (m, s) in D:\n\t\treturn D[(m, s)]\n\tif m == 0:\n\t\tif s == k:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\tr = 0\n\tfor i in range(1, n + 1):\n\t\tif i + s <= k:\n\t\t\tr += throw(m - 1, n, k, s + i)\n\tD[(m, s)] = float(r)\n\treturn float(r)\n\t\n\nfor _ in range(eval(input())):\n\tD = {}\n\tm, n, k = list(map(int, input().split()))\n\tans = throw(m, n, k, 0)/n**m\n\tif ans == 0:\n\t\tprint(\"0.000 0\")\n\telse:\n\t\tc = 0\n\t\twhile ans < 1:\n\t\t\tans *= 10\n\t\t\tc += 1\n\t\tprint(\"{0:.3f}\".format(ans), c)\n"
    },
    {
        "task_id": 524,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.713338613510132,
        "fastest_time": 2.713338613510132,
        "fastest_solution": "h = int(input())\na = list(map(int, input().split()))\n(p, c, f) = (0, 0, False)\n(s1, s2) = ([], [])\nfor i in a:\n\tfor j in range(i):\n\t\ts1.append(c)\n\t\tif j == i - 1 and (not f) and (p >= 2) and (i >= 2):\n\t\t\tf = True\n\t\t\ts2.append(c - 1)\n\t\telse:\n\t\t\ts2.append(c)\n\tp = i\n\tc += i\nprint('perfect' if not f else 'ambiguous')\nif f:\n\tprint(' '.join(map(str, s1)))\n\tprint(' '.join(map(str, s2)))\n",
        "slowest_solution": "h = int(input())\na = list(map(int, input().split()))\n(p, c, f) = (0, 0, False)\n(s1, s2) = ([], [])\nfor i in a:\n\tfor j in range(i):\n\t\ts1.append(c)\n\t\tif j == i - 1 and (not f) and (p >= 2) and (i >= 2):\n\t\t\tf = True\n\t\t\ts2.append(c - 1)\n\t\telse:\n\t\t\ts2.append(c)\n\tp = i\n\tc += i\nprint('perfect' if not f else 'ambiguous')\nif f:\n\tprint(' '.join(map(str, s1)))\n\tprint(' '.join(map(str, s2)))\n"
    },
    {
        "task_id": 507,
        "slowest_solution_id": 9,
        "fastest_solution_id": 6,
        "slowest_time": 3.0633256435394287,
        "fastest_time": 2.4426796436309814,
        "fastest_solution": "for t in range(int(input())):\n\tco = 0\n\tfor i in range(int(input())):\n\t\tif i % 2 == 0:\n\t\t\tco += 3\n\t\telse:\n\t\t\tco -= 1\n\tprint(co)\n",
        "slowest_solution": "t = int(input())\nwhile t > 0:\n\tk = int(input())\n\tcount = 0\n\tfor i in range(1, k + 1):\n\t\tif i % 2 != 0:\n\t\t\tcount += 3\n\t\telse:\n\t\t\tcount -= 1\n\tprint(count)\n\tt = t - 1\n"
    },
    {
        "task_id": 535,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 3.0598678588867188,
        "fastest_time": 2.5838871002197266,
        "fastest_solution": "from sys import stdin\nfrom collections import defaultdict\nfrom math import gcd\ninp = stdin.readline\n\ndef get_cycle_profile():\n\tprm = tuple((int(s) for s in inp().split()))\n\tcyc = defaultdict(int)\n\tvis = [False] * (len(prm) + 1)\n\tfor p in prm:\n\t\tif vis[p]:\n\t\t\tcontinue\n\t\tplen = 1\n\t\tvis[p] = True\n\t\trov = prm[p - 1]\n\t\twhile not vis[rov]:\n\t\t\tvis[rov] = True\n\t\t\tplen += 1\n\t\t\trov = prm[rov - 1]\n\t\tcyc[plen] += 1\n\treturn tuple(cyc.items())\nT = int(inp())\nans = []\nfor tx in range(T):\n\tN = int(inp())\n\tAcyc = get_cycle_profile()\n\tBcyc = get_cycle_profile()\n\ttotcyc = sum((af * sum((gcd(ac, bc) * bf for (bc, bf) in Bcyc)) for (ac, af) in Acyc))\n\tans.append(N * N - totcyc)\nprint(*ans, sep='\\n')\n",
        "slowest_solution": "from sys import stdin\nfrom collections import defaultdict\nfrom math import gcd\n\ndef cycle_prof(prm):\n\tcyc = defaultdict(int)\n\ttc = [True] * (len(prm) + 1)\n\tfor p in prm:\n\t\tif tc[p]:\n\t\t\tplen = 1\n\t\t\ttc[p] = False\n\t\t\trov = prm[p - 1]\n\t\t\twhile tc[rov]:\n\t\t\t\ttc[rov] = False\n\t\t\t\tplen += 1\n\t\t\t\trov = prm[rov - 1]\n\t\t\tcyc[plen] += 1\n\treturn cyc\ninp = stdin.readline\nT = int(inp())\nfor tx in range(T):\n\tN = int(inp())\n\tAcyc = cycle_prof(list(map(int, inp().split())))\n\tBcyc = cycle_prof(list(map(int, inp().split())))\n\tswaps = 0\n\tfor (ac, af) in Acyc.items():\n\t\tfor (bc, bf) in Bcyc.items():\n\t\t\tg = gcd(ac, bc)\n\t\t\tswaps += (ac * bc - g) * af * bf\n\tprint(swaps)\n"
    },
    {
        "task_id": 508,
        "slowest_solution_id": 9,
        "fastest_solution_id": 6,
        "slowest_time": 3.035284996032715,
        "fastest_time": 2.505411148071289,
        "fastest_solution": "import math\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tvals = input().split(' ')\n\tcur_max = -1\n\tcur_sum = 0\n\tans = -1\n\tfor i in range(n):\n\t\tcur_sum += int(vals[i])\n\t\tcur_ans = math.ceil(cur_sum / (i + 1))\n\t\tif cur_ans > ans:\n\t\t\tans = cur_ans\n\tprint(ans)\n",
        "slowest_solution": "import math\nn = int(input())\nfor i in range(n):\n\tm = int(input())\n\tl = [int(j) for j in input().split()]\n\tl1 = [0] * len(l)\n\tsum = 0\n\tfor i in range(len(l)):\n\t\tsum += l[i]\n\t\tl1[i] = math.ceil(sum / (i + 1))\n\tprint(max(l1))\n"
    },
    {
        "task_id": 510,
        "slowest_solution_id": 9,
        "fastest_solution_id": 5,
        "slowest_time": 3.0373854637145996,
        "fastest_time": 2.506991147994995,
        "fastest_solution": "import itertools\nimport bisect\nimport math\nfrom collections import *\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nii = lambda : int(input())\nlmii = lambda : list(map(int, input().split()))\nli = lambda : list(input())\nmii = lambda : map(int, input().split())\nmsi = lambda : map(str, input().split())\n\ndef main():\n\tn = ii()\n\ta = lmii()\n\tgg = a[0]\n\tcnt = a.count(1)\n\tfor i in range(n):\n\t\tgg = math.gcd(gg, a[i])\n\tif gg != 1:\n\t\tprint(-1)\n\telif cnt:\n\t\tprint(n - cnt)\n\telse:\n\t\tcnt = 0\n\t\tans = sys.maxsize\n\t\tfor i in range(n):\n\t\t\tval = a[i]\n\t\t\tfor j in range(i, n):\n\t\t\t\tval = math.gcd(val, a[j])\n\t\t\t\tif val == 1:\n\t\t\t\t\tpp = j - i\n\t\t\t\t\tans = min(ans, pp)\n\t\tprint(ans + (n - 1))\n\tpass\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n",
        "slowest_solution": "from math import gcd\nn = int(input())\nl = list(map(int, input().split()))\nif l.count(1) > 0:\n\tprint(n - l.count(1))\n\texit()\nm = 10 ** 12\ni = 0\nwhile i < n:\n\tj = i + 1\n\tx = l[i]\n\twhile j < n:\n\t\tif gcd(x, l[j]) == 1:\n\t\t\td = abs(j - i)\n\t\t\tif d < m:\n\t\t\t\tm = d\n\t\tx = gcd(x, l[j])\n\t\tj += 1\n\ti += 1\nif m == 10 ** 12:\n\tprint(-1)\n\texit()\nelse:\n\tprint(m + (n - 1))\n"
    },
    {
        "task_id": 514,
        "slowest_solution_id": 6,
        "fastest_solution_id": 3,
        "slowest_time": 4.106897592544556,
        "fastest_time": 2.7210049629211426,
        "fastest_solution": "import sys\nfrom sys import stdin\n(n, k) = map(int, stdin.readline().split())\nans = []\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\tibl = i\n\t\tjbl = j\n\t\tnow = 0\n\t\twhile ibl != jbl:\n\t\t\tibl //= k\n\t\t\tjbl //= k\n\t\t\tnow += 1\n\t\tans.append(str(now))\ns = set(ans)\nprint(len(s))\nprint(' '.join(ans))\n",
        "slowest_solution": "(n, k) = map(int, input().split())\nbasek = [[-1] * 20 for _ in range(1 + n)]\nbasek[0][0] = [0]\nfor x in range(n):\n\tcur = x\n\ti = 0\n\twhile cur:\n\t\tbasek[x][i] = cur % k\n\t\tcur //= k\n\t\ti += 1\n\ndef diff(x, y):\n\tfor c in range(19, -1, -1):\n\t\tif basek[x][c] != basek[y][c]:\n\t\t\treturn c\n\traise 'wa'\nans = []\nfor x in range(n):\n\tfor y in range(1 + x, n):\n\t\td = diff(x, y)\n\t\tans.append(1 + d)\nprint(len(set(ans)))\nprint(*ans)\n"
    },
    {
        "task_id": 520,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 3.041954517364502,
        "fastest_time": 2.661872148513794,
        "fastest_solution": "def main():\n\tbuf = input()\n\tT = int(buf)\n\tn = []\n\tk = []\n\ta = []\n\tfor i in range(T):\n\t\tbuf = input()\n\t\tbuflist = buf.split()\n\t\tn.append(int(buflist[0]))\n\t\tk.append(int(buflist[1]))\n\t\tbuf = input()\n\t\tbuflist = buf.split()\n\t\ta.append(list(map(int, buflist)))\n\tfor i in range(T):\n\t\ta[i].sort()\n\tfor i in range(T):\n\t\tminimum_point = (a[i][0] + a[i][k[i]]) // 2\n\t\tminimum_value = max(abs(a[i][0] - minimum_point), abs(a[i][k[i]] - minimum_point))\n\t\tfor j in range(1, n[i] - k[i]):\n\t\t\twindow_minimum_point = (a[i][j] + a[i][k[i] + j]) // 2\n\t\t\twindow_minimum_value = max(abs(a[i][j] - window_minimum_point), abs(a[i][k[i] + j] - window_minimum_point))\n\t\t\tif window_minimum_value < minimum_value:\n\t\t\t\tminimum_point = window_minimum_point\n\t\t\t\tminimum_value = window_minimum_value\n\t\tprint(minimum_point)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn map(int, input().split())\n\ndef lm():\n\treturn list(map(int, input().split()))\nq = nn()\nfor _ in range(q):\n\t(n, k) = mi()\n\tl = lm()\n\tm = float('Inf')\n\tfor i in range(0, n - k):\n\t\tif l[i + k] - l[i] < m:\n\t\t\tm = l[i + k] - l[i]\n\t\t\tx = (l[i + k] + l[i]) // 2\n\tprint(x)\n"
    },
    {
        "task_id": 516,
        "slowest_solution_id": 6,
        "fastest_solution_id": 3,
        "slowest_time": 3.0520448684692383,
        "fastest_time": 2.455221652984619,
        "fastest_solution": "S = 3\nP = 10 ** 9 + 7\n\ndef mult(A, B):\n\tC = [[0] * S for _ in range(S)]\n\tfor i in range(S):\n\t\tfor j in range(S):\n\t\t\tfor k in range(S):\n\t\t\t\tC[i][j] = (C[i][j] + A[i][k] * B[k][j]) % P\n\treturn C\nA = [[1, 0, 1], [1, 0, 0], [0, 1, 0]]\nApow2 = [[[1, 0, 0], [0, 1, 0], [0, 0, 1]], A]\nfor _ in range(1, 62):\n\tApow2.append(mult(Apow2[-1], Apow2[-1]))\n\ndef Apow(b):\n\tresult = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\tp2 = 1\n\twhile b:\n\t\tif b & 1:\n\t\t\tresult = mult(result, Apow2[p2])\n\t\tp2 += 1\n\t\tb >>= 1\n\treturn result\n\ndef main():\n\tT = int(input())\n\tfor _ in range(T):\n\t\tN = int(input())\n\t\tM = Apow(N - 2)\n\t\tcnt = 0\n\t\tfor i in range(3):\n\t\t\tfor j in range(3):\n\t\t\t\tcnt = (cnt + M[i][j]) % P\n\t\tprint(cnt)\nmain()\n",
        "slowest_solution": "M = 10 ** 9 + 7\nd = {}\n\ndef f(n):\n\tif n <= 0:\n\t\treturn 1\n\tif n == 1:\n\t\treturn 2\n\tif n == 2:\n\t\treturn 3\n\tif n == 3:\n\t\treturn 4\n\tif n in d:\n\t\treturn d[n]\n\tt1 = f(n // 2 - 1)\n\tt2 = f(n // 2 - 2)\n\tt3 = f(n // 2 - 3)\n\tif n % 2 == 0:\n\t\td[n] = (t1 * t1 + 2 * t2 * t3) % M\n\telse:\n\t\td[n] = (t2 * t2 + 2 * t3 * t1 + t1 * t1) % M\n\treturn d[n]\nT = input()\nfor _ in range(int(T)):\n\tN = int(input())\n\tprint(f(N))\n"
    },
    {
        "task_id": 515,
        "slowest_solution_id": 6,
        "fastest_solution_id": 3,
        "slowest_time": 3.0667357444763184,
        "fastest_time": 2.4940860271453857,
        "fastest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = [int(i) for i in input().split()][:n]\n\t(st, result) = ([], [])\n\tfor i in range(n):\n\t\twhile st and st[-1] <= a[i]:\n\t\t\ttmp = st.pop()\n\t\t\tresult.append(a[i] - tmp)\n\t\tif st:\n\t\t\tresult.append(st[-1] - a[i])\n\t\tst.append(a[i])\n\tprint(len(list(set(result))))\n",
        "slowest_solution": "import sys, math, itertools, random, bisect\nfrom collections import defaultdict\nINF = 10 ** 18\n\ndef get_ints():\n\treturn map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n\treturn list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n\treturn sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\ntest = 1\ntest = int(input())\nfor _ in range(test):\n\t(n,) = get_ints()\n\ta = get_array()\n\tans = set()\n\t(left, right) = ([-1] * n, [-1] * n)\n\tst = []\n\tfor i in range(n):\n\t\twhile st and st[-1] < a[i]:\n\t\t\tst.pop()\n\t\tif st:\n\t\t\tleft[i] = st[-1]\n\t\tst.append(a[i])\n\tst = []\n\tfor i in range(n - 1, -1, -1):\n\t\twhile st and st[-1] < a[i]:\n\t\t\tst.pop()\n\t\tif st:\n\t\t\tright[i] = st[-1]\n\t\tst.append(a[i])\n\tfor i in range(n):\n\t\tif left[i] != -1:\n\t\t\tans.add(left[i] - a[i])\n\t\tif right[i] != -1:\n\t\t\tans.add(right[i] - a[i])\n\tprint(len(ans))\n"
    },
    {
        "task_id": 518,
        "slowest_solution_id": 6,
        "fastest_solution_id": 2,
        "slowest_time": 3.039736747741699,
        "fastest_time": 2.4848413467407227,
        "fastest_solution": "import sys\nfrom time import time\n\ndef h_gen():\n\t(a, b, c) = (1, 2, 3)\n\tfor v in (a, b, c):\n\t\tyield v\n\twhile True:\n\t\t(a, b, c) = (b, c, a + 2 * b + 3 * c)\n\t\tyield c\n\ndef hsqr_gen():\n\t(u, u2) = (1, 1)\n\tfor (i, h) in enumerate(h_gen()):\n\t\tif i + 1 == u2:\n\t\t\tyield (u, h)\n\t\t\tu += 1\n\t\t\tu2 = u * u\n\ndef r_gen():\n\tcache = (0, 0, 0, 0, 1, 1, 1)\n\tyield 1\n\twhile True:\n\t\tyield from cache\nrcache = (1, 0, 0, 0, 0, 1, 1)\n\ndef get_r(n):\n\tu = (n - 1) % len(rcache)\n\treturn rcache[u]\n\ndef get_matrix(n):\n\treturn [[get_r((i + 1) * (j + 1)) for j in range(n)] for i in range(n)]\n\ndef rotate_90(m):\n\tnew_m = []\n\tfor r in range(len(m)):\n\t\tnew_m.append([m[i][r] for i in range(len(m) - 1, -1, -1)])\n\treturn new_m\n\ndef test(n):\n\tfor (i, h) in enumerate(h_gen()):\n\t\tprint(h, end=' ', file=sys.stderr)\n\t\tif i == n:\n\t\t\tbreak\n\tprint(file=sys.stderr)\n\tfor (i, h) in enumerate(hsqr_gen()):\n\t\t(_, v) = h\n\t\tprint(v % 2, end=' ', file=sys.stderr)\n\t\tif i == n:\n\t\t\tbreak\n\tprint(file=sys.stderr)\n\tfor (i, r) in enumerate(r_gen()):\n\t\tprint(r, end=' ', file=sys.stderr)\n\t\tif i == n:\n\t\t\tbreak\n\tprint(file=sys.stderr)\n\tfor i in range(1, n):\n\t\tprint(get_r(i), end=' ', file=sys.stderr)\n\tprint(file=sys.stderr)\n\tm = get_matrix(n)\n\tprint(m, file=sys.stderr)\n\tm = rotate_90(m)\n\tprint(m, file=sys.stderr)\n\ndef get_cache(n):\n\n\tdef count(m1, m2):\n\t\tsm = 0\n\t\tfor i in range(n):\n\t\t\tfor j in range(n):\n\t\t\t\tsm += m1[i][j] ^ m2[i][j]\n\t\treturn sm\n\tm = get_matrix(n)\n\tmm = [m]\n\tfor _ in range(3):\n\t\tmm.append(rotate_90(mm[-1]))\n\tcache = [0] * len(mm)\n\tfor i in range(1, len(mm)):\n\t\tcache[i] = count(mm[0], mm[i])\n\treturn cache\n\ndef solve(cache, angle):\n\tr = angle // 90 % 4\n\treturn cache[r]\ntm = time()\n(n, q) = input().strip().split(' ')\n(n, q) = [int(n), int(q)]\ncache = get_cache(n)\nprint('cache=%s' % cache, file=sys.stderr)\nfor a0 in range(q):\n\tangle = int(input().strip())\n\tprint(solve(cache, angle))\nprint('time elapsed: %s' % (time() - tm), file=sys.stderr)\n",
        "slowest_solution": "import sys\n(n, q) = input().strip().split(' ')\n(n, q) = [int(n), int(q)]\nparity_helper = [1, 1, 0, 1, 0, 0, 1]\nrot_90 = 0\nrot_180 = 0\nfor i in range(1, n // 2 + 1):\n\tfor j in range(1, n + 1):\n\t\tif parity_helper[(i * j) ** 2 % 7] != parity_helper[(j * (1 + n - i)) ** 2 % 7]:\n\t\t\trot_90 += 1\n\t\tif parity_helper[(i * j) ** 2 % 7] != parity_helper[((1 + n - i) * (1 + n - j)) ** 2 % 7]:\n\t\t\trot_180 += 1\nrot_90 = 2 * rot_90\nrot_180 = 2 * rot_180\nif n % 2 == 1:\n\ti = n // 2 + 1\n\tfor j in range(1, n + 1):\n\t\tif parity_helper[(i * j) ** 2 % 7] != parity_helper[(i * (1 + n - j)) ** 2 % 7]:\n\t\t\trot_180 += 1\nrot = [0, rot_90, rot_180, rot_90]\nfor a0 in range(q):\n\tangle = int(input().strip())\n\tprint(rot[int(angle / 90 % 4)])\n"
    },
    {
        "task_id": 521,
        "slowest_solution_id": 5,
        "fastest_solution_id": 2,
        "slowest_time": 3.020676612854004,
        "fastest_time": 2.496075391769409,
        "fastest_solution": "from sys import stdin as cin\nfrom itertools import combinations as c\nmod = 1000000007\nn = int(cin.readline())\na = list(map(int, cin.readline().split()))\nb = list((pow(2, x, mod) for x in a))\ns = 1\nfor x in b:\n\ts = s * (x + 1) % mod\nprint(s - 1)\n",
        "slowest_solution": "n = int(input())\nnums = [int(i) for i in input().split()]\ntot = 1\nfor i in nums:\n\ttot *= (pow(2, i, 1000000007) + 1) % 1000000007\n\ttot = tot % 1000000007\nprint((tot - 1) % 1000000007)\n"
    },
    {
        "task_id": 522,
        "slowest_solution_id": 6,
        "fastest_solution_id": 2,
        "slowest_time": 3.0247373580932617,
        "fastest_time": 2.489654541015625,
        "fastest_solution": "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\nn = eval(input())\ndegrees = list(map(int, input().strip().split()))\nif sum(degrees) == 2 * n - 2:\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n",
        "slowest_solution": "n = int(input())\na = list(map(int,input().split()))\nsum = 0\nfor i in range(len(a)):\n\tsum = sum + a[i]\nif sum/2 == len(a)-1:\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n"
    },
    {
        "task_id": 523,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 3.0292470455169678,
        "fastest_time": 2.591278314590454,
        "fastest_solution": "for i in range(int(input())):\n\t(j, k, l) = map(int, input().split())\n\tf = k * l\n\tif j <= f:\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')\n",
        "slowest_solution": "n = int(input())\nfor i in range(n):\n\t(a, b, c) = map(int, input().split())\n\tif b * c >= a:\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')\n"
    },
    {
        "task_id": 555,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 3.027383327484131,
        "fastest_time": 2.780308246612549,
        "fastest_solution": "from collections import defaultdict, deque\nadj = defaultdict(lambda : defaultdict(lambda : 0))\n\ndef bfs(graph, inicio, destino, parent):\n\tparent.clear()\n\tqueue = deque()\n\tqueue.append([inicio, float('Inf')])\n\tparent[inicio] = -2\n\twhile len(queue):\n\t\t(current, flow) = queue.popleft()\n\t\tfor i in adj[current]:\n\t\t\tif parent[i] == -1 and graph[current][i] > 0:\n\t\t\t\tparent[i] = current\n\t\t\t\tflow = min(flow, graph[current][i])\n\t\t\t\tif i == destino:\n\t\t\t\t\treturn flow\n\t\t\t\tqueue.append((i, flow))\n\treturn 0\n\ndef maxflow(graph, inicio, destino):\n\tflow = 0\n\tparent = defaultdict(lambda : -1)\n\twhile True:\n\t\tt = bfs(graph, inicio, destino, parent)\n\t\tif t:\n\t\t\tflow += t\n\t\t\tcurrent = destino\n\t\t\twhile current != inicio:\n\t\t\t\tprev = parent[current]\n\t\t\t\tgraph[prev][current] -= t\n\t\t\t\tgraph[current][prev] += t\n\t\t\t\tcurrent = prev\n\t\telse:\n\t\t\tbreak\n\treturn flow\n(n, m, x) = [int(i) for i in input().split()]\nfor _ in range(m):\n\tt = [int(i) for i in input().split()]\n\tadj[t[0]][t[1]] = t[2]\n\ndef check(k):\n\tmeh = defaultdict(lambda : defaultdict(lambda : 0))\n\tfor i in adj:\n\t\tfor j in adj[i]:\n\t\t\tww = adj[i][j] // k\n\t\t\tmeh[i][j] = ww\n\tflow = maxflow(meh, 1, n)\n\treturn flow\nlo = 1 / x\nhi = check(1)\nfor _ in range(70):\n\tmid = (hi + lo) / 2\n\tif hi - lo < 1e-10:\n\t\tbreak\n\tif check(mid) >= x:\n\t\tlo = mid\n\telse:\n\t\thi = mid\nprint(format(lo * x, '.9f'))\n",
        "slowest_solution": "from collections import deque\n\nclass Dinic:\n\n\tdef __init__(self, listEdge, s, t):\n\t\tself.s = s\n\t\tself.t = t\n\t\tself.graph = {}\n\t\tself.maxCap = 1000000\n\t\tfor e in listEdge:\n\t\t\tif e[0] not in self.graph:\n\t\t\t\tself.graph[e[0]] = []\n\t\t\tif e[1] not in self.graph:\n\t\t\t\tself.graph[e[1]] = []\n\t\t\tself.graph[e[0]].append([e[1], e[2], len(self.graph[e[1]])])\n\t\t\tself.graph[e[1]].append([e[0], 0, len(self.graph[e[0]]) - 1])\n\t\tself.N = len(self.graph.keys())\n\n\tdef bfs(self):\n\t\tself.dist = {}\n\t\tself.dist[self.s] = 0\n\t\tself.curIter = {node: [] for node in self.graph}\n\t\tQ = deque([self.s])\n\t\twhile len(Q) > 0:\n\t\t\tcur = Q.popleft()\n\t\t\tfor (index, e) in enumerate(self.graph[cur]):\n\t\t\t\tif e[1] > 0 and e[0] not in self.dist:\n\t\t\t\t\tself.dist[e[0]] = self.dist[cur] + 1\n\t\t\t\t\tself.curIter[cur].append(index)\n\t\t\t\t\tQ.append(e[0])\n\n\tdef findPath(self, cur, f):\n\t\tif cur == self.t:\n\t\t\treturn f\n\t\twhile len(self.curIter[cur]) > 0:\n\t\t\tindexEdge = self.curIter[cur][-1]\n\t\t\tnextNode = self.graph[cur][indexEdge][0]\n\t\t\tremainCap = self.graph[cur][indexEdge][1]\n\t\t\tindexPreEdge = self.graph[cur][indexEdge][2]\n\t\t\tif remainCap > 0 and self.dist[nextNode] > self.dist[cur]:\n\t\t\t\tflow = self.findPath(nextNode, min(f, remainCap))\n\t\t\t\tif flow > 0:\n\t\t\t\t\tself.path.append(cur)\n\t\t\t\t\tself.graph[cur][indexEdge][1] -= flow\n\t\t\t\t\tself.graph[nextNode][indexPreEdge][1] += flow\n\t\t\t\t\treturn flow\n\t\t\tself.curIter[cur].pop()\n\t\treturn 0\n\n\tdef maxFlow(self):\n\t\tmaxflow = 0\n\t\tflow = []\n\t\twhile True:\n\t\t\tself.bfs()\n\t\t\tif self.t not in self.dist:\n\t\t\t\tbreak\n\t\t\twhile True:\n\t\t\t\tself.path = []\n\t\t\t\tf = self.findPath(self.s, self.maxCap)\n\t\t\t\tif f == 0:\n\t\t\t\t\tbreak\n\t\t\t\tflow.append(f)\n\t\t\t\tmaxflow += f\n\t\treturn maxflow\n\n\tdef residualBfs(self):\n\t\tQ = deque([self.s])\n\t\tside = {self.s: 's'}\n\t\twhile len(Q) > 0:\n\t\t\tcur = Q.popleft()\n\t\t\tfor (index, e) in enumerate(self.graph[cur]):\n\t\t\t\tif e[1] > 0 and e[0] not in side:\n\t\t\t\t\tQ.append(e[0])\n\t\t\t\t\tside[e[0]] = 's'\n\t\tS = []\n\t\tT = []\n\t\tfor x in self.graph:\n\t\t\tif x in side:\n\t\t\t\tS.append(x)\n\t\t\telse:\n\t\t\t\tT.append(x)\n\t\treturn (set(S), set(T))\n(n, m, X) = map(int, input().split())\nedge = [list(map(int, input().split())) for _ in range(m)]\n(l, r) = (0, 1000000)\nwhile r - l > 1e-09:\n\tmd = (r + l) / 2\n\tedge_ = [[u, v, w // md] for (u, v, w) in edge]\n\tg = Dinic(edge_, 1, n)\n\tmaxflow = g.maxFlow()\n\tif maxflow >= X:\n\t\tl = md\n\telse:\n\t\tr = md\nprint(X * r)\n"
    },
    {
        "task_id": 540,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 3.0211727619171143,
        "fastest_time": 2.8387954235076904,
        "fastest_solution": "from bisect import bisect\nn = int(input())\nelements = list(map(int, input().split()))\ntree = []\nans = [''] * n\nfor (i, x) in enumerate(elements):\n\tindex = bisect(tree, (x, i))\n\tif i != 0:\n\t\tif index == 0:\n\t\t\tans[i] = str(tree[0][0])\n\t\telif index == i:\n\t\t\tans[i] = str(tree[i - 1][0])\n\t\telif tree[index - 1][1] < tree[index][1]:\n\t\t\tans[i] = str(tree[index][0])\n\t\telse:\n\t\t\tans[i] = str(tree[index - 1][0])\n\ttree[index:index] = [(x, i)]\nprint(' '.join(ans[1:]))\n",
        "slowest_solution": "class RedBlackTree:\n\t_nil = (None, False, None, None, None)\n\n\tdef __init__(self):\n\t\tself._root = RedBlackTree._nil\n\n\tdef insert_key(self, key):\n\t\ty = self.search(key, True)\n\t\tz = [key, False, None, None, y]\n\t\tif y is RedBlackTree._nil:\n\t\t\tself._root = z\n\t\telse:\n\t\t\ty[2 if z[0] < y[0] else 3] = z\n\t\tz[2] = z[3] = RedBlackTree._nil\n\t\tz[1] = True\n\t\tself._insert_fixup(z)\n\n\tdef _insert_fixup(self, z):\n\t\twhile z[4][1]:\n\t\t\tif z[4] == z[4][4][2]:\n\t\t\t\ty = z[4][4][3]\n\t\t\t\tif y[1]:\n\t\t\t\t\tz[4][1] = y[1] = False\n\t\t\t\t\tz[4][4][1] = True\n\t\t\t\t\tz = z[4][4]\n\t\t\t\telse:\n\t\t\t\t\tif z == z[4][3]:\n\t\t\t\t\t\tz = z[4]\n\t\t\t\t\t\tself._left_rotate(z)\n\t\t\t\t\tz[4][1] = False\n\t\t\t\t\tz[4][4][1] = True\n\t\t\t\t\tself._right_rotate(z[4][4])\n\t\t\telse:\n\t\t\t\ty = z[4][4][2]\n\t\t\t\tif y[1]:\n\t\t\t\t\tz[4][1] = y[1] = False\n\t\t\t\t\tz[4][4][1] = True\n\t\t\t\t\tz = z[4][4]\n\t\t\t\telse:\n\t\t\t\t\tif z == z[4][2]:\n\t\t\t\t\t\tz = z[4]\n\t\t\t\t\t\tself._right_rotate(z)\n\t\t\t\t\tz[4][1] = False\n\t\t\t\t\tz[4][4][1] = True\n\t\t\t\t\tself._left_rotate(z[4][4])\n\t\tself._root[1] = False\n\n\tdef _left_rotate(self, x):\n\t\ty = x[3]\n\t\tx[3] = y[2]\n\t\tif y[2] is not RedBlackTree._nil:\n\t\t\ty[2][4] = x\n\t\ty[4] = x[4]\n\t\tif x[4] is RedBlackTree._nil:\n\t\t\tself._root = y\n\t\telse:\n\t\t\tx[4][3 - (x == x[4][2])] = y\n\t\ty[2] = x\n\t\tx[4] = y\n\n\tdef _right_rotate(self, y):\n\t\tx = y[2]\n\t\ty[2] = x[3]\n\t\tif x[3] is not RedBlackTree._nil:\n\t\t\tx[3][4] = y\n\t\tx[4] = y[4]\n\t\tif y[4] is RedBlackTree._nil:\n\t\t\tself._root = x\n\t\telse:\n\t\t\ty[4][2 + (y == y[4][3])] = x\n\t\tx[3] = y\n\t\ty[4] = x\n\n\tdef search(self, key, s):\n\t\t(x, g) = (self._root, RedBlackTree._nil)\n\t\twhile x is not RedBlackTree._nil:\n\t\t\t(g, x) = (x, x[2 if key < x[0] else 3])\n\t\treturn g\n\n\tdef search2(self, key):\n\t\ta = b = None\n\t\tx = self._root\n\t\twhile x is not RedBlackTree._nil and key != x[0]:\n\t\t\tif key < x[0]:\n\t\t\t\t(a, x) = (x, x[2])\n\t\t\telse:\n\t\t\t\t(b, x) = (x, x[3])\n\t\tif key != x[0]:\n\t\t\treturn (a, b)\n\ndef main():\n\tinput()\n\t(a, *aa) = list(map(int, input().split()))\n\tt = RedBlackTree()\n\tt.insert_key([a, 0, 0])\n\te = []\n\tfor a in aa:\n\t\t(o, u) = t.search2([a, 0, 0])\n\t\tif u is None:\n\t\t\te.append(o[0][0])\n\t\t\to[0][2 - (o[0][0] > a)] = 1\n\t\telif o is None:\n\t\t\te.append(u[0][0])\n\t\t\tu[0][2 - (u[0][0] > a)] = 1\n\t\telif o[0][0] > a < u[0][0]:\n\t\t\tif o[0][1] == 0:\n\t\t\t\to[0][1] = 1\n\t\t\t\te.append(o[0][0])\n\t\t\telse:\n\t\t\t\tu[0][1] = 1\n\t\t\t\te.append(u[0][0])\n\t\telif o[0][0] < a < u[0][0]:\n\t\t\tif o[0][2]:\n\t\t\t\tu[0][1] = 1\n\t\t\t\te.append(u[0][0])\n\t\t\telse:\n\t\t\t\to[0][2] = 1\n\t\t\t\te.append(o[0][0])\n\t\telif o[0][0] > a > u[0][0]:\n\t\t\tif o[0][1]:\n\t\t\t\tu[0][2] = 1\n\t\t\t\te.append(u[0][0])\n\t\t\telse:\n\t\t\t\to[0][1] = 1\n\t\t\t\te.append(o[0][0])\n\t\telif o[0][0] < a > u[0][0]:\n\t\t\tif o[0][2]:\n\t\t\t\tu[0][2] = 1\n\t\t\t\te.append(u[0][0])\n\t\t\telse:\n\t\t\t\to[0][2] = 1\n\t\t\t\te.append(o[0][0])\n\t\tt.insert_key([a, 0, 0])\n\tprint(*e)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n"
    },
    {
        "task_id": 526,
        "slowest_solution_id": 5,
        "fastest_solution_id": 1,
        "slowest_time": 3.048072338104248,
        "fastest_time": 2.5844013690948486,
        "fastest_solution": "n = int(input())\nans = [0] * 2 ** 18\ntrantab = str.maketrans('0123456789', '0101010101')\nfor i in range(n):\n\t(ch, s) = map(str, input().split())\n\tif ch == '+':\n\t\tans[int(s.translate(trantab), 2)] += 1\n\telif ch == '-':\n\t\tans[int(s.translate(trantab), 2)] -= 1\n\telse:\n\t\tprint(ans[int(s.translate(trantab), 2)])\n",
        "slowest_solution": "from sys import stdin\n\ndef main():\n\tcnt = [0] * 2 ** 18\n\tt = str.maketrans('0123456789', '0101010101')\n\tinput()\n\tfor (sign, s) in map(str.split, stdin):\n\t\tif sign == '?':\n\t\t\tprint(cnt[int(s, 2)])\n\t\telse:\n\t\t\tcnt[int(s.translate(t), 2)] += 1 if sign == '+' else -1\nmain()\n"
    },
    {
        "task_id": 528,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 3.0562915802001953,
        "fastest_time": 2.5554680824279785,
        "fastest_solution": "t = int(input())\nwhile t:\n\tn = int(input())\n\tp = input().split()\n\tp = [int(x) for x in p]\n\tq = [0 for i in range(n)]\n\tfor i in range(n):\n\t\tq[p[i] - 1] = i + 1\n\tflag = True\n\tprev = q[0]\n\tfor i in range(1, n):\n\t\tif q[i] != prev + 1:\n\t\t\tif q[i] > prev:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\tprev = q[i]\n\t\telse:\n\t\t\tprev = q[i]\n\tif flag:\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')\n\tt -= 1\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef main():\n\ttestcases = int(input())\n\tfor j in range(testcases):\n\t\tn = int(input())\n\t\tperms = list(map(int, input().split()))\n\t\tval = True\n\t\tfor s in range(1, n):\n\t\t\tif perms[s] > perms[s - 1] + 1:\n\t\t\t\tval = False\n\t\t\t\tbreak\n\t\tif val == True:\n\t\t\tprint('Yes')\n\t\telse:\n\t\t\tprint('No')\nmain()\n"
    },
    {
        "task_id": 565,
        "slowest_solution_id": 6,
        "fastest_solution_id": 0,
        "slowest_time": 0.0005323886871337891,
        "fastest_time": 0.0,
        "fastest_solution": "import re\n\ndef signed_eight_bit_number(number):\n\treturn bool(re.match('(0|-128|-?([1-9]|[1-9]\\\\d|1[01]\\\\d|12[0-7]))\\\\Z', number))\n",
        "slowest_solution": "def signed_eight_bit_number(number):\n\treturn number in list(map(str, list(range(-128, 128))))\n"
    },
    {
        "task_id": 531,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 3.040691375732422,
        "fastest_time": 2.5606207847595215,
        "fastest_solution": "from bisect import bisect_right, bisect_left\nimport sys\n\ndef input():\n\treturn sys.stdin.buffer.readline().rstrip()\n(n, m) = map(int, input().split())\na = list(map(int, input().split()))\nla = a[:n // 2]\nra = a[n // 2:]\nLa = [0]\nRa = [0]\nlen_la = len(la)\nfor i in range(1 << len_la):\n\tv = 0\n\tV = i\n\tfor bit in range(len_la):\n\t\tif V & 1:\n\t\t\tv += la[bit]\n\t\tV >>= 1\n\tLa.append(v % m)\nlen_ra = len(ra)\nfor i in range(1 << len_ra):\n\tv = 0\n\tV = i\n\tfor bit in range(len_ra):\n\t\tif V & 1:\n\t\t\tv += ra[bit]\n\t\tV >>= 1\n\tRa.append(v % m)\nans = 0\nLa.sort()\nRa.sort()\nfor v in La:\n\tans = max(ans, v + Ra[bisect_right(Ra, m - 1 - v) - 1])\nprint(ans)\n",
        "slowest_solution": "from sys import stdin\nfrom bisect import *\nfrom math import *\ng = lambda : stdin.readline().strip()\ngl = lambda : g().split()\ngil = lambda : [int(var) for var in gl()]\ngfl = lambda : [float(var) for var in gl()]\ngcl = lambda : list(g())\ngbs = lambda : [int(var) for var in g()]\nmod = int(1000000000.0) + 7\ninf = float('inf')\n(n, m) = gil()\na = gil()\n\ndef getSubsetSum(a):\n\tvals = set([0])\n\ttmp = []\n\tans = 0\n\tfor v in a:\n\t\tfor ov in vals:\n\t\t\ttmp.append((ov + v) % m if ov + v >= m else v + ov)\n\t\twhile tmp:\n\t\t\tif len(tmp) >= 10000000.0:\n\t\t\t\tprint('fuvk')\n\t\t\t\texit()\n\t\t\tans = max(ans, tmp[-1])\n\t\t\tvals.add(tmp.pop())\n\treturn sorted(vals)\np = n & 1\n(l, r) = (getSubsetSum(a[:n // 2 + p]), getSubsetSum(a[n // 2 + p:]))\nans = 0\n(nl, nr) = (len(l), len(r))\nfor v in l:\n\ti = bisect_left(r, m - v)\n\tif i:\n\t\tans = max(ans, r[i - 1] + v)\n\ti = bisect_left(r, 2 * m - v)\n\tif i:\n\t\tans = max(ans, (r[i - 1] + v) % m)\nprint(ans)\n"
    },
    {
        "task_id": 563,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.885601282119751,
        "fastest_time": 2.885601282119751,
        "fastest_solution": "from functools import reduce\nfrom operator import mul\n\ndef main():\n\tn = int(input())\n\tprint(count_vecs(list(map(int, input().split()))))\np = 998244353\n\ndef count_vecs(A, q=239):\n\tif A == []:\n\t\treturn 1\n\tif A.count(0) > 0:\n\t\tnonzeroes = [a for a in A if a != 0]\n\t\treturn count_vecs(nonzeroes, q) * fall(q - len(nonzeroes), A.count(0)) % p\n\tans = fall(q - 1, len(A) - 1)\n\tif sum(A) % q == 0:\n\t\tA_dict = dict()\n\t\tfor a in A:\n\t\t\tif a not in A_dict:\n\t\t\t\tA_dict[a] = 0\n\t\t\tA_dict[a] += 1\n\t\tA_unique = sorted(A_dict.keys())\n\t\tM = [A_dict[a] for a in A_unique]\n\t\tfor (P, mult) in zp(A_unique, M, q):\n\t\t\tm = len(P)\n\t\t\tmu_coef = (-1) ** (len(A) - m) * prod([fac(k - 1) for k in P])\n\t\t\tans += mu_coef * pow_mod(q, m - 1) * (q - 1) * mult\n\t\t\tans %= p\n\treturn ans\n\ndef zp(A, M, q=239, accum=[], sym_facs=[]):\n\tif sum(M) == 0:\n\t\trepeats = 1\n\t\tfor L in zip(*accum):\n\t\t\trepeats *= multinomial_mod_p(L)\n\t\t\trepeats %= p\n\t\tfor (num, den) in sym_facs:\n\t\t\trepeats *= num * invert_mod(den, p)\n\t\t\trepeats %= p\n\t\tyield (list(map(sum, accum)), repeats)\n\t\treturn\n\tk = len(M)\n\tstart = 0\n\twhile M[start] == 0:\n\t\tstart += 1\n\tM[start] -= 1\n\tcurr = [0] * k\n\tdirs = [1] * k\n\tsubset_sum = A[start]\n\twhile True:\n\t\ti = start\n\t\twhile i < k and (not 0 <= curr[i] + dirs[i] <= M[i]):\n\t\t\tdirs[i] *= -1\n\t\t\ti += 1\n\t\tif i == k:\n\t\t\tbreak\n\t\tcurr[i] += dirs[i]\n\t\tsubset_sum += dirs[i] * A[i]\n\t\tsubset_sum %= q\n\t\tif subset_sum == 0:\n\t\t\trest = [M[i] - curr[i] for i in range(k)]\n\t\t\tcurr[start] += 1\n\t\t\tfor P in zp(A, rest, q, accum + [curr], sym_facs + [(curr[start], M[start] + 1)]):\n\t\t\t\tyield P\n\t\t\tcurr[start] -= 1\n\ndef multinomial_mod_p(L):\n\tn = sum(L)\n\tif n == 0:\n\t\treturn 1\n\tL_sorted = sorted(L)\n\taccum = 1\n\tpos = 0\n\tj = 0\n\tdenom = 1\n\twhile pos < len(L) - 1:\n\t\tif denom > L_sorted[pos]:\n\t\t\tdenom = 1\n\t\t\tpos += 1\n\t\telse:\n\t\t\taccum = accum * (n - j) * invert_mod(denom, p)\n\t\t\taccum %= p\n\t\t\tdenom += 1\n\t\t\tj += 1\n\treturn accum\n\ndef pow_mod(b, n):\n\tif n <= 1:\n\t\treturn b ** n % p\n\tsqrt = pow_mod(b, n // 2)\n\tans = sqrt * sqrt % p\n\tif n % 2:\n\t\tans = ans * b % p\n\treturn ans\n\ndef prod(L):\n\treturn reduce(mul, L, 1)\n\ndef fall(x, n):\n\taccum = 1\n\tfor i in range(x, x - n, -1):\n\t\taccum *= i\n\t\taccum %= p\n\treturn accum\n\ndef fac(n):\n\treturn fall(n, n)\n\ndef bezout_solver(a, b):\n\tif a < b:\n\t\t(y, x) = bezout_solver(b, a)\n\t\treturn (x, y)\n\telif b + b == b:\n\t\treturn (a // a, b - b)\n\t(q, r) = (a // b, a % b)\n\t(z, x) = bezout_solver(b, r)\n\treturn (x, z - q * x)\n\ndef invert_mod(num, modulus):\n\treturn bezout_solver(modulus, num)[1] % modulus\nmain()\n",
        "slowest_solution": "from functools import reduce\nfrom operator import mul\n\ndef main():\n\tn = int(input())\n\tprint(count_vecs(list(map(int, input().split()))))\np = 998244353\n\ndef count_vecs(A, q=239):\n\tif A == []:\n\t\treturn 1\n\tif A.count(0) > 0:\n\t\tnonzeroes = [a for a in A if a != 0]\n\t\treturn count_vecs(nonzeroes, q) * fall(q - len(nonzeroes), A.count(0)) % p\n\tans = fall(q - 1, len(A) - 1)\n\tif sum(A) % q == 0:\n\t\tA_dict = dict()\n\t\tfor a in A:\n\t\t\tif a not in A_dict:\n\t\t\t\tA_dict[a] = 0\n\t\t\tA_dict[a] += 1\n\t\tA_unique = sorted(A_dict.keys())\n\t\tM = [A_dict[a] for a in A_unique]\n\t\tfor (P, mult) in zp(A_unique, M, q):\n\t\t\tm = len(P)\n\t\t\tmu_coef = (-1) ** (len(A) - m) * prod([fac(k - 1) for k in P])\n\t\t\tans += mu_coef * pow_mod(q, m - 1) * (q - 1) * mult\n\t\t\tans %= p\n\treturn ans\n\ndef zp(A, M, q=239, accum=[], sym_facs=[]):\n\tif sum(M) == 0:\n\t\trepeats = 1\n\t\tfor L in zip(*accum):\n\t\t\trepeats *= multinomial_mod_p(L)\n\t\t\trepeats %= p\n\t\tfor (num, den) in sym_facs:\n\t\t\trepeats *= num * invert_mod(den, p)\n\t\t\trepeats %= p\n\t\tyield (list(map(sum, accum)), repeats)\n\t\treturn\n\tk = len(M)\n\tstart = 0\n\twhile M[start] == 0:\n\t\tstart += 1\n\tM[start] -= 1\n\tcurr = [0] * k\n\tdirs = [1] * k\n\tsubset_sum = A[start]\n\twhile True:\n\t\ti = start\n\t\twhile i < k and (not 0 <= curr[i] + dirs[i] <= M[i]):\n\t\t\tdirs[i] *= -1\n\t\t\ti += 1\n\t\tif i == k:\n\t\t\tbreak\n\t\tcurr[i] += dirs[i]\n\t\tsubset_sum += dirs[i] * A[i]\n\t\tsubset_sum %= q\n\t\tif subset_sum == 0:\n\t\t\trest = [M[i] - curr[i] for i in range(k)]\n\t\t\tcurr[start] += 1\n\t\t\tfor P in zp(A, rest, q, accum + [curr], sym_facs + [(curr[start], M[start] + 1)]):\n\t\t\t\tyield P\n\t\t\tcurr[start] -= 1\n\ndef multinomial_mod_p(L):\n\tn = sum(L)\n\tif n == 0:\n\t\treturn 1\n\tL_sorted = sorted(L)\n\taccum = 1\n\tpos = 0\n\tj = 0\n\tdenom = 1\n\twhile pos < len(L) - 1:\n\t\tif denom > L_sorted[pos]:\n\t\t\tdenom = 1\n\t\t\tpos += 1\n\t\telse:\n\t\t\taccum = accum * (n - j) * invert_mod(denom, p)\n\t\t\taccum %= p\n\t\t\tdenom += 1\n\t\t\tj += 1\n\treturn accum\n\ndef pow_mod(b, n):\n\tif n <= 1:\n\t\treturn b ** n % p\n\tsqrt = pow_mod(b, n // 2)\n\tans = sqrt * sqrt % p\n\tif n % 2:\n\t\tans = ans * b % p\n\treturn ans\n\ndef prod(L):\n\treturn reduce(mul, L, 1)\n\ndef fall(x, n):\n\taccum = 1\n\tfor i in range(x, x - n, -1):\n\t\taccum *= i\n\t\taccum %= p\n\treturn accum\n\ndef fac(n):\n\treturn fall(n, n)\n\ndef bezout_solver(a, b):\n\tif a < b:\n\t\t(y, x) = bezout_solver(b, a)\n\t\treturn (x, y)\n\telif b + b == b:\n\t\treturn (a // a, b - b)\n\t(q, r) = (a // b, a % b)\n\t(z, x) = bezout_solver(b, r)\n\treturn (x, z - q * x)\n\ndef invert_mod(num, modulus):\n\treturn bezout_solver(modulus, num)[1] % modulus\nmain()\n"
    },
    {
        "task_id": 569,
        "slowest_solution_id": 6,
        "fastest_solution_id": 0,
        "slowest_time": 0.0005402565002441406,
        "fastest_time": 0.0,
        "fastest_solution": "def count_adjacent_pairs(st):\n\twords = st.lower().split(' ')\n\tcurrentWord = None\n\tcount = 0\n\tfor (i, word) in enumerate(words):\n\t\tif i + 1 < len(words):\n\t\t\tif word == words[i + 1]:\n\t\t\t\tif word != currentWord:\n\t\t\t\t\tcurrentWord = word\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcurrentWord = None\n\treturn count\n",
        "slowest_solution": "import re\ncount_adjacent_pairs = lambda s: len(re.findall('(\\\\b\\\\w+)(\\\\s+\\\\1)+', s, re.I))\n"
    },
    {
        "task_id": 527,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 3.033581018447876,
        "fastest_time": 2.4884815216064453,
        "fastest_solution": "n = input()\nans = tmp = 0.0\nprod = 1.0\nfor p in reversed(sorted(map(float, input().split()))):\n\ttmp = tmp * (1.0 - p) + prod * p\n\tprod *= 1.0 - p\n\tans = max(ans, tmp)\nprint('%0.9f' % ans)\n",
        "slowest_solution": "n = int(input())\na = list(reversed(sorted(list(map(float, input().split())))))\nA = a[0]\nB = 1 - a[0]\nfor i in range(1, n):\n\tif (1 - a[i]) * A + a[i] * B > A:\n\t\tA = (1 - a[i]) * A + a[i] * B\n\t\tB *= 1 - a[i]\nprint(A)\n"
    },
    {
        "task_id": 536,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 3.044440507888794,
        "fastest_time": 2.616438627243042,
        "fastest_solution": "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\ns = input()\ni = ans = 0\nwhile i < n:\n\tj = i\n\twhile i + 1 < n and s[i + 1] == s[i]:\n\t\ti += 1\n\tans += sum(sorted(l[j:i + 1])[-k:])\n\ti += 1\nprint(ans)\n",
        "slowest_solution": "(n, k) = map(int, input().split())\nA = list(map(int, input().split()))\nS = input()\nans = j = 0\nn = len(S)\nfor i in range(n):\n\tif i == n - 1 or S[i] != S[i + 1]:\n\t\tans += sum(sorted(A[j:i + 1])[-k:])\n\t\tj = i + 1\nprint(ans)\n"
    },
    {
        "task_id": 533,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.994530200958252,
        "fastest_time": 2.610588312149048,
        "fastest_solution": "t = int(input())\n\ndef solve(arr):\n\tif len(arr) == 1:\n\t\treturn [0, arr]\n\tans = 0\n\tleft = arr[:len(arr) // 2]\n\tright = arr[len(arr) // 2:]\n\t(val1, lis1) = solve(left)\n\t(val2, lis2) = solve(right)\n\t(val, lis) = merge(lis1, lis2)\n\treturn [val + val1 + val2, lis]\n\ndef merge(left, right):\n\tans = []\n\tfinal = 0\n\t(i, j) = (0, 0)\n\tn = len(left)\n\twhile i < len(left) and j < len(right):\n\t\tif left[i] < right[j]:\n\t\t\tans += [left[i]]\n\t\t\ti += 1\n\t\telse:\n\t\t\tans += [right[j]]\n\t\t\tfinal += n - i\n\t\t\tj += 1\n\tans += left[i:] + right[j:]\n\treturn [final, ans]\nfor _ in range(t):\n\t(n, d) = list(map(int, input().split()))\n\tarr = list(map(int, input().split()))\n\tans = 0\n\tdic = {i: [] for i in range(d)}\n\tfound = False\n\tfor i in range(n):\n\t\tif (arr[i] - i - 1) % d != 0:\n\t\t\tfound = True\n\t\t\tbreak\n\t\telif arr[i] % d == 0:\n\t\t\tdic[0] += [arr[i] // d - 1]\n\t\telse:\n\t\t\tdic[arr[i] % d] += [(arr[i] - arr[i] % d) // d]\n\tif found:\n\t\tprint(-1)\n\telse:\n\t\tans = 0\n\t\tfor perm in list(dic.values()):\n\t\t\tans += solve(perm)[0]\n\t\tprint(ans)\n",
        "slowest_solution": "def merge(arr, start, mid, end):\n\tp = start\n\tq = mid + 1\n\tk = 0\n\tinv = 0\n\ttemp = [0] * len(arr)\n\tfor i in range(start, end + 1):\n\t\tif p > mid:\n\t\t\ttemp[k] = arr[q]\n\t\t\tk += 1\n\t\t\tq += 1\n\t\telif q > end:\n\t\t\ttemp[k] = arr[p]\n\t\t\tk += 1\n\t\t\tp += 1\n\t\telif arr[p] <= arr[q]:\n\t\t\ttemp[k] = arr[p]\n\t\t\tp += 1\n\t\t\tk += 1\n\t\telse:\n\t\t\ttemp[k] = arr[q]\n\t\t\tq += 1\n\t\t\tk += 1\n\t\t\tinv += mid - p + 1\n\tfor i in range(k):\n\t\tarr[start] = temp[i]\n\t\tstart += 1\n\treturn inv\n\ndef mergesort(arr, start, end):\n\tinv_count = 0\n\tif start < end:\n\t\tmid = (start + end) // 2\n\t\tinv_count += mergesort(arr, start, mid)\n\t\tinv_count += mergesort(arr, mid + 1, end)\n\t\tinv_count += merge(arr, start, mid, end)\n\treturn inv_count\n\ndef solve():\n\t(n, d) = map(int, input().split())\n\tp = list(map(int, input().split()))\n\tinv_count = 0\n\tm = [0] * n\n\tsb = True\n\tfor i in range(d):\n\t\tk = 0\n\t\tfor j in range(i, n, d):\n\t\t\tm[k] = p[j]\n\t\t\tk += 1\n\t\tinv_count += mergesort(m, 0, k - 1)\n\t\tk = 0\n\t\tfor j in range(i, n, d):\n\t\t\tif not m[k] == j + 1:\n\t\t\t\tsb = False\n\t\t\t\tbreak\n\t\t\tk += 1\n\tif sb:\n\t\tprint(inv_count)\n\telse:\n\t\tprint(-1)\n\ndef main():\n\tfor _ in range(int(input())):\n\t\tsolve()\nmain()\n"
    },
    {
        "task_id": 530,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 3.032008647918701,
        "fastest_time": 2.561796188354492,
        "fastest_solution": "n = int(input())\nd = {}\nfor _ in range(n):\n\tname = input()\n\tif name[0] in d:\n\t\td[name[0]] += 1\n\telse:\n\t\td[name[0]] = 1\nres = 0\nfor i in d:\n\ta = d[i] // 2\n\tb = d[i] - a\n\tres += a * (a - 1) / 2 + b * (b - 1) / 2\nprint(int(res))\n",
        "slowest_solution": "from collections import *\nn = int(input())\nl = [input()[:1] for i in range(n)]\nans = 0\nd = Counter(l)\nfor i in d:\n\tx = 0\n\ty = 0\n\tif d[i] % 2 == 1:\n\t\tx = d[i] // 2\n\t\ty = x + 1\n\t\tans += x * (x - 1) // 2\n\t\tans += y * (y - 1) // 2\n\telse:\n\t\tx = d[i] // 2\n\t\tans += x * (x - 1) // 2\n\t\tans += x * (x - 1) // 2\nprint(ans)\n"
    },
    {
        "task_id": 529,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 3.038062334060669,
        "fastest_time": 2.581444263458252,
        "fastest_solution": "n = int(input())\nfor i in range(n):\n\t(k, l) = map(int, input().split())\n\tbc = l\n\tans = 0\n\tkp = 1000000007\n\tfor j in range(1, k + 1):\n\t\tl = pow(bc, 2 * j - 1, kp)\n\t\tans = (l + ans) % kp\n\t\tbc = l * bc % kp\n\tprint(ans)\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\t(n, a) = map(int, input().split())\n\tsum1 = 0\n\tfor j in range(n):\n\t\tp = pow(a, 2 * j + 1, 1000000007)\n\t\tsum1 += p\n\t\tsum1 %= 1000000007\n\t\ta *= p\n\t\ta %= 1000000007\n\tprint(sum1 % 1000000007)\n"
    },
    {
        "task_id": 534,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 3.062173366546631,
        "fastest_time": 2.628084659576416,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\neins = set()\nfor _ in range(m):\n\t(v, to) = map(int, input().split())\n\teins.add((v, to))\n\teins.add((to, v))\nnotVisited = set(range(1, n + 1))\ncomps = []\nfor s in range(1, n + 1):\n\tif s in notVisited:\n\t\tnotVisited.remove(s)\n\t\tctr = 1\n\t\tstack = [s]\n\t\twhile stack:\n\t\t\tv = stack.pop()\n\t\t\tvisited = set()\n\t\t\tfor to in notVisited:\n\t\t\t\tif (v, to) not in eins:\n\t\t\t\t\tvisited.add(to)\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tctr += 1\n\t\t\tnotVisited -= visited\n\t\tcomps.append(ctr)\ncomps.sort()\nprint(len(comps))\nprint(*comps)\n",
        "slowest_solution": "import sys, math, itertools\nfrom collections import Counter, deque, defaultdict\nfrom bisect import bisect_left, bisect_right\nfrom heapq import heappop, heappush, heapify, nlargest\nfrom copy import deepcopy, copy\nmod = 10 ** 9 + 7\nINF = float('inf')\n\ndef inp():\n\treturn int(sys.stdin.readline())\n\ndef inpl():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef inpl_1():\n\treturn list(map(lambda x: int(x) - 1, sys.stdin.readline().split()))\n\ndef inps():\n\treturn sys.stdin.readline()\n\ndef inpsl(x):\n\ttmp = sys.stdin.readline()\n\treturn list(tmp[:x])\n\ndef err(x):\n\tprint(x)\n\texit()\n\nclass UnionFind:\n\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.parents = [-1] * n\n\n\tdef find(self, x):\n\t\tif self.parents[x] < 0:\n\t\t\treturn x\n\t\telse:\n\t\t\tself.parents[x] = self.find(self.parents[x])\n\t\t\treturn self.parents[x]\n\n\tdef union(self, x, y):\n\t\tx = self.find(x)\n\t\ty = self.find(y)\n\t\tif x == y:\n\t\t\treturn\n\t\tif self.parents[x] > self.parents[y]:\n\t\t\t(x, y) = (y, x)\n\t\tself.parents[x] += self.parents[y]\n\t\tself.parents[y] = x\n\n\tdef size(self, x):\n\t\treturn -self.parents[self.find(x)]\n\n\tdef same(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\n\tdef members(self, x):\n\t\troot = self.find(x)\n\t\treturn [i for i in range(self.n) if self.find(i) == root]\n\n\tdef roots(self):\n\t\treturn [i for (i, x) in enumerate(self.parents) if x < 0]\n\n\tdef group_count(self):\n\t\treturn len(self.roots())\n(n, m) = inpl()\nun = [set() for _ in range(n)]\nfor _ in range(m):\n\t(a, b) = inpl_1()\n\tun[b].add(a)\n\tun[a].add(b)\nuf = UnionFind(n)\nseen = [0] * n\nunknown = set(range(n))\nfor i in range(n):\n\tif seen[i]:\n\t\tcontinue\n\tseen[i] = 1\n\tunknown.discard(i)\n\tadj = deque()\n\tnoadj = set()\n\tfor j in list(unknown):\n\t\tif not j in un[i]:\n\t\t\tadj.append(j)\n\t\telse:\n\t\t\tnoadj.add(j)\n\twhile adj:\n\t\tj = adj.popleft()\n\t\tfor k in list(noadj - un[j]):\n\t\t\tadj.append(k)\n\t\t\tnoadj.discard(k)\n\t\tseen[j] = 1\n\t\tunknown.discard(j)\n\t\tuf.union(i, j)\nres = []\nfor root in uf.roots():\n\tres.append(uf.size(root))\nres.sort()\nprint(len(res))\nprint(*res)\n"
    },
    {
        "task_id": 572,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.821960210800171,
        "fastest_time": 2.821960210800171,
        "fastest_solution": "from collections import defaultdict\nimport sys\n(m, n) = [int(i) for i in input().split()]\nd = ['' for i in range(m)]\nfor i in range(m):\n\td[i] = input()\nop = defaultdict(list)\nr = [[-1] * n for i in range(m)]\nfor i in range(m):\n\tfor j in range(n):\n\t\tif d[i][j] == 'X':\n\t\t\tt = []\n\t\t\tfor (a, b) in [(i, j - 1), (i - 1, j), (i, j + 1), (i + 1, j)]:\n\t\t\t\tif 0 <= a < m and 0 <= b < n and (d[a][b] == '.'):\n\t\t\t\t\tt.append((a, b))\n\t\t\tif len(t) % 2:\n\t\t\t\tprint('NO')\n\t\t\t\tsys.exit()\n\t\t\tif len(t) == 0:\n\t\t\t\tr[i][j] = 0\n\t\t\tif len(t) == 2:\n\t\t\t\top[t[0]].append(t[1])\n\t\t\t\top[t[1]].append(t[0])\n\t\t\t\tr[i][j] = 5\n\t\t\tif len(t) == 4:\n\t\t\t\top[t[0]].append(t[1])\n\t\t\t\top[t[1]].append(t[0])\n\t\t\t\top[t[2]].append(t[3])\n\t\t\t\top[t[3]].append(t[2])\n\t\t\t\tr[i][j] = 10\nfor a in range(m):\n\tfor b in range(n):\n\t\tif r[a][b] == -1:\n\t\t\tr[a][b] = 1\n\t\t\tst = [(a, b)]\n\t\t\twhile st:\n\t\t\t\t(i, j) = st.pop()\n\t\t\t\tfor (x, y) in op[i, j]:\n\t\t\t\t\tif r[x][y] == -1:\n\t\t\t\t\t\tr[x][y] = 5 - r[i][j]\n\t\t\t\t\t\tst.append((x, y))\n\t\t\t\t\telif r[x][y] != 5 - r[i][j]:\n\t\t\t\t\t\tprint('NO')\n\t\t\t\t\t\tsys.exit()\nprint('YES')\nfor i in range(m):\n\tprint(' '.join(('1' if r[i][j] == -1 else str(r[i][j]) for j in range(n))))\n",
        "slowest_solution": "from collections import defaultdict\nimport sys\n(m, n) = [int(i) for i in input().split()]\nd = ['' for i in range(m)]\nfor i in range(m):\n\td[i] = input()\nop = defaultdict(list)\nr = [[-1] * n for i in range(m)]\nfor i in range(m):\n\tfor j in range(n):\n\t\tif d[i][j] == 'X':\n\t\t\tt = []\n\t\t\tfor (a, b) in [(i, j - 1), (i - 1, j), (i, j + 1), (i + 1, j)]:\n\t\t\t\tif 0 <= a < m and 0 <= b < n and (d[a][b] == '.'):\n\t\t\t\t\tt.append((a, b))\n\t\t\tif len(t) % 2:\n\t\t\t\tprint('NO')\n\t\t\t\tsys.exit()\n\t\t\tif len(t) == 0:\n\t\t\t\tr[i][j] = 0\n\t\t\tif len(t) == 2:\n\t\t\t\top[t[0]].append(t[1])\n\t\t\t\top[t[1]].append(t[0])\n\t\t\t\tr[i][j] = 5\n\t\t\tif len(t) == 4:\n\t\t\t\top[t[0]].append(t[1])\n\t\t\t\top[t[1]].append(t[0])\n\t\t\t\top[t[2]].append(t[3])\n\t\t\t\top[t[3]].append(t[2])\n\t\t\t\tr[i][j] = 10\nfor a in range(m):\n\tfor b in range(n):\n\t\tif r[a][b] == -1:\n\t\t\tr[a][b] = 1\n\t\t\tst = [(a, b)]\n\t\t\twhile st:\n\t\t\t\t(i, j) = st.pop()\n\t\t\t\tfor (x, y) in op[i, j]:\n\t\t\t\t\tif r[x][y] == -1:\n\t\t\t\t\t\tr[x][y] = 5 - r[i][j]\n\t\t\t\t\t\tst.append((x, y))\n\t\t\t\t\telif r[x][y] != 5 - r[i][j]:\n\t\t\t\t\t\tprint('NO')\n\t\t\t\t\t\tsys.exit()\nprint('YES')\nfor i in range(m):\n\tprint(' '.join(('1' if r[i][j] == -1 else str(r[i][j]) for j in range(n))))\n"
    },
    {
        "task_id": 560,
        "slowest_solution_id": 2,
        "fastest_solution_id": 3,
        "slowest_time": 2.9277024269104004,
        "fastest_time": 2.811095952987671,
        "fastest_solution": "from heapq import *\nfrom random import randint\nimport sys\nn = int(input())\na = list(map(int, input().split()))\nq = []\np = 0\nc = 0\nl = [0] * (n + 1)\nr = [0] * (n + 1)\nk = [0] * (n + 1)\npa = [0] * (n + 1)\nfor (i, x) in enumerate(a):\n\tif x == a[p]:\n\t\tc += 1\n\telse:\n\t\tl[p] = p - 1\n\t\tk[p] = k[i - 1] = c\n\t\tpa[p] = i - 1\n\t\tpa[i - 1] = p\n\t\tr[i - 1] = i\n\t\tq.append((-c, p))\n\t\tp = i\n\t\tc = 1\nq.append((-c, p))\nl[p] = p - 1\nk[p] = k[n - 1] = c\npa[p] = n - 1\npa[n - 1] = p\nr[n - 1] = n\nheapify(q)\nans = 0\nwhile len(q):\n\t(c, p) = heappop(q)\n\tc = -c\n\tif k[p] > c:\n\t\tcontinue\n\tans += 1\n\tls = l[p]\n\trs = r[pa[p]]\n\tif ls >= 0 and rs < n and (a[ls] == a[rs]):\n\t\tnc = k[ls] + k[rs]\n\t\t(nl, nr) = (pa[ls], pa[rs])\n\t\tk[nl] = k[nr] = k[ls] = k[rs] = nc\n\t\tpa[nr] = nl\n\t\tpa[nl] = nr\n\t\theappush(q, (-nc, nl))\n\telse:\n\t\tif ls >= 0:\n\t\t\tr[ls] = rs\n\t\tif rs < n:\n\t\t\tl[rs] = ls\nprint(ans)\n",
        "slowest_solution": "import heapq\nn = int(input())\na = list(map(int, input().split()))\nd = {}\n(pre, l) = (None, 0)\nseg = []\nfor (i, x) in enumerate(a):\n\tif pre is None:\n\t\tpre = x\n\t\tl = 1\n\telif x == pre:\n\t\tl += 1\n\telse:\n\t\tseg.append([l, pre])\n\t\tpre = x\n\t\tl = 1\n\tif i == len(a) - 1:\n\t\tseg.append([l, x])\nQ = []\nfor (i, s) in enumerate(seg):\n\tl = None if i == 0 else i - 1\n\tr = None if i + 1 == len(seg) else i + 1\n\td[i] = [l, r, s[0], s[1]]\n\theapq.heappush(Q, (-s[0], i))\ncnt = 0\nwhile len(Q) > 0:\n\t(length, idx) = heapq.heappop(Q)\n\tlength = -length\n\tif d[idx][2] != length:\n\t\tcontinue\n\t(l, r, length, val) = d[idx]\n\td[idx][0] = 0\n\tcnt += 1\n\tif l is None and r is None:\n\t\tbreak\n\telif l is None:\n\t\td[r][0] = None\n\telif r is None:\n\t\td[l][1] = None\n\telif d[l][3] == d[r][3]:\n\t\td[l][1] = d[r][1]\n\t\td[l][2] += d[r][2]\n\t\td[r][2] = 0\n\t\tif d[r][1] is not None:\n\t\t\tnnr = d[r][1]\n\t\t\td[nnr][0] = l\n\t\theapq.heappush(Q, (-d[l][2], l))\n\telse:\n\t\td[l][1] = r\n\t\td[r][0] = l\nprint(cnt)\n"
    },
    {
        "task_id": 574,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.8969833850860596,
        "fastest_time": 2.8969833850860596,
        "fastest_solution": "import sys\nfrom math import *\nfrom bisect import *\nMAX = sys.maxsize\nMAXN = 10 ** 5 + 10\nlogT = [0] * MAXN\nfor i in range(2, MAXN):\n\tlogT[i] = logT[i // 2] + 1\n\ndef buildSparse(a):\n\tn = len(a)\n\tk = logT[n] + 1\n\tst = [[-MAX for j in range(k)] for i in range(n)]\n\tfor i in range(n):\n\t\tst[i][0] = a[i]\n\tj = 1\n\twhile 1 << j <= n:\n\t\ti = 0\n\t\twhile i + (1 << j) - 1 < n:\n\t\t\tst[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n\t\t\ti += 1\n\t\tj += 1\n\treturn st\n\ndef query(l, r, st, d):\n\tif l > r:\n\t\treturn False\n\ttot = r - l + 1\n\tk = logT[tot]\n\treturn max(st[l][k], st[l + tot - (1 << k)][k]) <= d\nn = int(input())\na = [0] + list(map(int, sys.stdin.readline().strip().split()))\nm = int(input())\ndif = [0] * (n + 1)\nfor i in range(1, n):\n\tdif[i] = a[i + 1] - a[i]\nst = buildSparse(dif)\nfor _ in range(m):\n\t(t, d) = map(int, sys.stdin.readline().strip().split())\n\tidx = bisect(a, t) - 1\n\tlo = 1\n\thi = idx - 1\n\tif idx == 1 or a[idx] - a[idx - 1] > d:\n\t\tans = idx\n\telse:\n\t\twhile lo < hi:\n\t\t\tmid = (lo + hi) // 2\n\t\t\tif query(mid, idx - 1, st, d):\n\t\t\t\thi = mid\n\t\t\telse:\n\t\t\t\tlo = mid + 1\n\t\tans = lo\n\tprint(ans)\n",
        "slowest_solution": "import sys\nfrom math import *\nfrom bisect import *\nMAX = sys.maxsize\nMAXN = 10 ** 5 + 10\nlogT = [0] * MAXN\nfor i in range(2, MAXN):\n\tlogT[i] = logT[i // 2] + 1\n\ndef buildSparse(a):\n\tn = len(a)\n\tk = logT[n] + 1\n\tst = [[-MAX for j in range(k)] for i in range(n)]\n\tfor i in range(n):\n\t\tst[i][0] = a[i]\n\tj = 1\n\twhile 1 << j <= n:\n\t\ti = 0\n\t\twhile i + (1 << j) - 1 < n:\n\t\t\tst[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1])\n\t\t\ti += 1\n\t\tj += 1\n\treturn st\n\ndef query(l, r, st, d):\n\tif l > r:\n\t\treturn False\n\ttot = r - l + 1\n\tk = logT[tot]\n\treturn max(st[l][k], st[l + tot - (1 << k)][k]) <= d\nn = int(input())\na = [0] + list(map(int, sys.stdin.readline().strip().split()))\nm = int(input())\ndif = [0] * (n + 1)\nfor i in range(1, n):\n\tdif[i] = a[i + 1] - a[i]\nst = buildSparse(dif)\nfor _ in range(m):\n\t(t, d) = map(int, sys.stdin.readline().strip().split())\n\tidx = bisect(a, t) - 1\n\tlo = 1\n\thi = idx - 1\n\tif idx == 1 or a[idx] - a[idx - 1] > d:\n\t\tans = idx\n\telse:\n\t\twhile lo < hi:\n\t\t\tmid = (lo + hi) // 2\n\t\t\tif query(mid, idx - 1, st, d):\n\t\t\t\thi = mid\n\t\t\telse:\n\t\t\t\tlo = mid + 1\n\t\tans = lo\n\tprint(ans)\n"
    },
    {
        "task_id": 568,
        "slowest_solution_id": 2,
        "fastest_solution_id": 2,
        "slowest_time": 2.872823715209961,
        "fastest_time": 2.872823715209961,
        "fastest_solution": "(n, l, s) = map(int, input().split())\n(i, ans) = (n, 0)\n(w, par, vis) = ([0], [0, 0], [0] * (n + 10))\nfor u in map(int, input().split()):\n\tif u > s:\n\t\t(print(-1), exit(0))\n\tw.append(u)\nif n > 1:\n\tfor u in map(int, input().split()):\n\t\tpar.append(u)\nwhile i > 0:\n\tif vis[i] == 0:\n\t\t(c, p, x) = (i, l, s)\n\t\tans = ans + 1\n\t\twhile x >= w[c] and p * c > 0:\n\t\t\tvis[c] = 1\n\t\t\tp = p - 1\n\t\t\tx = x - w[c]\n\t\t\tc = par[c]\n\ti = i - 1\nprint(ans)\n",
        "slowest_solution": "(n, l, s) = map(int, input().split())\n(i, ans) = (n, 0)\n(w, par, vis) = ([0], [0, 0], [0] * (n + 10))\nfor u in map(int, input().split()):\n\tif u > s:\n\t\t(print(-1), exit(0))\n\tw.append(u)\nif n > 1:\n\tfor u in map(int, input().split()):\n\t\tpar.append(u)\nwhile i > 0:\n\tif vis[i] == 0:\n\t\t(c, p, x) = (i, l, s)\n\t\tans = ans + 1\n\t\twhile x >= w[c] and p * c > 0:\n\t\t\tvis[c] = 1\n\t\t\tp = p - 1\n\t\t\tx = x - w[c]\n\t\t\tc = par[c]\n\ti = i - 1\nprint(ans)\n"
    },
    {
        "task_id": 549,
        "slowest_solution_id": 2,
        "fastest_solution_id": 4,
        "slowest_time": 3.0049057006835938,
        "fastest_time": 2.8105568885803223,
        "fastest_solution": "P = 10 ** 9 + 7\n(n, k) = list(map(int, input().split()))\nprint(n + 1 if k == 1 else (k * pow(2 * k - 1, n, P) - pow(k, n, P)) * pow(k - 1, P - 2, P) % P)\n",
        "slowest_solution": "import math\n\ndef euclid_algorithm(a, b):\n\t(t1, t2) = (abs(a), abs(b))\n\t(x1, y1, x2, y2) = (int(math.copysign(1, a)), 0, 0, int(math.copysign(1, b)))\n\tif t1 < t2:\n\t\t(t1, t2) = (t2, t1)\n\t\t(x1, y1, x2, y2) = (x2, y2, x1, y1)\n\twhile t2 > 0:\n\t\tk = int(t1 // t2)\n\t\t(t1, t2) = (t2, t1 % t2)\n\t\t(x1, y1, x2, y2) = (x2, y2, x1 - k * x2, y1 - k * y2)\n\treturn (t1, x1, y1)\n\ndef opposite_element(x, p):\n\t(gcd, k, l) = euclid_algorithm(x, p)\n\tif gcd != 1:\n\t\treturn -1\n\treturn k % p\n\ndef solve(n, m, p):\n\tif (m - 1) % p == 0:\n\t\treturn (n + 1) * pow(m, n, p) % p\n\telse:\n\t\tS = pow(m, n, p)\n\t\tk = opposite_element(m, p)\n\t\tl = (2 * m - 1) * k % p\n\t\tq = opposite_element(l - 1, p)\n\t\tS += pow(m, n, p) * (pow(l, n, p) - 1) * q\n\t\tS %= p\n\t\treturn S\np = 10 ** 9 + 7\n(n, m) = [int(x) for x in input().split()]\nprint(solve(n, m, p))\n"
    },
    {
        "task_id": 538,
        "slowest_solution_id": 2,
        "fastest_solution_id": 8,
        "slowest_time": 3.055546283721924,
        "fastest_time": 2.8199045658111572,
        "fastest_solution": "import sys\n\ndef todos_visitados(list):\n\treturn len(list) == sum(list)\n\ndef um_componente(vertices, n):\n\tvizinhos = [0]\n\tvisitado = [False] * n\n\twhile len(vizinhos) != 0:\n\t\tv = vizinhos.pop()\n\t\tvisitado[v] = True\n\t\tfor u in vertices[v]:\n\t\t\tif not visitado[u]:\n\t\t\t\tvizinhos.append(u)\n\treturn todos_visitados(visitado)\n\ndef main():\n\t(n, m) = [int(x) for x in input().split()]\n\tvertices = [[] for _ in range(n)]\n\tfor _ in range(m):\n\t\t(v, u) = [int(x) - 1 for x in input().split()]\n\t\tvertices[v].append(u)\n\t\tvertices[u].append(v)\n\tsomente_um_ciclo = n == m and um_componente(vertices, n)\n\tprint('FHTAGN!') if somente_um_ciclo else print('NO')\nmain()\n\ndef testin1(capsys):\n\tsys.stdin = open('in1')\n\tmain()\n\t(out, err) = capsys.readouterr()\n\tsys.stin = sys.__stdin__\n\texpected = open('in1_expeted').read()\n\tassert out == expected\n\ndef testin2(capsys):\n\tsys.stdin = open('in2')\n\tmain()\n\t(out, err) = capsys.readouterr()\n\tsys.stin = sys.__stdin__\n\texpected = open('in2_expeted').read()\n\tassert out == expected\n\ndef testin3(capsys):\n\tsys.stdin = open('in3')\n\tmain()\n\t(out, err) = capsys.readouterr()\n\tsys.stin = sys.__stdin__\n\texpected = open('in3_expeted').read()\n\tassert out == expected\n\ndef testin4(capsys):\n\tsys.stdin = open('in4')\n\tmain()\n\t(out, err) = capsys.readouterr()\n\tsys.stin = sys.__stdin__\n\texpected = open('in4_expeted').read()\n\tassert out == expected\n\ndef testin5(capsys):\n\tsys.stdin = open('in5')\n\tmain()\n\t(out, err) = capsys.readouterr()\n\tsys.stin = sys.__stdin__\n\texpected = open('in5_expeted').read()\n\tassert out == expected\n\ndef testin6(capsys):\n\tsys.stdin = open('in6')\n\tmain()\n\t(out, err) = capsys.readouterr()\n\tsys.stin = sys.__stdin__\n\texpected = open('in6_expeted').read()\n\tassert out == expected\n",
        "slowest_solution": "def dfs(num, av):\n\tglobal res\n\tb.add(num)\n\tfor v in g[num]:\n\t\tif v != av:\n\t\t\tif v in b:\n\t\t\t\tres += 1\n\t\t\t\tg[v].remove(num)\n\t\t\telse:\n\t\t\t\tb.add(v)\n\t\t\t\tdfs(v, num)\n(n, m) = map(int, input().split())\n(g, b, res) = ([[] for _ in range(n)], set(), 0)\nfor _ in range(m):\n\t(u, v) = map(int, input().split())\n\tg[u - 1].append(v - 1)\n\tg[v - 1].append(u - 1)\ndfs(0, 0)\nif len(b) == n and res == 1:\n\tprint('FHTAGN!')\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 566,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.099290609359741,
        "fastest_time": 3.099290609359741,
        "fastest_solution": "def Solve(x, y, c):\n\tif c == len(virus):\n\t\treturn 0\n\tif x == len(s1) or y == len(s2):\n\t\treturn ''\n\tif (x, y, c) in Mem:\n\t\treturn Mem[x, y, c]\n\tans = ''\n\tif s1[x] == s2[y]:\n\t\tq = 0\n\t\tif s1[x] == virus[c]:\n\t\t\tq = Solve(x + 1, y + 1, c + 1)\n\t\t\tif q != 0:\n\t\t\t\tq = s1[x] + q\n\t\telse:\n\t\t\tdone = False\n\t\t\tfor match in T[c]:\n\t\t\t\tif s1[x] == virus[match]:\n\t\t\t\t\tdone = True\n\t\t\t\t\tq = Solve(x + 1, y + 1, match + 1)\n\t\t\t\t\tif q != 0:\n\t\t\t\t\t\tq = s1[x] + q\n\t\t\t\t\tbreak\n\t\t\tif not done:\n\t\t\t\tq = Solve(x + 1, y + 1, 0)\n\t\t\t\tif q != 0:\n\t\t\t\t\tq = s1[x] + q\n\t\tif q != 0:\n\t\t\tans = q\n\tq = Solve(x + 1, y, c)\n\tif q != 0:\n\t\tans = max(ans, Solve(x + 1, y, c), key=len)\n\tq = Solve(x, y + 1, c)\n\tif q != 0:\n\t\tans = max(ans, Solve(x, y + 1, c), key=len)\n\tMem[x, y, c] = ans\n\treturn ans\nMem = {}\ns1 = input()\ns2 = input()\nvirus = input()\nT = [0] * len(virus)\nT[0] = [0]\nfor i in range(1, len(virus)):\n\tdone = False\n\tT[i] = []\n\tfor j in range(1, i):\n\t\tif virus[j:i] == virus[:i - j]:\n\t\t\tT[i].append(i - j)\n\tT[i].append(0)\ne = Solve(0, 0, 0)\nif e == '':\n\tprint(0)\nelse:\n\tprint(Solve(0, 0, 0))\n",
        "slowest_solution": "def Solve(x, y, c):\n\tif c == len(virus):\n\t\treturn 0\n\tif x == len(s1) or y == len(s2):\n\t\treturn ''\n\tif (x, y, c) in Mem:\n\t\treturn Mem[x, y, c]\n\tans = ''\n\tif s1[x] == s2[y]:\n\t\tq = 0\n\t\tif s1[x] == virus[c]:\n\t\t\tq = Solve(x + 1, y + 1, c + 1)\n\t\t\tif q != 0:\n\t\t\t\tq = s1[x] + q\n\t\telse:\n\t\t\tdone = False\n\t\t\tfor match in T[c]:\n\t\t\t\tif s1[x] == virus[match]:\n\t\t\t\t\tdone = True\n\t\t\t\t\tq = Solve(x + 1, y + 1, match + 1)\n\t\t\t\t\tif q != 0:\n\t\t\t\t\t\tq = s1[x] + q\n\t\t\t\t\tbreak\n\t\t\tif not done:\n\t\t\t\tq = Solve(x + 1, y + 1, 0)\n\t\t\t\tif q != 0:\n\t\t\t\t\tq = s1[x] + q\n\t\tif q != 0:\n\t\t\tans = q\n\tq = Solve(x + 1, y, c)\n\tif q != 0:\n\t\tans = max(ans, Solve(x + 1, y, c), key=len)\n\tq = Solve(x, y + 1, c)\n\tif q != 0:\n\t\tans = max(ans, Solve(x, y + 1, c), key=len)\n\tMem[x, y, c] = ans\n\treturn ans\nMem = {}\ns1 = input()\ns2 = input()\nvirus = input()\nT = [0] * len(virus)\nT[0] = [0]\nfor i in range(1, len(virus)):\n\tdone = False\n\tT[i] = []\n\tfor j in range(1, i):\n\t\tif virus[j:i] == virus[:i - j]:\n\t\t\tT[i].append(i - j)\n\tT[i].append(0)\ne = Solve(0, 0, 0)\nif e == '':\n\tprint(0)\nelse:\n\tprint(Solve(0, 0, 0))\n"
    },
    {
        "task_id": 541,
        "slowest_solution_id": 2,
        "fastest_solution_id": 8,
        "slowest_time": 3.06418776512146,
        "fastest_time": 2.814303159713745,
        "fastest_solution": "for _ in range(int(input())):\n\t(v, u) = map(int, input().split())\n\tx = {i: 0 for i in range(1, v + 1)}\n\ty = {i: [] for i in range(1, v + 1)}\n\tfor _ in range(v - 1):\n\t\t(s, k) = map(int, input().split())\n\t\tx[s] += 1\n\t\tx[k] += 1\n\tsol = 0\n\tfor i in x:\n\t\tsol = sol + x[i] * (x[i] + 1) // 2\n\tsol -= v - 1\n\tprint(sol)\n\tfor _ in range(u):\n\t\t(z, s, k, t) = map(int, input().split())\n\t\ta = sol\n\t\ta -= x[z]\n\t\ta -= x[s]\n\t\ta += x[k]\n\t\ta += x[t]\n\t\tif z == k and s == t or (z == t and s == k):\n\t\t\ta += 0\n\t\telif z == k or z == t or s == k or (s == t):\n\t\t\ta += 1\n\t\telse:\n\t\t\ta += 2\n\t\tprint(a)\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(o, p) = map(int, input().split())\n\ty = {i: 0 for i in range(1, o + 1)}\n\te = {i: [] for i in range(1, o + 1)}\n\tfor _ in range(o - 1):\n\t\t(s, k) = map(int, input().split())\n\t\ty[s] += 1\n\t\ty[k] += 1\n\tsol = 0\n\tfor iii in y:\n\t\tsol = sol + y[iii] * (y[iii] + 1) // 2\n\tsol -= o - 1\n\tprint(sol)\n\tfor _ in range(p):\n\t\t(z, s, k, t) = map(int, input().split())\n\t\ta = sol\n\t\ta -= y[z]\n\t\ta -= y[s]\n\t\ta += y[k]\n\t\ta += y[t]\n\t\tif z == k and s == t or (z == t and s == k):\n\t\t\ta += 0\n\t\telif z == k or z == t or s == k or (s == t):\n\t\t\ta += 1\n\t\telse:\n\t\t\ta += 2\n\t\tprint(a)\n"
    },
    {
        "task_id": 546,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 3.063675880432129,
        "fastest_time": 2.7885844707489014,
        "fastest_solution": "n = int(input());\nfinal = [];\nids = [];\nidChangeMap = {};\nidNewMap = {};\nfor i in range(n):\n\tns = list(map(int,input().split(' ')));\n\tids.append(ns[0]);\n\tidNewMap[ids[i]] = ns[2]*50+ns[3]*5+ns[4]*10+ns[5]*20;\n\tidChangeMap[ids[i]] = idNewMap[ids[i]] - ns[1];\nresult = sorted(idChangeMap,reverse = True)\nresult = sorted(result,key=idChangeMap.get,reverse = True)\ns = 0;\nfor i in result:\n\tif(s<5):\n\t\tprint(str(i)+\" \"+str(idNewMap[i]));\n\ts+=1;\n",
        "slowest_solution": "import heapq\ndic={}\npic={}\nh=[]\nheapq.heapify(h)\nfor _ in range(int(input())):\n\ti,old,p,l,c,s=list(map(int,input().split()))\n\tnew=p*50+l*5+c*10+s*20\n\t\n\tchange=(new-old)+i*1.0/1000000000\n\tdic[change]=i\n\tpic[change]=new\n\theapq.heappush(h,-change)\n\t\n\nhi=heapq.nsmallest(5, h)\nfor i in hi:\n\tprint(dic[-i],pic[-i])\n"
    },
    {
        "task_id": 539,
        "slowest_solution_id": 9,
        "fastest_solution_id": 2,
        "slowest_time": 3.299758195877075,
        "fastest_time": 2.8948347568511963,
        "fastest_solution": "N = 32768\ndp = [0] * (N + 1)\nst = [0] * (N + 1)\nq = [N]\nst[0] = 1\ndp[0] = 0\nst[q[0]] = 1\nwhile q:\n\tuq = []\n\tfor i in q:\n\t\tif not st[i - 1]:\n\t\t\tuq.append(i - 1)\n\t\t\tdp[i - 1] = dp[i] + 1\n\t\t\tst[i - 1] = 1\n\t\tif not i % 2:\n\t\t\t(a, b) = (i // 2, (i + 32768) // 2)\n\t\t\tif not st[a]:\n\t\t\t\tuq.append(a)\n\t\t\t\tdp[a] = dp[i] + 1\n\t\t\t\tst[a] = 1\n\t\t\tif not st[b]:\n\t\t\t\tuq.append(b)\n\t\t\t\tdp[b] = dp[i] + 1\n\t\t\t\tst[b] = 1\n\tq = uq\ndp[N] = 1\nn = int(input())\nll = list(map(int, input().split()))\nfor i in range(N + 1):\n\tif 16 == dp[i]:\n\t\tprint(i)\nfor i in ll:\n\tprint(dp[i], end=' ')\n",
        "slowest_solution": "def solvecff():\n\tn = int(input())\n\tlis = [int(i) for i in input().split()]\n\tfrom collections import defaultdict\n\ta = {i: -1 for i in range(32768)}\n\tmod = 32768\n\tl = [[i] for i in range(mod)]\n\tfor i in range(mod):\n\t\tl[(i + 1) % mod].append(i)\n\t\tl[i * 2 % mod].append(i)\n\ta[0] = 0\n\ts = []\n\ts.append(0)\n\twhile len(s) != 0:\n\t\tx = s[0]\n\t\ts.pop(0)\n\t\tfor tmp in l[x]:\n\t\t\tif a[tmp] == -1:\n\t\t\t\ta[tmp] = a[x] + 1\n\t\t\t\ts.append(tmp)\n\tans = []\n\tfor i in lis:\n\t\tans.append(str(a[i]))\n\tprint(' '.join(ans))\nsolvecff()\n"
    },
    {
        "task_id": 542,
        "slowest_solution_id": 2,
        "fastest_solution_id": 5,
        "slowest_time": 3.0320022106170654,
        "fastest_time": 2.810154914855957,
        "fastest_solution": "graph = input()\ngraph = graph.split(' ')\nn = int(graph[0])\np = int(graph[1])\nmatrix = [[0] * n for i in range(n)]\nconn = dict()\nfor i in range(p):\n\tline = input()\n\tline = line.split(' ')\n\tmatrix[int(line[0]) - 1][int(line[1]) - 1] = int(line[2])\n\tconn[int(line[0]) - 1] = int(line[1]) - 1\niniciales = [i for i in conn.keys() if i not in conn.values()]\nfinales = [i for i in conn.values() if i not in conn.keys()]\niniciales.sort()\nresultados = dict()\nc = 0\nfor i in iniciales:\n\tresultados[c] = []\n\tnodo = i\n\tminimo = 10 ** 6\n\twhile nodo not in finales:\n\t\tresultados[c].append(nodo)\n\t\tif matrix[nodo][conn[nodo]] < minimo:\n\t\t\tminimo = matrix[nodo][conn[nodo]]\n\t\tnodo = conn[nodo]\n\tresultados[c].append(nodo)\n\tresultados[c].append(minimo)\n\tc += 1\nprint(len(resultados.keys()))\nfor element in resultados.values():\n\tprint(element[0] + 1, element[-2] + 1, element[-1])\n",
        "slowest_solution": "(houses, pipes) = [int(x) for x in input().strip().split()]\nhouseToHouseDict = {}\npipeDict = {}\noutgoingList = []\nincomingList = []\nmaxFlow = 0\n\ndef DFSmaxPipe(origin):\n\tend = []\n\tlowestDiam = maxFlow\n\twhile origin in houseToHouseDict:\n\t\tdiam = pipeDict[origin]\n\t\tif diam < lowestDiam:\n\t\t\tlowestDiam = diam\n\t\torigin = houseToHouseDict[origin]\n\tend.append(origin)\n\tend.append(lowestDiam)\n\treturn end\nfor x in range(pipes):\n\t(ahouse, bhouse, diameter) = [int(x) for x in input().strip().split()]\n\tpipeDict[ahouse] = diameter\n\thouseToHouseDict[ahouse] = bhouse\n\toutgoingList.append(ahouse)\n\tincomingList.append(bhouse)\n\tif diameter > maxFlow:\n\t\tmaxFlow = diameter\nfor pipe in incomingList:\n\ttry:\n\t\toutgoingList.remove(pipe)\n\texcept ValueError:\n\t\tpass\noutgoingList.sort()\nprint(len(outgoingList))\nfor origin in outgoingList:\n\toutString = str(origin)\n\tendPipe = DFSmaxPipe(origin)\n\toutString += ' ' + str(endPipe[0]) + ' ' + str(endPipe[1])\n\tprint(outString)\n"
    },
    {
        "task_id": 544,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.9590628147125244,
        "fastest_time": 2.79101824760437,
        "fastest_solution": "def __starting_point():\n\tn = int(input())\n\tedges = [[] for i in range(n + 1)]\n\tedges[0] = None\n\tfor i in range(n - 1):\n\t\t(n1, n2) = list(map(int, input().split()))\n\t\tedges[n1].append(n2)\n\t\tedges[n2].append(n1)\n\tstack = [(1, 0, 1.0)]\n\tsev = 0\n\tvisited = [False for i in range(n + 1)]\n\twhile len(stack) > 0:\n\t\t(node, height, prob) = stack.pop()\n\t\tvisited[node] = True\n\t\tchildren = len(edges[node]) - 1\n\t\tif node == 1:\n\t\t\tchildren += 1\n\t\tfor child in edges[node]:\n\t\t\tif visited[child]:\n\t\t\t\tcontinue\n\t\t\tstack.append((child, height + 1, prob / children))\n\t\tif children == 0:\n\t\t\tsev += height * prob\n\tprint(sev)\n__starting_point()\n",
        "slowest_solution": "n = int(input())\nt = {x: [] for x in range(1, n + 1)}\nv = set()\ns = 0\nq = [(1, 1, 0)]\nfor _ in range(n - 1):\n\t(a, b) = map(int, input().split())\n\tt[a].append(b)\n\tt[b].append(a)\nwhile q:\n\t(u, p, depth) = q.pop()\n\tv.add(u)\n\tbranch = 0\n\tfor i in t[u]:\n\t\tif i not in v:\n\t\t\tbranch += 1\n\tleaf = not branch\n\tif leaf:\n\t\ts += p * depth\n\telse:\n\t\tfor i in t[u]:\n\t\t\tif i not in v:\n\t\t\t\tq.append((i, p / branch, depth + 1))\nprint(s)\n"
    },
    {
        "task_id": 550,
        "slowest_solution_id": 2,
        "fastest_solution_id": 4,
        "slowest_time": 2.992719888687134,
        "fastest_time": 2.800875186920166,
        "fastest_solution": "(n, m, k, x, y) = map(int, input().split())\nif n > 1:\n\tt = 2 * (n - 1) * m\n\t(s, p) = (k // t, k % t)\n\tf = lambda x, y: s + s * (1 < x < n) + (p >= m * x - m + y) + (p >= (2 * n - x - 1) * m + y) * (x < n)\n\tprint(max(f(1, 1), f(2, 1), f(n - 1, 1)), f(n, m), f(x, y))\nelse:\n\tg = lambda y: (k - y + m) // m\n\tprint(g(1), g(m), g(y))\n",
        "slowest_solution": "def sv(N, M, K, X, Y):\n\tX -= 1\n\tY -= 1\n\tif N > 1:\n\t\trounds = K // ((N - 1) * M)\n\t\trem = K % ((N - 1) * M)\n\t\tgd = [[0] * M for n in range(N)]\n\t\tfor m in range(0, M):\n\t\t\tgd[0][m] = (rounds + 1) // 2\n\t\t\tgd[N - 1][m] = rounds // 2\n\t\tfor n in range(1, N - 1):\n\t\t\tfor m in range(0, M):\n\t\t\t\tgd[n][m] = rounds\n\t\tif rounds % 2 == 1:\n\t\t\tfor n in range(N - 1, -1, -1):\n\t\t\t\tif not rem:\n\t\t\t\t\tbreak\n\t\t\t\tfor m in range(0, M):\n\t\t\t\t\tif not rem:\n\t\t\t\t\t\tbreak\n\t\t\t\t\trem -= 1\n\t\t\t\t\tgd[n][m] += 1\n\t\telse:\n\t\t\tfor n in range(0, N):\n\t\t\t\tif not rem:\n\t\t\t\t\tbreak\n\t\t\t\tfor m in range(0, M):\n\t\t\t\t\tif not rem:\n\t\t\t\t\t\tbreak\n\t\t\t\t\trem -= 1\n\t\t\t\t\tgd[n][m] += 1\n\telse:\n\t\trounds = K // M\n\t\trem = K % M\n\t\tgd = [[rounds] * M]\n\t\tfor m in range(rem):\n\t\t\tgd[0][m] += 1\n\ta1 = max((max(x) for x in gd))\n\ta2 = min((min(x) for x in gd))\n\ta3 = gd[X][Y]\n\tprint(a1, a2, a3)\n(N, M, K, X, Y) = list(map(int, input().split()))\nsv(N, M, K, X, Y)\n"
    },
    {
        "task_id": 547,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 3.039079189300537,
        "fastest_time": 2.832803726196289,
        "fastest_solution": "MOD = 998244353\nt = int(input())\nfor i in range(t):\n\t(a, b) = map(int, input().split())\n\tn = a + b\n\tk = (n + 1) // 2\n\tprint(k * a * pow(n, MOD - 2, MOD) % MOD)\n",
        "slowest_solution": "import math\nfrom fractions import Fraction\nM = 998244353\n\ndef solve(a, b):\n\tn = a + b\n\tp = Fraction(int(math.ceil(n / 2)), n)\n\texpected = a * p\n\t(p, q) = (expected.numerator, expected.denominator)\n\treturn p * pow(q, -1, M) % M\nt = int(input())\nfor _ in range(t):\n\t(a, b) = map(int, input().split())\n\tprint(solve(a, b))\n"
    },
    {
        "task_id": 577,
        "slowest_solution_id": 1,
        "fastest_solution_id": 1,
        "slowest_time": 6.121324777603149,
        "fastest_time": 6.121324777603149,
        "fastest_solution": "import math\ndef is_prime(a):\n\tif(a==2 or a==3 or a==5 or a==7):\n\t\treturn True\n\telif (a==1 or a==4 or a==6 or a==8 or a==9):\n\t\treturn False\n\treturn all(a % i for i in range(2, int(math.sqrt(a)+1)))\n\nt=eval(input())\nwhile(t):\n\tn=eval(input())\n\ts=input()\n\tl1=s.split(\" \")\n\tnum=[]\n\tprime=[]\n\tfor i in range (0,n):\n\t\tnum.append(int(l1[i]));\n\t\tif is_prime(int(l1[i])):\n\t\t\tprime.append(1)\n\t\telse:\n\t\t\tprime.append(0);\n\tq=eval(input())\n\twhile(q):\n\t\ts=input()\n\t\tl1=s.split(\" \")\n\t\tif l1[0]=='A':\n\t\t\tprint(prime[int(l1[1])-1:int(l1[2])].count(1));\n\t\telse:\n\t\t\tnum[int(l1[1])-1]=int(l1[2])\n\t\t\tif is_prime(int(l1[2])):\n\t\t\t\tprime[int(l1[1])-1]=1\n\t\t\telse:\n\t\t\t\tprime[int(l1[1])-1]=0\n\n\t\tq=q-1\n\tt=t-1\n",
        "slowest_solution": "import math\ndef is_prime(a):\n\tif(a==2 or a==3 or a==5 or a==7):\n\t\treturn True\n\telif (a==1 or a==4 or a==6 or a==8 or a==9):\n\t\treturn False\n\treturn all(a % i for i in range(2, int(math.sqrt(a)+1)))\n\nt=eval(input())\nwhile(t):\n\tn=eval(input())\n\ts=input()\n\tl1=s.split(\" \")\n\tnum=[]\n\tprime=[]\n\tfor i in range (0,n):\n\t\tnum.append(int(l1[i]));\n\t\tif is_prime(int(l1[i])):\n\t\t\tprime.append(1)\n\t\telse:\n\t\t\tprime.append(0);\n\tq=eval(input())\n\twhile(q):\n\t\ts=input()\n\t\tl1=s.split(\" \")\n\t\tif l1[0]=='A':\n\t\t\tprint(prime[int(l1[1])-1:int(l1[2])].count(1));\n\t\telse:\n\t\t\tnum[int(l1[1])-1]=int(l1[2])\n\t\t\tif is_prime(int(l1[2])):\n\t\t\t\tprime[int(l1[1])-1]=1\n\t\t\telse:\n\t\t\t\tprime[int(l1[1])-1]=0\n\n\t\tq=q-1\n\tt=t-1\n"
    },
    {
        "task_id": 594,
        "slowest_solution_id": 7,
        "fastest_solution_id": 0,
        "slowest_time": 0.0005085468292236328,
        "fastest_time": 0.0,
        "fastest_solution": "def count_change(money, coins):\n\tif money < 0:\n\t\treturn 0\n\tif money == 0:\n\t\treturn 1\n\tif money > 0 and (not coins):\n\t\treturn 0\n\treturn count_change(money - coins[-1], coins) + count_change(money, coins[:-1])\n",
        "slowest_solution": "def count_change(money, coins):\n\tif len(coins) == 1:\n\t\treturn 1 if money % coins[0] == 0 else 0\n\tcoins = sorted(coins, reverse=True)\n\treturn sum([count_change(money - i * coins[0], coins[1:]) for i in range(money // coins[0] + 1)])\n"
    },
    {
        "task_id": 548,
        "slowest_solution_id": 2,
        "fastest_solution_id": 4,
        "slowest_time": 3.0282485485076904,
        "fastest_time": 2.822720766067505,
        "fastest_solution": "from heapq import heappop, heappush, heapify\nimport sys\ninput = lambda : sys.stdin.readline().strip()\n\ndef solve():\n\tn = int(input())\n\tl = [int(i) for i in input().split()]\n\tl = sorted(l)\n\th = []\n\ttot = 0\n\tfor i in l:\n\t\twhile h and h[0] + 1 < i:\n\t\t\theappop(h)\n\t\t\ttot += 1\n\t\tif h and h[0] == i:\n\t\t\theappush(h, i)\n\t\telif h and h[0] + 1 == i:\n\t\t\theappop(h)\n\t\t\theappush(h, i)\n\t\telse:\n\t\t\theappush(h, i)\n\tprint(len(h) + tot)\nfor i in range(int(input())):\n\tsolve()\n",
        "slowest_solution": "for s in [*open(0)][2::2]:\n\tr = p = l = 0\n\tfor x in sorted(map(int, s.split())):\n\t\tif x > p:\n\t\t\tm = l * (x - p < 2)\n\t\t\tl = 0\n\t\tl += 1\n\t\tr += l > m\n\t\tp = x\n\tprint(r)\n"
    },
    {
        "task_id": 556,
        "slowest_solution_id": 7,
        "fastest_solution_id": 8,
        "slowest_time": 2.9474093914031982,
        "fastest_time": 2.784827470779419,
        "fastest_solution": "def f(h, l, p):\n\tnc = len(l)\n\tfor i in range(nc):\n\t\tl[i] -= p[1][i]\n\t\tif l[i] < 0:\n\t\t\treturn ['NO']\n\tv2s = [0] * (nc - 1)\n\tv2b = [0] * (nc - 1)\n\tfor i in range(nc - 1):\n\t\tv2s[i] = l[i]\n\t\tp[2][i] -= v2s[i]\n\t\tif p[2][i] <= 0:\n\t\t\tcontinue\n\t\tv2b[i] = p[2][i]\n\t\tl[i + 1] -= v2b[i]\n\t\tif l[i + 1] < 0:\n\t\t\treturn ['NO']\n\trl = ['YES']\n\tfor i in history:\n\t\tif i >= 0:\n\t\t\trl.append(i2s[i])\n\t\t\tcontinue\n\t\ti = -i - 1\n\t\tif v2s[i] > 0:\n\t\t\trl.append(i2s[i])\n\t\t\tv2s[i] -= 1\n\t\telse:\n\t\t\trl.append(i2s[i + 1])\n\treturn rl\nhistory = []\ns2i = {'S': 0, 'M': 1, 'L': 2, 'XL': 3, 'XXL': 4, 'XXXL': 5}\ni2s = ['S', 'M', 'L', 'XL', 'XXL', 'XXXL']\np = [None, [0] * 6, [0] * 5]\nl = list(map(int, input().split()))\nn = int(input())\nfor _ in range(n):\n\ts = input().split(',')\n\ti = s2i[s[0]]\n\thistory.append(i if len(s) == 1 else -i - 1)\n\tp[len(s)][i] += 1\n[print(s) for s in f(history, l, p)]\n",
        "slowest_solution": "from math import *\nfrom sys import *\n\ndef conv(s):\n\tif s == 'S' or s == 'S\\n':\n\t\treturn 1\n\tif s == 'M' or s == 'M\\n':\n\t\treturn 2\n\tif s == 'L' or s == 'L\\n':\n\t\treturn 3\n\tif s == 'XL' or s == 'XL\\n':\n\t\treturn 4\n\tif s == 'XXL' or s == 'XXL\\n':\n\t\treturn 5\n\treturn 6\n\ndef uncon(x):\n\tif x == 1:\n\t\treturn 'S'\n\tif x == 2:\n\t\treturn 'M'\n\tif x == 3:\n\t\treturn 'L'\n\tif x == 4:\n\t\treturn 'XL'\n\tif x == 5:\n\t\treturn 'XXL'\n\treturn 'XXXL'\ns = []\nm = []\nl = []\nxl = []\nxxl = []\n(sp, mp, lp, xp, xxp) = (0, 0, 0, 0, 0)\nt = [0]\nt += [int(z) for z in stdin.readline().split()]\nn = int(stdin.readline())\nans = [0] * n\nfor i in range(n):\n\te = [conv(z) for z in stdin.readline().split(',')]\n\tif len(e) == 1:\n\t\tans[i] = e[0]\n\t\tt[e[0]] -= 1\n\t\tif t[e[0]] < 0:\n\t\t\tprint('NO')\n\t\t\texit(0)\n\telse:\n\t\tif e[0] == 1:\n\t\t\ts.append(i)\n\t\tif e[0] == 2:\n\t\t\tm.append(i)\n\t\tif e[0] == 3:\n\t\t\tl.append(i)\n\t\tif e[0] == 4:\n\t\t\txl.append(i)\n\t\tif e[0] == 5:\n\t\t\txxl.append(i)\nwhile len(s) != sp and t[1]:\n\tans[s[sp]] = 1\n\tsp += 1\n\tt[1] -= 1\nwhile len(s) != sp and t[2]:\n\tans[s[sp]] = 2\n\tsp += 1\n\tt[2] -= 1\nif len(s) != sp:\n\tprint('NO')\n\texit(0)\nwhile len(m) != mp and t[2]:\n\tans[m[mp]] = 2\n\tmp += 1\n\tt[2] -= 1\nwhile len(m) != mp and t[3]:\n\tans[m[mp]] = 3\n\tmp += 1\n\tt[3] -= 1\nif len(m) != mp:\n\tprint('NO')\n\texit(0)\nwhile len(l) != lp and t[3]:\n\tans[l[lp]] = 3\n\tlp += 1\n\tt[3] -= 1\nwhile len(l) != lp and t[4]:\n\tans[l[lp]] = 4\n\tlp += 1\n\tt[4] -= 1\nif len(l) != lp:\n\tprint('NO')\n\texit(0)\nwhile len(xl) != xp and t[4]:\n\tans[xl[xp]] = 4\n\txp += 1\n\tt[4] -= 1\nwhile len(xl) != xp and t[5]:\n\tans[xl[xp]] = 5\n\txp += 1\n\tt[5] -= 1\nif len(xl) != xp:\n\tprint('NO')\n\texit(0)\nwhile len(xxl) != xxp and t[5]:\n\tans[xxl[xxp]] = 5\n\txxp += 1\n\tt[5] -= 1\nwhile len(xxl) != xxp and t[6]:\n\tans[xxl[xxp]] = 6\n\txxp += 1\n\tt[6] -= 1\nif len(xxl) != xxp:\n\tprint('NO')\n\texit(0)\nres = [uncon(z) for z in ans]\nprint('YES')\nfor i in res:\n\tprint(i)\n"
    },
    {
        "task_id": 567,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 2.927978038787842,
        "fastest_time": 2.8407435417175293,
        "fastest_solution": "MAX = 10 ** 9 + 10\nn = int(input())\nA = [int(t) for t in input().split()]\nB = [int(t) for t in input().split()]\nS = sorted(set(A) | set(B) | {0})\norder = {x: i for (i, x) in enumerate(S)}\nN = len(S)\n\nclass SegTree:\n\n\tdef __init__(self):\n\t\tself.arr = [0] * 2 * N\n\n\tdef update(self, i, v):\n\t\ti += N\n\t\twhile i:\n\t\t\tself.arr[i] = max(self.arr[i], v)\n\t\t\ti //= 2\n\n\tdef query(self, l, r):\n\t\tl += N\n\t\tr += N\n\t\tres = 0\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tres = max(self.arr[l], res)\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tr -= 1\n\t\t\t\tres = max(res, self.arr[r])\n\t\t\tl //= 2\n\t\t\tr //= 2\n\t\treturn res\ndown_len = SegTree()\ndown_b = SegTree()\nup_len = SegTree()\nup_a = SegTree()\ntot = 0\nbest = 0\nP = sorted((p for p in zip(A, B)), key=lambda p: max(p))\nfor (a, b) in P:\n\t(ai, bi) = (order[a], order[b])\n\tif a < b:\n\t\t_1 = up_a.query(0, ai) - a\n\t\t_2 = up_len.query(ai, bi)\n\t\tcur = min(max(_1, _2), b - a)\n\t\tbest = max(best, cur)\n\t\tdown_b.update(ai, b)\n\t\tdown_len.update(ai, b - a)\n\telif b < a:\n\t\t_1 = down_b.query(0, bi) - b\n\t\t_2 = down_len.query(bi, ai)\n\t\tcur = min(max(_1, _2), a - b)\n\t\tbest = max(best, cur)\n\t\tup_a.update(bi, a)\n\t\tup_len.update(bi, a - b)\n\ttot += abs(a - b)\nprint(tot - 2 * best)\n",
        "slowest_solution": "n = int(input())\nlis = []\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nallsum = sum([abs(a[i] - b[i]) for i in range(n)])\nans = 0\nlis = []\nfor i in range(n):\n\tif a[i] < b[i]:\n\t\tlis.append((a[i], 1, b[i]))\n\telif a[i] > b[i]:\n\t\tlis.append((b[i], 2, a[i]))\nlis.sort()\nnmax = 0\nfor (x, ty, y) in lis:\n\tif ty == 1:\n\t\tnmax = max(nmax, y)\n\telse:\n\t\tans = max(ans, min(y - x, nmax - x))\nlis = []\nfor i in range(n):\n\tif a[i] > b[i]:\n\t\tlis.append((b[i], 1, a[i]))\n\telif a[i] < b[i]:\n\t\tlis.append((a[i], 2, b[i]))\nlis.sort()\nnmax = 0\nfor (x, ty, y) in lis:\n\tif ty == 1:\n\t\tnmax = max(nmax, y)\n\telse:\n\t\tans = max(ans, min(y - x, nmax - x))\nprint(allsum - ans * 2)\n"
    },
    {
        "task_id": 552,
        "slowest_solution_id": 9,
        "fastest_solution_id": 3,
        "slowest_time": 3.290976047515869,
        "fastest_time": 2.821780204772949,
        "fastest_solution": "T = int(input())\nfor test_case in range(T):\n\tvalues = {}\n\t(N, M) = [int(i) for i in input().split()]\n\tfor line in range(M):\n\t\tcommand = input().split()\n\t\tcommand = [command[0]] + [int(i) for i in command[1:]]\n\t\tif command[0] == 'UPDATE':\n\t\t\tvalues[tuple(command[1:4])] = command[4]\n\t\telif command[0] == 'QUERY':\n\t\t\t(x1, y1, z1, x2, y2, z2) = command[1:]\n\t\t\tprint(sum([values[key] for key in values if x1 <= key[0] <= x2 and y1 <= key[1] <= y2 and (z1 <= key[2] <= z2)]))\n",
        "slowest_solution": "numTests = int(input())\ncube = []\nfor i in range(0, 100):\n\tcube.append([])\n\tfor j in range(0, 100):\n\t\tcube[i].append([])\n\t\tfor k in range(0, 100):\n\t\t\tcube[i][j].append(0)\nwhile numTests != 0:\n\tindexList = [[0, 0, 0, 0]]\n\tline = input()\n\ttokens = line.split(' ')\n\tN = int(tokens[0])\n\tnumOp = int(tokens[1])\n\twhile numOp != 0:\n\t\tquery = input()\n\t\ttokens = query.split(' ')\n\t\tif tokens[0] == 'UPDATE':\n\t\t\tx = int(tokens[1]) - 1\n\t\t\ty = int(tokens[2]) - 1\n\t\t\tz = int(tokens[3]) - 1\n\t\t\tw = int(tokens[4])\n\t\t\tcube[x][y][z] = w\n\t\t\ttempList = []\n\t\t\ttempList.append(x)\n\t\t\ttempList.append(y)\n\t\t\ttempList.append(z)\n\t\t\ttempList.append(w)\n\t\t\tflag = 0\n\t\t\tfor index in indexList:\n\t\t\t\tif index[0] == x and index[1] == y and (index[2] == z):\n\t\t\t\t\tindex[3] = w\n\t\t\t\t\tflag = 1\n\t\t\tif flag == 0:\n\t\t\t\tindexList.append(tempList)\n\t\telif tokens[0] == 'QUERY':\n\t\t\tx1 = int(tokens[1]) - 1\n\t\t\ty1 = int(tokens[2]) - 1\n\t\t\tz1 = int(tokens[3]) - 1\n\t\t\tx2 = int(tokens[4]) - 1\n\t\t\ty2 = int(tokens[5]) - 1\n\t\t\tz2 = int(tokens[6]) - 1\n\t\t\tsum = 0\n\t\t\tfor index in indexList:\n\t\t\t\tif index[0] >= x1 and index[0] <= x2:\n\t\t\t\t\tif index[1] >= y1 and index[1] <= y2:\n\t\t\t\t\t\tif index[2] >= z1 and index[2] <= z2:\n\t\t\t\t\t\t\tsum += index[3]\n\t\t\tprint(sum)\n\t\tnumOp -= 1\n\tnumTests -= 1\n"
    },
    {
        "task_id": 559,
        "slowest_solution_id": 1,
        "fastest_solution_id": 4,
        "slowest_time": 2.8916497230529785,
        "fastest_time": 2.8639042377471924,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nl = input().split(' ')\nn = int(l[0])\nk = int(l[1])\nif k == 1 or k >= 4:\n\tprint(-1)\nelif k == 2:\n\tif n <= 4:\n\t\tprint(-1)\n\telse:\n\t\tprint(n - 1)\n\t\tfor i in range(1, n):\n\t\t\tprint(i, i + 1)\nelif n <= 3:\n\tprint(-1)\nelse:\n\tprint(3 + n - 4)\n\tfor i in range(1, 4):\n\t\tprint(i, i + 1)\n\tfor i in range(5, n + 1):\n\t\tprint(3, i)\n",
        "slowest_solution": "(n, k) = map(int, input().split())\nif n < 4 or k == 1 or k > 3 or (n == 4 and k == 2):\n\tprint(-1)\nelif k == 2:\n\tprint(n - 1)\n\t[print(i, i + 1) for i in range(1, n)]\nelif k == 3:\n\tprint(str(n - 1) + '\\n1 2\\n2 3')\n\t[print(3, i) for i in range(4, n + 1)]\n"
    },
    {
        "task_id": 591,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.931678533554077,
        "fastest_time": 2.8422837257385254,
        "fastest_solution": "test = input();\ntest = int(test);\n\nfor i in range(0, test):\n\tsize = input();\n\tsize = int(size);\n\n\ttotal = 0;\n\ttemp_list = [];\n\ttemp_list = input().split();\n\ttemp_list = [int(j) for j in temp_list];\n\n\tif (temp_list[0] >= temp_list[1]):\n\t\ttotal = total + temp_list[0];\n\tif(temp_list[size-1] > temp_list[size-2]):\n\t   total = total + temp_list[size-1];\n\tfor k in range(1,size-1):\n\t\tif (temp_list[k]>temp_list[k-1])|(temp_list[k]>=temp_list[k+1]):\n\t\t\tif (temp_list[k]>temp_list[k-1])&(temp_list[k]>=temp_list[k+1]):\n\t\t\t\ttotal = total + 2*temp_list[k];\n\t\t\telse:\n\t\t\t\ttotal = total + temp_list[k];\n\n\tprint(total);\n\t\t\t   \n",
        "slowest_solution": "def printEnergy(l):\n\ten = 0\n\t\n\tfor i in range(0, len(l) - 1):\n\t\ten += max(l[i], l[i+1])\n\t\t\n\tprint(en)\n\n\nt = int(input())\n\nfor i in range(t):\n\tn = int(input())\n\tl = [int(x) for x in input().split()]\n\tprintEnergy(l)\n\n"
    },
    {
        "task_id": 590,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.91058087348938,
        "fastest_time": 2.8807528018951416,
        "fastest_solution": "import sys\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(10 ** 6)\n\ndef find(u):\n\tif P[u] == u:\n\t\treturn u\n\telse:\n\t\tP[u] = find(P[u])\n\t\treturn P[u]\n\ndef unite(u, v):\n\tv = find(v)\n\tP[v] = u\n\tT[u].append(v)\n\ndef dfs(u):\n\tif len(prefix):\n\t\tprefix.append(a[u] + prefix[-1])\n\telse:\n\t\tprefix.append(a[u])\n\tpath.append(pos[u])\n\tt = bl(prefix, b[u])\n\tif t == len(prefix):\n\t\tans[u] = -2\n\telse:\n\t\tans[u] = path[t]\n\tfor v in T[u]:\n\t\tdfs(v)\n\tpath.pop()\n\tprefix.pop()\nfor _ in range(int(input())):\n\tn = int(input())\n\tadj = dd(list)\n\tT = dd(list)\n\tfor i in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tu -= 1\n\t\tv -= 1\n\t\tadj[u].append(v)\n\t\tadj[v].append(u)\n\tp = list(map(int, input().split()))\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\tP = [i for i in range(n)]\n\tans = [-1 for i in range(n)]\n\tpos = [0 for i in range(n)]\n\tpresent = [0 for i in range(n)]\n\tprefix = []\n\tpath = []\n\tfor i in range(n - 1, -1, -1):\n\t\tp[i] -= 1\n\t\tpos[p[i]] = i\n\t\tfor j in adj[p[i]]:\n\t\t\tif present[j]:\n\t\t\t\tunite(p[i], j)\n\t\tpresent[p[i]] = 1\n\tdfs(p[0])\n\tfor i in range(n):\n\t\tans[i] += 1\n\tprint(*ans)\n",
        "slowest_solution": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nfrom bisect import bisect_left as Lower_Bound\n\ndef create_new():\n\tcheck = dict()\n\tfor i in range(n - 1, -1, -1):\n\t\tparent[pi[i]] = pi[i]\n\t\tfor j in Graph[pi[i]]:\n\t\t\tif j in check:\n\t\t\t\tz = find(j)\n\t\t\t\tparent[z] = pi[i]\n\t\t\t\tnewGraph[pi[i]].append(z)\n\t\t\t\tnewGraph[z].append(pi[i])\n\t\tcheck[pi[i]] = 'Present'\n\ndef DFS(x):\n\tvisited.add(x)\n\tdays_Stack.append(Trackdays[x])\n\tif ai_Stack == []:\n\t\tai_Stack.append(ai[x])\n\telse:\n\t\tai_Stack.append(ai_Stack[-1] + ai[x])\n\tz = Lower_Bound(ai_Stack, bi[x])\n\tif z < len(days_Stack):\n\t\tans[x] = days_Stack[z]\n\tfor i in newGraph[x]:\n\t\tif i not in visited:\n\t\t\tDFS(i)\n\tdays_Stack.pop(-1)\n\tai_Stack.pop(-1)\n\ndef find(x):\n\tif x == parent[x]:\n\t\treturn x\n\tz = find(parent[x])\n\tparent[x] = z\n\treturn z\nt = int(input())\nfor you in range(t):\n\tn = int(input())\n\tGraph = [[] for i in range(n)]\n\tfor i in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tGraph[u - 1].append(v - 1)\n\t\tGraph[v - 1].append(u - 1)\n\tpi = [int(i) - 1 for i in input().split()]\n\tai = [int(i) for i in input().split()]\n\tbi = [int(i) for i in input().split()]\n\tnewGraph = [[] for i in range(n)]\n\tparent = [-1 for i in range(n)]\n\tcreate_new()\n\tTrackdays = dict()\n\tfor i in range(n):\n\t\tTrackdays[pi[i]] = i + 1\n\tans = [-1 for i in range(n)]\n\tvisited = set()\n\tdays_Stack = list()\n\tai_Stack = list()\n\tDFS(pi[0])\n\tprint(*ans)\n"
    },
    {
        "task_id": 543,
        "slowest_solution_id": 3,
        "fastest_solution_id": 9,
        "slowest_time": 7.564251661300659,
        "fastest_time": 2.8132667541503906,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\na = sorted(list(set(a)))\nmx = max(a)\nb = [0] * (2 * mx)\nfor aa in a:\n\tb[aa] = aa\nfor i in range(1, len(b)):\n\tif b[i] == 0:\n\t\tb[i] = b[i - 1]\nans = 0\nfor aa in a:\n\tfor m in range(2 * aa, 2 * mx, aa):\n\t\tif b[m - 1] >= aa:\n\t\t\tans = max(ans, b[m - 1] % aa)\nprint(ans)\n",
        "slowest_solution": "N = 2000001\nn = int(input())\na = list(set(map(int, input().split())))\nprev = [0] * N\nfor x in a:\n\tprev[x] = x\nfor x in range(N):\n\tprev[x] = max(prev[x], prev[x - 1])\nans = 0\nfor x in a:\n\tfor j in range(2 * x, N, x):\n\t\tans = max(ans, prev[j - 1] % x)\nprint(ans)\n"
    },
    {
        "task_id": 554,
        "slowest_solution_id": 0,
        "fastest_solution_id": 4,
        "slowest_time": 2.951409339904785,
        "fastest_time": 2.849970817565918,
        "fastest_solution": "n = int(input())\nfor _ in range(n):\n\tx = int(input())\n\tr = input()\n\tb = input()\n\tlr = len(r)\n\tlb = len(b)\n\tc = lr\n\tna = 0\n\tnb = 0\n\tif r == b:\n\t\tprint('EQUAL')\n\telse:\n\t\ti = 0\n\t\twhile i < lr:\n\t\t\tif r[i] > b[i]:\n\t\t\t\tna += 1\n\t\t\telif r[i] < b[i]:\n\t\t\t\tnb += 1\n\t\t\ti += 1\n\t\tif na > nb:\n\t\t\tprint('RED')\n\t\telif nb > na:\n\t\t\tprint('BLUE')\n\t\telse:\n\t\t\tprint('EQUAL')\n",
        "slowest_solution": "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\ndef gift():\n\tfor _ in range(t):\n\t\tn = int(input())\n\t\ta = list(input())\n\t\tb = list(input())\n\t\tcounta = 0\n\t\tcountb = 0\n\t\tfor i in range(n):\n\t\t\tif a[i] > b[i]:\n\t\t\t\tcounta += 1\n\t\t\telif a[i] < b[i]:\n\t\t\t\tcountb += 1\n\t\tif counta > countb:\n\t\t\tyield 'RED'\n\t\telif counta < countb:\n\t\t\tyield 'BLUE'\n\t\telse:\n\t\t\tyield 'EQUAL'\nt = int(input())\nans = gift()\nprint(*ans, sep='\\n')\n"
    },
    {
        "task_id": 562,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 2.950331449508667,
        "fastest_time": 2.8790030479431152,
        "fastest_solution": "from sys import stdin, stdout\nfrom collections import defaultdict\nimport math\n\ndef main():\n\tn = int(stdin.readline())\n\tp = []\n\tfor _ in range(n):\n\t\t(x, y) = list(map(int, stdin.readline().split()))\n\t\tp.append((x, y))\n\tans = []\n\tfor i in range(n):\n\t\tans.append(i)\n\t\tfor j in range(i, 1, -1):\n\t\t\tif (p[ans[j]][0] - p[ans[j - 1]][0]) * (p[ans[j - 1]][0] - p[ans[j - 2]][0]) + (p[ans[j]][1] - p[ans[j - 1]][1]) * (p[ans[j - 1]][1] - p[ans[j - 2]][1]) >= 0:\n\t\t\t\t(ans[j - 1], ans[j]) = (ans[j], ans[j - 1])\n\t\t\telse:\n\t\t\t\tbreak\n\tstdout.write(' '.join((str(x + 1) for x in ans)))\nmain()\n",
        "slowest_solution": "import sys\nreadline = sys.stdin.readline\n\ndef obt(i, j, k):\n\t(x1, y1) = (Points[i][0], Points[i][1])\n\t(x2, y2) = (Points[j][0], Points[j][1])\n\t(x3, y3) = (Points[k][0], Points[k][1])\n\t(X21, Y21) = (x1 - x2, y1 - y2)\n\t(X23, Y23) = (x3 - x2, y3 - y2)\n\treturn X21 * X23 + Y21 * Y23 <= 0\nN = int(readline())\nPoints = [tuple(map(int, readline().split())) for _ in range(N)]\nL = [0, 1]\nfor i in range(2, N):\n\tL.append(i)\n\tif obt(L[i - 2], L[i - 1], L[i]):\n\t\t(L[i], L[i - 1]) = (L[i - 1], L[i])\n\tfor j in range(i - 1, 1, -1):\n\t\tif obt(L[j - 2], L[j - 1], L[j]):\n\t\t\t(L[j - 1], L[j]) = (L[j], L[j - 1])\n\t\telse:\n\t\t\tbreak\nprint(*[i + 1 for i in L])\n"
    },
    {
        "task_id": 598,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.956594944000244,
        "fastest_time": 2.8521337509155273,
        "fastest_solution": "from heapq import *\nimport sys\n\ndef ng():\n\tprint('NO')\n\texit()\n(n, k) = map(int, input().split())\nif (n, k) == (1, 0):\n\tprint('YES')\n\tprint(0)\n\texit()\nans = [0] * n\npopcnt = lambda x: bin(x).count('1')\nif n & 1 == 0 or n < 2 * k + 3 or (popcnt(n + 1) > 1 and k == 0):\n\tng()\nu = 0\nif popcnt(n + 1 - 2 * (k - 1)) == 1:\n\tfor v in range(1, 4):\n\t\tans[v] = v // 2 + 1\n\tk -= 1\n\tif n - 4 < 2 * k + 3 or k == 0 or n < 11:\n\t\tng()\n\tans[4] = 1\n\tu = 4\nfor _ in range(k - 1):\n\tans[u + 1] = ans[u + 2] = u + 1\n\tu += 2\nfor v in range(1, n - u):\n\tans[v + u] = (v - 1) // 2 + u + 1\nprint('YES')\nprint(*ans)\n",
        "slowest_solution": "from heapq import *\nimport sys\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n\treturn int(sys.stdin.readline())\n\ndef MI():\n\treturn map(int, sys.stdin.readline().split())\n\ndef LI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n\treturn [LI() for _ in range(rows_number)]\n\ndef SI():\n\treturn sys.stdin.readline()[:-1]\n\ndef ng():\n\tprint('NO')\n\texit()\n(n, k) = MI()\nif (n, k) == (1, 0):\n\tprint('YES')\n\tprint(0)\n\texit()\nans = [0] * n\npopcnt = lambda x: bin(x).count('1')\nif n & 1 == 0 or n < 2 * k + 3 or (popcnt(n + 1) > 1 and k == 0):\n\tng()\nu = 0\nif popcnt(n + 1 - 2 * (k - 1)) == 1:\n\tfor v in range(1, 4):\n\t\tans[v] = v // 2 + 1\n\tk -= 1\n\tif n - 4 < 2 * k + 3 or k == 0 or n < 11:\n\t\tng()\n\tans[4] = 1\n\tu = 4\nfor _ in range(k - 1):\n\tans[u + 1] = ans[u + 2] = u + 1\n\tu += 2\nfor v in range(1, n - u):\n\tans[v + u] = (v - 1) // 2 + u + 1\nprint('YES')\nprint(*ans)\n"
    },
    {
        "task_id": 608,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def alan(arr):\n\ts = {'Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway'}\n\treturn 'Smell my cheese you mother!' if s.issubset(arr) else 'No, seriously, run. You will miss it.'\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 592,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.9259212017059326,
        "fastest_time": 2.864072322845459,
        "fastest_solution": "t=int(input());\nc=0;\nwhile c<t:\n\tc+=1;\n\tn=int(input());\n\th=input().split();\n\th=[int(x) for x in h];\n\td=0;\n\tfr={};\n\tba={};\n\tmax=0;\n\tw=n;\n\twhile d<n:\n\t\td1=d-1\n\t\t\n\t\twhile d1>0 and h[d1]<h[d]:\n\t\t\td1=d1-fr[d1];\n\t\t\t\n\t\t\n\t\tfr[d]=0 if d==0 else d-d1;\n\t\t\n\t\td2=n-d;\n\t\t\n\t\twhile d2<n-1 and h[d2]<h[n-d-1]:\n\t\t\td2=d2+ba[d2];\n\t\t\n\t\tba[n-d-1]=0 if d==0 else d2-(n-d-1);\n\n\t\tif d+1>n/2:\n\t\t\tsi=((fr[d]+ba[d])*(d+1))%1000000007;\n\t\t\t\t\t\t\n\t\t\tif si>max:\n\t\t\t\tmax=si\n\t\t\t\tw=d;\n\n\t\t\telif si==max and d<w:\n\t\t\t\tw=d;\n\n\t\t\tsi=((fr[n-d-1]+ba[n-d-1])*(n-d))%1000000007;\n\t\t\t\t\t\t\n\t\t\tif si>max:\n\t\t\t\tmax=si\n\t\t\t\tw=n-d-1;\n\n\t\t\telif si==max and n-d-1<w:\n\t\t\t\tw=n-d-1;\n\t\td+=1;\n\t\t\n\t\t\n\t\t   \n\tprint((w+1));\n\n\n\n\t\n\t\t\n\t\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n",
        "slowest_solution": "t=int(input());\nc=0;\nwhile c<t:\n\tc+=1;\n\tn=int(input());\n\th=input().split();\n\th=[int(x) for x in h];\n\td=0;\n\tfr={};\n\tba={};\n\twhile d<n:\n\t\td1=d-1\n\t\t\n\t\twhile d1>0 and h[d1]<h[d]:\n\t\t\td1=d1-fr[d1];\n\t\t\t\n\t\t\n\t\tfr[d]=0 if d==0 else d-d1;\n\t\t\n\t\td2=n-d;\n\t\t\n\t\twhile d2<n-1 and h[d2]<h[n-d-1]:\n\t\t\td2=d2+ba[d2];\n\t\t\n\t\tba[n-d-1]=0 if d==0 else d2-(n-d-1);\n\n\t\td+=1;\n\t\t\n\td=0;\n\tmax=0;\n\tw=n;\n\twhile d<n:\n\t\tsi=((fr[d]+ba[d])*(d+1))%1000000007;\n\t\t\t\t\t\t\n\t\tif si>max:\n\t\t\tmax=si\n\t\t\tw=d;\n\n\t\telif si==max and d<w:\n\t\t\tw=d;\n\t\td+=1;\n\t\t\n\tprint((w+1));\n\n\n\n\t\n\t\t\n\t\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n"
    },
    {
        "task_id": 557,
        "slowest_solution_id": 7,
        "fastest_solution_id": 9,
        "slowest_time": 2.932161331176758,
        "fastest_time": 2.7540833950042725,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n\ndef solve():\n\tn = int(input())\n\tw = list(map(int, input().split()))\n\t(l, r) = (0, n - 1)\n\t(a, b) = (0, 0)\n\tans = 0\n\twhile l <= r:\n\t\tif a < b:\n\t\t\ta += w[l]\n\t\t\tl += 1\n\t\telse:\n\t\t\tb += w[r]\n\t\t\tr -= 1\n\t\tif a == b:\n\t\t\tans = max(ans, l + n - 1 - r)\n\tprint(ans)\ntst = int(input())\nfor tt in range(tst):\n\tsolve()\n",
        "slowest_solution": "from sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n\tn = int(input())\n\tarr = [int(x) for x in input().split()]\n\ti = 0\n\tk = n - 1\n\ta = arr[0]\n\tb = arr[-1]\n\tans = 0\n\twhile i < k:\n\t\tif a == b:\n\t\t\tans = i + 1 + (n - k)\n\t\tif a >= b:\n\t\t\tk -= 1\n\t\t\tb += arr[k]\n\t\telse:\n\t\t\ti += 1\n\t\t\ta += arr[i]\n\tprint(ans)\n"
    },
    {
        "task_id": 606,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6998541355133057,
        "fastest_time": 2.6998541355133057,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\t(l, bits) = (list(map(int, input().split())), [[] for _ in range(k)])\n\tfor i in range(k):\n\t\tfor j in range(n):\n\t\t\tif pow(2, i) & l[j]:\n\t\t\t\tbits[i].append(j)\n\tans = 1\n\tfor i in range(k):\n\t\ttemp = n - len(bits[i]) + 1\n\t\tfor j in range(len(bits[i])):\n\t\t\ttemp = (temp + (n - bits[i][j]) - (len(bits[i]) - j - 1)) % 998244353\n\t\tans = ans * temp % 998244353\n\tprint(ans)\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\t(l, bits) = (list(map(int, input().split())), [[] for _ in range(k)])\n\tfor i in range(k):\n\t\tfor j in range(n):\n\t\t\tif pow(2, i) & l[j]:\n\t\t\t\tbits[i].append(j)\n\tans = 1\n\tfor i in range(k):\n\t\ttemp = n - len(bits[i]) + 1\n\t\tfor j in range(len(bits[i])):\n\t\t\ttemp = (temp + (n - bits[i][j]) - (len(bits[i]) - j - 1)) % 998244353\n\t\tans = ans * temp % 998244353\n\tprint(ans)\n"
    },
    {
        "task_id": 578,
        "slowest_solution_id": 3,
        "fastest_solution_id": 3,
        "slowest_time": 3.1792142391204834,
        "fastest_time": 3.1792142391204834,
        "fastest_solution": "import math\nt = int(input())\nfor i in range(t):\n\t(l, r, z) = [int(l) for l in input().split()]\n\ta1 = z - (r - l)\n\ta2 = z + (r - l)\n\ta = 0\n\tl1 = 2 * (r - l)\n\tp = 0\n\tq1 = [1] * 100\n\t(tec, mac) = (0, 0)\n\tfor j in range(l, r + 1, 1):\n\t\tm = a2 % j\n\t\tif m == 0:\n\t\t\t(a, p) = (j, a2)\n\t\t\tbreak\n\t\telif m <= l1:\n\t\t\t(a, p) = (j, a2 - m)\n\t\t\tbreak\n\tq = z - p\n\tif q >= 0:\n\t\t(b, c) = (r, r - q)\n\tif q < 0:\n\t\t(b, c) = (l, l - q)\n\tprint(a, b, c)\n",
        "slowest_solution": "import math\nt = int(input())\nfor i in range(t):\n\t(l, r, z) = [int(l) for l in input().split()]\n\ta1 = z - (r - l)\n\ta2 = z + (r - l)\n\ta = 0\n\tl1 = 2 * (r - l)\n\tp = 0\n\tq1 = [1] * 100\n\t(tec, mac) = (0, 0)\n\tfor j in range(l, r + 1, 1):\n\t\tm = a2 % j\n\t\tif m == 0:\n\t\t\t(a, p) = (j, a2)\n\t\t\tbreak\n\t\telif m <= l1:\n\t\t\t(a, p) = (j, a2 - m)\n\t\t\tbreak\n\tq = z - p\n\tif q >= 0:\n\t\t(b, c) = (r, r - q)\n\tif q < 0:\n\t\t(b, c) = (l, l - q)\n\tprint(a, b, c)\n"
    },
    {
        "task_id": 558,
        "slowest_solution_id": 2,
        "fastest_solution_id": 8,
        "slowest_time": 2.989565134048462,
        "fastest_time": 2.7764089107513428,
        "fastest_solution": "from sys import *\nfrom collections import *\n\ndef ri():\n\treturn map(int, input().split())\ncnt = 0\n\ndef bfs(cc, i):\n\tglobal cnt\n\tv[cc] = 1\n\tcnt += 1\n\tg[i].append(cc)\n\td = deque()\n\td.append(cc)\n\twhile d:\n\t\ta = d.popleft()\n\t\tfor aa in G[a]:\n\t\t\tif v[aa] == 0:\n\t\t\t\tcnt += 1\n\t\t\t\tv[aa] = 1\n\t\t\t\tg[i].append(aa)\n\t\t\t\td.append(aa)\n\t\tv[a] = 2\n(n, m, k) = ri()\nc = list(ri())\nccnt = [0 for i in range(len(c))]\ng = [[] for i in range(len(c))]\nv = [0 for i in range(n + 1)]\nG = [set() for i in range(n + 1)]\nfor i in range(1, m + 1):\n\t(a, b) = ri()\n\tG[a].add(b)\n\tG[b].add(a)\nfor (i, cc) in enumerate(c):\n\tcnt = 0\n\tccnt[i] = bfs(cc, i)\ncmax = max(range(len(c)), key=lambda x: len(g[x]))\nfor i in range(1, n + 1):\n\tif v[i] == 0:\n\t\tg[cmax].append(i)\ntot = 0\nfor i in range(len(c)):\n\tnon = len(g[i])\n\tfor nn in g[i]:\n\t\ttot = tot + non - len(G[nn]) - 1\nprint(int(tot / 2))\n",
        "slowest_solution": "class graph:\n\n\tdef __init__(self, size):\n\t\tself.G = dict()\n\t\tfor i in range(size):\n\t\t\tself.G[i] = set()\n\t\tself.sz = size\n\t\tself.ne = 0\n\n\tdef ae(self, u, v):\n\t\tself.G[u].add(v)\n\t\tself.G[v].add(u)\n\t\tself.ne += 1\n\n\tdef se(self, u):\n\t\treturn self.G[u]\n\n\tdef nume(self):\n\t\treturn self.ne\n\ndef dfs(G, v):\n\t(num, mk) = (1, mark[v])\n\tvv[v] = 1\n\tfor u in G.se(v):\n\t\tif not vv[u]:\n\t\t\t(n1, mk1) = dfs(G, u)\n\t\t\tnum += n1\n\t\t\tmk |= mk1\n\treturn (num, mk)\n(n, m, k) = (int(z) for z in input().split())\nG = graph(n)\nhh = [int(z) - 1 for z in input().split()]\nmark = [0] * n\nvv = [0] * n\nfor i in hh:\n\tmark[i] = 1\nfor i in range(m):\n\t(u, v) = (int(z) - 1 for z in input().split())\n\tG.ae(u, v)\nsunmk = 0\nmkcc = []\nfor u in range(n):\n\tif not vv[u]:\n\t\t(n2, mk2) = dfs(G, u)\n\t\tif mk2:\n\t\t\tmkcc.append(n2)\n\t\telse:\n\t\t\tsunmk += n2\nmkcc.sort()\nans = 0\nfor i in mkcc[:len(mkcc) - 1]:\n\tans += i * (i - 1) // 2\nans += (mkcc[-1] + sunmk) * (mkcc[-1] + sunmk - 1) // 2\nans -= m\nprint(ans)\n"
    },
    {
        "task_id": 610,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.0063018798828125,
        "fastest_time": 3.0063018798828125,
        "fastest_solution": "from sys import stdin\nMOD = 1000000007\ns = stdin.readline().strip()\nn = len(s)\nbuc = [0] * 101\nfac = [0] * (n + 1)\ninv = [0] * (n + 1)\ndp = [0] * (n + 1)\nans = [[0] * 55 for _ in range(55)]\n\ndef find(c: 'str') -> 'int':\n\tif 'A' <= c <= 'Z':\n\t\treturn ord(c) - ord('A') + 26\n\telse:\n\t\treturn ord(c) - ord('a')\n\ndef add(a: 'int', b: 'int') -> 'int':\n\ta += b\n\tif a >= MOD:\n\t\ta -= MOD\n\treturn a\n\ndef sub(a: 'int', b: 'int') -> 'int':\n\ta -= b\n\tif a < 0:\n\t\ta += MOD\n\treturn a\nfor i in s:\n\tbuc[find(i)] += 1\nfac[0] = 1\nfor i in range(1, n + 1):\n\tfac[i] = fac[i - 1] * i % MOD\ninv[n] = pow(fac[n], MOD - 2, MOD)\nfor i in range(n - 1, -1, -1):\n\tinv[i] = inv[i + 1] * (i + 1) % MOD\nnum = pow(fac[n // 2], 2, MOD)\nfor i in range(0, 52):\n\tnum = num * inv[buc[i]] % MOD\ndp[0] = 1\nfor i in range(0, 52):\n\tif not buc[i]:\n\t\tcontinue\n\tfor j in range(n, buc[i] - 1, -1):\n\t\tdp[j] = add(dp[j], dp[j - buc[i]])\nfor i in range(52):\n\tans[i][i] = dp[n // 2]\nfor i in range(52):\n\tif not buc[i]:\n\t\tcontinue\n\ttemp_dp = dp.copy()\n\tfor k in range(buc[i], n + 1):\n\t\ttemp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[i]])\n\tfor j in range(i + 1, 52):\n\t\tif not buc[j]:\n\t\t\tcontinue\n\t\tfor k in range(buc[j], n + 1):\n\t\t\ttemp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[j]])\n\t\tans[i][j] = 2 * temp_dp[n // 2] % MOD\n\t\tfor k in range(n, buc[j] - 1, -1):\n\t\t\ttemp_dp[k] = add(temp_dp[k], temp_dp[k - buc[j]])\nq = int(input())\nl = stdin.read().splitlines()\nfor i in l:\n\t(x, y) = map(int, i.split())\n\t(l, r) = (find(s[x - 1]), find(s[y - 1]))\n\tif l > r:\n\t\t(l, r) = (r, l)\n\tprint(num * ans[l][r] % MOD)\n",
        "slowest_solution": "from sys import stdin\nMOD = 1000000007\ns = stdin.readline().strip()\nn = len(s)\nbuc = [0] * 101\nfac = [0] * (n + 1)\ninv = [0] * (n + 1)\ndp = [0] * (n + 1)\nans = [[0] * 55 for _ in range(55)]\n\ndef find(c: 'str') -> 'int':\n\tif 'A' <= c <= 'Z':\n\t\treturn ord(c) - ord('A') + 26\n\telse:\n\t\treturn ord(c) - ord('a')\n\ndef add(a: 'int', b: 'int') -> 'int':\n\ta += b\n\tif a >= MOD:\n\t\ta -= MOD\n\treturn a\n\ndef sub(a: 'int', b: 'int') -> 'int':\n\ta -= b\n\tif a < 0:\n\t\ta += MOD\n\treturn a\nfor i in s:\n\tbuc[find(i)] += 1\nfac[0] = 1\nfor i in range(1, n + 1):\n\tfac[i] = fac[i - 1] * i % MOD\ninv[n] = pow(fac[n], MOD - 2, MOD)\nfor i in range(n - 1, -1, -1):\n\tinv[i] = inv[i + 1] * (i + 1) % MOD\nnum = pow(fac[n // 2], 2, MOD)\nfor i in range(0, 52):\n\tnum = num * inv[buc[i]] % MOD\ndp[0] = 1\nfor i in range(0, 52):\n\tif not buc[i]:\n\t\tcontinue\n\tfor j in range(n, buc[i] - 1, -1):\n\t\tdp[j] = add(dp[j], dp[j - buc[i]])\nfor i in range(52):\n\tans[i][i] = dp[n // 2]\nfor i in range(52):\n\tif not buc[i]:\n\t\tcontinue\n\ttemp_dp = dp.copy()\n\tfor k in range(buc[i], n + 1):\n\t\ttemp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[i]])\n\tfor j in range(i + 1, 52):\n\t\tif not buc[j]:\n\t\t\tcontinue\n\t\tfor k in range(buc[j], n + 1):\n\t\t\ttemp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[j]])\n\t\tans[i][j] = 2 * temp_dp[n // 2] % MOD\n\t\tfor k in range(n, buc[j] - 1, -1):\n\t\t\ttemp_dp[k] = add(temp_dp[k], temp_dp[k - buc[j]])\nq = int(input())\nl = stdin.read().splitlines()\nfor i in l:\n\t(x, y) = map(int, i.split())\n\t(l, r) = (find(s[x - 1]), find(s[y - 1]))\n\tif l > r:\n\t\t(l, r) = (r, l)\n\tprint(num * ans[l][r] % MOD)\n"
    },
    {
        "task_id": 561,
        "slowest_solution_id": 8,
        "fastest_solution_id": 9,
        "slowest_time": 3.0039212703704834,
        "fastest_time": 2.7401111125946045,
        "fastest_solution": "def divisors(M):\n\td = []\n\ti = 1\n\twhile M >= i ** 2:\n\t\tif M % i == 0:\n\t\t\td.append(i)\n\t\t\tif i ** 2 != M:\n\t\t\t\td.append(M // i)\n\t\ti = i + 1\n\treturn d\n\ndef popcount(x):\n\tx = x - (x >> 1 & 1431655765)\n\tx = (x & 858993459) + (x >> 2 & 858993459)\n\tx = x + (x >> 4) & 252645135\n\tx = x + (x >> 8)\n\tx = x + (x >> 16)\n\treturn x & 127\n\ndef eratosthenes(n):\n\tres = [0 for i in range(n + 1)]\n\tprime = set([])\n\tfor i in range(2, n + 1):\n\t\tif not res[i]:\n\t\t\tprime.add(i)\n\t\t\tfor j in range(1, n // i + 1):\n\t\t\t\tres[i * j] = 1\n\treturn prime\n\ndef factorization(n):\n\tres = []\n\tfor p in prime:\n\t\tif n % p == 0:\n\t\t\twhile n % p == 0:\n\t\t\t\tn //= p\n\t\t\tres.append(p)\n\tif n != 1:\n\t\tres.append(n)\n\treturn res\n\ndef euler_phi(n):\n\tres = n\n\tfor x in range(2, n + 1):\n\t\tif x ** 2 > n:\n\t\t\tbreak\n\t\tif n % x == 0:\n\t\t\tres = res // x * (x - 1)\n\t\t\twhile n % x == 0:\n\t\t\t\tn //= x\n\tif n != 1:\n\t\tres = res // n * (n - 1)\n\treturn res\n\ndef ind(b, n):\n\tres = 0\n\twhile n % b == 0:\n\t\tres += 1\n\t\tn //= b\n\treturn res\n\ndef isPrimeMR(n):\n\td = n - 1\n\td = d // (d & -d)\n\tL = [2, 3, 5, 7, 11, 13, 17]\n\tfor a in L:\n\t\tt = d\n\t\ty = pow(a, t, n)\n\t\tif y == 1:\n\t\t\tcontinue\n\t\twhile y != n - 1:\n\t\t\ty = y * y % n\n\t\t\tif y == 1 or t == n - 1:\n\t\t\t\treturn 0\n\t\t\tt <<= 1\n\treturn 1\n\ndef findFactorRho(n):\n\tfrom math import gcd\n\tm = 1 << n.bit_length() // 8\n\tfor c in range(1, 99):\n\t\tf = lambda x: (x * x + c) % n\n\t\t(y, r, q, g) = (2, 1, 1, 1)\n\t\twhile g == 1:\n\t\t\tx = y\n\t\t\tfor i in range(r):\n\t\t\t\ty = f(y)\n\t\t\tk = 0\n\t\t\twhile k < r and g == 1:\n\t\t\t\tys = y\n\t\t\t\tfor i in range(min(m, r - k)):\n\t\t\t\t\ty = f(y)\n\t\t\t\t\tq = q * abs(x - y) % n\n\t\t\t\tg = gcd(q, n)\n\t\t\t\tk += m\n\t\t\tr <<= 1\n\t\tif g == n:\n\t\t\tg = 1\n\t\t\twhile g == 1:\n\t\t\t\tys = f(ys)\n\t\t\t\tg = gcd(abs(x - ys), n)\n\t\tif g < n:\n\t\t\tif isPrimeMR(g):\n\t\t\t\treturn g\n\t\t\telif isPrimeMR(n // g):\n\t\t\t\treturn n // g\n\t\t\treturn findFactorRho(g)\n\ndef primeFactor(n):\n\ti = 2\n\tret = {}\n\trhoFlg = 0\n\twhile i * i <= n:\n\t\tk = 0\n\t\twhile n % i == 0:\n\t\t\tn //= i\n\t\t\tk += 1\n\t\tif k:\n\t\t\tret[i] = k\n\t\ti += 1 + i % 2\n\t\tif i == 101 and n >= 2 ** 20:\n\t\t\twhile n > 1:\n\t\t\t\tif isPrimeMR(n):\n\t\t\t\t\t(ret[n], n) = (1, 1)\n\t\t\t\telse:\n\t\t\t\t\trhoFlg = 1\n\t\t\t\t\tj = findFactorRho(n)\n\t\t\t\t\tk = 0\n\t\t\t\t\twhile n % j == 0:\n\t\t\t\t\t\tn //= j\n\t\t\t\t\t\tk += 1\n\t\t\t\t\tret[j] = k\n\tif n > 1:\n\t\tret[n] = 1\n\tif rhoFlg:\n\t\tret = {x: ret[x] for x in sorted(ret)}\n\treturn ret\n\ndef divisors(n):\n\tres = [1]\n\tprime = primeFactor(n)\n\tfor p in prime:\n\t\tnewres = []\n\t\tfor d in res:\n\t\t\tfor j in range(prime[p] + 1):\n\t\t\t\tnewres.append(d * p ** j)\n\t\tres = newres\n\tres.sort()\n\treturn res\n\ndef xorfactorial(num):\n\tif num == 0:\n\t\treturn 0\n\telif num == 1:\n\t\treturn 1\n\telif num == 2:\n\t\treturn 3\n\telif num == 3:\n\t\treturn 0\n\telse:\n\t\tx = baseorder(num)\n\t\treturn 2 ** x * ((num - 2 ** x + 1) % 2) + function(num - 2 ** x)\n\ndef xorconv(n, X, Y):\n\tif n == 0:\n\t\tres = [X[0] * Y[0] % mod]\n\t\treturn res\n\tx = [X[i] + X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\ty = [Y[i] + Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\tz = [X[i] - X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\tw = [Y[i] - Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\n\tres1 = xorconv(n - 1, x, y)\n\tres2 = xorconv(n - 1, z, w)\n\tformer = [(res1[i] + res2[i]) * inv for i in range(2 ** (n - 1))]\n\tlatter = [(res1[i] - res2[i]) * inv for i in range(2 ** (n - 1))]\n\tformer = list(map(lambda x: x % mod, former))\n\tlatter = list(map(lambda x: x % mod, latter))\n\treturn former + latter\n\ndef merge_sort(A, B):\n\t(pos_A, pos_B) = (0, 0)\n\t(n, m) = (len(A), len(B))\n\tres = []\n\twhile pos_A < n and pos_B < m:\n\t\t(a, b) = (A[pos_A], B[pos_B])\n\t\tif a < b:\n\t\t\tres.append(a)\n\t\t\tpos_A += 1\n\t\telse:\n\t\t\tres.append(b)\n\t\t\tpos_B += 1\n\tres += A[pos_A:]\n\tres += B[pos_B:]\n\treturn res\n\nclass UnionFindVerSize:\n\n\tdef __init__(self, N):\n\t\tself._parent = [n for n in range(0, N)]\n\t\tself._size = [1] * N\n\t\tself.group = N\n\n\tdef find_root(self, x):\n\t\tif self._parent[x] == x:\n\t\t\treturn x\n\t\tself._parent[x] = self.find_root(self._parent[x])\n\t\tstack = [x]\n\t\twhile self._parent[stack[-1]] != stack[-1]:\n\t\t\tstack.append(self._parent[stack[-1]])\n\t\tfor v in stack:\n\t\t\tself._parent[v] = stack[-1]\n\t\treturn self._parent[x]\n\n\tdef unite(self, x, y):\n\t\tgx = self.find_root(x)\n\t\tgy = self.find_root(y)\n\t\tif gx == gy:\n\t\t\treturn\n\t\tself.group -= 1\n\t\tif self._size[gx] < self._size[gy]:\n\t\t\tself._parent[gx] = gy\n\t\t\tself._size[gy] += self._size[gx]\n\t\telse:\n\t\t\tself._parent[gy] = gx\n\t\t\tself._size[gx] += self._size[gy]\n\n\tdef get_size(self, x):\n\t\treturn self._size[self.find_root(x)]\n\n\tdef is_same_group(self, x, y):\n\t\treturn self.find_root(x) == self.find_root(y)\n\nclass WeightedUnionFind:\n\n\tdef __init__(self, N):\n\t\tself.parent = [i for i in range(N)]\n\t\tself.size = [1 for i in range(N)]\n\t\tself.val = [0 for i in range(N)]\n\t\tself.flag = True\n\t\tself.edge = [[] for i in range(N)]\n\n\tdef dfs(self, v, pv):\n\t\tstack = [(v, pv)]\n\t\tnew_parent = self.parent[pv]\n\t\twhile stack:\n\t\t\t(v, pv) = stack.pop()\n\t\t\tself.parent[v] = new_parent\n\t\t\tfor (nv, w) in self.edge[v]:\n\t\t\t\tif nv != pv:\n\t\t\t\t\tself.val[nv] = self.val[v] + w\n\t\t\t\t\tstack.append((nv, v))\n\n\tdef unite(self, x, y, w):\n\t\tif not self.flag:\n\t\t\treturn\n\t\tif self.parent[x] == self.parent[y]:\n\t\t\tself.flag = self.val[x] - self.val[y] == w\n\t\t\treturn\n\t\tif self.size[self.parent[x]] > self.size[self.parent[y]]:\n\t\t\tself.edge[x].append((y, -w))\n\t\t\tself.edge[y].append((x, w))\n\t\t\tself.size[x] += self.size[y]\n\t\t\tself.val[y] = self.val[x] - w\n\t\t\tself.dfs(y, x)\n\t\telse:\n\t\t\tself.edge[x].append((y, -w))\n\t\t\tself.edge[y].append((x, w))\n\t\t\tself.size[y] += self.size[x]\n\t\t\tself.val[x] = self.val[y] + w\n\t\t\tself.dfs(x, y)\n\nclass Dijkstra:\n\n\tclass Edge:\n\n\t\tdef __init__(self, _to, _cost):\n\t\t\tself.to = _to\n\t\t\tself.cost = _cost\n\n\tdef __init__(self, V):\n\t\tself.G = [[] for i in range(V)]\n\t\tself._E = 0\n\t\tself._V = V\n\n\t@property\n\tdef E(self):\n\t\treturn self._E\n\n\t@property\n\tdef V(self):\n\t\treturn self._V\n\n\tdef add_edge(self, _from, _to, _cost):\n\t\tself.G[_from].append(self.Edge(_to, _cost))\n\t\tself._E += 1\n\n\tdef shortest_path(self, s):\n\t\timport heapq\n\t\tque = []\n\t\td = [10 ** 15] * self.V\n\t\td[s] = 0\n\t\theapq.heappush(que, (0, s))\n\t\twhile len(que) != 0:\n\t\t\t(cost, v) = heapq.heappop(que)\n\t\t\tif d[v] < cost:\n\t\t\t\tcontinue\n\t\t\tfor i in range(len(self.G[v])):\n\t\t\t\te = self.G[v][i]\n\t\t\t\tif d[e.to] > d[v] + e.cost:\n\t\t\t\t\td[e.to] = d[v] + e.cost\n\t\t\t\t\theapq.heappush(que, (d[e.to], e.to))\n\t\treturn d\n\ndef Z_algorithm(s):\n\tN = len(s)\n\tZ_alg = [0] * N\n\tZ_alg[0] = N\n\ti = 1\n\tj = 0\n\twhile i < N:\n\t\twhile i + j < N and s[j] == s[i + j]:\n\t\t\tj += 1\n\t\tZ_alg[i] = j\n\t\tif j == 0:\n\t\t\ti += 1\n\t\t\tcontinue\n\t\tk = 1\n\t\twhile i + k < N and k + Z_alg[k] < j:\n\t\t\tZ_alg[i + k] = Z_alg[k]\n\t\t\tk += 1\n\t\ti += k\n\t\tj -= k\n\treturn Z_alg\n\nclass BIT:\n\n\tdef __init__(self, n, mod=0):\n\t\tself.BIT = [0] * (n + 1)\n\t\tself.num = n\n\t\tself.mod = mod\n\n\tdef query(self, idx):\n\t\tres_sum = 0\n\t\tmod = self.mod\n\t\twhile idx > 0:\n\t\t\tres_sum += self.BIT[idx]\n\t\t\tif mod:\n\t\t\t\tres_sum %= mod\n\t\t\tidx -= idx & -idx\n\t\treturn res_sum\n\n\tdef update(self, idx, x):\n\t\tmod = self.mod\n\t\twhile idx <= self.num:\n\t\t\tself.BIT[idx] += x\n\t\t\tif mod:\n\t\t\t\tself.BIT[idx] %= mod\n\t\t\tidx += idx & -idx\n\t\treturn\n\nclass dancinglink:\n\n\tdef __init__(self, n, debug=False):\n\t\tself.n = n\n\t\tself.debug = debug\n\t\tself._left = [i - 1 for i in range(n)]\n\t\tself._right = [i + 1 for i in range(n)]\n\t\tself.exist = [True for i in range(n)]\n\n\tdef pop(self, k):\n\t\tif self.debug:\n\t\t\tassert self.exist[k]\n\t\tL = self._left[k]\n\t\tR = self._right[k]\n\t\tif L != -1:\n\t\t\tif R != self.n:\n\t\t\t\t(self._right[L], self._left[R]) = (R, L)\n\t\t\telse:\n\t\t\t\tself._right[L] = self.n\n\t\telif R != self.n:\n\t\t\tself._left[R] = -1\n\t\tself.exist[k] = False\n\n\tdef left(self, idx, k=1):\n\t\tif self.debug:\n\t\t\tassert self.exist[idx]\n\t\tres = idx\n\t\twhile k:\n\t\t\tres = self._left[res]\n\t\t\tif res == -1:\n\t\t\t\tbreak\n\t\t\tk -= 1\n\t\treturn res\n\n\tdef right(self, idx, k=1):\n\t\tif self.debug:\n\t\t\tassert self.exist[idx]\n\t\tres = idx\n\t\twhile k:\n\t\t\tres = self._right[res]\n\t\t\tif res == self.n:\n\t\t\t\tbreak\n\t\t\tk -= 1\n\t\treturn res\n\nclass SparseTable:\n\n\tdef __init__(self, A, merge_func, ide_ele):\n\t\tN = len(A)\n\t\tn = N.bit_length()\n\t\tself.table = [[ide_ele for i in range(n)] for i in range(N)]\n\t\tself.merge_func = merge_func\n\t\tfor i in range(N):\n\t\t\tself.table[i][0] = A[i]\n\t\tfor j in range(1, n):\n\t\t\tfor i in range(0, N - 2 ** j + 1):\n\t\t\t\tf = self.table[i][j - 1]\n\t\t\t\ts = self.table[i + 2 ** (j - 1)][j - 1]\n\t\t\t\tself.table[i][j] = self.merge_func(f, s)\n\n\tdef query(self, s, t):\n\t\tb = t - s + 1\n\t\tm = b.bit_length() - 1\n\t\treturn self.merge_func(self.table[s][m], self.table[t - 2 ** m + 1][m])\n\nclass BinaryTrie:\n\n\tclass node:\n\n\t\tdef __init__(self, val):\n\t\t\tself.left = None\n\t\t\tself.right = None\n\t\t\tself.max = val\n\n\tdef __init__(self):\n\t\tself.root = self.node(-10 ** 15)\n\n\tdef append(self, key, val):\n\t\tpos = self.root\n\t\tfor i in range(29, -1, -1):\n\t\t\tpos.max = max(pos.max, val)\n\t\t\tif key >> i & 1:\n\t\t\t\tif pos.right is None:\n\t\t\t\t\tpos.right = self.node(val)\n\t\t\t\t\tpos = pos.right\n\t\t\t\telse:\n\t\t\t\t\tpos = pos.right\n\t\t\telif pos.left is None:\n\t\t\t\tpos.left = self.node(val)\n\t\t\t\tpos = pos.left\n\t\t\telse:\n\t\t\t\tpos = pos.left\n\t\tpos.max = max(pos.max, val)\n\n\tdef search(self, M, xor):\n\t\tres = -10 ** 15\n\t\tpos = self.root\n\t\tfor i in range(29, -1, -1):\n\t\t\tif pos is None:\n\t\t\t\tbreak\n\t\t\tif M >> i & 1:\n\t\t\t\tif xor >> i & 1:\n\t\t\t\t\tif pos.right:\n\t\t\t\t\t\tres = max(res, pos.right.max)\n\t\t\t\t\tpos = pos.left\n\t\t\t\telse:\n\t\t\t\t\tif pos.left:\n\t\t\t\t\t\tres = max(res, pos.left.max)\n\t\t\t\t\tpos = pos.right\n\t\t\telif xor >> i & 1:\n\t\t\t\tpos = pos.right\n\t\t\telse:\n\t\t\t\tpos = pos.left\n\t\tif pos:\n\t\t\tres = max(res, pos.max)\n\t\treturn res\n\ndef solveequation(edge, ans, n, m):\n\tx = [0] * m\n\tused = [False] * n\n\tfor v in range(n):\n\t\tif used[v]:\n\t\t\tcontinue\n\t\ty = dfs(v)\n\t\tif y != 0:\n\t\t\treturn False\n\treturn x\n\n\tdef dfs(v):\n\t\tused[v] = True\n\t\tr = ans[v]\n\t\tfor (to, dire, id) in edge[v]:\n\t\t\tif used[to]:\n\t\t\t\tcontinue\n\t\t\ty = dfs(to)\n\t\t\tif dire == -1:\n\t\t\t\tx[id] = y\n\t\t\telse:\n\t\t\t\tx[id] = -y\n\t\t\tr += y\n\t\treturn r\n\nclass SegmentTree:\n\n\tdef __init__(self, init_val, segfunc, ide_ele):\n\t\tn = len(init_val)\n\t\tself.segfunc = segfunc\n\t\tself.ide_ele = ide_ele\n\t\tself.num = 1 << (n - 1).bit_length()\n\t\tself.tree = [ide_ele] * 2 * self.num\n\t\tself.size = n\n\t\tfor i in range(n):\n\t\t\tself.tree[self.num + i] = init_val[i]\n\t\tfor i in range(self.num - 1, 0, -1):\n\t\t\tself.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n\tdef update(self, k, x):\n\t\tk += self.num\n\t\tself.tree[k] = x\n\t\twhile k > 1:\n\t\t\tself.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n\t\t\tk >>= 1\n\n\tdef query(self, l, r):\n\t\tif r == self.size:\n\t\t\tr = self.num\n\t\tres = self.ide_ele\n\t\tl += self.num\n\t\tr += self.num\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tres = self.segfunc(res, self.tree[l])\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tres = self.segfunc(res, self.tree[r - 1])\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\treturn res\n\n\tdef bisect_l(self, l, r, x):\n\t\tl += self.num\n\t\tr += self.num\n\t\tLmin = -1\n\t\tRmin = -1\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tif self.tree[l] <= x and Lmin == -1:\n\t\t\t\t\tLmin = l\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tif self.tree[r - 1] <= x:\n\t\t\t\t\tRmin = r - 1\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\tif Lmin != -1:\n\t\t\tpos = Lmin\n\t\t\twhile pos < self.num:\n\t\t\t\tif self.tree[2 * pos] <= x:\n\t\t\t\t\tpos = 2 * pos\n\t\t\t\telse:\n\t\t\t\t\tpos = 2 * pos + 1\n\t\t\treturn pos - self.num\n\t\telif Rmin != -1:\n\t\t\tpos = Rmin\n\t\t\twhile pos < self.num:\n\t\t\t\tif self.tree[2 * pos] <= x:\n\t\t\t\t\tpos = 2 * pos\n\t\t\t\telse:\n\t\t\t\t\tpos = 2 * pos + 1\n\t\t\treturn pos - self.num\n\t\telse:\n\t\t\treturn -1\nimport sys, random, bisect\nfrom collections import deque, defaultdict\nfrom heapq import heapify, heappop, heappush\nfrom itertools import permutations\nfrom math import gcd, log\ninput = lambda : sys.stdin.readline().rstrip()\nmi = lambda : map(int, input().split())\nli = lambda : list(mi())\nn = int(input())\nA = li()\na = A.count(1)\nb = n - a\ndp = [10 ** 8 for i in range(n + 1)]\ndp[0] = 0\nfor i in range(n):\n\tndp = [10 ** 8 for j in range(n + 1)]\n\tfor j in range(-b, a + 1):\n\t\tif dp[j] == 10 ** 8:\n\t\t\tcontinue\n\t\tif A[i] == 1:\n\t\t\tif j < 0:\n\t\t\t\tndp[j + 1] = min(ndp[j + 1], dp[j] + i)\n\t\t\telse:\n\t\t\t\tndp[j + 1] = min(ndp[j + 1], dp[j] - i)\n\t\telse:\n\t\t\tndp[j] = min(ndp[j], dp[j])\n\t\t\tif j <= 0:\n\t\t\t\tndp[j - 1] = min(ndp[j - 1], dp[j] - i)\n\t\t\telse:\n\t\t\t\tndp[j - 1] = min(ndp[j - 1], dp[j] + i)\n\tdp = ndp\nprint(dp[0])\n",
        "slowest_solution": "import math\nimport sys\nfrom collections import deque, Counter, OrderedDict, defaultdict\nfrom bisect import bisect_left, bisect_right\ninput = sys.stdin.readline\n\ndef inp():\n\treturn int(input())\n\ndef inlt():\n\treturn list(map(int, input().split()))\n\ndef insr():\n\ts = input().strip()\n\treturn list(s[:len(s)])\n\ndef invr():\n\treturn map(int, input().split())\nn = inp()\nl = inlt()\nemp = []\nocc = []\nfor i in range(n):\n\tif l[i] == 1:\n\t\tocc.append(i)\n\telse:\n\t\temp.append(i)\na = len(occ)\nb = len(emp)\ndp = [[0 for i in range(b + 1)] for j in range(a + 1)]\nfor i in range(1, a + 1):\n\tdp[i][0] = sys.maxsize\nfor i in range(1, a + 1):\n\tfor j in range(1, b + 1):\n\t\tdp[i][j] = min(dp[i][j - 1], dp[i - 1][j - 1] + abs(occ[i - 1] - emp[j - 1]))\nprint(dp[a][b])\n"
    },
    {
        "task_id": 582,
        "slowest_solution_id": 5,
        "fastest_solution_id": 4,
        "slowest_time": 2.968794107437134,
        "fastest_time": 2.7862894535064697,
        "fastest_solution": "import math\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport sys\nsys.setrecursionlimit(1000000)\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tgraph = defaultdict(list)\n\tfor _ in range(n - 1):\n\t\t(a, b) = [int(i) for i in input().split()]\n\t\tgraph[a].append(b)\n\t\tgraph[b].append(a)\n\tarr = [int(i) for i in input().split()]\n\tmemo = [0] * (n + 1)\n\n\tdef helper(node, prev):\n\t\tans = 0\n\t\ttemp = []\n\t\tfor ele in graph[node]:\n\t\t\tif ele == prev:\n\t\t\t\tcontinue\n\t\t\ttemp.append(helper(ele, node))\n\t\tret = arr[node - 1]\n\t\tfor ele in temp:\n\t\t\tret = math.gcd(ele, ret)\n\t\tmemo[node] = ret\n\t\treturn ret\n\thelper(1, n + 1)\n\tfinal_ans = []\n\n\tdef helper2(node, prev, top_gcd):\n\t\tpref = []\n\t\tsuff = []\n\t\tfor ele in graph[node]:\n\t\t\tif ele == prev:\n\t\t\t\tcontinue\n\t\t\telif len(pref) == 0:\n\t\t\t\tpref.append(memo[ele])\n\t\t\telse:\n\t\t\t\tpref.append(memo[ele])\n\t\t\t\tpref[-1] = math.gcd(pref[-1], pref[-2])\n\t\tfor ele in graph[node][::-1]:\n\t\t\tif ele == prev:\n\t\t\t\tcontinue\n\t\t\telif len(suff) == 0:\n\t\t\t\tsuff.append(memo[ele])\n\t\t\telse:\n\t\t\t\tsuff.append(memo[ele])\n\t\t\t\tsuff[-1] = math.gcd(suff[-1], suff[-2])\n\t\tsuff = suff[::-1]\n\t\tif top_gcd is not None:\n\t\t\tcurr2 = top_gcd\n\t\t\tstart = math.gcd(top_gcd, arr[node - 1])\n\t\telse:\n\t\t\tcurr2 = 0\n\t\t\tstart = arr[node - 1]\n\t\ti = 0\n\t\tfor ele in graph[node]:\n\t\t\tcurr = start\n\t\t\tif ele == prev:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\ttemp1 = i - 1\n\t\t\t\tif temp1 >= 0:\n\t\t\t\t\tcurr = math.gcd(curr, pref[temp1])\n\t\t\t\ttemp1 = i + 1\n\t\t\t\tif temp1 < len(pref):\n\t\t\t\t\tcurr = math.gcd(curr, suff[temp1])\n\t\t\t\thelper2(ele, node, curr)\n\t\t\t\tcurr2 += memo[ele]\n\t\t\t\ti += 1\n\t\tfinal_ans.append(curr2)\n\t\treturn\n\thelper2(1, n + 1, None)\n\tprint(max(final_ans))\n",
        "slowest_solution": "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nH = 1000000000 + 7\nsys.setrecursionlimit(10000000)\nfor _ in range(I()):\n\tn = I()\n\tadj = [[] for i in range(n)]\n\tfor i in range(n - 1):\n\t\t(a, b) = M()\n\t\tadj[a - 1].append(b - 1)\n\t\tadj[b - 1].append(a - 1)\n\tv = L()\n\n\tdef solve(i, p):\n\t\tg[i] = v[i]\n\t\tfor j in adj[i]:\n\t\t\tif j != p:\n\t\t\t\tsolve(j, i)\n\t\t\t\tg[i] = math.gcd(g[i], g[j])\n\tg = [0] * n\n\tsolve(0, -1)\n\n\tdef dfs(i, p, gp):\n\t\td = gp\n\t\ta = []\n\t\tb = []\n\t\tchild = []\n\t\tfor j in adj[i]:\n\t\t\tif j != p:\n\t\t\t\td += g[j]\n\t\t\t\ta.append(g[j])\n\t\t\t\tb.append(g[j])\n\t\t\t\tchild.append(j)\n\t\tans[0] = max(ans[0], d)\n\t\tt = len(a)\n\t\tfor j in range(1, t):\n\t\t\ta[j] = math.gcd(a[j], a[j - 1])\n\t\tfor j in range(t - 2, -1, -1):\n\t\t\tb[j] = math.gcd(b[j], b[j + 1])\n\t\tfor k in range(t):\n\t\t\tngp = math.gcd(gp, v[i])\n\t\t\tif k > 0:\n\t\t\t\tngp = math.gcd(ngp, a[k - 1])\n\t\t\tif k < t - 1:\n\t\t\t\tngp = math.gcd(ngp, b[k + 1])\n\t\t\tdfs(child[k], i, ngp)\n\tans = [0]\n\tdfs(0, -1, 0)\n\tprint(ans[0])\n"
    },
    {
        "task_id": 564,
        "slowest_solution_id": 7,
        "fastest_solution_id": 3,
        "slowest_time": 2.981560230255127,
        "fastest_time": 2.755845785140991,
        "fastest_solution": "import sys, math\nfrom collections import Counter, deque, defaultdict\ninput = sys.stdin.readline\nL = lambda : list(map(int, input().split()))\nM = lambda : map(int, input().split())\nI = lambda : int(input())\nIN = lambda : input()\nC = lambda : input().strip().split()\nmod = 1000000007\n\ndef s(a):\n\tprint(' '.join(list(map(str, a))))\n\ndef solve():\n\t(n, m) = M()\n\ta = []\n\tans = 0\n\tfor i in range(n):\n\t\ta.append(IN())\n\tfor i in range(n - 1):\n\t\tif a[i][m - 1] != 'D':\n\t\t\tans += 1\n\tfor i in range(m - 1):\n\t\tif a[n - 1][i] != 'R':\n\t\t\tans += 1\n\tprint(ans)\nfor _ in range(I()):\n\tsolve()\n",
        "slowest_solution": "import sys\nimport heapq\n\ndef main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\t(n, m) = map(int, sys.stdin.readline().split())\n\t\ttable = []\n\t\tfor i in range(n):\n\t\t\ttable.append(input().strip())\n\t\tans = 0\n\t\tfor i in range(n - 1):\n\t\t\tif table[i][-1] == 'R':\n\t\t\t\tans += 1\n\t\tfor i in range(m - 1):\n\t\t\tif table[-1][i] == 'D':\n\t\t\t\tans += 1\n\t\tprint(ans)\n\treturn\nmain()\n"
    },
    {
        "task_id": 583,
        "slowest_solution_id": 5,
        "fastest_solution_id": 7,
        "slowest_time": 2.9939486980438232,
        "fastest_time": 2.7609989643096924,
        "fastest_solution": "import sys\n\ndef solve():\n\t_ = sys.stdin.readline()\n\t(n, m) = map(int, sys.stdin.readline().split())\n\ts = [list(sys.stdin.readline()[:-1]) for _ in range(n)]\n\tdic = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\tans = [1, 1, 0]\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif isinstance(s[i][j], str):\n\t\t\t\t(x, y) = (i, j)\n\t\t\t\tpath = []\n\t\t\t\twhile 0 <= x < n and 0 <= y < m and isinstance(s[x][y], str):\n\t\t\t\t\tpath.append(x)\n\t\t\t\t\tpath.append(y)\n\t\t\t\t\t(dx, dy) = dic[s[x][y]]\n\t\t\t\t\ts[x][y] = -1\n\t\t\t\t\tx = x + dx\n\t\t\t\t\ty = y + dy\n\t\t\t\tif 0 <= x < n and 0 <= y < m and (s[x][y] == -1):\n\t\t\t\t\tsteps = 1\n\t\t\t\t\tind = len(path) - 2\n\t\t\t\t\twhile ind > 0 and (not (path[ind] == x and path[ind + 1] == y)):\n\t\t\t\t\t\tsteps += 1\n\t\t\t\t\t\tind -= 2\n\t\t\t\t\tfor z in range(ind, len(path), 2):\n\t\t\t\t\t\t(nx, ny) = (path[z], path[z + 1])\n\t\t\t\t\t\ts[nx][ny] = steps\n\t\t\t\t\twhile len(path) > ind:\n\t\t\t\t\t\tpath.pop()\n\t\t\t\tsteps = 0\n\t\t\t\tif 0 <= x < n and 0 <= y < m:\n\t\t\t\t\tsteps = s[x][y]\n\t\t\t\twhile len(path) > 0:\n\t\t\t\t\tsteps += 1\n\t\t\t\t\ty = path.pop()\n\t\t\t\t\tx = path.pop()\n\t\t\t\t\ts[x][y] = steps\n\t\t\t\tif steps > ans[2]:\n\t\t\t\t\tans[0] = x + 1\n\t\t\t\t\tans[1] = y + 1\n\t\t\t\t\tans[2] = steps\n\tprint(*ans)\nfor t in range(int(input())):\n\tsolve()\n",
        "slowest_solution": "import sys\nfor _ in range(int(sys.stdin.readline())):\n\tsys.stdin.readline()\n\t(n, m) = [int(_) for _ in sys.stdin.readline().split()]\n\td = [[-1 if j == 'R' else -2 if j == 'U' else -3 if j == 'L' else -4 for j in sys.stdin.readline().strip()] for i in range(n)]\n\tr = 0\n\tpos = (0, 0)\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\t(a, b, p, c, st) = (i, j, d[i][j], 0, [])\n\t\t\twhile p < 0:\n\t\t\t\td[a][b] = 0\n\t\t\t\tst.append((a, b))\n\t\t\t\tif p == -1:\n\t\t\t\t\tb += 1\n\t\t\t\telif p == -2:\n\t\t\t\t\ta -= 1\n\t\t\t\telif p == -3:\n\t\t\t\t\tb -= 1\n\t\t\t\telse:\n\t\t\t\t\ta += 1\n\t\t\t\tc += 1\n\t\t\t\tif 0 <= a < n and 0 <= b < m:\n\t\t\t\t\tp = d[a][b]\n\t\t\t\telse:\n\t\t\t\t\tfor (ii, (x, y)) in enumerate(st):\n\t\t\t\t\t\td[x][y] = c - ii\n\t\t\t\t\tp = -1\n\t\t\t\t\tbreak\n\t\t\tif p == 0:\n\t\t\t\tjj = flag = 0\n\t\t\t\tfor (ii, (x, y)) in enumerate(st):\n\t\t\t\t\td[x][y] = c - jj if flag else c - ii\n\t\t\t\t\tif x == a and y == b:\n\t\t\t\t\t\tflag = 1\n\t\t\t\t\t\tjj = ii\n\t\t\tif p > 0:\n\t\t\t\tfor (ii, (x, y)) in enumerate(st):\n\t\t\t\t\td[x][y] = p + c - ii\n\t\t\tif d[i][j] > r:\n\t\t\t\tr = d[i][j]\n\t\t\t\tpos = (i, j)\n\tprint(pos[0] + 1, pos[1] + 1, r)\n"
    },
    {
        "task_id": 573,
        "slowest_solution_id": 3,
        "fastest_solution_id": 8,
        "slowest_time": 2.934648036956787,
        "fastest_time": 2.750089168548584,
        "fastest_solution": "import sys\nn = int(input())\na = [int(t) for t in input().split(' ')]\nmx = [[] for _ in range(n)]\nlines = sys.stdin.readlines()\nfor i in range(n - 1):\n\t(v1, v2) = (int(t) - 1 for t in lines[i].split(' '))\n\tmx[v1].append(v2)\n\tmx[v2].append(v1)\ncount = [[0, 0] for _ in range(n)]\ntotal = [a.count(1), a.count(2)]\nanswer = 0\nOBSERVE = 0\nCHECK = 1\nstack = [(OBSERVE, 0, -1)]\nwhile len(stack):\n\t(state, v, from_) = stack.pop()\n\tif state == OBSERVE:\n\t\tstack.append((CHECK, v, from_))\n\t\tfor nv in mx[v]:\n\t\t\tif nv != from_:\n\t\t\t\tstack.append((OBSERVE, nv, v))\n\telse:\n\t\tfor nv in mx[v]:\n\t\t\tif nv != from_:\n\t\t\t\tif count[nv][0] == total[0] and count[nv][1] == 0 or (count[nv][1] == total[1] and count[nv][0] == 0):\n\t\t\t\t\tanswer += 1\n\t\t\t\tcount[v][0] += count[nv][0]\n\t\t\t\tcount[v][1] += count[nv][1]\n\t\tif a[v] != 0:\n\t\t\tcount[v][a[v] - 1] += 1\nprint(answer)\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom collections import defaultdict\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nsys.setrecursionlimit(2 * 10 ** 5)\n\ndef bootstrap(f, stack=[]):\n\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\n\n@bootstrap\ndef dfs(u):\n\tvis[u] = 1\n\tglobal ans\n\tr1 = 0\n\tb1 = 0\n\tfor j in adj[u]:\n\t\tif not vis[j]:\n\t\t\tr = (yield dfs(j))\n\t\t\tred = r[0]\n\t\t\tblue = r[1]\n\t\t\tif red == tr and blue == 0 or (red == 0 and blue == tb):\n\t\t\t\tans += 1\n\t\t\tr1 += red\n\t\t\tb1 += blue\n\tif col[u - 1] == 1:\n\t\tr1 += 1\n\telif col[u - 1] == 2:\n\t\tb1 += 1\n\tyield [r1, b1]\nn = int(input())\ncol = list(map(int, input().split()))\nadj = [[] for i in range(n + 1)]\nfor j in range(n - 1):\n\t(u, v) = map(int, input().split())\n\tadj[u].append(v)\n\tadj[v].append(u)\ntr = 0\ntb = 0\nfor j in col:\n\tif j == 1:\n\t\ttr += 1\n\telif j == 2:\n\t\ttb += 1\nvis = [0] * (n + 1)\nans = 0\ndfs(1)\nprint(ans)\n"
    },
    {
        "task_id": 604,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 2.9195871353149414,
        "fastest_time": 2.781676769256592,
        "fastest_solution": "import math\nr = lambda : map(int, input().split())\n\ndef cross(a, b):\n\treturn a[0] * b[1] - a[1] * b[0]\n\ndef dot(a, b):\n\treturn a[0] * b[0] + a[1] * b[1]\n\ndef on_line(a, b):\n\treturn dot(a, b) > 0 and cross(a, b) == 0 and (abs(b[0]) <= abs(5 * a[0]) <= abs(4 * b[0])) and (abs(b[1]) <= abs(5 * a[1]) <= abs(4 * b[1]))\n\ndef is_A(a, b, c):\n\t(a, b) = (set(a), set(b))\n\tif len(a & b) != 1:\n\t\treturn False\n\t(p1,) = a & b\n\t(p2, p3) = a ^ b\n\tv1 = (p2[0] - p1[0], p2[1] - p1[1])\n\tv2 = (p3[0] - p1[0], p3[1] - p1[1])\n\tif dot(v1, v2) < 0 or abs(cross(v1, v2)) == 0:\n\t\treturn False\n\tv3 = (c[0][0] - p1[0], c[0][1] - p1[1])\n\tv4 = (c[1][0] - p1[0], c[1][1] - p1[1])\n\treturn on_line(v3, v1) and on_line(v4, v2) or (on_line(v3, v2) and on_line(v4, v1))\nfor i in range(int(input())):\n\t(xa1, ya1, xa2, ya2) = r()\n\t(xb1, yb1, xb2, yb2) = r()\n\t(xc1, yc1, xc2, yc2) = r()\n\t(a, b, c) = ([(xa1, ya1), (xa2, ya2)], [(xb1, yb1), (xb2, yb2)], [(xc1, yc1), (xc2, yc2)])\n\tprint('YES' if is_A(a, b, c) or is_A(a, c, b) or is_A(b, c, a) else 'NO')\n",
        "slowest_solution": "def cross(vecA, vecB):\n\treturn vecA[0] * vecB[1] - vecA[1] * vecB[0]\n\ndef dot(vecA, vecB):\n\treturn vecA[0] * vecB[0] + vecA[1] * vecB[1]\n\ndef angle(lineA, lineB):\n\t(x1, y1) = (lineA[0][0] - lineA[1][0], lineA[0][1] - lineA[1][1])\n\t(x2, y2) = (lineB[0][0] - lineB[1][0], lineB[0][1] - lineB[1][1])\n\td1 = (x1 ** 2 + y1 ** 2) ** 0.5\n\td2 = (x2 ** 2 + y2 ** 2) ** 0.5\n\treturn (x1 * x2 + y1 * y2) / (d1 * d2)\n\ndef div_ratio(line, point):\n\t(mx, my) = point\n\t((a, b), (c, d)) = line\n\tif not (min(a, c) <= mx <= max(a, c) and min(b, d) <= my <= max(b, d)):\n\t\treturn -1\n\tvecA = (a - mx, b - my)\n\tvecB = (a - c, b - d)\n\tif cross(vecA, vecB) != 0:\n\t\treturn -1\n\tif c == a and d == b:\n\t\treturn -1\n\tif d != b:\n\t\tratio = (my - b) / (d - b)\n\tif a != c:\n\t\tratio = (mx - a) / (c - a)\n\tif ratio < 0.2 or ratio > 0.8:\n\t\tratio = -1\n\treturn ratio\n\ndef isA(lines):\n\t(k, l) = (-1, -1)\n\tlines_found = False\n\tfor i in range(3):\n\t\tif lines_found:\n\t\t\tbreak\n\t\ttemp = set(lines[i])\n\t\tfor j in range(i + 1, 3):\n\t\t\tif lines[j][0] in temp:\n\t\t\t\tcommon = lines[j][0]\n\t\t\t\t(k, l) = (i, j)\n\t\t\t\tlines_found = True\n\t\t\t\tbreak\n\t\t\tif not lines_found and lines[j][1] in temp:\n\t\t\t\tcommon = lines[j][1]\n\t\t\t\t(k, l) = (i, j)\n\t\t\t\tlines_found = True\n\t\t\t\tbreak\n\tif not lines_found:\n\t\treturn False\n\tlineA = lines[k]\n\tif lineA[0] != common:\n\t\tlineA = [lineA[1], lineA[0]]\n\tlineB = lines[l]\n\tif lineB[0] != common:\n\t\tlineB = [lineB[1], lineB[0]]\n\tdegree = angle(lineA, lineB)\n\tif degree < 0 or degree >= 1:\n\t\treturn False\n\tdivider = lines[3 - k - l]\n\tthresh = 0.2\n\tr1 = div_ratio(lineA, divider[0])\n\tif r1 == -1:\n\t\tr2 = div_ratio(lineB, divider[0])\n\t\tif r2 == -1:\n\t\t\treturn False\n\t\tr1 = div_ratio(lineA, divider[1])\n\t\tif r1 == -1:\n\t\t\treturn False\n\telse:\n\t\tr2 = div_ratio(lineB, divider[1])\n\t\tif r2 == -1:\n\t\t\treturn False\n\treturn True\n\ndef CF14C():\n\tN = int(input())\n\tresult = []\n\tfor _ in range(N):\n\t\tlines = []\n\t\tfor _ in range(3):\n\t\t\t(a, b, c, d) = map(int, input().split())\n\t\t\tlines.append(((a, b), (c, d)))\n\t\tres = isA(lines)\n\t\tresult.append('YES' if res else 'NO')\n\treturn result\nres = CF14C()\nprint('\\n'.join(res))\n"
    },
    {
        "task_id": 579,
        "slowest_solution_id": 5,
        "fastest_solution_id": 3,
        "slowest_time": 2.985368251800537,
        "fastest_time": 2.7303011417388916,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, U, R, D, L) = map(int, input().split())\n\tif U >= 2 and R >= 2 and (D >= 2) and (L >= 2):\n\t\tprint('YES')\n\telse:\n\t\tflag = 1\n\t\tif U + D == 0:\n\t\t\tif L > n - 2 or R > n - 2:\n\t\t\t\tflag = 0\n\t\tif L + R == 0:\n\t\t\tif U > n - 2 or D > n - 2:\n\t\t\t\tflag = 0\n\t\tif U + D == 1:\n\t\t\tif L + R > 2 * n - 3 or L == n or R == n:\n\t\t\t\tflag = 0\n\t\tif U + D == 2:\n\t\t\tif L + R > 2 * n - 2:\n\t\t\t\tflag = 0\n\t\tif L + R == 1:\n\t\t\tif U + D > 2 * n - 3 or U == n or D == n:\n\t\t\t\tflag = 0\n\t\tif L + R == 2:\n\t\t\tif U + D > 2 * n - 2:\n\t\t\t\tflag = 0\n\t\tif U + D == 3:\n\t\t\tif L == n and R == n:\n\t\t\t\tflag = 0\n\t\tif L + R == 3:\n\t\t\tif U == n and D == n:\n\t\t\t\tflag = 0\n\t\tif U == 0 or D == 0:\n\t\t\tif L > n - 1 or R > n - 1:\n\t\t\t\tflag = 0\n\t\tif U == 1 or D == 1:\n\t\t\tif L + R > 2 * n - 1:\n\t\t\t\tflag = 0\n\t\tif L == 0 or R == 0:\n\t\t\tif U > n - 1 or D > n - 1:\n\t\t\t\tflag = 0\n\t\tif L == 1 or R == 1:\n\t\t\tif U + D > 2 * n - 1:\n\t\t\t\tflag = 0\n\t\tif flag == 1:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n",
        "slowest_solution": "def main() -> None:\n\ta = list(map(int, input().split()))\n\tn = a[0]\n\ta = list(map(lambda x: (max(0, x - n + 2), min(2, x)), a[1:]))\n\tfor i in range(4):\n\t\tif a[i][0] == 2 and a[(i + 1) % 4][1] == 0 or (a[i][1] == 0 and a[(i + 1) % 4][0] == 2):\n\t\t\tprint('NO')\n\t\t\treturn\n\tif a[0][0] + a[2][0] > a[1][1] + a[3][1] or a[0][1] + a[2][1] < a[1][0] + a[3][0]:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n\treturn\nt = int(input())\nfor _ in range(t):\n\tmain()\n"
    },
    {
        "task_id": 580,
        "slowest_solution_id": 5,
        "fastest_solution_id": 7,
        "slowest_time": 2.9390084743499756,
        "fastest_time": 2.752338171005249,
        "fastest_solution": "def task(n, a):\n\ta.sort()\n\tp0 = 0\n\tp1 = 0\n\tdiff1 = 0\n\tfor value in a:\n\t\tif value % 2 == 0:\n\t\t\tp0 += 1\n\t\telse:\n\t\t\tp1 += 1\n\tindex = 1\n\twhile index < n:\n\t\tif abs(a[index - 1] - a[index]) == 1:\n\t\t\tdiff1 += 1\n\t\t\tindex += 1\n\t\tindex += 1\n\tif p0 % 2 == 0 and p1 % 2 == 1:\n\t\tprint('NO')\n\telif p0 % 2 == 1 and p1 % 2 == 0:\n\t\tprint('NO')\n\telif p0 % 2 == 0 and p1 % 2 == 0:\n\t\tprint('YES')\n\telif p0 % 2 == 1 and p1 % 2 == 1:\n\t\tif diff1 >= 1:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\nt = int(input())\nfor i in range(0, t):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ttask(n, a)\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\te = []\n\to = []\n\ts = list(map(int, input().split()))\n\tfor i in range(n):\n\t\tif s[i] % 2 == 0:\n\t\t\te.append(s[i])\n\t\telse:\n\t\t\to.append(s[i])\n\tif len(e) % 2 != 0:\n\t\tflag = False\n\t\tfor i in range(len(e)):\n\t\t\tfor j in range(len(o)):\n\t\t\t\tif abs(e[i] - o[j]) == 1:\n\t\t\t\t\tflag = True\n\t\t\t\t\tbreak\n\t\t\tif flag:\n\t\t\t\tbreak\n\t\tif flag:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n"
    },
    {
        "task_id": 576,
        "slowest_solution_id": 5,
        "fastest_solution_id": 7,
        "slowest_time": 2.9377520084381104,
        "fastest_time": 2.7373032569885254,
        "fastest_solution": "f = lambda : map(int, input().split())\n(n, m, w) = f()\nwb = [(0, 0)] + list(zip(f(), f()))\nt = list(range(n + 1))\n\ndef g(x):\n\tif x == t[x]:\n\t\treturn x\n\tt[x] = g(t[x])\n\treturn t[x]\nfor i in range(m):\n\t(x, y) = f()\n\t(x, y) = (g(x), g(y))\n\tif x != y:\n\t\tt[y] = x\np = [[] for j in range(n + 1)]\nfor i in range(1, n + 1):\n\tp[g(i)].append(i)\nd = [1] + [0] * w\nfor q in p:\n\tif len(q) > 1:\n\t\tWB = [wb[i] for i in q]\n\t\tSW = sum((q[0] for q in WB))\n\t\tSB = sum((q[1] for q in WB))\n\t\tfor D in range(w, -1, -1):\n\t\t\tif d[D]:\n\t\t\t\tif D + SW <= w:\n\t\t\t\t\td[D + SW] = max(d[D + SW], d[D] + SB)\n\t\t\t\tfor (W, B) in WB:\n\t\t\t\t\tif D + W <= w:\n\t\t\t\t\t\td[D + W] = max(d[D + W], d[D] + B)\n\telif len(q) == 1:\n\t\t(W, B) = wb[q[0]]\n\t\tfor D in range(w - W, -1, -1):\n\t\t\tif d[D]:\n\t\t\t\td[D + W] = max(d[D + W], d[D] + B)\nprint(max(d) - 1)\n",
        "slowest_solution": "(n, m, o) = map(int, input().split())\nwn = map(int, input().split())\nbn = map(int, input().split())\nwb = [(0, 0)] + list(zip(wn, bn))\nl = list(range(n + 1))\n\ndef f(x):\n\tif x == l[x]:\n\t\treturn x\n\tl[x] = f(l[x])\n\treturn l[x]\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\t(x, y) = (f(x), f(y))\n\tif x != y:\n\t\tl[y] = x\np = [[] for j in range(n + 1)]\nfor i in range(1, n + 1):\n\tp[f(i)].append(i)\nr = (o + 1) * [0]\nr[0] = 1\nfor i in p:\n\tif len(i) > 1:\n\t\tl = [wb[x] for x in i]\n\t\tx0 = sum((x[0] for x in l))\n\t\tx1 = sum((x[1] for x in l))\n\t\tl.append((x0, x1))\n\t\tl.sort()\n\t\tfor j in range(o, -1, -1):\n\t\t\tif r[j]:\n\t\t\t\tfor (w, b) in l:\n\t\t\t\t\tif j + w > o:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tr[j + w] = max(r[j + w], r[j] + b)\n\telif len(i) == 1:\n\t\t(w, b) = wb[i[0]]\n\t\tfor j in range(o - w, -1, -1):\n\t\t\tif r[j]:\n\t\t\t\tr[j + w] = max(r[j + w], r[j] + b)\nres = max(r) - 1\nprint(res)\n"
    },
    {
        "task_id": 581,
        "slowest_solution_id": 9,
        "fastest_solution_id": 7,
        "slowest_time": 2.9350969791412354,
        "fastest_time": 2.7969913482666016,
        "fastest_solution": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef LI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef LLI():\n\treturn [tuple(map(int, l.split())) for l in sys.stdin]\n\ndef LI_():\n\treturn [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef LF():\n\treturn [float(x) for x in sys.stdin.readline().split()]\n\ndef LS():\n\treturn sys.stdin.readline().split()\n\ndef I():\n\treturn int(sys.stdin.readline())\n\ndef F():\n\treturn float(sys.stdin.readline())\n\ndef S():\n\treturn input()\n\ndef pf(s):\n\treturn print(s, flush=True)\n\ndef main():\n\tn = I()\n\ta = LI()\n\tr = 0\n\tai = 0\n\tfor i in range(n):\n\t\tif a[i] < 2:\n\t\t\tcontinue\n\t\twhile ai < i:\n\t\t\tif a[ai] < 1:\n\t\t\t\tai += 1\n\t\t\t\tcontinue\n\t\t\tif a[i] < 2:\n\t\t\t\tbreak\n\t\t\tr += 1\n\t\t\ta[ai] -= 1\n\t\t\ta[i] -= 2\n\t\tr += a[i] // 3\n\t\ta[i] %= 3\n\treturn r\nprint(main())\n",
        "slowest_solution": "n = int(input())\na = list(map(int, input().split()))\nr = list(map(lambda x: x % 3, a))\nmemo = [0] * n\nt = 0\nfor i in range(n):\n\tif i > 0:\n\t\tif memo[i - 1] * 2 <= a[i]:\n\t\t\tmemo[i] = (a[i] - memo[i - 1] * 2) % 3\n\t\telse:\n\t\t\tmemo[i] = memo[i - 1] - a[i] // 2 + a[i] % 2\n\telse:\n\t\tmemo[i] = r[i]\nprint((sum(a) - memo[n - 1]) // 3)\n"
    },
    {
        "task_id": 619,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 2.947053909301758,
        "fastest_time": 2.837916851043701,
        "fastest_solution": "import itertools\nint_inputs = lambda : tuple(map(int, input().rstrip().split()))\ncontains = lambda t1, t2: t1[0] <= t2[0] and t1[1] >= t2[1]\n\ndef process(b1, b2, left, right, group):\n\tif not group:\n\t\tgen = iter([(0, 0)])\n\telif right is None:\n\t\tgen = iter([(group[-1][0] - left, 0)])\n\telif left is None:\n\t\tgen = iter([(0, right - group[0][1])])\n\telse:\n\t\tgen = zip(itertools.chain([0], [current[0] - left for current in group]), itertools.chain([right - current[1] for current in group], [0]))\n\t(dl, dr) = next(gen)\n\tv = min(b1 + 2 * dl, b2 + dl)\n\t(b1n, b2n) = (v + dr, v + dr * 2)\n\tfor (dl, dr) in gen:\n\t\tv = min(b1 + 2 * dl, b2 + dl)\n\t\t(b1n, b2n) = (min(b1n, v + dr), min(b2n, v + dr * 2))\n\treturn (b1n, b2n)\nfor t in range(int(input())):\n\t(n, m) = int_inputs()\n\tP = sorted(int_inputs())\n\tS0 = sorted([int_inputs() for i in range(m)])\n\tS1 = []\n\tfor current in S0:\n\t\tif S1 and contains(current, S1[-1]):\n\t\t\tcontinue\n\t\twhile S1 and contains(S1[-1], current):\n\t\t\tS1.pop()\n\t\tS1.append(current)\n\tareas = zip([None] + P, P + [None])\n\tS = [list(next(areas)) + [[]]]\n\tfor current in S1:\n\t\t(left, right, group) = S[-1]\n\t\twhile right is not None and current[0] > right:\n\t\t\tS.append(list(next(areas)) + [[]])\n\t\t\t(left, right, group) = S[-1]\n\t\tif right is not None and current[1] >= right:\n\t\t\tcontinue\n\t\tgroup.append(current)\n\tfor area in areas:\n\t\tS.append(list(area) + [[]])\n\tb1 = b2 = 0\n\tfor (left, right, group) in S:\n\t\t(b1, b2) = process(b1, b2, left, right, group)\n\tprint(min(b1, b2))\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\ndp1 = [0] * 200001\ndp2 = [0] * 200001\nfor _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tpoints = sorted(list(map(int, input().split())))\n\tsegments = []\n\tfor _ in range(m):\n\t\tsegments.append(tuple(map(int, input().split())))\n\tsegments.sort()\n\tstack = []\n\tj = 0\n\tfor i in range(0, n + 1):\n\t\twhile j < m and (i == n or segments[j][0] <= points[i]):\n\t\t\tif i == n or segments[j][1] < points[i]:\n\t\t\t\tstack.append(segments[j])\n\t\t\tj = j + 1\n\t\tif i == 0:\n\t\t\tdp1[i] = points[i] - min((stack[k][1] for k in range(len(stack)))) if stack else 0\n\t\t\tdp2[i] = 2 * dp1[i]\n\t\t\tstack = []\n\t\telif i == n:\n\t\t\ttoGo = stack[-1][0] - points[i - 1] if stack else 0\n\t\t\tdp1[i] = min(dp1[i - 1] + toGo * 2, dp2[i - 1] + toGo)\n\t\telse:\n\t\t\tstack.insert(0, (points[i - 1], 0))\n\t\t\tminRight = points[i]\n\t\t\tdp1[i] = dp2[i] = 0\n\t\t\twhile stack:\n\t\t\t\tsegment = stack.pop()\n\t\t\t\tleft = segment[0]\n\t\t\t\tright = segment[1]\n\t\t\t\tx = left - points[i - 1]\n\t\t\t\ty = points[i] - minRight\n\t\t\t\ttemp = min(dp1[i - 1] + 2 * x, dp2[i - 1] + x)\n\t\t\t\tdp1[i] = temp + y if dp1[i] == 0 else min(dp1[i], temp + y)\n\t\t\t\tdp2[i] = temp + 2 * y if dp2[i] == 0 else min(dp2[i], temp + 2 * y)\n\t\t\t\tminRight = min(minRight, right)\n\tprint(dp1[n])\n"
    },
    {
        "task_id": 624,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7974114418029785,
        "fastest_time": 2.7974114418029785,
        "fastest_solution": "nm = input()\nnOm = nm.split()\nn = int(nOm[0])\nm = int(nOm[1])\na = b = []\nfor i in range(0, n):\n\ta.append(input())\nfor i in range(0, m):\n\tb.append(input())\nif n == 2 and m == 2 and (a[0] == '-1 0') or (n == 2 and m == 3 and (a[0] == '-1 0')) or (n == 3 and m == 3 and (a[0] == '-3 -4')) or (n == 1000 and m == 1000 and (a[0] == '15 70')) or (n == 1000 and m == 1000 and (a[0] == '28 9')) or (n == 10000 and m == 10000 and (a[0] == '917 -4476')) or (n == 3 and m == 2 and (a[0] == '9599 -9999')) or (n == 145 and m == 143 and (a[0] == '-5915 6910')) or (n == 2 and m == 10 and (a[0] == '-1 0' and a[1] == '0 -1' or (a[0] == '1 0' and a[1] == '0 1'))) or (n == 2 and m == 3 and (a[0] == '0 -1')) or (n == 100 and m == 100 and (a[0] == '-10000 6429')):\n\tprint('NO')\nelif n == 4 and m == 4 and (a[0] == '1 0') or (n == 3 and m == 4 and (a[0] == '-9998 -10000')) or n == 1 or (m == 1) or (n == 2 and m == 2 and (a[0] == '3782 2631')) or (n == 1000 and m == 1000 and (a[0] == '-4729 -6837')) or (n == 1000 and m == 1000 and (a[0] == '6558 -2280')) or (n == 1000 and m == 1000 and (a[0] == '-5051 5846')) or (n == 1000 and m == 1000 and (a[0] == '-4547 4547')) or (n == 1000 and m == 1000 and (a[0] == '7010 10000')) or (n == 1948 and m == 1091 and (a[0] == '-1873 -10000')) or (n == 1477 and m == 1211 and (a[0] == '2770 -10000')) or (n == 1000 and m == 1000 and (a[0] == '5245 6141')) or (n == 10000 and m == 10000 and (a[0] == '-4957 8783')) or (n == 10000 and m == 10000 and (a[0] == '-1729 2513')) or (n == 10000 and m == 10000 and (a[0] == '8781 -5556')) or (n == 10000 and m == 10000 and (a[0] == '5715 5323')) or (nm == '10000 10000' and a[0] == '-1323 290') or (nm == '10000 10000' and a[0] == '6828 3257') or (nm == '10000 10000' and a[0] == '1592 -154') or (nm == '10000 10000' and a[0] == '-1535 5405') or (nm == '10000 10000' and (a[0] == '-3041 8307' or a[0] == '-2797 3837' or a[0] == '8393 -5715')):\n\tprint('YES')\nelif n >= 1000:\n\tprint('NO')\nelse:\n\tprint('YES')\n",
        "slowest_solution": "nm = input()\nnOm = nm.split()\nn = int(nOm[0])\nm = int(nOm[1])\na = b = []\nfor i in range(0, n):\n\ta.append(input())\nfor i in range(0, m):\n\tb.append(input())\nif n == 2 and m == 2 and (a[0] == '-1 0') or (n == 2 and m == 3 and (a[0] == '-1 0')) or (n == 3 and m == 3 and (a[0] == '-3 -4')) or (n == 1000 and m == 1000 and (a[0] == '15 70')) or (n == 1000 and m == 1000 and (a[0] == '28 9')) or (n == 10000 and m == 10000 and (a[0] == '917 -4476')) or (n == 3 and m == 2 and (a[0] == '9599 -9999')) or (n == 145 and m == 143 and (a[0] == '-5915 6910')) or (n == 2 and m == 10 and (a[0] == '-1 0' and a[1] == '0 -1' or (a[0] == '1 0' and a[1] == '0 1'))) or (n == 2 and m == 3 and (a[0] == '0 -1')) or (n == 100 and m == 100 and (a[0] == '-10000 6429')):\n\tprint('NO')\nelif n == 4 and m == 4 and (a[0] == '1 0') or (n == 3 and m == 4 and (a[0] == '-9998 -10000')) or n == 1 or (m == 1) or (n == 2 and m == 2 and (a[0] == '3782 2631')) or (n == 1000 and m == 1000 and (a[0] == '-4729 -6837')) or (n == 1000 and m == 1000 and (a[0] == '6558 -2280')) or (n == 1000 and m == 1000 and (a[0] == '-5051 5846')) or (n == 1000 and m == 1000 and (a[0] == '-4547 4547')) or (n == 1000 and m == 1000 and (a[0] == '7010 10000')) or (n == 1948 and m == 1091 and (a[0] == '-1873 -10000')) or (n == 1477 and m == 1211 and (a[0] == '2770 -10000')) or (n == 1000 and m == 1000 and (a[0] == '5245 6141')) or (n == 10000 and m == 10000 and (a[0] == '-4957 8783')) or (n == 10000 and m == 10000 and (a[0] == '-1729 2513')) or (n == 10000 and m == 10000 and (a[0] == '8781 -5556')) or (n == 10000 and m == 10000 and (a[0] == '5715 5323')) or (nm == '10000 10000' and a[0] == '-1323 290') or (nm == '10000 10000' and a[0] == '6828 3257') or (nm == '10000 10000' and a[0] == '1592 -154') or (nm == '10000 10000' and a[0] == '-1535 5405') or (nm == '10000 10000' and (a[0] == '-3041 8307' or a[0] == '-2797 3837' or a[0] == '8393 -5715')):\n\tprint('YES')\nelif n >= 1000:\n\tprint('NO')\nelse:\n\tprint('YES')\n"
    },
    {
        "task_id": 627,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.9201712608337402,
        "fastest_time": 2.9201712608337402,
        "fastest_solution": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\nP = -123123123\n\ndef solve(u=0, p=P):\n\tif len(g[u]) == 1:\n\t\tif a[u] == 0:\n\t\t\treturn (float('inf'), 1)\n\t\treturn (a[u], 1)\n\ts = l = 0\n\tfor v in g[u]:\n\t\tif v != p:\n\t\t\t(x, y) = solve(v, u)\n\t\t\ts += x\n\t\t\tl += y\n\tif a[u] == 0:\n\t\treturn (s, l)\n\treturn (min(s, a[u] * l), l)\nfor _ in range(int(input())):\n\tn = int(input())\n\tg = [[] for _ in range(n)]\n\tg[0].append(P)\n\tfor _ in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tg[u - 1].append(v - 1)\n\t\tg[v - 1].append(u - 1)\n\ta = list(map(int, input().split()))\n\tif n == 1:\n\t\tprint(a[0])\n\t\tcontinue\n\tprint(solve()[0])\n",
        "slowest_solution": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\nP = -123123123\n\ndef solve(u=0, p=P):\n\tif len(g[u]) == 1:\n\t\tif a[u] == 0:\n\t\t\treturn (float('inf'), 1)\n\t\treturn (a[u], 1)\n\ts = l = 0\n\tfor v in g[u]:\n\t\tif v != p:\n\t\t\t(x, y) = solve(v, u)\n\t\t\ts += x\n\t\t\tl += y\n\tif a[u] == 0:\n\t\treturn (s, l)\n\treturn (min(s, a[u] * l), l)\nfor _ in range(int(input())):\n\tn = int(input())\n\tg = [[] for _ in range(n)]\n\tg[0].append(P)\n\tfor _ in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tg[u - 1].append(v - 1)\n\t\tg[v - 1].append(u - 1)\n\ta = list(map(int, input().split()))\n\tif n == 1:\n\t\tprint(a[0])\n\t\tcontinue\n\tprint(solve()[0])\n"
    },
    {
        "task_id": 584,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 2.9815196990966797,
        "fastest_time": 2.7563493251800537,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tf = 0\n\ta = k\n\tb = k\n\tc = 0\n\tf = 1\n\tfor i in range(n):\n\t\t(t, l, h) = map(int, input().split())\n\t\tp = t - c\n\t\ta -= p\n\t\tb += p\n\t\tif b < l or a > h:\n\t\t\tf = 0\n\t\tc = t\n\t\ta = max(a, l)\n\t\tb = min(b, h)\n\tif f:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tt = []\n\tl = []\n\th = []\n\tfor i in range(n):\n\t\t(a, b, c) = map(int, input().split())\n\t\tt.append(a)\n\t\tl.append(b)\n\t\th.append(c)\n\tif m + t[0] < l[0] or m - t[0] > h[0]:\n\t\tg = 0\n\t\t(cl, ch) = (0, 0)\n\telse:\n\t\tg = 1\n\t\t(cl, ch) = (max(m - t[0], l[0]), min(m + t[0], h[0]))\n\tfor i in range(1, n):\n\t\t(p, q, r) = (t[i] - t[i - 1], l[i], h[i])\n\t\tif q > ch + p or r < cl - p:\n\t\t\tg = 0\n\t\t\tbreak\n\t\telse:\n\t\t\t(cl, ch) = (max(cl - p, q), min(ch + p, r))\n\tif g:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 585,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 2.985157012939453,
        "fastest_time": 2.7986483573913574,
        "fastest_solution": "def move(mv):\n\terr = 'Error'\n\tno = 'No'\n\tyes = 'Yes'\n\tif len(mv) != 5:\n\t\treturn err\n\telif (mv[0] < 'a' or mv[0] > 'h') or (mv[1] < '1' or mv[1] > '8') or mv[2] != '-' or (mv[3] < 'a' or mv[3] > 'h') or (mv[4] < '1' or mv[4] > '8'):\n\t\treturn err\n\telse:\n\t\tc1 = ord(mv[0])\n\t\tc2 = ord(mv[3])\n\t\td1 = int(mv[1])\n\t\td2 = int(mv[4])\n\t\tif abs((c1 - c2) * (d1 - d2)) == 2:\n\t\t\treturn yes\n\t\telse:\n\t\t\treturn no\ntc = int(input())\nfor _ in range(tc):\n\ts = input()\n\tprint(move(s))\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\ts = input()\n\tif len(s) == 5 and s[2] == '-' and (s[0] in 'abcdefgh') and (s[3] in 'abcdefgh') and (s[1] in '12345678') and (s[4] in '12345678'):\n\t\tif abs(ord(s[0]) - ord(s[3])) == 2 and abs(int(s[1]) - int(s[4])) == 1 or (abs(ord(s[0]) - ord(s[3])) == 1 and abs(int(s[1]) - int(s[4])) == 2):\n\t\t\tprint('Yes')\n\t\telse:\n\t\t\tprint('No')\n\telse:\n\t\tprint('Error')\n"
    },
    {
        "task_id": 586,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.8339650630950928,
        "fastest_time": 2.8322436809539795,
        "fastest_solution": "import numpy as np\nmod = 998244353\ntwo = [1]\nfor i in range(1, 10 ** 5 + 100):\n\ttwo.append(2 * two[i - 1] % mod)\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tfreq = [0] * (n + 5)\n\tfor x in a:\n\t\tfreq[min(x, n + 1)] += 1\n\tsf = [0] * (n + 5)\n\tfor i in range(n + 3, -1, -1):\n\t\tsf[i] = sf[i + 1] + freq[i]\n\tans = 0\n\tpf = 1\n\tfor i in range(1, n + 1):\n\t\tans = (ans + i * (pf * two[sf[i + 1]] % mod)) % mod\n\t\tpf = pf * (two[freq[i]] - 1) % mod\n\tans %= mod\n\tprint(ans)\n",
        "slowest_solution": "import sys\nfrom collections import defaultdict, deque\nimport math\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninp = lambda : list(map(int, sys.stdin.readline().rstrip('\\r\\n').split()))\nmod = 998244353\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = inp()\n\tfreq = defaultdict(int)\n\tfor i in a:\n\t\tif i not in freq:\n\t\t\tfreq[i] = 1\n\t\telse:\n\t\t\tfreq[i] += 1\n\tmul = 1\n\tadd = 0\n\tres = 0\n\tfor i in range(1, n + 1):\n\t\tmex = i * mul % mod\n\t\tadd = (add + freq[i]) % mod\n\t\tmex = mex * pow(2, n - add, mod) % mod\n\t\tres = (res + mex) % mod\n\t\tmul = mul * (pow(2, freq[i], mod) - 1) % mod\n\tprint(res)\n"
    },
    {
        "task_id": 588,
        "slowest_solution_id": 4,
        "fastest_solution_id": 6,
        "slowest_time": 3.015838623046875,
        "fastest_time": 2.7310760021209717,
        "fastest_solution": "I = lambda : map(float, input().split())\nn = int(input())\nli = sorted((list(I()) for i in range(n)), key=lambda x: x[2])\nd = {}\nans = 0\nfor i in range(n):\n\tx1 = li[i][0]\n\ty1 = li[i][1]\n\tt1 = li[i][2]\n\tp1 = li[i][3]\n\td[i] = p1\n\tfor j in range(i):\n\t\tx = li[j][0]\n\t\ty = li[j][1]\n\t\tt = li[j][2]\n\t\tp = li[j][3]\n\t\tif (y1 - y) ** 2 + (x1 - x) ** 2 <= (t1 - t) ** 2:\n\t\t\td[i] = max(d[i], d[j] + p1)\n\tans = max(ans, d[i])\nprint(ans)\n",
        "slowest_solution": "def is_reachable(from_state, target):\n\treturn (from_state[0] - target[0]) ** 2 + (from_state[1] - target[1]) ** 2 <= (target[2] - from_state[2]) ** 2\nnum_iter = int(input())\ntargets = sorted([list(map(float, input().strip().split(' '))) for dummy in range(0, num_iter)], key=lambda single_target: single_target[2])\nstates = []\nfor (i, target) in enumerate(targets):\n\tstates.append(target[3])\n\tfor j in range(i):\n\t\tif is_reachable(targets[j], target):\n\t\t\tscore_estimate = states[j] + target[3]\n\t\t\tif states[i] < score_estimate:\n\t\t\t\tstates[i] = score_estimate\nmax_score = max(states)\nprint(max_score)\n"
    },
    {
        "task_id": 635,
        "slowest_solution_id": 5,
        "fastest_solution_id": 0,
        "slowest_time": 0.014262914657592773,
        "fastest_time": 0.0,
        "fastest_solution": "from itertools import combinations\n\ndef count_col_triang(a):\n\t(p, r) = ({}, {})\n\tfor (xy, col) in a:\n\t\tp[col] = p.get(col, []) + [xy]\n\tfor k in p:\n\t\tr[k] = sum((1 for c in combinations(p[k], 3) if triangle(*c)))\n\tmx = max(r.values())\n\treturn [len(a), len(p), sum(r.values()), sorted((k for k in r if r[k] == mx)) + [mx] if mx else []]\n\ndef triangle(a, b, c):\n\treturn area(*[((p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2) ** 0.5 for (p, q) in [(a, b), (a, c), (b, c)]]) > 0.0\n\ndef area(a, b, c):\n\ts = 0.5 * (a + b + c)\n\treturn round(max(s * ((s - a) * (s - b) * (s - c)), 0.0) ** 0.5, 4)\n",
        "slowest_solution": "import numpy as np\nfrom itertools import combinations\n\ndef ctri(lst):\n\tif len(lst) < 3:\n\t\treturn 0\n\treturn sum((1 for j in combinations(lst, 3) if abs(np.linalg.det(np.mat([i + [1] for i in j]))) > 0.001))\n\ndef count_col_triang(ipt):\n\td = {}\n\tfor i in ipt:\n\t\tif i[1] not in d:\n\t\t\td[i[1]] = [i[0]]\n\t\telse:\n\t\t\td[i[1]].append(i[0])\n\tp = {i: ctri(d[i]) for i in d}\n\tpmax = max(p.values())\n\tplst = [] if pmax == 0 else sorted([i for i in p if p[i] == pmax]) + [pmax]\n\treturn [len(ipt), len(p), sum(p.values()), plst]\n"
    },
    {
        "task_id": 593,
        "slowest_solution_id": 5,
        "fastest_solution_id": 9,
        "slowest_time": 3.0394644737243652,
        "fastest_time": 2.402371644973755,
        "fastest_solution": "n = int(input())\na = [0 for i in range(n)]\nfor i in range(n):\n\tk = int(input())\n\tfac = 1\n\tfor j in range(2, k + 1):\n\t\tfac = j * fac % 1000000007\n\tsig = 0\n\ta[i] = fac * k * (k - 1) % 1000000007\nfor i in range(n):\n\tprint(a[i])\n",
        "slowest_solution": "M = 10 ** 9 + 7\nf = [1]\nfor i in range(1, 7 ** 6):\n\tf += (f[-1] * i % M,)\nfor n in [*map(int, open(0))][1:]:\n\tprint(n * (n - 1) * f[n] % M)\n"
    },
    {
        "task_id": 607,
        "slowest_solution_id": 3,
        "fastest_solution_id": 6,
        "slowest_time": 3.8404476642608643,
        "fastest_time": 2.5567879676818848,
        "fastest_solution": "from collections import defaultdict\nPMAX = 10 ** 5\nbprimes = [True] * PMAX\nprimes = []\nfor i in range(2, 1000):\n\tif bprimes[i]:\n\t\tt = i * i\n\t\twhile t < PMAX:\n\t\t\tbprimes[t] = False\n\t\t\tt += i\nfor i in range(2, PMAX):\n\tif bprimes[i]:\n\t\tprimes.append(i)\n\ndef factor_small(n):\n\tfdict = defaultdict(int)\n\tfor p in primes:\n\t\tif n <= 1:\n\t\t\tbreak\n\t\tif p * p > n:\n\t\t\tfdict[n] += 1\n\t\t\tbreak\n\t\twhile n % p == 0:\n\t\t\tfdict[p] += 1\n\t\t\tn //= p\n\treturn fdict\n\ndef inv(n, m):\n\t(nn, nm, mn, mm) = (1, 0, 0, 1)\n\twhile m:\n\t\t(div, mod) = divmod(n, m)\n\t\tnn -= mn * div\n\t\tnm -= mm * div\n\t\tn = mod\n\t\t(n, m) = (m, n)\n\t\t(nn, nm, mn, mm) = (mn, mm, nn, nm)\n\treturn nn\n\ndef co_mod(mod_remains):\n\tprod_all = 1\n\tfor mod in mod_remains:\n\t\tprod_all *= mod\n\tres = 0\n\tfor (mod, remain) in mod_remains.items():\n\t\tprod_others = prod_all // mod\n\t\tres += remain * prod_others * inv(prod_others, mod)\n\t\tres %= prod_all\n\tres = (res + prod_all) % prod_all\n\treturn res\n\ndef comb_ppm(n, m, prime, power):\n\tppm = prime ** power\n\tfacts = [1, 1]\n\tfor f in range(2, ppm):\n\t\tif f % prime == 0:\n\t\t\tfacts.append(facts[-1])\n\t\telse:\n\t\t\tfacts.append(facts[-1] * f % ppm)\n\tr = n - m\n\tpos = 0\n\tcarry = 0\n\tcarryq1 = 0\n\t(tn, tm, tr) = (n, m, r)\n\twhile tn > 0 or tm > 0:\n\t\tnm = tn % prime\n\t\tmm = tm % prime\n\t\trm = tr % prime\n\t\tif nm < mm or nm < rm:\n\t\t\tcarry += 1\n\t\t\tif pos >= power - 1:\n\t\t\t\tcarryq1 += 1\n\t\ttn //= prime\n\t\ttm //= prime\n\t\ttr //= prime\n\t\tpos += 1\n\tres = 1\n\t(tn, tm, tr) = (n, m, r)\n\twhile tn > 0 or tm > 0 or tr > 0:\n\t\tnm = tn % ppm\n\t\tmm = tm % ppm\n\t\trm = tr % ppm\n\t\tres *= facts[nm]\n\t\tres *= inv(facts[mm], ppm)\n\t\tres *= inv(facts[rm], ppm)\n\t\tres %= ppm\n\t\tres = (res + ppm) % ppm\n\t\ttn //= prime\n\t\ttm //= prime\n\t\ttr //= prime\n\tres *= prime ** carry\n\tres %= ppm\n\tif carryq1 % 2 == 1 and (prime != 2 or power < 3):\n\t\tres = (ppm - res) % ppm\n\treturn res\n\ndef comb(n, r, m):\n\tcomb_by_ppms = {}\n\tfor (prime, count) in factor_small(m).items():\n\t\tcomb_by_ppms[prime ** count] = comb_ppm(n, r, prime, count)\n\treturn co_mod(comb_by_ppms)\nT = int(input())\nfor _ in range(T):\n\t(N, K, M) = map(int, input().split())\n\tscount = (N + K - 1) // K\n\tif N % K == 0:\n\t\tkind = 1\n\telse:\n\t\tkind = comb(N // K + K - N % K, N // K, M)\n\tprint(scount, kind)\n",
        "slowest_solution": "from functools import *\nimport math\nimport operator\n\ndef len_in_bits(n):\n\ttry:\n\t\treturn n.bit_length()\n\texcept AttributeError:\n\t\tif n == 0:\n\t\t\treturn 0\n\t\treturn len(bin(n)) - 2\n\ndef randint_bits(size):\n\tlow = 1 << size - 1\n\thi = (1 << size) - 1\n\treturn random.randint(low, hi)\n\ndef ceil(x, y):\n\treturn x / y + (x % y != 0)\n\ndef nroot(x, n):\n\tif n < 0:\n\t\traise ValueError(\"can't extract negative root\")\n\tif n == 0:\n\t\traise ValueError(\"can't extract zero root\")\n\tsign = 1\n\tif x < 0:\n\t\tsign = -1\n\t\tx = -x\n\t\tif n % 2 == 0:\n\t\t\traise ValueError(\"can't extract even root of negative\")\n\thigh = 1\n\twhile high ** n <= x:\n\t\thigh <<= 1\n\tlow = high >> 1\n\twhile low < high:\n\t\tmid = low + high >> 1\n\t\tif low < mid and mid ** n < x:\n\t\t\tlow = mid\n\t\telif high > mid and mid ** n > x:\n\t\t\thigh = mid\n\t\telse:\n\t\t\treturn sign * mid\n\treturn sign * (mid + 1)\n\ndef _gcd(a, b):\n\tif a == 0:\n\t\treturn b\n\tif b == 0:\n\t\treturn a\n\twhile b:\n\t\t(a, b) = (b, a % b)\n\treturn abs(a)\n\ndef _lcm(a, b):\n\tif not a or not b:\n\t\traise ZeroDivisionError('lcm arguments may not be zeros')\n\treturn abs(a * b) // _gcd(a, b)\n\ndef gcd(*lst):\n\treturn abs(reduce(lambda a, b: _gcd(a, b), lst))\n\ndef lcm(*lst):\n\treturn reduce(lambda a, b: _lcm(a, b), lst)\n\ndef xgcd(a, b):\n\tif a == 0:\n\t\treturn (0, 1, b)\n\tif b == 0:\n\t\treturn (1, 0, a)\n\t(px, ppx) = (0, 1)\n\t(py, ppy) = (1, 0)\n\twhile b:\n\t\tq = a // b\n\t\t(a, b) = (b, a % b)\n\t\tx = ppx - q * px\n\t\ty = ppy - q * py\n\t\t(ppx, px) = (px, x)\n\t\t(ppy, py) = (py, y)\n\treturn (ppx, ppy, a)\n\ndef extract_prime_power(a, p):\n\ts = 0\n\tif p > 2:\n\t\twhile a and a % p == 0:\n\t\t\ts += 1\n\t\t\ta //= p\n\telif p == 2:\n\t\twhile a and a & 1 == 0:\n\t\t\ts += 1\n\t\t\ta >>= 1\n\telse:\n\t\traise ValueError('Number %d is not a prime (is smaller than 2)' % p)\n\treturn (s, a)\n\ndef solve_linear(a, b, c):\n\treturn None\n\ndef grey_code(n):\n\treturn n ^ n >> 1\n\ndef rev_grey_code(g):\n\tn = 0\n\twhile g:\n\t\tn ^= g\n\t\tg >>= 1\n\treturn n\n\ndef factorial(n):\n\tres = 1\n\twhile n > 1:\n\t\tres *= n\n\t\tn -= 1\n\treturn res\n\ndef factorial_get_prime_pow(n, p):\n\tcount = 0\n\tppow = p\n\twhile ppow <= n:\n\t\tcount += n // ppow\n\t\tppow *= p\n\treturn count\n\ndef nCk(n, k):\n\tif n < 0:\n\t\traise ValueError('Invalid value for n: %s' % n)\n\tif k < 0 or k > n:\n\t\treturn 0\n\tif k in (0, n):\n\t\treturn 1\n\tif k in (1, n - 1):\n\t\treturn n\n\tlow_min = 1\n\tlow_max = min(n, k)\n\thigh_min = max(1, n - k + 1)\n\thigh_max = n\n\treturn reduce(operator.mul, range(high_min, high_max + 1), 1) / reduce(operator.mul, range(low_min, low_max + 1), 1)\n\ndef has_invmod(a, modulus):\n\tif modulus < 2:\n\t\traise ValueError('modulus must be greater than 1')\n\tif a == 0 or gcd(a, modulus) != 1:\n\t\treturn False\n\telse:\n\t\treturn True\n\ndef invmod(a, n):\n\tif n < 2:\n\t\traise ValueError('modulus must be greater than 1')\n\t(x, y, g) = xgcd(a, n)\n\tif g != 1:\n\t\traise ValueError('no invmod for given @a and @n')\n\telse:\n\t\treturn x % n\n\ndef solve_crt(remainders, modules):\n\tif len(modules) != len(remainders):\n\t\traise TypeError('modules and remainders lists must have same len')\n\tif len(modules) == 0:\n\t\traise ValueError('Empty lists are given')\n\tif len(modules) == 1:\n\t\treturn remainders[0]\n\tx = 0\n\tN = reduce(operator.mul, modules)\n\tfor (i, module) in enumerate(modules):\n\t\tif module == 1:\n\t\t\tcontinue\n\t\tNi = N // module\n\t\tb = invmod(Ni, module)\n\t\tx += remainders[i] * Ni * b\n\treturn x % N\n\ndef nCk_mod(n, k, factors):\n\trems = []\n\tmods = []\n\tfor (p, e) in factors.items():\n\t\trems.append(nCk_mod_prime_power(n, k, p, e))\n\t\tmods.append(p ** e)\n\treturn solve_crt(rems, mods)\n\ndef factorial_mod(n, factors):\n\trems = []\n\tmods = []\n\tfor (p, e) in factors.items():\n\t\tpe = p ** e\n\t\tif n >= pe or factorial_get_prime_pow(n, p) >= e:\n\t\t\tfactmod = 0\n\t\telse:\n\t\t\tfactmod = factorial(n) % pe\n\t\trems.append(factmod)\n\t\tmods.append(pe)\n\treturn solve_crt(rems, mods)\n\ndef nCk_mod_prime_power(n, k, p, e):\n\n\tdef nCk_get_prime_pow(n, k, p):\n\t\tres = factorial_get_prime_pow(n, p)\n\t\tres -= factorial_get_prime_pow(k, p)\n\t\tres -= factorial_get_prime_pow(n - k, p)\n\t\treturn res\n\n\tdef nCk_get_non_prime_part(n, k, p, e):\n\t\tpe = p ** e\n\t\tr = n - k\n\t\tfact_pe = [1]\n\t\tacc = 1\n\t\tfor x in range(1, pe):\n\t\t\tif x % p == 0:\n\t\t\t\tx = 1\n\t\t\tacc = acc * x % pe\n\t\t\tfact_pe.append(acc)\n\t\ttop = bottom = 1\n\t\tis_negative = 0\n\t\tdigits = 0\n\t\twhile n != 0:\n\t\t\tif acc != 1:\n\t\t\t\tif digits >= e:\n\t\t\t\t\tis_negative ^= n & 1\n\t\t\t\t\tis_negative ^= r & 1\n\t\t\t\t\tis_negative ^= k & 1\n\t\t\ttop = top * fact_pe[n % pe] % pe\n\t\t\tbottom = bottom * fact_pe[r % pe] % pe\n\t\t\tbottom = bottom * fact_pe[k % pe] % pe\n\t\t\tn //= p\n\t\t\tr //= p\n\t\t\tk //= p\n\t\t\tdigits += 1\n\t\tres = top * invmod(bottom, pe) % pe\n\t\tif p != 2 or e < 3:\n\t\t\tif is_negative:\n\t\t\t\tres = pe - res\n\t\treturn res\n\tprime_part_pow = nCk_get_prime_pow(n, k, p)\n\tif prime_part_pow >= e:\n\t\treturn 0\n\tmodpow = e - prime_part_pow\n\tr = nCk_get_non_prime_part(n, k, p, modpow) % p ** modpow\n\treturn p ** prime_part_pow * r % p ** e\nsieve = [0 for x in range(1000010)]\nfor i in range(2, 1000001):\n\tif sieve[i] == 0:\n\t\tsieve[i] = i\n\t\tfor j in range(i * i, 1000001, i):\n\t\t\tsieve[j] = i\nprimes = [x for x in range(2, 1000001) if sieve[x] == 1]\nt = int(input())\nfor i in range(t):\n\t(n, k, m) = list(map(int, input().split()))\n\ttmpm = int(m)\n\tfacs = {}\n\twhile tmpm > 1:\n\t\tx = sieve[tmpm]\n\t\tc = 0\n\t\twhile tmpm % x == 0:\n\t\t\tc += 1\n\t\t\ttmpm //= x\n\t\tfacs[x] = c\n\tp = n // k\n\trem = n % k\n\ttmp = p\n\tans = 1\n\tif rem == 0:\n\t\tans = 1\n\telse:\n\t\tans = (ans + nCk_mod(p + (k - rem) % k, p, facs) - 1) % m\n\tprint(p + int(rem > 0), ans)\n"
    },
    {
        "task_id": 596,
        "slowest_solution_id": 6,
        "fastest_solution_id": 9,
        "slowest_time": 2.981227397918701,
        "fastest_time": 2.4064552783966064,
        "fastest_solution": "[print('First' if int(input()) % 8 else 'Second') for _ in range(int(input()))]\n",
        "slowest_solution": "for _ in range(int(input())):\n\tprint('Second' if int(input()) % 8 == 0 else 'First')\n"
    },
    {
        "task_id": 597,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.9791157245635986,
        "fastest_time": 2.44866943359375,
        "fastest_solution": "import bisect\nimport sys\nEPS = sys.float_info.epsilon\nLENGTH = 10\nmatrix = [[] for i in range(LENGTH)]\narray = [0] * LENGTH\n(n, m) = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = [-10 ** 12]\nb.extend(list(map(int, sys.stdin.readline().split())))\nb.append(10 ** 12)\nanswer = 0\nfor val in a:\n\tindex = bisect.bisect_left(b, val)\n\tanswer = max(answer, min(abs(val - b[index - 1]), abs(b[index] - val)))\nprint(answer)\n",
        "slowest_solution": "import bisect\n\ndef read():\n\treturn [int(x) for x in input().split()]\n\ndef main():\n\t(n, m) = read()\n\ta = read()\n\tb = read()\n\tres = 0\n\tfor i in range(0, n):\n\t\tcover_left = -1\n\t\tbi = bisect.bisect_left(b, a[i])\n\t\tif bi != m and b[bi] == a[i]:\n\t\t\tcover_left = 0\n\t\telif bi:\n\t\t\tcover_left = a[i] - b[bi - 1]\n\t\tcover_right = -1\n\t\tbi = bisect.bisect_right(b, a[i])\n\t\tif bi != m:\n\t\t\tcover_right = b[bi] - a[i]\n\t\tif cover_left != -1 and cover_right != -1:\n\t\t\tres = max(res, min(cover_left, cover_right))\n\t\telif cover_right != -1:\n\t\t\tres = max(res, cover_right)\n\t\telse:\n\t\t\tres = max(res, cover_left)\n\tprint(res)\nmain()\n"
    },
    {
        "task_id": 611,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 2.9881927967071533,
        "fastest_time": 2.8607070446014404,
        "fastest_solution": "from math import sin, pi\n\ndef func(x, b, c):\n\treturn (x * x + b * x + c) / sin(x)\nfor _ in range(int(input())):\n\t(b, c) = map(float, input().split())\n\tstart = 0\n\tend = pi / 2\n\twhile end - start > 1e-06:\n\t\tm1 = start + (end - start) / 3\n\t\tm2 = end - (end - start) / 3\n\t\tfm1 = func(m1, b, c)\n\t\tfm2 = func(m2, b, c)\n\t\tif fm1 > fm2:\n\t\t\tstart = m1\n\t\telif fm1 < fm2:\n\t\t\tend = m2\n\t\telse:\n\t\t\tstart = m1\n\t\t\tend = m2\n\tprint(func(start, b, c))\n",
        "slowest_solution": "import math\n\ndef function(x, b, c):\n\treturn (x ** 2 + b * x + c) / math.sin(x)\n\ndef ternary_search(l, r, precision, b, c):\n\tcount = 0\n\twhile r - l > precision:\n\t\tpartition = (r - l) / 3\n\t\tm1 = l + partition\n\t\tm2 = r - partition\n\t\tfm1 = function(m1, b, c)\n\t\tfm2 = function(m2, b, c)\n\t\tif fm1 > fm2:\n\t\t\tl = m1\n\t\telif fm1 < fm2:\n\t\t\tr = m2\n\t\telse:\n\t\t\tl = m1\n\t\t\tr = m2\n\t\tcount += 1\n\treturn l\ncant = int(input())\nfor i in range(cant):\n\t(b, c) = map(float, input().split())\n\tprint(function(ternary_search(0, math.pi / 2, 10 ** (-6), b, c), b, c))\n"
    },
    {
        "task_id": 629,
        "slowest_solution_id": 3,
        "fastest_solution_id": 3,
        "slowest_time": 2.4802610874176025,
        "fastest_time": 2.4802610874176025,
        "fastest_solution": "from collections import defaultdict\nimport math\nn = int(input())\na = list(map(int, input().split()))\ng = defaultdict(set)\nfor ele in a:\n\txx = ele\n\twhile xx:\n\t\tvv = math.ceil(math.log(xx, 2))\n\t\tbb = pow(2, vv) - xx\n\t\tg[bb].add(xx)\n\t\txx = bb\nglobal_max = -1\nans = []\n\ndef max_dist(node):\n\tif len(g[node]) == 0:\n\t\treturn (0, node)\n\tglobal global_max\n\tglobal ans\n\tmax1 = max2 = -1\n\tmax_cur1 = -1\n\tmax_cur2 = -1\n\tfor c in g[node]:\n\t\t(max_d, cur) = max_dist(c)\n\t\tif max_d > max1:\n\t\t\tmax2 = max1\n\t\t\tmax_cur2 = max_cur1\n\t\t\tmax1 = max_d\n\t\t\tmax_cur1 = cur\n\t\telif max_d > max2:\n\t\t\tmax2 = max_d\n\t\t\tmax_cur2 = cur\n\tif max1 + max2 + 2 > global_max:\n\t\tif max2 != -1:\n\t\t\tglobal_max = max1 + max2 + 2\n\t\t\tans = [max_cur1, max_cur2]\n\t\telse:\n\t\t\tglobal_max = max1 + max2 + 2\n\t\t\tans = [max_cur1, node]\n\treturn (max1 + 1, max_cur1)\nmax_dist(0)\nfinals = []\nfor (i, ele) in enumerate(a):\n\tif ele == ans[0] or ele == ans[1]:\n\t\tfinals.append(i + 1)\nprint(finals[0], finals[1], global_max, sep=' ')\n",
        "slowest_solution": "from collections import defaultdict\nimport math\nn = int(input())\na = list(map(int, input().split()))\ng = defaultdict(set)\nfor ele in a:\n\txx = ele\n\twhile xx:\n\t\tvv = math.ceil(math.log(xx, 2))\n\t\tbb = pow(2, vv) - xx\n\t\tg[bb].add(xx)\n\t\txx = bb\nglobal_max = -1\nans = []\n\ndef max_dist(node):\n\tif len(g[node]) == 0:\n\t\treturn (0, node)\n\tglobal global_max\n\tglobal ans\n\tmax1 = max2 = -1\n\tmax_cur1 = -1\n\tmax_cur2 = -1\n\tfor c in g[node]:\n\t\t(max_d, cur) = max_dist(c)\n\t\tif max_d > max1:\n\t\t\tmax2 = max1\n\t\t\tmax_cur2 = max_cur1\n\t\t\tmax1 = max_d\n\t\t\tmax_cur1 = cur\n\t\telif max_d > max2:\n\t\t\tmax2 = max_d\n\t\t\tmax_cur2 = cur\n\tif max1 + max2 + 2 > global_max:\n\t\tif max2 != -1:\n\t\t\tglobal_max = max1 + max2 + 2\n\t\t\tans = [max_cur1, max_cur2]\n\t\telse:\n\t\t\tglobal_max = max1 + max2 + 2\n\t\t\tans = [max_cur1, node]\n\treturn (max1 + 1, max_cur1)\nmax_dist(0)\nfinals = []\nfor (i, ele) in enumerate(a):\n\tif ele == ans[0] or ele == ans[1]:\n\t\tfinals.append(i + 1)\nprint(finals[0], finals[1], global_max, sep=' ')\n"
    },
    {
        "task_id": 603,
        "slowest_solution_id": 2,
        "fastest_solution_id": 8,
        "slowest_time": 3.4908595085144043,
        "fastest_time": 2.607179880142212,
        "fastest_solution": "t=eval(input())\na=[ 0 for i in range(t) ]\nfor _ in range(t):\n\tl=input().split()\n\ta[_]=l\ndif = [ (1,0), (-1,0), (0,1), (0,-1) ]#down,upward,right,left(i,j)\nmark = [ [0 for j in range(t+1)] for i in range(t+1) ]\nparent= [ [0 for j in range(t+1)] for i in range(t+1) ]\ndef valid(y, x):\n\treturn y >= 0 and x >= 0 and y < t and x < t\n\n\ndef bfs(start):\n\tq=[]\n\tq.append(start)\n\tFound=False\n\tl=0\n\tm=0\n\twhile q and not Found:\n\t\ttop=q.pop(0)\n\t\t#print top\n\t\tif a[top[0]][top[1]]==\"E\":\n\t\t   l,m=top[0],top[1]\n\t\t   #print \"l,m\",(l,m)\n\t\t   Found=True\n\t\t\n\t\tfor k in dif:\n\t\t\tif (valid(top[1]+k[1],top[0]+k[0]))and (a[top[0]+k[0]][top[1]+k[1]]==\"P\" or a[top[0]+k[0]][top[1]+k[1]]==\"E\") and mark[top[0]+k[0]]    [top[1]+k[1]]==False:\n\t\t\t   mark[top[0]+k[0]][top[1]+k[1]]=True\n\t\t\t   parent[top[0]+k[0]][top[1]+k[1]]=parent[top[0]][top[1]]+1\n\t\t\t   q.append((top[0]+k[0],top[1]+k[1]))\n\t\t\t  \n\t\t\t\n\treturn l,m\nfor i in range(t+1):\n\tfor j in range(t+1):\n\t\tif a[i][j]==\"S\":\n\t\t\ttI=bfs((i,j))\n\t\t\tbreak\n\tbreak\n#print parent\n#print tI\nprint(parent[tI[0]][tI[1]])            \n",
        "slowest_solution": "from collections import defaultdict\ndef Adj(n):\n\tadj_list = defaultdict(list)\n\tfor i in range(len(n)):\n\t\tfor j in range(len(n)):\n\t\t\t#print i,j\n\t\t\tfor k in [[i+1,j],[i-1,j],[i,j+1],[i,j-1]]:\n\t\t\t\tif N > k[0] >= 0 and N > k[1] >= 0:\n\t\t\t\t\tif  n[k[0]][k[1]] != 'T':\n\t\t\t\t\t\tadj_list[i,j].append(k)\n\treturn adj_list\nN = int(input())\ndef find_shortest_path(n,graph, start, end, path=[]):\n\t\tpath = path + [start]\n\t\tif n[start[0]][start[1]] == end:\n\t\t\treturn path\n\t\tif start in list(graph.keys()):\n\t\t\treturn None\n\t\tshortest = None\n\t\tfor node in graph[start[0],start[1]]:\n\t\t\tif node not in path:\n\t\t\t\tnewpath = find_shortest_path(n,graph, node, end, path)\n\t\t\t\tif newpath:\n\t\t\t\t\tif not shortest or len(newpath) < len(shortest):\n\t\t\t\t\t\tshortest = newpath\n\t\treturn shortest\n\n\n\n\n\n\n\nn = [[i for i in input().strip().split()] for j  in range(N)]\n\ns =[0,0]\nadj = Adj(n)\n\nx = find_shortest_path(n,adj,s,'E')\nprint(len(x)-1)\n"
    },
    {
        "task_id": 599,
        "slowest_solution_id": 2,
        "fastest_solution_id": 8,
        "slowest_time": 3.0330238342285156,
        "fastest_time": 2.387220859527588,
        "fastest_solution": "t = int(input())\nfor i in range(t):\n\tc = 0\n\tn = int(input())\n\tl1 = list(map(int, input().split()))\n\tl2 = list(map(int, input().split()))\n\td = {}\n\tfor j in range(len(l1)):\n\t\td[l1[j]] = [j + 1, l2[j]]\n\tfor k in range(2, len(l1) + 1):\n\t\twhile d[k][0] <= d[k - 1][0]:\n\t\t\td[k][0] += d[k][1]\n\t\t\tc += 1\n\tprint(c)\n",
        "slowest_solution": "import math\nfor _ in range(int(input())):\n\tn = int(input())\n\tw = list(map(int, input().split()))\n\tl = list(map(int, input().split()))\n\t(d, s) = ({}, 0)\n\tfor i in range(1, n + 1):\n\t\td[i] = w.index(i)\n\tfor i in range(2, n + 1):\n\t\t(t1, t2, t) = (d[i], d[i - 1], 0)\n\t\tif t1 <= t2:\n\t\t\tt = math.ceil((t2 + 1 - t1) / l[t1])\n\t\ts += t\n\t\td[i] += t * l[t1]\n\tprint(s)\n"
    },
    {
        "task_id": 601,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 2.984570264816284,
        "fastest_time": 2.3795740604400635,
        "fastest_solution": "import math\nimport sys\nn = int(input())\nm = int((n - 1) / 2)\nk = int(m / 2)\nif n % 2 == 1:\n\tk = 0\nprint(k)\n",
        "slowest_solution": "n = int(input())\nprint(0 if n % 2 != 0 else n // 4 - 1 if n % 4 == 0 else n // 4)\n"
    },
    {
        "task_id": 600,
        "slowest_solution_id": 4,
        "fastest_solution_id": 8,
        "slowest_time": 3.0415005683898926,
        "fastest_time": 2.482252597808838,
        "fastest_solution": "for i in range(int(input())):\n\tn = int(input())\n\ta = []\n\tb = []\n\tc = 0\n\tfor j in range(n):\n\t\tl = input().split()\n\t\tf = 0\n\t\tfor k in range(c):\n\t\t\tif int(l[1]) <= int(a[k][0]) <= int(l[2]) and int(a[k][1]) <= int(l[0]) <= int(a[k][2]) and (a[k][3] == l[3]) and (a[k][4] == l[4]) and (a[k][5] == l[5] and l[5] == 'random' or (a[k][5] != l[5] and l[5] != 'random' and (a[k][5] != 'random'))):\n\t\t\t\tf = 1\n\t\t\t\tx = b[k]\n\t\t\t\tdel a[k]\n\t\t\t\tdel b[k]\n\t\t\t\tbreak\n\t\tif f == 0:\n\t\t\tprint('wait')\n\t\t\ta.append(l)\n\t\t\tb.append(j + 1)\n\t\t\tc += 1\n\t\telse:\n\t\t\tprint(x)\n\t\t\tc -= 1\n",
        "slowest_solution": "for i in range(int(input())):\n\tn = int(input())\n\tl1 = []\n\tfor i in range(n):\n\t\tl1.append(list(map(str, input().split())))\n\tl2 = []\n\tfor i in range(n):\n\t\tf = 0\n\t\tfor j in range(i):\n\t\t\tif j not in l2:\n\t\t\t\tif int(l1[j][1]) <= int(l1[i][0]) <= int(l1[j][2]) and int(l1[i][1]) <= int(l1[j][0]) <= int(l1[i][2]) and (l1[i][3] == l1[j][3]) and (l1[i][4] == l1[j][4]) and (l1[i][5] == 'random' and l1[j][5] == 'random' or (l1[i][5] == 'white' and l1[j][5] == 'black') or (l1[j][5] == 'white' and l1[i][5] == 'black')):\n\t\t\t\t\tprint(j + 1)\n\t\t\t\t\tf = 1\n\t\t\t\t\tl2.append(j)\n\t\t\t\t\tl2.append(i)\n\t\t\t\t\tbreak\n\t\tif f == 0:\n\t\t\tprint('wait')\n"
    },
    {
        "task_id": 643,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.4559264183044434,
        "fastest_time": 2.4559264183044434,
        "fastest_solution": "m = 1000000007\nn = int(input())\na = map(int, input().split())\n(t1, t2) = (0, 0)\nfor i in a:\n\tif i == 1:\n\t\tt1 += 1\n\telse:\n\t\tt2 += 1\na = [1, 2]\nfor i in range(3, t1 + 1):\n\ta = a[::-1]\n\ta[1] = (a[0] + (i - 1) * a[1]) % m\nif not t1 or t1 == 1:\n\ta[1] = 1\nfor i in range(t1 + 1, n + 1):\n\ta[1] = a[1] * i % m\nprint(a[1])\n",
        "slowest_solution": "m = 1000000007\nn = int(input())\na = map(int, input().split())\n(t1, t2) = (0, 0)\nfor i in a:\n\tif i == 1:\n\t\tt1 += 1\n\telse:\n\t\tt2 += 1\na = [1, 2]\nfor i in range(3, t1 + 1):\n\ta = a[::-1]\n\ta[1] = (a[0] + (i - 1) * a[1]) % m\nif not t1 or t1 == 1:\n\ta[1] = 1\nfor i in range(t1 + 1, n + 1):\n\ta[1] = a[1] * i % m\nprint(a[1])\n"
    },
    {
        "task_id": 618,
        "slowest_solution_id": 2,
        "fastest_solution_id": 5,
        "slowest_time": 2.917762279510498,
        "fastest_time": 2.4638569355010986,
        "fastest_solution": "def dfs(start, color):\n\tm[start] = True\n\tif len(mas[start]) == 0:\n\t\tcolors[0].append(start + 1)\n\telse:\n\t\tcolors[color].append(start + 1)\n\t\tfor i in mas[start]:\n\t\t\tif not m[i]:\n\t\t\t\tdfs(i, color)\n(n, m) = map(int, input().split())\nmas = []\nfor i in range(n):\n\tmas.append([])\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tmas[a - 1].append(b - 1)\n\tmas[b - 1].append(a - 1)\nm = [False] * n\ncolors = []\nfor i in range(n):\n\tcolors.append([])\ncolor = 1\nfor i in range(n):\n\tif not m[i]:\n\t\tdfs(i, color)\n\t\tcolor += 1\nfor i in range(1, n):\n\tif len(colors[i]) > 3:\n\t\tprint(-1)\n\t\texit()\n\telif len(colors[i]) == 3 or len(colors[i]) == 0:\n\t\tcontinue\n\telif len(colors[0]) == 0:\n\t\tprint(-1)\n\t\texit()\n\telif len(colors[i]) == 2 and len(colors[0]) > 0:\n\t\tcolors[i].append(colors[0][0])\n\t\tdel colors[0][0]\n\telif len(colors[i]) == 1 and len(colors[0]) > 1:\n\t\tcolors[i].append(colors[0][0])\n\t\tcolors[i].append(colors[0][1])\n\t\tdel colors[0][0]\n\t\tdel colors[0][1]\n\telse:\n\t\tprint(-1)\n\t\texit()\nif len(colors[0]) % 3 == 0:\n\tfor i in range(0, len(colors[0]), 3):\n\t\tprint(' '.join(map(str, colors[0][i:i + 3])))\n\tfor i in range(1, n):\n\t\tif colors[i] != []:\n\t\t\tprint(' '.join(map(str, colors[i])))\nelse:\n\tprint(-1)\n",
        "slowest_solution": "from collections import defaultdict\n(n, m) = map(int, input().split())\nd = defaultdict(list)\nf = [False] * (n + 1)\nv = []\n\ndef dfs(i, s):\n\ts.add(i)\n\tf[i] = True\n\tfor k in d[i]:\n\t\tif not f[k]:\n\t\t\tdfs(k, s)\nfor j in range(m):\n\t(x, y) = map(int, input().split())\n\td[x].append(y)\n\td[y].append(x)\nfor i in range(1, n + 1):\n\tif d[i] and (not f[i]):\n\t\ts = set()\n\t\tdfs(i, s)\n\t\tif len(s) > 3:\n\t\t\tprint(-1)\n\t\t\texit()\n\t\tv.append(list(s))\nif len(v) > n // 3:\n\tprint(-1)\n\texit()\nwhile len(v) < n // 3:\n\tv.append([])\nj = 0\nfor i in range(1, n + 1):\n\tif not f[i]:\n\t\twhile len(v[j]) == 3:\n\t\t\tj += 1\n\t\tv[j].append(i)\nfor i in v:\n\tprint(i[0], i[1], i[2])\n"
    },
    {
        "task_id": 613,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 3.0467369556427,
        "fastest_time": 2.4455323219299316,
        "fastest_solution": "R = lambda : map(int, input().split())\n(n, d) = R()\na = [0] + list(R()) + [0]\nx = []\ny = []\nINF = float('inf')\nfor i in range(n):\n\t(xi, yi) = R()\n\tx += [xi]\n\ty += [yi]\nb = [INF] * n\nb[0] = 0\nc = True\nwhile c:\n\tc = False\n\tfor i in range(n):\n\t\tfor j in range(1, n):\n\t\t\tif i != j and b[i] != -1:\n\t\t\t\tt = b[i] + (abs(x[i] - x[j]) + abs(y[i] - y[j])) * d - a[j]\n\t\t\t\tif t < b[j]:\n\t\t\t\t\tb[j] = t\n\t\t\t\t\tc = True\nprint(b[-1])\n",
        "slowest_solution": "from sys import stdin\nfrom math import inf\n\ndef readline():\n\treturn list(map(int, stdin.readline().strip().split()))\n\ndef dijkstra():\n\t(n, d) = readline()\n\ta = [0] + list(readline()) + [0]\n\tx = [0] * n\n\ty = [0] * n\n\tfor i in range(n):\n\t\t(x[i], y[i]) = readline()\n\tlower_cost = [inf] * n\n\tlower_cost[0] = 0\n\tvisited = [False] * n\n\tfor i in range(n - 1):\n\t\tlower_value = inf\n\t\tposition = 0\n\t\tfor j in range(n):\n\t\t\tif not visited[j] and lower_value > lower_cost[j]:\n\t\t\t\tlower_value = lower_cost[j]\n\t\t\t\tposition = j\n\t\tvisited[position] = True\n\t\tfor k in range(n):\n\t\t\tif not visited[k]:\n\t\t\t\tdiff = lower_cost[position] + d * (abs(x[k] - x[position]) + abs(y[k] - y[position])) - a[position]\n\t\t\t\tif lower_cost[k] > diff:\n\t\t\t\t\tlower_cost[k] = diff\n\treturn lower_cost[-1]\n\ndef __starting_point():\n\tprint(dijkstra())\n__starting_point()\n"
    },
    {
        "task_id": 630,
        "slowest_solution_id": 0,
        "fastest_solution_id": 4,
        "slowest_time": 2.7017507553100586,
        "fastest_time": 2.4451897144317627,
        "fastest_solution": "def sol(na, nb, a, b, c):\n\textra = a[-1] - c\n\tif extra <= 0:\n\t\tif b[-1] - na <= c:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\telse:\n\t\tn = 0\n\t\tfor i in range(nb):\n\t\t\tif b[i] > c:\n\t\t\t\tn = i\n\t\t\t\tbreak\n\t\tif n < extra:\n\t\t\treturn 0\n\t\telif b[-1] - na + extra <= c:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\nt = int(input())\nfor ijkl in range(t):\n\t(na, nb, c) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\tans = max(sol(na, nb, a, b, c), sol(nb, na, b, a, c))\n\td = {0: 'NO', 1: 'YES'}\n\tprint(d[ans])\n",
        "slowest_solution": "def solve(a, b):\n\tdiff = max(0, a[-1] - c)\n\treturn diff < len(b) and (diff == 0 or b[diff - 1] <= c) and (b[-1] + diff - len(a) <= c)\nfor t in range(int(input())):\n\t(n, m, c) = map(int, input().split())\n\tx = list(map(int, input().split()))\n\ty = list(map(int, input().split()))\n\tprint('YES' if solve(x, y) or solve(y, x) else 'NO')\n"
    },
    {
        "task_id": 609,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.9259297847747803,
        "fastest_time": 2.441124677658081,
        "fastest_solution": "import sys\n\ndef main():\n\t(p, x, y) = list(map(int, sys.stdin.readline().split()))\n\ts = x\n\ti = s // 50 % 475\n\tfor _ in range(25):\n\t\ti = (i * 96 + 42) % 475\n\t\tnext = 26 + i\n\t\tif next == p:\n\t\t\tresult = 0\n\t\t\tsys.stdout.write(str(result) + '\\n')\n\t\t\treturn\n\ts = x - 50\n\twhile True:\n\t\tif s < y:\n\t\t\tbreak\n\t\ti = s // 50 % 475\n\t\tfor _ in range(25):\n\t\t\ti = (i * 96 + 42) % 475\n\t\t\tnext = 26 + i\n\t\t\tif next == p:\n\t\t\t\tresult = 0\n\t\t\t\tsys.stdout.write(str(result) + '\\n')\n\t\t\t\treturn\n\t\ts -= 50\n\tiplus = 1\n\twhile True:\n\t\tfor s in (x + iplus * 100, x + iplus * 100 - 50):\n\t\t\ti = s // 50 % 475\n\t\t\tfor _ in range(25):\n\t\t\t\ti = (i * 96 + 42) % 475\n\t\t\t\tnext = 26 + i\n\t\t\t\tif next == p:\n\t\t\t\t\tresult = iplus\n\t\t\t\t\tsys.stdout.write(str(result) + '\\n')\n\t\t\t\t\treturn\n\t\tiplus += 1\nmain()\n",
        "slowest_solution": "(p, x, y) = map(int, input().split())\ncur = x\nwhile cur - 50 >= y:\n\tcur -= 50\n\ndef gen(s):\n\ti = s // 50 % 475\n\tres = []\n\tfor _ in range(25):\n\t\ti = (i * 96 + 42) % 475\n\t\tres.append(26 + i)\n\treturn res\nwhile p not in gen(cur):\n\tcur += 50\nprint((max(cur - x, 0) + 99) // 100)\n"
    },
    {
        "task_id": 612,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 2.94333553314209,
        "fastest_time": 2.3934428691864014,
        "fastest_solution": "t = int(input())\nfor t1 in range(0, t):\n\t(n, name) = input().split()\n\tc0 = 0\n\tc1 = 0\n\tfor i in range(0, int(n)):\n\t\tx = input()\n\t\tif x[0] == x[-1]:\n\t\t\tif x[0] == '0':\n\t\t\t\tc0 += 1\n\t\t\telse:\n\t\t\t\tc1 += 1\n\tif name == 'Dee':\n\t\tif c0 <= c1:\n\t\t\tprint('Dee')\n\t\telse:\n\t\t\tprint('Dum')\n\telif c1 <= c0:\n\t\tprint('Dum')\n\telse:\n\t\tprint('Dee')\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\t(x, w) = input().split()\n\td1 = d2 = 0\n\tfor j in range(int(x)):\n\t\ty = input()\n\t\tif y[0] == '1' and y[-1] == '1':\n\t\t\td1 += 1\n\t\telif y[0] == '0' and y[-1] == '0':\n\t\t\td2 += 1\n\tif d1 < d2:\n\t\tprint('Dum')\n\telif d2 < d1:\n\t\tprint('Dee')\n\telse:\n\t\tprint(w)\n"
    },
    {
        "task_id": 615,
        "slowest_solution_id": 3,
        "fastest_solution_id": 6,
        "slowest_time": 3.052211284637451,
        "fastest_time": 2.4437692165374756,
        "fastest_solution": "t = int(input())\nfor i in range(t):\n\t(n, s) = map(int, input().split())\n\tt1 = min(n, s)\n\tt2 = s - t1\n\tprint(t1 - t2)\n",
        "slowest_solution": "for tc in range(int(input())):\n\t(n, s) = map(int, input().split())\n\tif s > n:\n\t\tprint(abs(2 * n - s))\n\telse:\n\t\tprint(s)\n"
    },
    {
        "task_id": 638,
        "slowest_solution_id": 3,
        "fastest_solution_id": 2,
        "slowest_time": 2.6283645629882812,
        "fastest_time": 2.4482696056365967,
        "fastest_solution": "from math import inf\nT = int(input())\nfor _ in range(T):\n\t(n, m) = map(int, input().split())\n\t(r, c) = map(int, input().split())\n\tgrid = [[False] * (m + 2) for __ in range(n + 2)]\n\tfor i in range(n):\n\t\ts = input()\n\t\tfor (j, x) in enumerate(s):\n\t\t\tgrid[i][j] = x == '1'\n\tsolution = [[[inf, inf, inf] for ___ in range(m)] for __ in range(n)]\n\tr -= 1\n\tc -= 1\n\tsolution[r][c][0] = 0\n\tA = []\n\tB = []\n\tC = []\n\tA.append(r)\n\tB.append(c)\n\tC.append(0)\n\twhile len(A):\n\t\tr = A.pop(0)\n\t\tc = B.pop(0)\n\t\to = C.pop(0)\n\t\tnew_sol = 1 + solution[r][c][o]\n\t\tif o == 0:\n\t\t\tif grid[r][c + 1] and grid[r][c + 2] and (solution[r][c + 1][1] > new_sol):\n\t\t\t\tsolution[r][c + 1][1] = new_sol\n\t\t\t\tA.append(r)\n\t\t\t\tB.append(c + 1)\n\t\t\t\tC.append(1)\n\t\t\tif grid[r + 1][c] and grid[r + 2][c] and (solution[r + 1][c][2] > new_sol):\n\t\t\t\tsolution[r + 1][c][2] = new_sol\n\t\t\t\tA.append(r + 1)\n\t\t\t\tB.append(c)\n\t\t\t\tC.append(2)\n\t\t\tif grid[r][c - 2] and grid[r][c - 1] and (solution[r][c - 2][1] > new_sol):\n\t\t\t\tsolution[r][c - 2][1] = new_sol\n\t\t\t\tA.append(r)\n\t\t\t\tB.append(c - 2)\n\t\t\t\tC.append(1)\n\t\t\tif grid[r - 2][c] and grid[r - 1][c] and (solution[r - 2][c][2] > new_sol):\n\t\t\t\tsolution[r - 2][c][2] = new_sol\n\t\t\t\tA.append(r - 2)\n\t\t\t\tB.append(c)\n\t\t\t\tC.append(2)\n\t\telif o == 1:\n\t\t\tif grid[r][c + 2] and solution[r][c + 2][0] > new_sol:\n\t\t\t\tsolution[r][c + 2][0] = new_sol\n\t\t\t\tA.append(r)\n\t\t\t\tB.append(c + 2)\n\t\t\t\tC.append(0)\n\t\t\tif grid[r + 1][c] and grid[r + 1][c + 1] and (solution[r + 1][c][1] > new_sol):\n\t\t\t\tsolution[r + 1][c][1] = new_sol\n\t\t\t\tA.append(r + 1)\n\t\t\t\tB.append(c)\n\t\t\t\tC.append(1)\n\t\t\tif grid[r][c - 1] and solution[r][c - 1][0] > new_sol:\n\t\t\t\tsolution[r][c - 1][0] = new_sol\n\t\t\t\tA.append(r)\n\t\t\t\tB.append(c - 1)\n\t\t\t\tC.append(0)\n\t\t\tif grid[r - 1][c] and grid[r - 1][c + 1] and (solution[r - 1][c][1] > new_sol):\n\t\t\t\tsolution[r - 1][c][1] = new_sol\n\t\t\t\tA.append(r - 1)\n\t\t\t\tB.append(c)\n\t\t\t\tC.append(1)\n\t\telse:\n\t\t\tif grid[r][c + 1] and grid[r + 1][c + 1] and (solution[r][c + 1][2] > new_sol):\n\t\t\t\tsolution[r][c + 1][2] = new_sol\n\t\t\t\tA.append(r)\n\t\t\t\tB.append(c + 1)\n\t\t\t\tC.append(2)\n\t\t\tif grid[r + 2][c] and solution[r + 2][c][0] > new_sol:\n\t\t\t\tsolution[r + 2][c][0] = new_sol\n\t\t\t\tA.append(r + 2)\n\t\t\t\tB.append(c)\n\t\t\t\tC.append(0)\n\t\t\tif grid[r][c - 1] and grid[r + 1][c - 1] and (solution[r][c - 1][2] > new_sol):\n\t\t\t\tsolution[r][c - 1][2] = new_sol\n\t\t\t\tA.append(r)\n\t\t\t\tB.append(c - 1)\n\t\t\t\tC.append(2)\n\t\t\tif grid[r - 1][c] and solution[r - 1][c][0] > new_sol:\n\t\t\t\tsolution[r - 1][c][0] = new_sol\n\t\t\t\tA.append(r - 1)\n\t\t\t\tB.append(c)\n\t\t\t\tC.append(0)\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tprint(solution[i][j][0] if solution[i][j][0] != inf else -1, end=' ')\n\t\tprint()\n",
        "slowest_solution": "from math import inf\nt = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\t(r, c) = map(int, input().split())\n\ta = [[0] * (m + 2) for _ in range(n + 2)]\n\tfor i in range(n):\n\t\ts = input()\n\t\tfor (j, x) in enumerate(s):\n\t\t\ta[i][j] = x\n\tr -= 1\n\tc -= 1\n\tans = [[[inf, inf, inf] for i in range(m)] for j in range(n)]\n\tans[r][c][0] = 0\n\ttouched = set()\n\ttouched.add((r, c, 0))\n\twhile len(touched):\n\t\tvisited = set()\n\t\twhile len(touched):\n\t\t\t(r, c, o) = touched.pop()\n\t\t\tcount = 1 + ans[r][c][o]\n\t\t\tif o == 0:\n\t\t\t\tif a[r][c + 1] == '1' and a[r][c + 2] == '1' and (ans[r][c + 1][1] > count):\n\t\t\t\t\tans[r][c + 1][1] = count\n\t\t\t\t\tvisited.add((r, c + 1, 1))\n\t\t\t\tif a[r][c - 2] == '1' and a[r][c - 1] == '1' and (ans[r][c - 2][1] > count):\n\t\t\t\t\tans[r][c - 2][1] = count\n\t\t\t\t\tvisited.add((r, c - 2, 1))\n\t\t\t\tif a[r + 1][c] == '1' and a[r + 2][c] == '1' and (ans[r + 1][c][2] > count):\n\t\t\t\t\tans[r + 1][c][2] = count\n\t\t\t\t\tvisited.add((r + 1, c, 2))\n\t\t\t\tif a[r - 1][c] == '1' and a[r - 2][c] == '1' and (ans[r - 2][c][2] > count):\n\t\t\t\t\tans[r - 2][c][2] = count\n\t\t\t\t\tvisited.add((r - 2, c, 2))\n\t\t\telif o == 1:\n\t\t\t\tif a[r][c + 2] == '1' and ans[r][c + 2][0] > count:\n\t\t\t\t\tans[r][c + 2][0] = count\n\t\t\t\t\tvisited.add((r, c + 2, 0))\n\t\t\t\tif a[r][c - 1] == '1' and ans[r][c - 1][0] > count:\n\t\t\t\t\tans[r][c - 1][0] = count\n\t\t\t\t\tvisited.add((r, c - 1, 0))\n\t\t\t\tif a[r + 1][c] == '1' and a[r + 1][c + 1] == '1' and (ans[r + 1][c][1] > count):\n\t\t\t\t\tans[r + 1][c][1] = count\n\t\t\t\t\tvisited.add((r + 1, c, 1))\n\t\t\t\tif a[r - 1][c] == '1' and a[r - 1][c + 1] == '1' and (ans[r - 1][c][1] > count):\n\t\t\t\t\tans[r - 1][c][1] = count\n\t\t\t\t\tvisited.add((r - 1, c, 1))\n\t\t\telse:\n\t\t\t\tif a[r][c + 1] == '1' and a[r + 1][c + 1] == '1' and (ans[r][c + 1][2] > count):\n\t\t\t\t\tans[r][c + 1][2] = count\n\t\t\t\t\tvisited.add((r, c + 1, 2))\n\t\t\t\tif a[r][c - 1] == '1' and a[r + 1][c - 1] == '1' and (ans[r][c - 1][2] > count):\n\t\t\t\t\tans[r][c - 1][2] = count\n\t\t\t\t\tvisited.add((r, c - 1, 2))\n\t\t\t\tif a[r + 2][c] == '1' and ans[r + 2][c][0] > count:\n\t\t\t\t\tans[r + 2][c][0] = count\n\t\t\t\t\tvisited.add((r + 2, c, 0))\n\t\t\t\tif a[r - 1][c] == '1' and ans[r - 1][c][0] > count:\n\t\t\t\t\tans[r - 1][c][0] = count\n\t\t\t\t\tvisited.add((r - 1, c, 0))\n\t\ttouched = visited\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tprint(ans[i][j][0] if ans[i][j][0] != inf else -1, end=' ')\n\t\tprint()\n"
    },
    {
        "task_id": 640,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.6711928844451904,
        "fastest_time": 2.4728689193725586,
        "fastest_solution": "(n, a, b) = [int(x) for x in input().split()]\nhs = [int(x) for x in input().split()]\nhs = sorted(enumerate(hs), key=lambda x: x[1])\nfor i in range(1, n + 1):\n\tif hs[-i][1] * i >= a:\n\t\tbreak\nelse:\n\tprint('No')\n\texit()\nfor j in range(i + 1, n + 1):\n\tif hs[-j][1] * (j - i) >= b:\n\t\tprint('Yes')\n\t\tprint(i, j - i)\n\t\tprint(' '.join(map(str, [index + 1 for (index, _) in hs[-i:]])))\n\t\tprint(' '.join(map(str, [index + 1 for (index, _) in hs[-j:-i]])))\n\t\tbreak\nelse:\n\tfor i in range(1, n + 1):\n\t\tif hs[-i][1] * i >= b:\n\t\t\tbreak\n\telse:\n\t\tprint('No')\n\t\texit()\n\tfor j in range(i + 1, n + 1):\n\t\tif hs[-j][1] * (j - i) >= a:\n\t\t\tprint('Yes')\n\t\t\tprint(j - i, i)\n\t\t\tprint(' '.join(map(str, [index + 1 for (index, _) in hs[-j:-i]])))\n\t\t\tprint(' '.join(map(str, [index + 1 for (index, _) in hs[-i:]])))\n\t\t\tbreak\n\telse:\n\t\tprint('No')\n",
        "slowest_solution": "import math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\nmod = 10 ** 9 + 7\nmod1 = 998244353\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass TreeNode:\n\n\tdef __init__(self, k, v):\n\t\tself.key = k\n\t\tself.value = v\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.parent = None\n\t\tself.height = 1\n\t\tself.num_left = 1\n\t\tself.num_total = 1\n\nclass AvlTree:\n\n\tdef __init__(self):\n\t\tself._tree = None\n\n\tdef add(self, k, v):\n\t\tif not self._tree:\n\t\t\tself._tree = TreeNode(k, v)\n\t\t\treturn\n\t\tnode = self._add(k, v)\n\t\tif node:\n\t\t\tself._rebalance(node)\n\n\tdef _add(self, k, v):\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tif node.left:\n\t\t\t\t\tnode = node.left\n\t\t\t\telse:\n\t\t\t\t\tnode.left = TreeNode(k, v)\n\t\t\t\t\tnode.left.parent = node\n\t\t\t\t\treturn node.left\n\t\t\telif node.key < k:\n\t\t\t\tif node.right:\n\t\t\t\t\tnode = node.right\n\t\t\t\telse:\n\t\t\t\t\tnode.right = TreeNode(k, v)\n\t\t\t\t\tnode.right.parent = node\n\t\t\t\t\treturn node.right\n\t\t\telse:\n\t\t\t\tnode.value = v\n\t\t\t\treturn\n\n\t@staticmethod\n\tdef get_height(x):\n\t\treturn x.height if x else 0\n\n\t@staticmethod\n\tdef get_num_total(x):\n\t\treturn x.num_total if x else 0\n\n\tdef _rebalance(self, node):\n\t\tn = node\n\t\twhile n:\n\t\t\tlh = self.get_height(n.left)\n\t\t\trh = self.get_height(n.right)\n\t\t\tn.height = max(lh, rh) + 1\n\t\t\tbalance_factor = lh - rh\n\t\t\tn.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n\t\t\tn.num_left = 1 + self.get_num_total(n.left)\n\t\t\tif balance_factor > 1:\n\t\t\t\tif self.get_height(n.left.left) < self.get_height(n.left.right):\n\t\t\t\t\tself._rotate_left(n.left)\n\t\t\t\tself._rotate_right(n)\n\t\t\telif balance_factor < -1:\n\t\t\t\tif self.get_height(n.right.right) < self.get_height(n.right.left):\n\t\t\t\t\tself._rotate_right(n.right)\n\t\t\t\tself._rotate_left(n)\n\t\t\telse:\n\t\t\t\tn = n.parent\n\n\tdef _remove_one(self, node):\n\t\treplacement = node.left or node.right\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = replacement\n\t\t\telse:\n\t\t\t\tnode.parent.right = replacement\n\t\t\treplacement.parent = node.parent\n\t\t\tnode.parent = None\n\t\telse:\n\t\t\tself._tree = replacement\n\t\t\treplacement.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\t\tnode.parent = None\n\t\tself._rebalance(replacement)\n\n\tdef _remove_leaf(self, node):\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = None\n\t\t\telse:\n\t\t\t\tnode.parent.right = None\n\t\t\tself._rebalance(node.parent)\n\t\telse:\n\t\t\tself._tree = None\n\t\tnode.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\n\tdef remove(self, k):\n\t\tnode = self._get_node(k)\n\t\tif not node:\n\t\t\treturn\n\t\tif AvlTree._is_leaf(node):\n\t\t\tself._remove_leaf(node)\n\t\t\treturn\n\t\tif node.left and node.right:\n\t\t\tnxt = AvlTree._get_next(node)\n\t\t\tnode.key = nxt.key\n\t\t\tnode.value = nxt.value\n\t\t\tif self._is_leaf(nxt):\n\t\t\t\tself._remove_leaf(nxt)\n\t\t\telse:\n\t\t\t\tself._remove_one(nxt)\n\t\t\tself._rebalance(node)\n\t\telse:\n\t\t\tself._remove_one(node)\n\n\tdef get(self, k):\n\t\tnode = self._get_node(k)\n\t\treturn node.value if node else -1\n\n\tdef _get_node(self, k):\n\t\tif not self._tree:\n\t\t\treturn None\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tnode = node.left\n\t\t\telif node.key < k:\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn node\n\t\treturn None\n\n\tdef get_at(self, pos):\n\t\tx = pos + 1\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif x < node.num_left:\n\t\t\t\tnode = node.left\n\t\t\telif node.num_left < x:\n\t\t\t\tx -= node.num_left\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn (node.key, node.value)\n\t\traise IndexError('Out of ranges')\n\n\t@staticmethod\n\tdef _is_left(node):\n\t\treturn node.parent.left and node.parent.left == node\n\n\t@staticmethod\n\tdef _is_leaf(node):\n\t\treturn node.left is None and node.right is None\n\n\tdef _rotate_right(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.left\n\t\t\tnode.left.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.left\n\t\t\tnode.left.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.left\n\t\t\tnode.left.parent = node.parent\n\t\tbk = node.left.right\n\t\tnode.left.right = node\n\t\tnode.parent = node.left\n\t\tnode.left = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\tdef _rotate_left(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.right\n\t\t\tnode.right.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.right\n\t\t\tnode.right.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.right\n\t\t\tnode.right.parent = node.parent\n\t\tbk = node.right.left\n\t\tnode.right.left = node\n\t\tnode.parent = node.right\n\t\tnode.right = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\t@staticmethod\n\tdef _get_next(node):\n\t\tif not node.right:\n\t\t\treturn node.parent\n\t\tn = node.right\n\t\twhile n.left:\n\t\t\tn = n.left\n\t\treturn n\n\nclass SegmentTree1:\n\n\tdef __init__(self, data, default=300006, func=lambda a, b: min(a, b)):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass SegmentTree:\n\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass Factorial:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorials = [1, 1]\n\t\tself.invModulos = [0, 1]\n\t\tself.invFactorial_ = [1, 1]\n\n\tdef calc(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.factorials):\n\t\t\treturn self.factorials[n]\n\t\tnextArr = [0] * (n + 1 - len(self.factorials))\n\t\tinitialI = len(self.factorials)\n\t\tprev = self.factorials[-1]\n\t\tm = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * i % m\n\t\tself.factorials += nextArr\n\t\treturn self.factorials[n]\n\n\tdef inv(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n^(-1)')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tp = self.MOD\n\t\tpi = n % p\n\t\tif pi < len(self.invModulos):\n\t\t\treturn self.invModulos[pi]\n\t\tnextArr = [0] * (n + 1 - len(self.invModulos))\n\t\tinitialI = len(self.invModulos)\n\t\tfor i in range(initialI, min(p, n + 1)):\n\t\t\tnext = -self.invModulos[p % i] * (p // i) % p\n\t\t\tself.invModulos.append(next)\n\t\treturn self.invModulos[pi]\n\n\tdef invFactorial(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate (n^(-1))!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.invFactorial_):\n\t\t\treturn self.invFactorial_[n]\n\t\tself.inv(n)\n\t\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\n\t\tinitialI = len(self.invFactorial_)\n\t\tprev = self.invFactorial_[-1]\n\t\tp = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\n\t\tself.invFactorial_ += nextArr\n\t\treturn self.invFactorial_[n]\n\nclass Combination:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorial = Factorial(MOD)\n\n\tdef ncr(self, n, k):\n\t\tif k < 0 or n < k:\n\t\t\treturn 0\n\t\tk = min(k, n - k)\n\t\tf = self.factorial\n\t\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n\tif a == 1 or n == 0:\n\t\treturn 1\n\tif n % 2 == 0:\n\t\ts = powm(a, n // 2, m)\n\t\treturn s * s % m\n\telse:\n\t\treturn a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n\tzipped_pairs = zip(list2, list1)\n\tz = [x for (_, x) in sorted(zipped_pairs)]\n\treturn z\n\ndef product(l):\n\tpor = 1\n\tfor i in range(len(l)):\n\t\tpor *= l[i]\n\treturn por\n\ndef binarySearchCount(arr, n, key):\n\tleft = 0\n\tright = n - 1\n\tcount = 0\n\twhile left <= right:\n\t\tmid = int((right + left) / 2)\n\t\tif arr[mid] <= key:\n\t\t\tcount = mid + 1\n\t\t\tleft = mid + 1\n\t\telse:\n\t\t\tright = mid - 1\n\treturn count\n\ndef countdig(n):\n\tc = 0\n\twhile n > 0:\n\t\tn //= 10\n\t\tc += 1\n\treturn c\n\ndef binary(x, length):\n\ty = bin(x)[2:]\n\treturn y if len(y) >= length else '0' * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n\tl = 0\n\tr = n - 1\n\tleftGreater = n\n\twhile l <= r:\n\t\tm = int(l + (r - l) / 2)\n\t\tif arr[m] >= k:\n\t\t\tleftGreater = m\n\t\t\tr = m - 1\n\t\telse:\n\t\t\tl = m + 1\n\treturn n - leftGreater\n\nclass TrieNode:\n\n\tdef __init__(self):\n\t\tself.children = [None] * 26\n\t\tself.isEndOfWord = False\n\nclass Trie:\n\n\tdef __init__(self):\n\t\tself.root = self.getNode()\n\n\tdef getNode(self):\n\t\treturn TrieNode()\n\n\tdef _charToIndex(self, ch):\n\t\treturn ord(ch) - ord('a')\n\n\tdef insert(self, key):\n\t\tpCrawl = self.root\n\t\tlength = len(key)\n\t\tfor level in range(length):\n\t\t\tindex = self._charToIndex(key[level])\n\t\t\tif not pCrawl.children[index]:\n\t\t\t\tpCrawl.children[index] = self.getNode()\n\t\t\tpCrawl = pCrawl.children[index]\n\t\tpCrawl.isEndOfWord = True\n\n\tdef search(self, key):\n\t\tpCrawl = self.root\n\t\tlength = len(key)\n\t\tfor level in range(length):\n\t\t\tindex = self._charToIndex(key[level])\n\t\t\tif not pCrawl.children[index]:\n\t\t\t\treturn False\n\t\t\tpCrawl = pCrawl.children[index]\n\t\treturn pCrawl != None and pCrawl.isEndOfWord\n\nclass Node:\n\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.count = 0\n\t\tself.left = None\n\t\tself.right = None\n\nclass BinaryTrie:\n\n\tdef __init__(self):\n\t\tself.root = Node(0)\n\n\tdef insert(self, pre_xor):\n\t\tself.temp = self.root\n\t\tfor i in range(31, -1, -1):\n\t\t\tval = pre_xor & 1 << i\n\t\t\tif val:\n\t\t\t\tif not self.temp.right:\n\t\t\t\t\tself.temp.right = Node(0)\n\t\t\t\tself.temp = self.temp.right\n\t\t\t\tself.temp.count += 1\n\t\t\tif not val:\n\t\t\t\tif not self.temp.left:\n\t\t\t\t\tself.temp.left = Node(0)\n\t\t\t\tself.temp = self.temp.left\n\t\t\t\tself.temp.count += 1\n\t\tself.temp.data = pre_xor\n\n\tdef query(self, xor):\n\t\tself.temp = self.root\n\t\tfor i in range(31, -1, -1):\n\t\t\tval = xor & 1 << i\n\t\t\tif not val:\n\t\t\t\tif self.temp.left and self.temp.left.count > 0:\n\t\t\t\t\tself.temp = self.temp.left\n\t\t\t\telif self.temp.right:\n\t\t\t\t\tself.temp = self.temp.right\n\t\t\telif self.temp.right and self.temp.right.count > 0:\n\t\t\t\tself.temp = self.temp.right\n\t\t\telif self.temp.left:\n\t\t\t\tself.temp = self.temp.left\n\t\t\tself.temp.count -= 1\n\t\treturn xor ^ self.temp.data\n(n, x, y) = map(int, input().split())\nl = list(map(int, input().split()))\nl = [(l[i], i + 1) for i in range(n)]\nl.sort()\nt = 1\nf = -1\nfor i in range(n - 1, 0, -1):\n\tif l[i][0] * t >= x:\n\t\tf = i\n\t\tbreak\n\tt += 1\nt = 1\nf1 = -1\nif f != -1:\n\tfor i in range(f - 1, -1, -1):\n\t\tif l[i][0] * t >= y:\n\t\t\tf1 = i\n\t\t\tbreak\n\t\tt += 1\nif f1 != -1:\n\tq = []\n\tq1 = []\n\tfor i in range(f1, f):\n\t\tq.append(l[i][1])\n\tfor i in range(f, n):\n\t\tq1.append(l[i][1])\n\tprint('Yes')\n\tprint(len(q1), len(q))\n\tprint(*q1)\n\tprint(*q)\n\tsys.exit(0)\nt = 1\nf = -1\nfor i in range(n - 1, 0, -1):\n\tif l[i][0] * t >= y:\n\t\tf = i\n\t\tbreak\n\tt += 1\nt = 1\nf1 = -1\nif f != -1:\n\tfor i in range(f - 1, -1, -1):\n\t\tif l[i][0] * t >= x:\n\t\t\tf1 = i\n\t\t\tbreak\n\t\tt += 1\nif f1 != -1:\n\tq = []\n\tq1 = []\n\tfor i in range(f1, f):\n\t\tq.append(l[i][1])\n\tfor i in range(f, n):\n\t\tq1.append(l[i][1])\n\tprint('Yes')\n\tprint(len(q), len(q1))\n\tprint(*q)\n\tprint(*q1)\n\tsys.exit(0)\nprint('No')\n"
    },
    {
        "task_id": 656,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5262463092803955,
        "fastest_time": 2.5262463092803955,
        "fastest_solution": "import math\n\ndef bin_search(a, left, right, threshold):\n\tleft -= 1\n\twhile right - left - 1 > 0:\n\t\tm = int((left + right) / 2)\n\t\tif a[m] < threshold:\n\t\t\tleft = m\n\t\telse:\n\t\t\tright = m\n\treturn right\n\ndef divide(a, b):\n\tif b == 0:\n\t\tif a > 0:\n\t\t\treturn math.inf\n\t\telse:\n\t\t\treturn -math.inf\n\treturn a / b\n\ndef main():\n\t(n, l, w) = [int(x) for x in input().split()]\n\t(u, v) = ([], [])\n\tfor i in range(n):\n\t\t(x, vel) = [int(x) for x in input().split()]\n\t\tif vel > 0:\n\t\t\tu.append(x)\n\t\telse:\n\t\t\tv.append(x)\n\tu = sorted(u)\n\tv = sorted(v)\n\tans = 0\n\tfor x in v:\n\t\tthreshold = min(divide((x + l) * (w + 1), w - 1), -(x + l), x)\n\t\tr1 = bin_search(u, 0, len(u), threshold)\n\t\tthreshold = min(divide((x + l) * (w - 1), w + 1), x)\n\t\tr2 = bin_search(u, 0, len(u), threshold)\n\t\tl2 = bin_search(u, 0, len(u), -(x + l))\n\t\tif l2 <= r1:\n\t\t\tans += r2\n\t\telse:\n\t\t\tans += r1\n\t\t\tans += max(0, r2 - l2)\n\tprint(ans)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n",
        "slowest_solution": "import math\n\ndef bin_search(a, left, right, threshold):\n\tleft -= 1\n\twhile right - left - 1 > 0:\n\t\tm = int((left + right) / 2)\n\t\tif a[m] < threshold:\n\t\t\tleft = m\n\t\telse:\n\t\t\tright = m\n\treturn right\n\ndef divide(a, b):\n\tif b == 0:\n\t\tif a > 0:\n\t\t\treturn math.inf\n\t\telse:\n\t\t\treturn -math.inf\n\treturn a / b\n\ndef main():\n\t(n, l, w) = [int(x) for x in input().split()]\n\t(u, v) = ([], [])\n\tfor i in range(n):\n\t\t(x, vel) = [int(x) for x in input().split()]\n\t\tif vel > 0:\n\t\t\tu.append(x)\n\t\telse:\n\t\t\tv.append(x)\n\tu = sorted(u)\n\tv = sorted(v)\n\tans = 0\n\tfor x in v:\n\t\tthreshold = min(divide((x + l) * (w + 1), w - 1), -(x + l), x)\n\t\tr1 = bin_search(u, 0, len(u), threshold)\n\t\tthreshold = min(divide((x + l) * (w - 1), w + 1), x)\n\t\tr2 = bin_search(u, 0, len(u), threshold)\n\t\tl2 = bin_search(u, 0, len(u), -(x + l))\n\t\tif l2 <= r1:\n\t\t\tans += r2\n\t\telse:\n\t\t\tans += r1\n\t\t\tans += max(0, r2 - l2)\n\tprint(ans)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n"
    },
    {
        "task_id": 614,
        "slowest_solution_id": 5,
        "fastest_solution_id": 6,
        "slowest_time": 3.4436230659484863,
        "fastest_time": 2.6165175437927246,
        "fastest_solution": "import math\n\ndef modFact(n, p):\n\tif n >= p:\n\t\treturn 0\n\tresult = 1\n\tfor i in range(1, n + 1):\n\t\tresult = result * i % p\n\treturn result\nn = int(input())\nmod = 10 ** 9 + 7\nfact = modFact(n, mod)\npower = pow(2, n - 1, mod)\nresult = (fact - power) % mod\nprint(result)\n",
        "slowest_solution": "import math\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nmod = 10 ** 9 + 7\nmod1 = 998244353\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nsys.setrecursionlimit(300000)\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass TreeNode:\n\n\tdef __init__(self, k, v):\n\t\tself.key = k\n\t\tself.value = v\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.parent = None\n\t\tself.height = 1\n\t\tself.num_left = 1\n\t\tself.num_total = 1\n\nclass AvlTree:\n\n\tdef __init__(self):\n\t\tself._tree = None\n\n\tdef add(self, k, v):\n\t\tif not self._tree:\n\t\t\tself._tree = TreeNode(k, v)\n\t\t\treturn\n\t\tnode = self._add(k, v)\n\t\tif node:\n\t\t\tself._rebalance(node)\n\n\tdef _add(self, k, v):\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tif node.left:\n\t\t\t\t\tnode = node.left\n\t\t\t\telse:\n\t\t\t\t\tnode.left = TreeNode(k, v)\n\t\t\t\t\tnode.left.parent = node\n\t\t\t\t\treturn node.left\n\t\t\telif node.key < k:\n\t\t\t\tif node.right:\n\t\t\t\t\tnode = node.right\n\t\t\t\telse:\n\t\t\t\t\tnode.right = TreeNode(k, v)\n\t\t\t\t\tnode.right.parent = node\n\t\t\t\t\treturn node.right\n\t\t\telse:\n\t\t\t\tnode.value = v\n\t\t\t\treturn\n\n\t@staticmethod\n\tdef get_height(x):\n\t\treturn x.height if x else 0\n\n\t@staticmethod\n\tdef get_num_total(x):\n\t\treturn x.num_total if x else 0\n\n\tdef _rebalance(self, node):\n\t\tn = node\n\t\twhile n:\n\t\t\tlh = self.get_height(n.left)\n\t\t\trh = self.get_height(n.right)\n\t\t\tn.height = max(lh, rh) + 1\n\t\t\tbalance_factor = lh - rh\n\t\t\tn.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n\t\t\tn.num_left = 1 + self.get_num_total(n.left)\n\t\t\tif balance_factor > 1:\n\t\t\t\tif self.get_height(n.left.left) < self.get_height(n.left.right):\n\t\t\t\t\tself._rotate_left(n.left)\n\t\t\t\tself._rotate_right(n)\n\t\t\telif balance_factor < -1:\n\t\t\t\tif self.get_height(n.right.right) < self.get_height(n.right.left):\n\t\t\t\t\tself._rotate_right(n.right)\n\t\t\t\tself._rotate_left(n)\n\t\t\telse:\n\t\t\t\tn = n.parent\n\n\tdef _remove_one(self, node):\n\t\treplacement = node.left or node.right\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = replacement\n\t\t\telse:\n\t\t\t\tnode.parent.right = replacement\n\t\t\treplacement.parent = node.parent\n\t\t\tnode.parent = None\n\t\telse:\n\t\t\tself._tree = replacement\n\t\t\treplacement.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\t\tnode.parent = None\n\t\tself._rebalance(replacement)\n\n\tdef _remove_leaf(self, node):\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = None\n\t\t\telse:\n\t\t\t\tnode.parent.right = None\n\t\t\tself._rebalance(node.parent)\n\t\telse:\n\t\t\tself._tree = None\n\t\tnode.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\n\tdef remove(self, k):\n\t\tnode = self._get_node(k)\n\t\tif not node:\n\t\t\treturn\n\t\tif AvlTree._is_leaf(node):\n\t\t\tself._remove_leaf(node)\n\t\t\treturn\n\t\tif node.left and node.right:\n\t\t\tnxt = AvlTree._get_next(node)\n\t\t\tnode.key = nxt.key\n\t\t\tnode.value = nxt.value\n\t\t\tif self._is_leaf(nxt):\n\t\t\t\tself._remove_leaf(nxt)\n\t\t\telse:\n\t\t\t\tself._remove_one(nxt)\n\t\t\tself._rebalance(node)\n\t\telse:\n\t\t\tself._remove_one(node)\n\n\tdef get(self, k):\n\t\tnode = self._get_node(k)\n\t\treturn node.value if node else -1\n\n\tdef _get_node(self, k):\n\t\tif not self._tree:\n\t\t\treturn None\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tnode = node.left\n\t\t\telif node.key < k:\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn node\n\t\treturn None\n\n\tdef get_at(self, pos):\n\t\tx = pos + 1\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif x < node.num_left:\n\t\t\t\tnode = node.left\n\t\t\telif node.num_left < x:\n\t\t\t\tx -= node.num_left\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn (node.key, node.value)\n\t\traise IndexError('Out of ranges')\n\n\t@staticmethod\n\tdef _is_left(node):\n\t\treturn node.parent.left and node.parent.left == node\n\n\t@staticmethod\n\tdef _is_leaf(node):\n\t\treturn node.left is None and node.right is None\n\n\tdef _rotate_right(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.left\n\t\t\tnode.left.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.left\n\t\t\tnode.left.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.left\n\t\t\tnode.left.parent = node.parent\n\t\tbk = node.left.right\n\t\tnode.left.right = node\n\t\tnode.parent = node.left\n\t\tnode.left = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\tdef _rotate_left(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.right\n\t\t\tnode.right.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.right\n\t\t\tnode.right.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.right\n\t\t\tnode.right.parent = node.parent\n\t\tbk = node.right.left\n\t\tnode.right.left = node\n\t\tnode.parent = node.right\n\t\tnode.right = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\t@staticmethod\n\tdef _get_next(node):\n\t\tif not node.right:\n\t\t\treturn node.parent\n\t\tn = node.right\n\t\twhile n.left:\n\t\t\tn = n.left\n\t\treturn n\n\nclass SegmentTree1:\n\n\tdef __init__(self, data, default=0, func=lambda a, b: max(a, b)):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass SegmentTree:\n\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass Factorial:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorials = [1, 1]\n\t\tself.invModulos = [0, 1]\n\t\tself.invFactorial_ = [1, 1]\n\n\tdef calc(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.factorials):\n\t\t\treturn self.factorials[n]\n\t\tnextArr = [0] * (n + 1 - len(self.factorials))\n\t\tinitialI = len(self.factorials)\n\t\tprev = self.factorials[-1]\n\t\tm = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * i % m\n\t\tself.factorials += nextArr\n\t\treturn self.factorials[n]\n\n\tdef inv(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n^(-1)')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tp = self.MOD\n\t\tpi = n % p\n\t\tif pi < len(self.invModulos):\n\t\t\treturn self.invModulos[pi]\n\t\tnextArr = [0] * (n + 1 - len(self.invModulos))\n\t\tinitialI = len(self.invModulos)\n\t\tfor i in range(initialI, min(p, n + 1)):\n\t\t\tnext = -self.invModulos[p % i] * (p // i) % p\n\t\t\tself.invModulos.append(next)\n\t\treturn self.invModulos[pi]\n\n\tdef invFactorial(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate (n^(-1))!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.invFactorial_):\n\t\t\treturn self.invFactorial_[n]\n\t\tself.inv(n)\n\t\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\n\t\tinitialI = len(self.invFactorial_)\n\t\tprev = self.invFactorial_[-1]\n\t\tp = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\n\t\tself.invFactorial_ += nextArr\n\t\treturn self.invFactorial_[n]\n\nclass Combination:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorial = Factorial(MOD)\n\n\tdef ncr(self, n, k):\n\t\tif k < 0 or n < k:\n\t\t\treturn 0\n\t\tk = min(k, n - k)\n\t\tf = self.factorial\n\t\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n\tif a == 1 or n == 0:\n\t\treturn 1\n\tif n % 2 == 0:\n\t\ts = powm(a, n // 2, m)\n\t\treturn s * s % m\n\telse:\n\t\treturn a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n\tzipped_pairs = zip(list2, list1)\n\tz = [x for (_, x) in sorted(zipped_pairs)]\n\treturn z\n\ndef product(l):\n\tpor = 1\n\tfor i in range(len(l)):\n\t\tpor *= l[i]\n\treturn por\n\ndef binarySearchCount(arr, n, key):\n\tleft = 0\n\tright = n - 1\n\tcount = 0\n\twhile left <= right:\n\t\tmid = int((right + left) / 2)\n\t\tif arr[mid] < key:\n\t\t\tcount = mid + 1\n\t\t\tleft = mid + 1\n\t\telse:\n\t\t\tright = mid - 1\n\treturn count\n\ndef countdig(n):\n\tc = 0\n\twhile n > 0:\n\t\tn //= 10\n\t\tc += 1\n\treturn c\n\ndef binary(x, length):\n\ty = bin(x)[2:]\n\treturn y if len(y) >= length else '0' * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n\tl = 0\n\tr = n - 1\n\tleftGreater = n\n\twhile l <= r:\n\t\tm = int(l + (r - l) / 2)\n\t\tif arr[m] >= k:\n\t\t\tleftGreater = m\n\t\t\tr = m - 1\n\t\telse:\n\t\t\tl = m + 1\n\treturn n - leftGreater\nn = int(input())\nans = 0\nt = 2\nfact = 2\nr = n - 3\nfor i in range(n - 2):\n\tans += fact * (t - 1) % mod * pow(2, r, mod) % mod\n\tans %= mod\n\tt += 1\n\tfact *= t\n\tfact %= mod\n\tr -= 1\nprint(ans)\n"
    },
    {
        "task_id": 620,
        "slowest_solution_id": 0,
        "fastest_solution_id": 5,
        "slowest_time": 2.915203094482422,
        "fastest_time": 2.493772506713867,
        "fastest_solution": "from sys import stdin\ninput = lambda : stdin.readline().strip()\nfrom math import ceil, sqrt, factorial, gcd\n\ndef check(z):\n\tc = 0\n\tfor i in range(len(z)):\n\t\tif z[i] == '#':\n\t\t\tif c == 0:\n\t\t\t\tc += 1\n\t\t\telif z[i - 1] != '#':\n\t\t\t\treturn False\n\treturn True\n(n, m) = map(int, input().split())\nl = []\nemptyrow = 0\nemptycol = 0\nfor i in range(n):\n\tl.append(list(input()))\n\tif l[i].count('#') == 0:\n\t\temptyrow += 1\n\tif check(l[i]) == False:\n\t\tprint(-1)\n\t\texit()\nfor i in range(m):\n\tf = 0\n\tz = []\n\tfor j in range(n):\n\t\tz.append(l[j][i])\n\t\tif l[j][i] == '.':\n\t\t\tf += 1\n\tif f == n:\n\t\temptycol += 1\n\tif check(z) == False:\n\t\tprint(-1)\n\t\texit()\nif emptyrow > 0 and emptycol > 0 or (emptycol == 0 and emptyrow == 0):\n\ts = [[0 for i in range(m)] for i in range(n)]\n\tcount = 0\n\tconnected = dict()\n\tz = []\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif l[i][j] == '#':\n\t\t\t\tx = 1\n\t\t\t\tconnected[i, j] = []\n\t\t\t\tif i > 0 and l[i - 1][j] == '#':\n\t\t\t\t\tconnected[i - 1, j].append((i, j))\n\t\t\t\t\tconnected[i, j].append((i - 1, j))\n\t\t\t\telse:\n\t\t\t\t\tx += 1\n\t\t\t\tif j > 0 and l[i][j - 1] == '#':\n\t\t\t\t\tconnected[i, j - 1].append((i, j))\n\t\t\t\t\tconnected[i, j].append((i, j - 1))\n\t\t\t\telse:\n\t\t\t\t\tx += 1\n\t\t\t\tif x == 3:\n\t\t\t\t\tz.append((i, j))\n\tfor i in z:\n\t\tif s[i[0]][i[1]] == 0:\n\t\t\tstack = [i]\n\t\t\tcount += 1\n\t\t\twhile stack:\n\t\t\t\ta = stack.pop()\n\t\t\t\tfor j in connected[a]:\n\t\t\t\t\tif s[j[0]][j[1]] == 0:\n\t\t\t\t\t\tstack.append(j)\n\t\t\t\t\t\ts[j[0]][j[1]] = 1\n\t\t\t\ts[a[0]][a[1]] = 1\n\t\t\t\tdel connected[a]\n\tprint(count)\nelse:\n\tprint(-1)\n",
        "slowest_solution": "import sys\n(n, m) = map(int, input().split())\ngrid = [list(input()) for _ in range(n)]\ncheck_row = [0 for _ in range(n)]\ncheck_column = [0 for _ in range(m)]\nflg_column = 0\nflg_row = 0\nfor i in range(n):\n\tcheck_1 = grid[i]\n\tflg = 0\n\tfor j in range(m):\n\t\tif flg == 0 and check_1[j] == '#':\n\t\t\tflg = 1\n\t\tif flg == 1 and check_1[j] == '.':\n\t\t\tflg = 2\n\t\tif flg == 2 and check_1[j] == '#':\n\t\t\tflg = 3\n\tif flg == 3:\n\t\tprint(-1)\n\t\tsys.exit()\n\telif flg == 1 or flg == 2:\n\t\tcheck_row[i] = 1\n\telse:\n\t\tflg_row = 1\nfor k in range(m):\n\tflg_2 = 0\n\tfor s in range(n):\n\t\tif flg_2 == 0 and grid[s][k] == '#':\n\t\t\tflg_2 = 1\n\t\tif flg_2 == 1 and grid[s][k] == '.':\n\t\t\tflg_2 = 2\n\t\tif flg_2 == 2 and grid[s][k] == '#':\n\t\t\tflg_2 = 3\n\tif flg_2 == 3:\n\t\tprint(-1)\n\t\tsys.exit()\n\telif flg_2 == 1 or flg_2 == 2:\n\t\tcheck_column[k] = 1\n\telse:\n\t\tflg_column = 1\nif 0 in check_row and flg_column == 0:\n\tprint(-1)\n\tsys.exit()\nif 0 in check_column and flg_row == 0:\n\tprint(-1)\n\tsys.exit()\n\ndef dfs(x, y):\n\tdx = [-1, 0, 1, 0]\n\tdy = [0, -1, 0, 1]\n\tstack = [(x, y)]\n\twhile stack:\n\t\t(x, y) = stack.pop()\n\t\tgrid[x][y] = '.'\n\t\tfor a in range(4):\n\t\t\tnx = x + dx[a]\n\t\t\tny = y + dy[a]\n\t\t\tif 0 <= nx and nx <= n - 1 and (0 <= ny) and (ny <= m - 1):\n\t\t\t\tif grid[nx][ny] == '#':\n\t\t\t\t\tt = nx\n\t\t\t\t\tw = ny\n\t\t\t\t\tstack.append((t, w))\nans = 0\nfor p in range(n):\n\tfor q in range(m):\n\t\tif grid[p][q] == '#':\n\t\t\tdfs(p, q)\n\t\t\tans += 1\nprint(ans)\n"
    },
    {
        "task_id": 634,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 2.6461732387542725,
        "fastest_time": 2.3802011013031006,
        "fastest_solution": "mod = 1000000007\nfactlist = [1]\nfor i in range(2005):\n\tfactlist.append(factlist[-1] * (i + 1) % mod)\nfactinvlist = [0] * len(factlist)\nfactinvlist[-1] = pow(factlist[-1], mod - 2, mod)\nfor i in range(len(factlist) - 1, 0, -1):\n\tfactinvlist[i - 1] = factinvlist[i] * i % mod\n\ndef choose(n, r):\n\tif r < 0 or n < r:\n\t\treturn 0\n\telse:\n\t\treturn factlist[n] * factinvlist[r] * factinvlist[n - r] % mod\nt = int(input())\nfor _ in range(t):\n\tk = int(input())\n\tn = int(input())\n\tr = int(input())\n\trmininv = pow(r - 1, mod - 2, mod)\n\trinv = pow(r, mod - 2, mod)\n\toneminrinv = pow(1 - rinv, mod - 2, mod)\n\tarr = []\n\tfor i in range(k + 1):\n\t\tarr.append([0] * (k + 1))\n\t\tarr[i][i] = 1 - rinv\n\t\tfor j in range(i - 1, -1, -1):\n\t\t\tarr[j][i] = -pow(-1, i - j) * choose(i, j) * rinv\n\toutputvec = [0] * k + [1]\n\tinputvec = [0] * (k + 1)\n\tsumzero = 0\n\ttoprint = 0\n\tfor i in range(k, -1, -1):\n\t\tinputvec[i] = oneminrinv * outputvec[i] % mod\n\t\tfor j in range(i):\n\t\t\toutputvec[j] -= arr[j][i] * inputvec[i] % mod\n\t\ttoprint += inputvec[i] * pow(n, i, mod) * pow(r, n, mod)\n\tsumzero = inputvec[0]\n\tprint((toprint - sumzero) % mod)\n",
        "slowest_solution": "mod = 1000000007\nfactlist = [1]\nfor i in range(2005):\n\tfactlist.append(factlist[-1] * (i + 1) % mod)\nfactinvlist = [0] * len(factlist)\nfactinvlist[-1] = pow(factlist[-1], mod - 2, mod)\nfor i in range(len(factlist) - 1, 0, -1):\n\tfactinvlist[i - 1] = factinvlist[i] * i % mod\n\ndef choose(n, r):\n\tif r < 0 or n < r:\n\t\treturn 0\n\telse:\n\t\treturn factlist[n] * factinvlist[r] * factinvlist[n - r] % mod\nt = int(input())\nfor _ in range(t):\n\tk = int(input())\n\tn = int(input())\n\tr = int(input())\n\trmininv = pow(r - 1, mod - 2, mod)\n\trinv = pow(r, mod - 2, mod)\n\toneminrinv = pow(1 - rinv, mod - 2, mod)\n\tarr = []\n\tfor i in range(k + 1):\n\t\tarr.append([0] * (k + 1))\n\t\tarr[i][i] = 1 - rinv\n\t\tfor j in range(i - 1, -1, -1):\n\t\t\tarr[j][i] = -pow(-1, i - j) * choose(i, j) * rinv\n\toutputvec = [0] * k + [1]\n\tinputvec = [0] * (k + 1)\n\tsumzero = 0\n\ttoprint = 0\n\tfor i in range(k, -1, -1):\n\t\tinputvec[i] = oneminrinv * outputvec[i] % mod\n\t\tfor j in range(i):\n\t\t\toutputvec[j] -= arr[j][i] * inputvec[i] % mod\n\t\ttoprint += inputvec[i] * pow(n, i, mod) * pow(r, n, mod)\n\tsumzero = inputvec[0]\n\tprint((toprint - sumzero) % mod)\n"
    },
    {
        "task_id": 626,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.8617286682128906,
        "fastest_time": 2.378722906112671,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nstrs = [input() for i in range(n)]\nbycol = [0] * m\nfor i in range(1, n):\n\tfor j in range(1, m):\n\t\tif strs[i - 1][j] == 'X' and strs[i][j - 1] == 'X':\n\t\t\tbycol[j] += 1\nsums = [bycol[0]]\nfor i in range(1, m):\n\tsums.append(sums[-1] + bycol[i])\nfor i in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tif a == m:\n\t\tprint('YES')\n\telse:\n\t\tprint('YES') if sums[b - 1] - sums[a - 1] == 0 else print('NO')\n",
        "slowest_solution": "import os\nimport sys\nfrom collections import defaultdict, Counter\nfrom io import BytesIO, IOBase\nfrom math import gcd\n\ndef lcm(a, b):\n\treturn a * b // gcd(a, b)\n\ndef sieve():\n\tglobal spf, adj, MAXN\n\tspf[1] = 1\n\tfor i in range(2, MAXN):\n\t\tspf[i] = i\n\tfor i in range(2, MAXN):\n\t\tif i * i > MAXN:\n\t\t\tbreak\n\t\tif spf[i] == i:\n\t\t\tfor j in range(i * i, MAXN, i):\n\t\t\t\tif spf[j] == j:\n\t\t\t\t\tspf[j] = i\n\ndef getdistinctFactorization(n):\n\tglobal adj, spf, MAXN\n\tfor i in range(1, n + 1):\n\t\tindex = 1\n\t\tx = i\n\t\tif x != 1:\n\t\t\tadj[i].append(spf[x])\n\t\tx = x // spf[x]\n\t\twhile x != 1:\n\t\t\tif adj[i][index - 1] != spf[x]:\n\t\t\t\tadj[i].append(spf[x])\n\t\t\t\tindex += 1\n\t\t\tx = x // spf[x]\n\ndef printDivisors(n):\n\ti = 2\n\tz = [1, n]\n\twhile i <= sqrt(n):\n\t\tif n % i == 0:\n\t\t\tif n / i == i:\n\t\t\t\tz.append(i)\n\t\t\telse:\n\t\t\t\tz.append(i)\n\t\t\t\tz.append(n // i)\n\t\ti = i + 1\n\treturn z\n\ndef create(n, x, f):\n\tpq = len(bin(n)[2:])\n\tif f == 0:\n\t\ttt = min\n\telse:\n\t\ttt = max\n\tdp = [[inf] * n for _ in range(pq)]\n\tdp[0] = x\n\tfor i in range(1, pq):\n\t\tfor j in range(n - (1 << i) + 1):\n\t\t\tdp[i][j] = tt(dp[i - 1][j], dp[i - 1][j + (1 << i - 1)])\n\treturn dp\n\ndef enquiry(l, r, dp, f):\n\tif l > r:\n\t\treturn inf if not f else -inf\n\tif f == 1:\n\t\ttt = max\n\telse:\n\t\ttt = min\n\tpq1 = len(bin(r - l + 1)[2:]) - 1\n\treturn tt(dp[pq1][l], dp[pq1][r - (1 << pq1) + 1])\n\ndef SieveOfEratosthenes(n):\n\tprime = [True for i in range(n + 1)]\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\tx = []\n\tfor i in range(2, n + 1):\n\t\tif prime[i]:\n\t\t\tx.append(i)\n\treturn x\n\ndef main():\n\t(n, m) = map(int, input().split())\n\ts = [input().strip() for i in range(n)]\n\tdp = [0] * m\n\tfor i in range(m - 1, 0, -1):\n\t\tfor j in range(1, n):\n\t\t\tif s[j - 1][i] == 'X' and s[j][i - 1] == 'X':\n\t\t\t\tdp[i] = 1\n\tfor i in range(1, m):\n\t\tdp[i] += dp[i - 1]\n\tfor i in range(int(input())):\n\t\t(xx, yy) = map(int, input().split())\n\t\tif xx == yy:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tyy -= 1\n\t\t\txx -= 1\n\t\t\tif dp[yy] - dp[xx] > 0:\n\t\t\t\tprint('NO')\n\t\t\telse:\n\t\t\t\tprint('YES')\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n"
    },
    {
        "task_id": 659,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.630178451538086,
        "fastest_time": 2.4718575477600098,
        "fastest_solution": "import sys\nsys.setrecursionlimit(20000)\n\ndef go(v, w, last):\n\tif game[v][w][last] >= 0:\n\t\treturn game[v][w][last]\n\tflag = 0\n\tmove = 0\n\tfor p in edges_out[v]:\n\t\tif p[1] >= last:\n\t\t\tmove = 1\n\t\t\tif not go(w, p[0], p[1]):\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\tif not move or not flag:\n\t\tgame[v][w][last] = 0\n\t\treturn 0\n\telse:\n\t\tgame[v][w][last] = 1\n\t\treturn 1\n(n, m) = [int(i) for i in input().split()]\nedges_in = []\nedges_out = []\nfor i in range(n):\n\tedges_in.append([])\n\tedges_out.append([])\nfor i in range(m):\n\t(s1, s2, s3) = input().split()\n\tv = int(s1) - 1\n\tw = int(s2) - 1\n\tweight = ord(s3[0]) - ord('a') + 1\n\tedges_out[v].append((w, weight))\n\tedges_in[w].append((v, weight))\ngame = []\nfor i in range(n):\n\ttmp1 = []\n\tfor j in range(n):\n\t\ttmp2 = []\n\t\tfor c in range(27):\n\t\t\ttmp2.append(-1)\n\t\ttmp1.append(tmp2)\n\tgame.append(tmp1)\nfor v in range(n):\n\ts = ''\n\tfor w in range(n):\n\t\tif go(v, w, 0):\n\t\t\ts = s + 'A'\n\t\telse:\n\t\t\ts = s + 'B'\n\tprint(s)\n",
        "slowest_solution": "from functools import lru_cache\n\ndef readline():\n\treturn list(map(int, input().split()))\n\ndef main():\n\t(n, m) = readline()\n\tedges = [list() for __ in range(n)]\n\tfor __ in range(m):\n\t\ttokens = input().split()\n\t\t(begin, end) = map(int, tokens[:2])\n\t\tweight = ord(tokens[2])\n\t\tedges[begin - 1].append((end - 1, weight))\n\n\t@lru_cache(maxsize=None)\n\tdef first_wins(first, second, lower=0):\n\t\tfor (nxt, w) in edges[first]:\n\t\t\tif w >= lower:\n\t\t\t\tif not first_wins(second, nxt, w):\n\t\t\t\t\treturn True\n\t\treturn False\n\tfor i in range(n):\n\t\tprint(''.join(('BA'[first_wins(i, j)] for j in range(n))))\nmain()\n"
    },
    {
        "task_id": 632,
        "slowest_solution_id": 6,
        "fastest_solution_id": 1,
        "slowest_time": 2.6618616580963135,
        "fastest_time": 2.4117627143859863,
        "fastest_solution": "tc = int(input())\nwhile tc > 0:\n\ttc -= 1\n\tn = int(input())\n\tp = [0] + list(map(int, input().split()))\n\tans = [0] * (n + 1)\n\tmk = [False] * (n + 1)\n\tfor i in range(1, n + 1):\n\t\tif not mk[i]:\n\t\t\tsz = 1\n\t\t\tcurr = p[i]\n\t\t\tmk[i] = True\n\t\t\twhile curr != i:\n\t\t\t\tsz += 1\n\t\t\t\tmk[curr] = True\n\t\t\t\tcurr = p[curr]\n\t\t\tans[i] = sz\n\t\t\tcurr = p[i]\n\t\t\twhile curr != i:\n\t\t\t\tans[curr] = sz\n\t\t\t\tcurr = p[curr]\n\tprint(' '.join([str(x) for x in ans[1:]]))\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn_kids = int(input())\n\tl = list(map(int, input().split()))\n\tres = [None] * n_kids\n\tdays = 1\n\tfor i in range(n_kids):\n\t\tif not res[i]:\n\t\t\tif l[i] == i + 1:\n\t\t\t\tres[i] = 1\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tcycle = [l[i]]\n\t\t\t\twhile cycle[-1] != i + 1:\n\t\t\t\t\tdays += 1\n\t\t\t\t\tcycle.append(l[cycle[-1] - 1])\n\t\t\t\tfor e in cycle:\n\t\t\t\t\tres[e - 1] = days\n\t\t\t\tdays = 1\n\tprint(*res)\n"
    },
    {
        "task_id": 651,
        "slowest_solution_id": 1,
        "fastest_solution_id": 3,
        "slowest_time": 2.6299195289611816,
        "fastest_time": 2.571683406829834,
        "fastest_solution": "def check(d, k):\n\t(pos, cur, P) = (0, 1, 0)\n\ttotal = 1\n\tfor (i, x) in enumerate(L):\n\t\twhile cur == 0:\n\t\t\tpos += 1\n\t\t\tP += add[pos]\n\t\t\tif pos + 1 >= d:\n\t\t\t\tbreak\n\t\t\tcur += P\n\t\tcur -= 1\n\t\tif pos + x // 2 + 1 <= d:\n\t\t\ttotal += x - 2\n\t\telse:\n\t\t\ttotal += (d - pos - 1) * 2 - 1\n\t\tif total >= k:\n\t\t\treturn True\n\treturn total >= k\n(n, k) = list(map(int, input().split()))\nL = list(map(int, input().split()))\nL = sorted(L, key=lambda x: -x)\nMAX = 2 * 10 ** 5\ncnt = [0] * MAX\nadd = [0] * MAX\ncnt[0] = 0\n(pos, cur, P) = (0, 1, 0)\ntotal = 1\nfor (i, x) in enumerate(L):\n\twhile cur == 0:\n\t\tpos += 1\n\t\tP += add[pos]\n\t\tcur += P\n\tcur -= 1\n\tnums = (x - 1) // 2\n\tadd[pos + 2] += 2\n\tadd[pos + 2 + nums] -= 2\n\tif x % 2 == 0:\n\t\tadd[pos + 2 + nums] += 1\n\t\tadd[pos + 3 + nums] -= 1\n\ttotal += x - 2\nif total < k:\n\tprint(-1)\nelse:\n\t(l, r) = (1, MAX)\n\twhile r - l > 1:\n\t\tmd = (l + r) // 2\n\t\tif check(md, k) == True:\n\t\t\tr = md\n\t\telse:\n\t\t\tl = md\n\tprint(r)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nimport math\n(n, k) = map(int, input().split())\nB = sorted(map(int, input().split()), reverse=True)\nN = 5 * (n + max(B))\nA = [0] * N\nA[0] = 1\nA[1] = -1\nans = float('inf')\ntotal = 0\nj = 0\nfor i in range(N - 1):\n\ttotal += A[i]\n\tA[i + 1] += A[i]\n\tif total + A[i + 1] >= k:\n\t\tans = min(ans, i + 1)\n\twhile A[i] > 0 and j < n:\n\t\tu = (B[j] - 1) // 2\n\t\tv = B[j] - 1 - u\n\t\tA[i + 2] += 1\n\t\tA[i + 2 + u] -= 1\n\t\tA[i + 2] += 1\n\t\tA[i + 2 + v] -= 1\n\t\tA[i] -= 1\n\t\ttotal -= 1\n\t\tj += 1\nprint(ans if ans < float('inf') else -1)\n"
    },
    {
        "task_id": 623,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 3.028858184814453,
        "fastest_time": 2.381526470184326,
        "fastest_solution": "mod = 10 ** 9 + 7\n\ndef fp(a, b):\n\tans = 1\n\twhile b > 0:\n\t\tif b & 1:\n\t\t\tans = ans * a % mod\n\t\tb >>= 1\n\t\ta = a * a % mod\n\treturn ans\nfor _ in range(int(input())):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\tpair = list(enumerate(arr))\n\tpair.sort(key=lambda x: x[1])\n\tans = [0] * n\n\tfor i in range(n):\n\t\ts = 0\n\t\ta = n - i - 1\n\t\tb = a * (a + 1) // 2\n\t\tp = fp(2, i)\n\t\ts = (s + p - 1) % mod\n\t\ts = (s + b * p % mod) % mod\n\t\tans[pair[i][0]] = s\n\tprint(' '.join(map(str, ans)))\n",
        "slowest_solution": "T = int(input())\nmod = 10 ** 9 + 7\nfor _ in range(T):\n\tN = int(input())\n\tA = list(map(int, input().split()))[:N]\n\tB = {}\n\tfor i in range(N):\n\t\tB[A[i]] = i\n\tnewresult = [0] * N\n\tA.sort()\n\tfor i in range(N):\n\t\tindex = B[A[i]]\n\t\tvalue = (pow(2, i, mod) - 1 + pow(2, i, mod) * (N - i - 1) % mod + pow(2, i, mod) * ((N - i - 1) * (N - i - 2)) // 2 % mod) % mod\n\t\tnewresult[index] = value\n\tprint(*newresult)\n"
    },
    {
        "task_id": 667,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.4656195640563965,
        "fastest_time": 2.4656195640563965,
        "fastest_solution": "def solve(n, m, k, edge_list, house_members):\n\troom_sets = [i for i in range(n)]\n\tvalid_move = [True for i in range(n)]\n\troom_status = [[1 << i, 0, []] for i in range(n)]\n\tfor i in range(k):\n\t\troom_status[house_members[i][1]][1] |= 1 << i\n\t\tfor j in house_members[i][2]:\n\t\t\troom_status[house_members[i][1]][2].append(j)\n\tmove = True\n\twhile move:\n\t\tmove = False\n\t\tfor i in range(n):\n\t\t\tif valid_move[i]:\n\t\t\t\tmove = move or expand(i, room_sets, valid_move, room_status, edge_list)\n\thouse_part = []\n\tfor i in range(n):\n\t\tif room_sets[i] == i:\n\t\t\thouse_part.append(i)\n\treturn adjust_answer(house_part, room_status, n, m, k)\n\ndef setoff(index, room_sets):\n\tif room_sets[index] == index:\n\t\treturn index\n\telse:\n\t\tnew_val = setoff(room_sets[index], room_sets)\n\t\troom_sets[index] = new_val\n\t\treturn new_val\n\ndef expand(current_room, room_sets, valid_move, room_status, edge_list):\n\tmoving = room_status[current_room][2]\n\tmove = False\n\tfor i in moving:\n\t\tedge = edge_list[i]\n\t\tif setoff(edge[0], room_sets) == current_room:\n\t\t\tmove = move or merge(current_room, edge[1], room_sets, valid_move, room_status)\n\t\tif setoff(edge[1], room_sets) == current_room:\n\t\t\tmove = move or merge(current_room, edge[0], room_sets, valid_move, room_status)\n\treturn move\n\ndef merge(x, y, room_sets, valid_move, room_status):\n\tsetx = setoff(x, room_sets)\n\tsety = setoff(y, room_sets)\n\tif setx == sety:\n\t\treturn False\n\telse:\n\t\tm = len(room_status[setx][2])\n\t\tm1 = len(room_status[sety][2])\n\t\tif m >= m1:\n\t\t\thead = setx\n\t\t\ttail = sety\n\t\telse:\n\t\t\thead = sety\n\t\t\ttail = setx\n\t\tvalid_move[tail] = 0\n\t\troom_sets[tail] = head\n\t\tkeys = room_status[tail][2]\n\t\twhile len(keys) > 0:\n\t\t\troom_status[head][2].append(keys.pop())\n\t\troom_status[head][1] |= room_status[tail][1]\n\t\troom_status[head][0] |= room_status[tail][0]\n\t\treturn True\n\ndef adjust_answer(house_part, room_status, n, m, k):\n\tsize = len(house_part)\n\trooms = [0 for i in range(size)]\n\tmembers = [0 for i in range(size)]\n\tkeys = [0 for i in range(size)]\n\tfor i in range(size):\n\t\tkeys_list = room_status[house_part[i]][2]\n\t\tfor j in keys_list:\n\t\t\tkeys[i] |= 1 << j\n\t\trooms[i] = room_status[house_part[i]][0]\n\t\tmembers[i] = room_status[house_part[i]][1]\n\treturn [rooms, members, keys]\n\ndef compare_answer(answer_1, answer_2, n, m, k):\n\trooms1 = answer_1[0]\n\tmembers1 = answer_1[1]\n\tkeys1 = answer_1[2]\n\tif len(rooms1) != len(members1) != len(keys1):\n\t\treturn False\n\trooms2 = answer_2[0]\n\tmembers2 = answer_2[1]\n\tkeys2 = answer_2[2]\n\tif len(rooms2) != len(members2) != len(keys2):\n\t\treturn False\n\tif len(rooms1) != len(rooms2):\n\t\treturn False\n\tfor i in range(len(rooms1)):\n\t\tif rooms1[i] != rooms2[i] or keys1[i] != keys2[i] or members1[i] != members2[i]:\n\t\t\treturn False\n\treturn True\ndata = [int(i) for i in input().split()]\n(n, m, k) = (data[0], data[1], data[2])\nhouse_members = [['', 0, []] for i in range(k)]\nhouse_members_2 = [['', 0, []] for i in range(k)]\npos_adjustment = {}\nedge_list = []\nfor i in range(m):\n\tdoors_data = [int(i) for i in input().split()]\n\t(a, b) = (doors_data[0] - 1, doors_data[1] - 1)\n\tedge_list.append((a, b))\nfor i in range(k):\n\ttemp = input().split()\n\tpos_adjustment[temp[0]] = i\n\thouse_members[i][0] = temp[0]\n\thouse_members[i][1] = int(temp[1]) - 1\n\tfor j in range(3, len(temp)):\n\t\tval = int(temp[j]) - 1\n\t\thouse_members[i][2].append(val)\nanswer_1 = solve(n, m, k, edge_list, house_members)\nfor i in range(k):\n\ttemp = input().split()\n\thouse_members_2[pos_adjustment[temp[0]]][0] = temp[0]\n\thouse_members_2[pos_adjustment[temp[0]]][1] = int(temp[1]) - 1\n\tfor j in range(3, len(temp)):\n\t\tval = int(temp[j]) - 1\n\t\thouse_members_2[pos_adjustment[temp[0]]][2].append(val)\nanswer_2 = solve(n, m, k, edge_list, house_members_2)\nif compare_answer(answer_1, answer_2, n, m, k):\n\tprint('YES')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "def solve(n, m, k, edge_list, house_members):\n\troom_sets = [i for i in range(n)]\n\tvalid_move = [True for i in range(n)]\n\troom_status = [[1 << i, 0, []] for i in range(n)]\n\tfor i in range(k):\n\t\troom_status[house_members[i][1]][1] |= 1 << i\n\t\tfor j in house_members[i][2]:\n\t\t\troom_status[house_members[i][1]][2].append(j)\n\tmove = True\n\twhile move:\n\t\tmove = False\n\t\tfor i in range(n):\n\t\t\tif valid_move[i]:\n\t\t\t\tmove = move or expand(i, room_sets, valid_move, room_status, edge_list)\n\thouse_part = []\n\tfor i in range(n):\n\t\tif room_sets[i] == i:\n\t\t\thouse_part.append(i)\n\treturn adjust_answer(house_part, room_status, n, m, k)\n\ndef setoff(index, room_sets):\n\tif room_sets[index] == index:\n\t\treturn index\n\telse:\n\t\tnew_val = setoff(room_sets[index], room_sets)\n\t\troom_sets[index] = new_val\n\t\treturn new_val\n\ndef expand(current_room, room_sets, valid_move, room_status, edge_list):\n\tmoving = room_status[current_room][2]\n\tmove = False\n\tfor i in moving:\n\t\tedge = edge_list[i]\n\t\tif setoff(edge[0], room_sets) == current_room:\n\t\t\tmove = move or merge(current_room, edge[1], room_sets, valid_move, room_status)\n\t\tif setoff(edge[1], room_sets) == current_room:\n\t\t\tmove = move or merge(current_room, edge[0], room_sets, valid_move, room_status)\n\treturn move\n\ndef merge(x, y, room_sets, valid_move, room_status):\n\tsetx = setoff(x, room_sets)\n\tsety = setoff(y, room_sets)\n\tif setx == sety:\n\t\treturn False\n\telse:\n\t\tm = len(room_status[setx][2])\n\t\tm1 = len(room_status[sety][2])\n\t\tif m >= m1:\n\t\t\thead = setx\n\t\t\ttail = sety\n\t\telse:\n\t\t\thead = sety\n\t\t\ttail = setx\n\t\tvalid_move[tail] = 0\n\t\troom_sets[tail] = head\n\t\tkeys = room_status[tail][2]\n\t\twhile len(keys) > 0:\n\t\t\troom_status[head][2].append(keys.pop())\n\t\troom_status[head][1] |= room_status[tail][1]\n\t\troom_status[head][0] |= room_status[tail][0]\n\t\treturn True\n\ndef adjust_answer(house_part, room_status, n, m, k):\n\tsize = len(house_part)\n\trooms = [0 for i in range(size)]\n\tmembers = [0 for i in range(size)]\n\tkeys = [0 for i in range(size)]\n\tfor i in range(size):\n\t\tkeys_list = room_status[house_part[i]][2]\n\t\tfor j in keys_list:\n\t\t\tkeys[i] |= 1 << j\n\t\trooms[i] = room_status[house_part[i]][0]\n\t\tmembers[i] = room_status[house_part[i]][1]\n\treturn [rooms, members, keys]\n\ndef compare_answer(answer_1, answer_2, n, m, k):\n\trooms1 = answer_1[0]\n\tmembers1 = answer_1[1]\n\tkeys1 = answer_1[2]\n\tif len(rooms1) != len(members1) != len(keys1):\n\t\treturn False\n\trooms2 = answer_2[0]\n\tmembers2 = answer_2[1]\n\tkeys2 = answer_2[2]\n\tif len(rooms2) != len(members2) != len(keys2):\n\t\treturn False\n\tif len(rooms1) != len(rooms2):\n\t\treturn False\n\tfor i in range(len(rooms1)):\n\t\tif rooms1[i] != rooms2[i] or keys1[i] != keys2[i] or members1[i] != members2[i]:\n\t\t\treturn False\n\treturn True\ndata = [int(i) for i in input().split()]\n(n, m, k) = (data[0], data[1], data[2])\nhouse_members = [['', 0, []] for i in range(k)]\nhouse_members_2 = [['', 0, []] for i in range(k)]\npos_adjustment = {}\nedge_list = []\nfor i in range(m):\n\tdoors_data = [int(i) for i in input().split()]\n\t(a, b) = (doors_data[0] - 1, doors_data[1] - 1)\n\tedge_list.append((a, b))\nfor i in range(k):\n\ttemp = input().split()\n\tpos_adjustment[temp[0]] = i\n\thouse_members[i][0] = temp[0]\n\thouse_members[i][1] = int(temp[1]) - 1\n\tfor j in range(3, len(temp)):\n\t\tval = int(temp[j]) - 1\n\t\thouse_members[i][2].append(val)\nanswer_1 = solve(n, m, k, edge_list, house_members)\nfor i in range(k):\n\ttemp = input().split()\n\thouse_members_2[pos_adjustment[temp[0]]][0] = temp[0]\n\thouse_members_2[pos_adjustment[temp[0]]][1] = int(temp[1]) - 1\n\tfor j in range(3, len(temp)):\n\t\tval = int(temp[j]) - 1\n\t\thouse_members_2[pos_adjustment[temp[0]]][2].append(val)\nanswer_2 = solve(n, m, k, edge_list, house_members_2)\nif compare_answer(answer_1, answer_2, n, m, k):\n\tprint('YES')\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 647,
        "slowest_solution_id": 6,
        "fastest_solution_id": 4,
        "slowest_time": 2.6243984699249268,
        "fastest_time": 2.5778591632843018,
        "fastest_solution": "def prime(k):\n\tif k <= 1:\n\t\treturn 0\n\telif k == 2:\n\t\treturn 1\n\telif k % 2 == 0:\n\t\treturn 0\n\telse:\n\t\tfor i in range(3, int(k ** 0.5) + 1, 2):\n\t\t\tif k % i == 0:\n\t\t\t\treturn 0\n\t\treturn 1\nt = int(input())\nfor a in range(t):\n\t(n, m) = map(int, input().split())\n\tfor i in range(n, m + 1):\n\t\tif prime(i):\n\t\t\tprint(i)\n\tprint()\n",
        "slowest_solution": "def prime(n):\n\tif n < 2:\n\t\treturn False\n\telif n == 2 or n == 3:\n\t\treturn True\n\telif n % 2 == 0 or n % 3 == 0 or n % 4 == 0:\n\t\treturn False\n\tfor i in range(5, int(n ** 0.5) + 1, 6):\n\t\tif n % i == 0 or n % (i + 2) == 0:\n\t\t\treturn False\n\treturn True\nfor i in range(int(input())):\n\t(m, n) = map(int, input().split())\n\tfor i in range(m, n + 1):\n\t\tif prime(i):\n\t\t\tprint(i)\n\tprint()\n"
    },
    {
        "task_id": 625,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.837214231491089,
        "fastest_time": 2.4116873741149902,
        "fastest_solution": "n = int(input())\nt = input().split()\nmax1 = 1\nlst = []\nfor i in range(n - 1):\n\tif int(t[i + 1]) >= int(t[i]):\n\t\tmax1 += 1\n\t\tlst.append(max1)\n\telse:\n\t\tmax1 = 1\nmax2 = 1\nfor i in lst:\n\tif int(i) > max2:\n\t\tmax2 = i\nprint(max2)\n",
        "slowest_solution": "n = int(input())\na = list(map(int, input().split()))\npm = 1\nmax = 0\nfor i in range(1, len(a)):\n\tif a[i] >= a[i - 1]:\n\t\tpm += 1\n\telse:\n\t\tif pm > max:\n\t\t\tmax = pm\n\t\tpm = 1\nif pm > max:\n\tmax = pm\nprint(max)\n"
    },
    {
        "task_id": 662,
        "slowest_solution_id": 1,
        "fastest_solution_id": 1,
        "slowest_time": 6.239646911621094,
        "fastest_time": 6.239646911621094,
        "fastest_solution": "from sys import *\nmaxn = 3 * 10 ** 5 + 5\nfre = [0] * maxn\ndivi = [0] * maxn\nisprime = [0] * maxn\nprime = []\n\ndef seive(n):\n\tfor i in range(n):\n\t\tisprime[i] = True\n\tfor i in range(2, n):\n\t\tif isprime[i] is True:\n\t\t\tprime.append(i)\n\t\tfor j in range(1, n):\n\t\t\tif i * j >= n:\n\t\t\t\tbreak\n\t\t\tisprime[i * j] = False\n\t\t\tdivi[i] += fre[i * j]\nmobius = [0] * maxn\n\ndef calc_mobius(n):\n\tfor i in range(1, n):\n\t\tmobius[i] = 1\n\tfor p in prime:\n\t\tif p * p >= n:\n\t\t\tbreak\n\t\tx = p * p\n\t\tfor j in range(x, n, x):\n\t\t\tmobius[j] = 0\n\tfor p in prime:\n\t\tfor j in range(p, n, p):\n\t\t\tmobius[j] *= -1\nfact = [1] * 10\n\ndef calc_fact():\n\tfact[0] = 1\n\tfor i in range(1, 10):\n\t\tfact[i] = i * fact[i - 1]\n\ndef nCr(n, r):\n\tif n < r:\n\t\treturn 0\n\tif n is r:\n\t\treturn 1\n\tpro = 1\n\tfor i in range(r):\n\t\tpro *= n - i\n\tpro //= fact[r]\n\treturn pro\n\ndef count_coprime(r):\n\tcoprime = 0\n\tfor d in range(1, maxn):\n\t\tncr = nCr(divi[d], r)\n\t\tcoprime += mobius[d] * ncr\n\treturn coprime\n\ndef __starting_point():\n\tn = int(stdin.readline())\n\tarr = list(map(int, stdin.readline().split()))\n\tfor i in arr:\n\t\tif i is 1:\n\t\t\tprint(1)\n\t\t\treturn\n\t\tfre[i] += 1\n\tdivi[1] = n\n\tseive(maxn)\n\tcalc_mobius(maxn)\n\tcalc_fact()\n\tfor r in range(2, 8):\n\t\tcoprime = count_coprime(r)\n\t\tif coprime > 0:\n\t\t\tprint(r)\n\t\t\treturn\n\tprint(-1)\n__starting_point()\n",
        "slowest_solution": "from sys import *\nmaxn = 3 * 10 ** 5 + 5\nfre = [0] * maxn\ndivi = [0] * maxn\nisprime = [0] * maxn\nprime = []\n\ndef seive(n):\n\tfor i in range(n):\n\t\tisprime[i] = True\n\tfor i in range(2, n):\n\t\tif isprime[i] is True:\n\t\t\tprime.append(i)\n\t\tfor j in range(1, n):\n\t\t\tif i * j >= n:\n\t\t\t\tbreak\n\t\t\tisprime[i * j] = False\n\t\t\tdivi[i] += fre[i * j]\nmobius = [0] * maxn\n\ndef calc_mobius(n):\n\tfor i in range(1, n):\n\t\tmobius[i] = 1\n\tfor p in prime:\n\t\tif p * p >= n:\n\t\t\tbreak\n\t\tx = p * p\n\t\tfor j in range(x, n, x):\n\t\t\tmobius[j] = 0\n\tfor p in prime:\n\t\tfor j in range(p, n, p):\n\t\t\tmobius[j] *= -1\nfact = [1] * 10\n\ndef calc_fact():\n\tfact[0] = 1\n\tfor i in range(1, 10):\n\t\tfact[i] = i * fact[i - 1]\n\ndef nCr(n, r):\n\tif n < r:\n\t\treturn 0\n\tif n is r:\n\t\treturn 1\n\tpro = 1\n\tfor i in range(r):\n\t\tpro *= n - i\n\tpro //= fact[r]\n\treturn pro\n\ndef count_coprime(r):\n\tcoprime = 0\n\tfor d in range(1, maxn):\n\t\tncr = nCr(divi[d], r)\n\t\tcoprime += mobius[d] * ncr\n\treturn coprime\n\ndef __starting_point():\n\tn = int(stdin.readline())\n\tarr = list(map(int, stdin.readline().split()))\n\tfor i in arr:\n\t\tif i is 1:\n\t\t\tprint(1)\n\t\t\treturn\n\t\tfre[i] += 1\n\tdivi[1] = n\n\tseive(maxn)\n\tcalc_mobius(maxn)\n\tcalc_fact()\n\tfor r in range(2, 8):\n\t\tcoprime = count_coprime(r)\n\t\tif coprime > 0:\n\t\t\tprint(r)\n\t\t\treturn\n\tprint(-1)\n__starting_point()\n"
    },
    {
        "task_id": 628,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.822734832763672,
        "fastest_time": 2.3960001468658447,
        "fastest_solution": "t = int(input())\nfor z in range(t):\n\ts = int(input())\n\tsong = list(map(int, input().split()))\n\ttot = 0\n\tfor i in range(s):\n\t\te = list(map(int, input().split()))\n\t\ttot = tot + sum(e) - (len(e) - 2) * song[i] - e[0]\n\tprint(tot)\n",
        "slowest_solution": "t = int(input())\nwhile t > 0:\n\ts = int(input())\n\tl = list(map(int, input().split()))\n\tk = []\n\tm = 0\n\tans = 0\n\tfor i in range(s):\n\t\tl1 = list(map(int, input().split()))\n\t\tk.append(l1)\n\tfor i in range(s):\n\t\tm = m + sum(k[i])\n\t\tm = m - k[i][0]\n\tfor i in range(s):\n\t\tans = ans + l[i] * (k[i][0] - 1)\n\tans = m - ans\n\tprint(ans)\n\tt = t - 1\n"
    },
    {
        "task_id": 673,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6270480155944824,
        "fastest_time": 2.6270480155944824,
        "fastest_solution": "n = int(input())\nnum = input().split(' ')\nl = [0] * 4\nfor i in range(4):\n\tl[i] = int(num[i])\nt = tuple(l)\n(a, b, c, d) = t\np = [0] * (n + 1)\nnum = input().split(' ')\nmp = [list() for _ in range(n + 1)]\nfor i in range(2, n + 1):\n\tp[i] = int(num[i - 2])\n\tmp[p[i]].append(i)\ns = [0] * (n + 1)\n\ndef sof(i):\n\tif s[i] != 0:\n\t\treturn s[i]\n\tif len(mp[i]) > 0:\n\t\tres = 0\n\t\tfor son in mp[i]:\n\t\t\tres += sof(son)\n\t\ts[i] = res\n\t\treturn res\n\telse:\n\t\ts[i] = 1\n\t\treturn 1\nrootofl = list()\nfor leaf in l:\n\twhile p[leaf] != 1:\n\t\tleaf = p[leaf]\n\trootofl.append(leaf)\nrootlist = list()\nfor rootson in mp[1]:\n\tif not rootson in rootofl:\n\t\trootlist.append(rootson)\n\ndef canpick(a, des):\n\tif des == 0:\n\t\treturn True\n\tpicklist = rootlist[:]\n\tfor j in range(2):\n\t\tcur = a[j]\n\t\twhile p[cur] != 1:\n\t\t\tfa = p[cur]\n\t\t\tfor i in mp[fa]:\n\t\t\t\tif i != cur:\n\t\t\t\t\tpicklist.append(i)\n\t\t\tcur = fa\n\tv = set()\n\tv.add(0)\n\tfor i in range(len(picklist)):\n\t\tval = sof(picklist[i])\n\t\tv |= {ori + val for ori in v}\n\t\tif des in v:\n\t\t\treturn True\n\treturn False\nm = sof(1)\nif m % 2 == 1:\n\tprint('NO')\nelse:\n\tv1 = m // 2 - 1 - sof(rootofl[2])\n\tv2 = m // 2 - 1 - sof(rootofl[0])\n\tif canpick([a, b], v1) and canpick([c, d], v2):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "n = int(input())\nnum = input().split(' ')\nl = [0] * 4\nfor i in range(4):\n\tl[i] = int(num[i])\nt = tuple(l)\n(a, b, c, d) = t\np = [0] * (n + 1)\nnum = input().split(' ')\nmp = [list() for _ in range(n + 1)]\nfor i in range(2, n + 1):\n\tp[i] = int(num[i - 2])\n\tmp[p[i]].append(i)\ns = [0] * (n + 1)\n\ndef sof(i):\n\tif s[i] != 0:\n\t\treturn s[i]\n\tif len(mp[i]) > 0:\n\t\tres = 0\n\t\tfor son in mp[i]:\n\t\t\tres += sof(son)\n\t\ts[i] = res\n\t\treturn res\n\telse:\n\t\ts[i] = 1\n\t\treturn 1\nrootofl = list()\nfor leaf in l:\n\twhile p[leaf] != 1:\n\t\tleaf = p[leaf]\n\trootofl.append(leaf)\nrootlist = list()\nfor rootson in mp[1]:\n\tif not rootson in rootofl:\n\t\trootlist.append(rootson)\n\ndef canpick(a, des):\n\tif des == 0:\n\t\treturn True\n\tpicklist = rootlist[:]\n\tfor j in range(2):\n\t\tcur = a[j]\n\t\twhile p[cur] != 1:\n\t\t\tfa = p[cur]\n\t\t\tfor i in mp[fa]:\n\t\t\t\tif i != cur:\n\t\t\t\t\tpicklist.append(i)\n\t\t\tcur = fa\n\tv = set()\n\tv.add(0)\n\tfor i in range(len(picklist)):\n\t\tval = sof(picklist[i])\n\t\tv |= {ori + val for ori in v}\n\t\tif des in v:\n\t\t\treturn True\n\treturn False\nm = sof(1)\nif m % 2 == 1:\n\tprint('NO')\nelse:\n\tv1 = m // 2 - 1 - sof(rootofl[2])\n\tv2 = m // 2 - 1 - sof(rootofl[0])\n\tif canpick([a, b], v1) and canpick([c, d], v2):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 631,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.820288896560669,
        "fastest_time": 2.374446153640747,
        "fastest_solution": "(n, m, s, d) = [int(i) for i in input().split()]\nA = [-1] + sorted([int(i) for i in input().split()]) + [m + 1]\nans_size = 2 * 10 ** 5\nans = [0 for i in range(4 * ans_size)]\n\ndef obstacle():\n\trun = -1\n\tjump = -1\n\ttop = 0\n\tfor i in range(1, n + 1):\n\t\tif s + 2 <= A[i] - A[i - 1]:\n\t\t\tif jump != -1:\n\t\t\t\tif A[i - 1] + 1 - jump <= d and top > 0 and (ans[top - 1][0] == 0) and (ans[top - 1][1] >= s):\n\t\t\t\t\tans[top] = (1, A[i - 1] + 1 - jump)\n\t\t\t\t\ttop += 1\n\t\t\t\telse:\n\t\t\t\t\tprint('IMPOSSIBLE')\n\t\t\t\t\treturn\n\t\t\tans[top] = (0, A[i] - A[i - 1] - 2)\n\t\t\ttop += 1\n\t\t\tjump = A[i] - 1\n\tif A[n] + 1 - jump <= d and top > 0 and (ans[top - 1][0] == 0) and (ans[top - 1][1] >= s):\n\t\tans[top] = (1, A[n] + 1 - jump)\n\t\ttop += 1\n\telse:\n\t\tprint('IMPOSSIBLE')\n\t\treturn\n\tif m != A[n] + 1:\n\t\tans[top] = (0, m - A[n] - 1)\n\t\ttop += 1\n\tfor i in range(top):\n\t\tif ans[i][0]:\n\t\t\tprint('JUMP', ans[i][1])\n\t\telse:\n\t\t\tprint('RUN', ans[i][1])\nobstacle()\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef gcd(a, b):\n\tif a == 0:\n\t\treturn b\n\treturn gcd(b % a, a)\n\ndef lcm(a, b):\n\treturn a * b / gcd(a, b)\n\ndef main():\n\t(n, m, s, d) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\ta.sort()\n\tcurr = 0\n\tf = 0\n\tans = []\n\tobs = []\n\tobs.append([a[0], 0])\n\tj = 0\n\tfor i in range(1, n):\n\t\tif a[i] - a[i - 1] - 2 < s:\n\t\t\tobs[j][1] += a[i] - a[i - 1]\n\t\telse:\n\t\t\tobs.append([a[i], 0])\n\t\t\tj += 1\n\tcurr = 0\n\tobs.append([float('inf'), -1])\n\ti = 0\n\twhile 1:\n\t\tif obs[i][1] == -1:\n\t\t\tbreak\n\t\tif obs[i][0] - 1 - curr >= s:\n\t\t\tind = -1\n\t\t\tfor j in range(i, len(obs) - 1):\n\t\t\t\tif obs[j][0] - (obs[i][0] - 1) + obs[j][1] + 1 <= d:\n\t\t\t\t\tind = j\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tif ind < i:\n\t\t\t\tprint('IMPOSSIBLE')\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tans.append(['RUN', obs[i][0] - 1 - curr])\n\t\t\t\tans.append(['JUMP', obs[ind][0] - (obs[i][0] - 1) + obs[ind][1] + 1])\n\t\t\t\tcurr = obs[ind][0] + obs[ind][1] + 1\n\t\t\t\ti = ind + 1\n\t\telse:\n\t\t\tprint('IMPOSSIBLE')\n\t\t\treturn\n\tif m - curr:\n\t\tans.append(['RUN', m - curr])\n\tfor i in ans:\n\t\tprint(*i)\n\treturn\nmain()\n"
    },
    {
        "task_id": 670,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.64559268951416,
        "fastest_time": 2.4837608337402344,
        "fastest_solution": "class RangeBit:\n\n\tdef __init__(self, n):\n\t\tsz = 1\n\t\twhile n >= sz:\n\t\t\tsz *= 2\n\t\tself.size = sz\n\t\tself.dataAdd = [0] * sz\n\t\tself.dataMul = [0] * sz\n\n\tdef sum(self, i):\n\t\tr = 0\n\t\tif i > 0:\n\t\t\tadd = 0\n\t\t\tmul = 0\n\t\t\tstart = i\n\t\t\twhile i > 0:\n\t\t\t\tadd += self.dataAdd[i]\n\t\t\t\tmul += self.dataMul[i]\n\t\t\t\ti -= i & -i\n\t\t\tr = mul * start + add\n\t\treturn r\n\n\tdef add(self, left, right, by):\n\t\tassert 0 < left <= right\n\t\tself._add(left, by, -by * (left - 1))\n\t\tself._add(right, -by, by * right)\n\n\tdef _add(self, i, mul, add):\n\t\tassert i > 0\n\t\twhile i < self.size:\n\t\t\tself.dataAdd[i] += add\n\t\t\tself.dataMul[i] += mul\n\t\t\ti += i & -i\n\n\tdef sum_range(self, i, j):\n\t\treturn self.sum(j) - self.sum(i - 1)\n\n\tdef sum_back(self, i):\n\t\treturn self.sum_range(i, self.size - 1)\n\n\tdef add_point(self, i, by):\n\t\tself.add(i, i, by)\n\nclass numero:\n\n\tdef __init__(self, valor, posicion_inicial):\n\t\tself.valor = valor\n\t\tself.posicion_inicial = posicion_inicial\n\t\tself.posicion_final = -1\n\n\tdef __lt__(self, other):\n\t\tif self.valor == other.valor:\n\t\t\tr = self.posicion_inicial < other.posicion_inicial\n\t\telse:\n\t\t\tr = self.valor < other.valor\n\t\treturn r\n\n\tdef __repr__(self):\n\t\treturn '{}:{}:{}'.format(self.valor, self.posicion_inicial, self.posicion_final)\n\ndef swap(a, i, j):\n\t(a[i], a[j]) = (a[j], a[i])\n\ndef crea_arreglo_enriquecido(nums):\n\tnumse = list(sorted(map(lambda t: numero(t[1], t[0]), enumerate(nums))))\n\tr = [0] * len(nums)\n\tfor (i, n) in enumerate(numse):\n\t\tr[n.posicion_inicial] = i + 1\n\treturn r\n\ndef fuerza_bruta(a):\n\ta_len = len(a)\n\tr = 0\n\tfor i in range(a_len):\n\t\tfor j in range(i):\n\t\t\tif a[i] < a[j]:\n\t\t\t\tr += 1\n\treturn r\n\ndef quita(bi, bd, a, i):\n\treturn modifica(bi, bd, a, i, False)\n\ndef anade(bi, bd, a, i):\n\treturn modifica(bi, bd, a, i, True)\n\ndef modifica(bi, bd, a, i, anade):\n\tif anade:\n\t\tbc = bi\n\t\tfac = 1\n\telse:\n\t\tbc = bd\n\t\tfac = -1\n\tinv = bi.sum_back(a[i] + 1) + bd.sum(a[i] - 1)\n\tbc.add_point(a[i], fac)\n\treturn inv\n\ndef core(nums, nmi):\n\tnumse = crea_arreglo_enriquecido(nums)\n\ta = numse\n\ti = 0\n\tj = 0\n\tni = 0\n\tr = 0\n\ta_len = len(a)\n\tbitch_izq = RangeBit(a_len + 2)\n\tbitch_der = RangeBit(a_len + 2)\n\tnif = 0\n\tfor (i, x) in enumerate(a):\n\t\tnif += bitch_der.sum_range(x + 1, a_len)\n\t\tbitch_der.add(x, x, 1)\n\tj = 0\n\tni = nif\n\tni += anade(bitch_izq, bitch_der, a, 0)\n\tfor i in range(1, a_len):\n\t\twhile j < a_len and (j < i or ni > nmi):\n\t\t\tni -= quita(bitch_izq, bitch_der, a, j)\n\t\t\tj += 1\n\t\tr += a_len - j\n\t\tni += anade(bitch_izq, bitch_der, a, i)\n\treturn r\n(_, k) = [int(x) for x in input().strip().split(' ')]\nnums = [int(x) for x in input().strip().split(' ')]\nprint(core(nums, k))\n",
        "slowest_solution": "import sys\nfrom collections import defaultdict\n\nclass BIT:\n\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.tree = [0] * n\n\n\tdef _F(self, i):\n\t\treturn i & i + 1\n\n\tdef _get_sum(self, r):\n\t\tresult = 0\n\t\twhile r > 0:\n\t\t\tresult += self.tree[r - 1]\n\t\t\tr = self._F(r - 1)\n\t\treturn result\n\n\tdef get_sum(self, l, r):\n\t\treturn self._get_sum(r) - self._get_sum(l)\n\n\tdef _H(self, i):\n\t\treturn i | i + 1\n\n\tdef add(self, i, value=1):\n\t\twhile i < self.n:\n\t\t\tself.tree[i] += value\n\t\t\ti = self._H(i)\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\npos = defaultdict(list)\nfor (i, val) in enumerate(a):\n\tpos[val].append(i)\ni = 0\nprev = -1\nfor val in sorted(a):\n\tif prev == val:\n\t\tcontinue\n\tfor j in pos[val]:\n\t\ta[j] = i\n\ti += 1\n\tprev = val\nleft = BIT(n)\nright = BIT(n)\ntotal_inv = 0\nleft.add(a[0])\nfor t in range(1, n):\n\ti = a[t]\n\ttotal_inv += right.get_sum(i + 1, n)\n\tright.add(i)\n\tif i < a[0]:\n\t\ttotal_inv += 1\nif total_inv <= k:\n\tprint(n * (n - 1) >> 1)\n\tsys.exit()\nl = 0\nr = 1\nwhile r < n and total_inv > k:\n\ttotal_inv -= left.get_sum(a[r] + 1, n) + right.get_sum(0, a[r])\n\tright.add(a[r], -1)\n\tr += 1\npairs = 0\nwhile r < n:\n\twhile True:\n\t\tadd = left.get_sum(a[l + 1] + 1, n) + right.get_sum(0, a[l + 1])\n\t\tif total_inv + add > k:\n\t\t\tpairs += l + 1\n\t\t\tbreak\n\t\telse:\n\t\t\tl += 1\n\t\t\ttotal_inv += add\n\t\t\tleft.add(a[l])\n\ttotal_inv -= left.get_sum(a[r] + 1, n) + right.get_sum(0, a[r])\n\tright.add(a[r], -1)\n\tr += 1\nprint(pairs)\n"
    },
    {
        "task_id": 669,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 3.045989990234375,
        "fastest_time": 2.8044087886810303,
        "fastest_solution": "import math\nsmall = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523]\nsmallest = [0 for i in range(4001)]\nsmallest[0] = 1\nsmallest[1] = 1\nfor i in range(2, len(smallest)):\n\tif smallest[i] == 0:\n\t\tfor j in range(2 * i, len(smallest), i):\n\t\t\tsmallest[j] = i\n\t\tsmallest[i] = i\n\ndef listfactor(N):\n\tif N == 2:\n\t\treturn [2]\n\telif N == 3:\n\t\treturn [3]\n\telse:\n\t\ttemp = []\n\t\twhile N > 1:\n\t\t\tt = smallest[N]\n\t\t\ttemp += [t]\n\t\t\tN = N // t\n\t\ttemp = temp[::-1]\n\t\tANS = [temp[0]]\n\t\tcur = temp[0]\n\t\tfor i in range(len(temp)):\n\t\t\tif temp[i] > cur:\n\t\t\t\tcur = temp[i]\n\t\t\t\tANS += [cur]\n\t\treturn ANS\n\ndef check(a, b):\n\tfor x in small:\n\t\tif (a % x == 0 and b % x == 0) == True:\n\t\t\treturn 0\n\t\tif x > max(a, b) ** 0.5:\n\t\t\treturn 1\n\treturn 1\n\ndef ceil(x):\n\tif x != int(x):\n\t\treturn int(x) + 1\n\telse:\n\t\treturn int(x)\n\ndef gcd(a, b):\n\t(a, b) = (min(a, b), max(a, b))\n\tif b % a == 0:\n\t\treturn a\n\telse:\n\t\treturn gcd(a, b % a)\n\ndef find(n, l, r):\n\tif r - l + 1 < n:\n\t\treturn 0\n\telif n == 1:\n\t\treturn r - l + 1\n\telif n == 2:\n\t\treturn (r - l + 1) * (r - l)\n\telif n >= 30:\n\t\tans = 0\n\t\ttemp = 0\n\t\tfor d in range(2, 10 ** 10):\n\t\t\ttemp = max(r // d ** (n - 1) - l + 1, 0)\n\t\t\tans += temp\n\t\t\tif temp == 0:\n\t\t\t\tbreak\n\t\treturn 2 * ans\n\telse:\n\t\tans = 0\n\t\tfor d in range(2, 10 ** 10):\n\t\t\ttemp = max(r // d ** (n - 1) - l + 1, 0)\n\t\t\tans += temp\n\t\t\tif temp == 0:\n\t\t\t\tbreak\n\t\tbound = int(r ** (1 / (n - 1)))\n\t\tANS = 0\n\t\tfor q in range(2, bound + 1):\n\t\t\tCUR = listfactor(q)\n\t\t\tfor p in range(q + 1, bound + 2):\n\t\t\t\tcheck = 1\n\t\t\t\tfor cc in CUR:\n\t\t\t\t\tif p % cc == 0:\n\t\t\t\t\t\tcheck = 0\n\t\t\t\tif check == 1:\n\t\t\t\t\tANS += max(r // p ** (n - 1) - ceil(l / q ** (n - 1)) + 1, 0)\n\t\treturn 2 * (ans + ANS)\n(n, l, r) = list(map(int, input().strip().split(' ')))\nprint(find(n, l, r))\n",
        "slowest_solution": "Primes = [2, 3, 5, 7]\n\ndef check(a, b):\n\tfor pr in Primes:\n\t\tif a % pr == 0 and b % pr == 0:\n\t\t\treturn False\n\twhile b:\n\t\ta %= b\n\t\ta ^= b\n\t\tb ^= a\n\t\ta ^= b\n\treturn a == 1\n(n, l, r) = map(int, input().split())\nif n == 1:\n\tans = r - l + 1\nelif n == 2:\n\tans = (r - l + 1) * (r - l)\nelse:\n\tn -= 1\n\tl -= 1\n\tans = 0\n\tfor q in range(2, 100000):\n\t\tupper = r // q ** n\n\t\tif upper == 0:\n\t\t\tbreak\n\t\tfor p in range(1, q):\n\t\t\tif check(q, p):\n\t\t\t\tans += max(0, upper - l // p ** n)\n\tans *= 2\nprint(ans)\n"
    },
    {
        "task_id": 676,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6137685775756836,
        "fastest_time": 2.6137685775756836,
        "fastest_solution": "import sys, math\n\ndef dist(a, b):\n\treturn pow((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2, 0.5)\n\ndef vxv(v1, v2):\n\tx = -v1[2] * v2[1] + v1[1] * v2[2]\n\ty = -v1[0] * v2[2] + v1[2] * v2[0]\n\tz = -v1[1] * v2[0] + v1[0] * v2[1]\n\treturn (x, y, z)\nreadline = sys.stdin.readline\n(s1, s2, s3, v1, v2, v3, R) = map(int, readline().split())\nn = int(readline())\npm = []\np = []\nfor _ in range(n):\n\t(o1, o2, o3, r, m) = map(int, readline().split())\n\tp.append((o1, o2, o3, r))\n\tfor _ in range(m):\n\t\t(pm1, pm2, pm3) = map(int, readline().split())\n\t\tpm.append((pm1 + o1, pm2 + o2, pm3 + o3))\nnv = (v1, v2, v3)\nm = (s1, s2, s3)\ndistance = []\nfor x in pm:\n\ttp = (x[0] - m[0], x[1] - m[1], x[2] - m[2])\n\ttp1 = vxv(tp, nv)\n\td = dist(tp1, (0, 0, 0)) / dist(nv, (0, 0, 0))\n\tif d <= R:\n\t\tdd = pow(dist(x, m) ** 2 - d ** 2, 0.5)\n\t\tdnv = dist(nv, (0, 0, 0))\n\t\tnnv = (dd * nv[0] / dnv + m[0], dd * nv[1] / dnv + m[1], dd * nv[2] / dnv + m[2])\n\t\tif dist(nnv, x) < dist(x, m):\n\t\t\tdistance.append(dd - pow(R ** 2 - d ** 2, 0.5))\nfor i in range(len(p)):\n\tpi = (p[i][0], p[i][1], p[i][2])\n\ttp = (pi[0] - m[0], pi[1] - m[1], pi[2] - m[2])\n\ttp1 = vxv(tp, nv)\n\td = dist(tp1, (0, 0, 0)) / dist(nv, (0, 0, 0))\n\tif d - p[i][3] <= R:\n\t\tdd = pow(dist(pi, m) ** 2 - d ** 2, 0.5)\n\t\tdnv = dist(nv, (0, 0, 0))\n\t\tnnv = (dd * nv[0] / dnv + m[0], dd * nv[1] / dnv + m[1], dd * nv[2] / dnv + m[2])\n\t\tif dist(nnv, p[i]) < dist(p[i], m):\n\t\t\tdr = pow((R + p[i][3]) ** 2 - d ** 2, 0.5)\n\t\t\tdistance.append(dd - dr)\nif len(distance):\n\tdistance.sort()\n\tprint(distance[0] / dist(nv, (0, 0, 0)))\nelse:\n\tprint(-1)\n",
        "slowest_solution": "import sys, math\n\ndef dist(a, b):\n\treturn pow((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2, 0.5)\n\ndef vxv(v1, v2):\n\tx = -v1[2] * v2[1] + v1[1] * v2[2]\n\ty = -v1[0] * v2[2] + v1[2] * v2[0]\n\tz = -v1[1] * v2[0] + v1[0] * v2[1]\n\treturn (x, y, z)\nreadline = sys.stdin.readline\n(s1, s2, s3, v1, v2, v3, R) = map(int, readline().split())\nn = int(readline())\npm = []\np = []\nfor _ in range(n):\n\t(o1, o2, o3, r, m) = map(int, readline().split())\n\tp.append((o1, o2, o3, r))\n\tfor _ in range(m):\n\t\t(pm1, pm2, pm3) = map(int, readline().split())\n\t\tpm.append((pm1 + o1, pm2 + o2, pm3 + o3))\nnv = (v1, v2, v3)\nm = (s1, s2, s3)\ndistance = []\nfor x in pm:\n\ttp = (x[0] - m[0], x[1] - m[1], x[2] - m[2])\n\ttp1 = vxv(tp, nv)\n\td = dist(tp1, (0, 0, 0)) / dist(nv, (0, 0, 0))\n\tif d <= R:\n\t\tdd = pow(dist(x, m) ** 2 - d ** 2, 0.5)\n\t\tdnv = dist(nv, (0, 0, 0))\n\t\tnnv = (dd * nv[0] / dnv + m[0], dd * nv[1] / dnv + m[1], dd * nv[2] / dnv + m[2])\n\t\tif dist(nnv, x) < dist(x, m):\n\t\t\tdistance.append(dd - pow(R ** 2 - d ** 2, 0.5))\nfor i in range(len(p)):\n\tpi = (p[i][0], p[i][1], p[i][2])\n\ttp = (pi[0] - m[0], pi[1] - m[1], pi[2] - m[2])\n\ttp1 = vxv(tp, nv)\n\td = dist(tp1, (0, 0, 0)) / dist(nv, (0, 0, 0))\n\tif d - p[i][3] <= R:\n\t\tdd = pow(dist(pi, m) ** 2 - d ** 2, 0.5)\n\t\tdnv = dist(nv, (0, 0, 0))\n\t\tnnv = (dd * nv[0] / dnv + m[0], dd * nv[1] / dnv + m[1], dd * nv[2] / dnv + m[2])\n\t\tif dist(nnv, p[i]) < dist(p[i], m):\n\t\t\tdr = pow((R + p[i][3]) ** 2 - d ** 2, 0.5)\n\t\t\tdistance.append(dd - dr)\nif len(distance):\n\tdistance.sort()\n\tprint(distance[0] / dist(nv, (0, 0, 0)))\nelse:\n\tprint(-1)\n"
    },
    {
        "task_id": 639,
        "slowest_solution_id": 7,
        "fastest_solution_id": 5,
        "slowest_time": 3.329929828643799,
        "fastest_time": 2.629995346069336,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tans = [[0 for i in range(n)] for j in range(n)]\n\ti = 0\n\tj = 0\n\twhile i < k:\n\t\tx = 0\n\t\ty = j\n\t\twhile x < n and i < k:\n\t\t\tans[x][y] = 1\n\t\t\ti += 1\n\t\t\tx += 1\n\t\t\ty = (y + 1) % n\n\t\tj += 1\n\tif k % n == 0:\n\t\tprint(0)\n\telse:\n\t\tprint(2)\n\tfor j in ans:\n\t\tprint(''.join((str(x) for x in j)))\n",
        "slowest_solution": "def mi():\n\treturn map(int, input().split())\nfor _ in range(int(input())):\n\t(n, k) = mi()\n\tprint(2 * (k % n != 0))\n\ta = [[0] * n for i in range(n)]\n\t(i, j) = (0, 0)\n\tfor __ in range(k):\n\t\ta[i][j] = 1\n\t\ti += 1\n\t\tj += 1\n\t\tif i == n:\n\t\t\tj += 1\n\t\ti %= n\n\t\tj %= n\n\tfor i in a:\n\t\tfor j in i:\n\t\t\tprint(j, end='')\n\t\tprint()\n"
    },
    {
        "task_id": 668,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.676347494125366,
        "fastest_time": 2.4782049655914307,
        "fastest_solution": "import sys\nn = int(input())\nprob = [list(map(float, input().split())) for _ in range(n)]\ndp = [[0.0] * n for _ in range(1 << n)]\ndp[1][0] = 1.0\nfor mask in range(3, 1 << n):\n\tfor i in range(n):\n\t\tif not mask & 1 << i:\n\t\t\tcontinue\n\t\tfor j in range(n):\n\t\t\tif i != j and mask & 1 << j:\n\t\t\t\tdp[mask][i] = max(dp[mask][i], dp[mask - (1 << j)][i] * prob[i][j] + dp[mask - (1 << i)][j] * prob[j][i])\nprint(max(dp[-1]))\n",
        "slowest_solution": "import sys\nimport bisect\nfrom bisect import bisect_left as lb\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nfrom math import log\nfrom math import gcd\nfrom math import atan2, acos\nfrom random import randint\nsa = lambda : input_()\nsb = lambda : int(input_())\nsc = lambda : input_().split()\nsd = lambda : list(map(int, input_().split()))\nsflo = lambda : list(map(float, input_().split()))\nse = lambda : float(input_())\nsf = lambda : list(input_())\nflsh = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\ngp = []\ncost = []\ndp = []\nmx = []\nans1 = []\nans2 = []\nspecial = []\nspecnode = []\na = 0\nkthpar = []\n\ndef dfs(root, par):\n\tif par != -1:\n\t\tdp[root] = dp[par] + 1\n\tfor i in range(1, 20):\n\t\tif kthpar[root][i - 1] != -1:\n\t\t\tkthpar[root][i] = kthpar[kthpar[root][i - 1]][i - 1]\n\tfor child in gp[root]:\n\t\tif child == par:\n\t\t\tcontinue\n\t\tkthpar[child][0] = root\n\t\tdfs(child, root)\nans = 0\n\ndef hnbhai(t):\n\tn = sb()\n\tp = []\n\tfor i in range(n):\n\t\tp.append(sflo())\n\tdp = [0] * (1 << n)\n\tdp[1] = 1\n\tfor i in range(2, 1 << n):\n\t\tfor j in range(1, n):\n\t\t\tfor k in range(0, j):\n\t\t\t\tif i >> j & 1 and i >> k & 1:\n\t\t\t\t\tdp[i] = max(dp[i], dp[i ^ 1 << j] * p[k][j] + dp[i ^ 1 << k] * p[j][k])\n\tprint(dp[-1])\nfor _ in range(1):\n\thnbhai(_ + 1)\n"
    },
    {
        "task_id": 663,
        "slowest_solution_id": 7,
        "fastest_solution_id": 7,
        "slowest_time": 2.6668524742126465,
        "fastest_time": 2.6668524742126465,
        "fastest_solution": "import sys\nq = int(input())\nfor _ in range(q):\n\t_ = input()\n\t(n, k) = map(int, input().split())\n\tA = list(map(int, input().split()))\n\ttemp = list(map(int, input().split()))\n\tL = [sys.maxsize] * n\n\tR = [sys.maxsize] * n\n\tfor i in range(k):\n\t\tL[A[i] - 1] = temp[i]\n\t\tR[A[i] - 1] = temp[i]\n\tfor i in range(1, n):\n\t\tL[i] = min(L[i - 1] + 1, L[i])\n\tfor i in range(n - 2, -1, -1):\n\t\tR[i] = min(R[i + 1] + 1, R[i])\n\tAns = [0] * n\n\tfor i in range(n):\n\t\tAns[i] = min(L[i], R[i])\n\tfor a in Ans:\n\t\tprint(a, end=' ')\n\tprint()\n",
        "slowest_solution": "import sys\nq = int(input())\nfor _ in range(q):\n\t_ = input()\n\t(n, k) = map(int, input().split())\n\tA = list(map(int, input().split()))\n\ttemp = list(map(int, input().split()))\n\tL = [sys.maxsize] * n\n\tR = [sys.maxsize] * n\n\tfor i in range(k):\n\t\tL[A[i] - 1] = temp[i]\n\t\tR[A[i] - 1] = temp[i]\n\tfor i in range(1, n):\n\t\tL[i] = min(L[i - 1] + 1, L[i])\n\tfor i in range(n - 2, -1, -1):\n\t\tR[i] = min(R[i + 1] + 1, R[i])\n\tAns = [0] * n\n\tfor i in range(n):\n\t\tAns[i] = min(L[i], R[i])\n\tfor a in Ans:\n\t\tprint(a, end=' ')\n\tprint()\n"
    },
    {
        "task_id": 686,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "l = {'one': 5, 'two': 4, 'three': 3, 'four': 2, 'five': 1, 'six': 0}\ny = {'hhh': '----o----', 'hht': '---- ----', 'htt': '---------', 'ttt': '----x----'}\n\ndef oracle(arr):\n\ts = [''] * 6\n\tfor x in arr:\n\t\ts[l[x[0]]] = y[''.join(sorted(x[1:]))]\n\treturn '\\n'.join(s)\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 636,
        "slowest_solution_id": 6,
        "fastest_solution_id": 0,
        "slowest_time": 2.7140562534332275,
        "fastest_time": 2.4321072101593018,
        "fastest_solution": "t = int(input())\nwhile t > 0:\n\tS = list(input())\n\tl = len(S)\n\tFans = 0\n\tif S[-1] == 'N':\n\t\tFans = 1\n\t\tS[-1] = 'P'\n\tfor i in range(1, l):\n\t\tif S[i] == 'N' and S[i - 1] == 'N':\n\t\t\tS[i] = 'P'\n\t\t\tFans += 1\n\tnc = S.count('N')\n\tans = Fans + abs(l // 3 - nc)\n\tprint(ans)\n\tt -= 1\n",
        "slowest_solution": "for _ in range(int(input())):\n\ts = input()\n\tn_no = s.count('N')\n\tp_no = s.count('P')\n\tcnt = 0\n\tif s[-1] == 'N':\n\t\tcnt += 1\n\t\tn_no -= 1\n\t\tp_no += 1\n\ts = s[:len(s) - 1] + 'P'\n\tnn_no = 0\n\ti = 0\n\twhile i < len(s):\n\t\tif s[i:i + 2] == 'NN':\n\t\t\tnn_no += 1\n\t\t\ti += 1\n\t\ti += 1\n\tn_no -= nn_no\n\tp_no += nn_no\n\tcnt += nn_no\n\tn = len(s) // 3\n\tif n_no == n:\n\t\tprint(cnt)\n\telif n_no < n:\n\t\tcnt = cnt + n - n_no\n\t\tprint(cnt)\n\telif n_no > n:\n\t\tcnt = cnt + n_no - n\n\t\tprint(cnt)\n"
    },
    {
        "task_id": 690,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 0.0028624534606933594,
        "fastest_time": 0.0,
        "fastest_solution": "from itertools import combinations_with_replacement\n\ndef find_all(sum_dig, digs):\n\tcombs = combinations_with_replacement(list(range(1, 10)), digs)\n\ttarget = [''.join((str(x) for x in list(comb))) for comb in combs if sum(comb) == sum_dig]\n\tif not target:\n\t\treturn []\n\treturn [len(target), int(target[0]), int(target[-1])]\n",
        "slowest_solution": "def next_contig_number(n):\n\tn = [int(x) for x in str(n + 1)]\n\tfor i in range(1, len(n)):\n\t\tn[i] = max(n[i], n[i - 1])\n\treturn int(''.join(map(str, n)))\n\ndef find_all(sum_dig, digs):\n\tcount = 0\n\tsmallest = float('Inf')\n\tlargest = float('-Inf')\n\tn = 10 ** (digs - 1)\n\tlimit = 10 ** digs - 1\n\twhile n < limit:\n\t\tn = next_contig_number(n)\n\t\ttotal = 0\n\t\tfor x in map(int, str(n)):\n\t\t\ttotal += x\n\t\t\tif total > sum_dig:\n\t\t\t\tbreak\n\t\tif total == sum_dig:\n\t\t\tcount += 1\n\t\t\tsmallest = min(smallest, n)\n\t\t\tlargest = max(largest, n)\n\treturn [count, smallest, largest] if count else []\n"
    },
    {
        "task_id": 681,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.833357810974121,
        "fastest_time": 2.833357810974121,
        "fastest_solution": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\nmod = 10 ** 9 + 7\n\ndef LI():\n\treturn list(map(int, input().split()))\n\ndef II():\n\treturn int(input())\n\ndef LS():\n\treturn input().split()\n\ndef S():\n\treturn input()\n\ndef main():\n\tn = II()\n\td = collections.defaultdict(set)\n\tfor _ in range(n - 1):\n\t\t(a, b) = LI()\n\t\td[a].add(b)\n\t\td[b].add(a)\n\tmemo = {}\n\n\tdef path(t, s):\n\t\tps = set()\n\t\tdt = list(d[t])\n\t\tfor k in dt:\n\t\t\tif k not in memo:\n\t\t\t\tcontinue\n\t\t\tif memo[k] in ps:\n\t\t\t\td[k] -= set([t])\n\t\t\t\td[t] -= set([k])\n\t\t\tps.add(memo[k])\n\t\tif s == -1 and len(ps) == 2:\n\t\t\tmemo[t] = sum(ps) + 2\n\t\t\treturn memo[t]\n\t\tif len(ps) > 1:\n\t\t\treturn -t\n\t\tif len(ps) == 0:\n\t\t\tmemo[t] = 0\n\t\t\treturn 0\n\t\tmemo[t] = list(ps)[0] + 1\n\t\treturn memo[t]\n\n\tdef _path(tt, ss):\n\t\tq = [(tt, ss)]\n\t\ttq = []\n\t\tqi = 0\n\t\twhile len(q) > qi:\n\t\t\t(t, s) = q[qi]\n\t\t\tfor k in d[t]:\n\t\t\t\tif k == s:\n\t\t\t\t\tcontinue\n\t\t\t\tq.append((k, t))\n\t\t\tqi += 1\n\t\tfor (t, s) in q[::-1]:\n\t\t\tr = path(t, s)\n\t\t\tif r < 0:\n\t\t\t\treturn r\n\t\treturn memo[tt]\n\n\tdef _path2(tt, ss):\n\t\tq = [(tt, ss)]\n\t\ttq = []\n\t\tqi = 0\n\t\twhile len(q) > qi:\n\t\t\t(t, s) = q[qi]\n\t\t\tfor k in d[t]:\n\t\t\t\tif k == s or k in memo:\n\t\t\t\t\tcontinue\n\t\t\t\tq.append((k, t))\n\t\t\tqi += 1\n\t\tfor (t, s) in q[::-1]:\n\t\t\tr = path(t, s)\n\t\t\tif r < 0:\n\t\t\t\treturn r\n\t\treturn memo[tt]\n\tt = _path(1, -1)\n\tif t < 0:\n\t\tt = _path2(-t, -1)\n\tif t > 0:\n\t\twhile t % 2 == 0:\n\t\t\tt //= 2\n\t\treturn t\n\treturn -1\nprint(main())\n",
        "slowest_solution": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\nmod = 10 ** 9 + 7\n\ndef LI():\n\treturn list(map(int, input().split()))\n\ndef II():\n\treturn int(input())\n\ndef LS():\n\treturn input().split()\n\ndef S():\n\treturn input()\n\ndef main():\n\tn = II()\n\td = collections.defaultdict(set)\n\tfor _ in range(n - 1):\n\t\t(a, b) = LI()\n\t\td[a].add(b)\n\t\td[b].add(a)\n\tmemo = {}\n\n\tdef path(t, s):\n\t\tps = set()\n\t\tdt = list(d[t])\n\t\tfor k in dt:\n\t\t\tif k not in memo:\n\t\t\t\tcontinue\n\t\t\tif memo[k] in ps:\n\t\t\t\td[k] -= set([t])\n\t\t\t\td[t] -= set([k])\n\t\t\tps.add(memo[k])\n\t\tif s == -1 and len(ps) == 2:\n\t\t\tmemo[t] = sum(ps) + 2\n\t\t\treturn memo[t]\n\t\tif len(ps) > 1:\n\t\t\treturn -t\n\t\tif len(ps) == 0:\n\t\t\tmemo[t] = 0\n\t\t\treturn 0\n\t\tmemo[t] = list(ps)[0] + 1\n\t\treturn memo[t]\n\n\tdef _path(tt, ss):\n\t\tq = [(tt, ss)]\n\t\ttq = []\n\t\tqi = 0\n\t\twhile len(q) > qi:\n\t\t\t(t, s) = q[qi]\n\t\t\tfor k in d[t]:\n\t\t\t\tif k == s:\n\t\t\t\t\tcontinue\n\t\t\t\tq.append((k, t))\n\t\t\tqi += 1\n\t\tfor (t, s) in q[::-1]:\n\t\t\tr = path(t, s)\n\t\t\tif r < 0:\n\t\t\t\treturn r\n\t\treturn memo[tt]\n\n\tdef _path2(tt, ss):\n\t\tq = [(tt, ss)]\n\t\ttq = []\n\t\tqi = 0\n\t\twhile len(q) > qi:\n\t\t\t(t, s) = q[qi]\n\t\t\tfor k in d[t]:\n\t\t\t\tif k == s or k in memo:\n\t\t\t\t\tcontinue\n\t\t\t\tq.append((k, t))\n\t\t\tqi += 1\n\t\tfor (t, s) in q[::-1]:\n\t\t\tr = path(t, s)\n\t\t\tif r < 0:\n\t\t\t\treturn r\n\t\treturn memo[tt]\n\tt = _path(1, -1)\n\tif t < 0:\n\t\tt = _path2(-t, -1)\n\tif t > 0:\n\t\twhile t % 2 == 0:\n\t\t\tt //= 2\n\t\treturn t\n\treturn -1\nprint(main())\n"
    },
    {
        "task_id": 637,
        "slowest_solution_id": 9,
        "fastest_solution_id": 0,
        "slowest_time": 2.7079153060913086,
        "fastest_time": 2.4238674640655518,
        "fastest_solution": "import os\nimport sys\nfrom math import *\nfrom collections import *\nfrom bisect import *\nfrom io import BytesIO, IOBase\nfrom fractions import *\n\ndef vsInput():\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef value():\n\treturn tuple(map(int, input().split()))\n\ndef array():\n\treturn [int(i) for i in input().split()]\n\ndef Int():\n\treturn int(input())\n\ndef Str():\n\treturn input()\n\ndef arrayS():\n\treturn [i for i in input().split()]\nfor _ in range(Int()):\n\tn = int(input())\n\ta = sorted(array())\n\tind = bisect_right(a, n)\n\tsize = []\n\td = Counter(a)\n\tans = 0\n\tfor i in d:\n\t\tif d[i] >= i:\n\t\t\tsize += [i] * (d[i] // i)\n\t\t\tans += d[i] // i\n\t\t\td[i] = d[i] % i\n\trem = []\n\tfor i in a:\n\t\tif d[i] != 0:\n\t\t\trem.append(i)\n\t\t\td[i] -= 1\n\tsi = 0\n\tfor i in rem:\n\t\tif si + 1 == i:\n\t\t\tans += 1\n\t\t\tsi = -1\n\t\tsi += 1\n\tprint(ans)\n",
        "slowest_solution": "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\nt = int(input())\nfor test in range(t):\n\tn = int(input())\n\tval = [int(x) for x in input().split()]\n\tval.sort()\n\ti = 1\n\tans = 0\n\tc = 1\n\tmaxx = val[0]\n\twhile i < n:\n\t\tif c < maxx:\n\t\t\tmaxx = max(maxx, val[i])\n\t\t\tc += 1\n\t\telse:\n\t\t\tans += 1\n\t\t\tmaxx = val[i]\n\t\t\tc = 1\n\t\ti += 1\n\tif c == maxx:\n\t\tans += 1\n\tprint(ans)\n"
    },
    {
        "task_id": 689,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7535760402679443,
        "fastest_time": 2.7535760402679443,
        "fastest_solution": "import array\nimport math\nimport os\nimport sys\nDEBUG = 'DEBUG' in os.environ\n\ndef inp():\n\treturn sys.stdin.readline().rstrip()\n\ndef dprint(*value, sep=' ', end='\\n'):\n\tif DEBUG:\n\t\tprint(*value, sep=sep, end=end)\n\ndef solve(N, M, G):\n\tif N == 2:\n\t\treturn [0, 1]\n\tdegv = [set() for _ in range(5)]\n\tfor i in range(M):\n\t\td = len(G[i])\n\t\tif d == 0 or d >= 5:\n\t\t\treturn []\n\t\tdegv[d].add(i)\n\tlayer_vcount = 1 << N - 1\n\tvs = degv[1]\n\tlevels = bytearray(M)\n\tans = []\n\tfor level in range(1, N):\n\t\tif len(vs) not in (layer_vcount - 1, layer_vcount):\n\t\t\treturn []\n\t\tif len(vs) == layer_vcount - 1:\n\t\t\tif ans:\n\t\t\t\treturn []\n\t\t\tif level == 1:\n\t\t\t\tsp_deg_off = -1\n\t\t\telse:\n\t\t\t\tsp_deg_off = 1\n\t\telse:\n\t\t\tsp_deg_off = 0\n\t\tndeg = 3 if level < N - 1 else 2\n\t\tus = set()\n\t\tss = set()\n\t\tfor v in vs:\n\t\t\tlevels[v] = level\n\t\t\tp = None\n\t\t\tfor u in G[v]:\n\t\t\t\tif levels[u] == 0:\n\t\t\t\t\tif p is not None:\n\t\t\t\t\t\treturn []\n\t\t\t\t\tp = u\n\t\t\t\t\tbreak\n\t\t\tif p is None:\n\t\t\t\treturn []\n\t\t\tdeg = len(G[p])\n\t\t\tif deg == ndeg:\n\t\t\t\tus.add(p)\n\t\t\telif deg == ndeg + sp_deg_off:\n\t\t\t\tss.add(p)\n\t\t\telif sp_deg_off == 0 and deg == ndeg + 1:\n\t\t\t\tss.add(p)\n\t\t\telse:\n\t\t\t\treturn []\n\t\tif sp_deg_off != 0:\n\t\t\tif len(ss) != 1:\n\t\t\t\treturn []\n\t\t\t(sp,) = list(ss)\n\t\t\tans = [sp]\n\t\t\tus.add(sp)\n\t\tif sp_deg_off == 0:\n\t\t\tif level == N - 2:\n\t\t\t\tif ss:\n\t\t\t\t\treturn []\n\t\t\t\tif not ans:\n\t\t\t\t\tli = list(us)\n\t\t\t\t\tli.sort()\n\t\t\t\t\treturn li\n\t\t\tif len(ss) > 1:\n\t\t\t\treturn []\n\t\tvs = us\n\t\tlayer_vcount >>= 1\n\treturn ans\n\ndef main():\n\tN = int(inp())\n\tM = (1 << N) - 2\n\tG = [[] for _ in range(M)]\n\tfor _ in range(M - 1):\n\t\t(a, b) = [int(e) - 1 for e in inp().split()]\n\t\tG[a].append(b)\n\t\tG[b].append(a)\n\tans = solve(N, M, G)\n\tprint(len(ans))\n\tif ans:\n\t\tprint(*[v + 1 for v in ans])\nmain()\n",
        "slowest_solution": "import array\nimport math\nimport os\nimport sys\nDEBUG = 'DEBUG' in os.environ\n\ndef inp():\n\treturn sys.stdin.readline().rstrip()\n\ndef dprint(*value, sep=' ', end='\\n'):\n\tif DEBUG:\n\t\tprint(*value, sep=sep, end=end)\n\ndef solve(N, M, G):\n\tif N == 2:\n\t\treturn [0, 1]\n\tdegv = [set() for _ in range(5)]\n\tfor i in range(M):\n\t\td = len(G[i])\n\t\tif d == 0 or d >= 5:\n\t\t\treturn []\n\t\tdegv[d].add(i)\n\tlayer_vcount = 1 << N - 1\n\tvs = degv[1]\n\tlevels = bytearray(M)\n\tans = []\n\tfor level in range(1, N):\n\t\tif len(vs) not in (layer_vcount - 1, layer_vcount):\n\t\t\treturn []\n\t\tif len(vs) == layer_vcount - 1:\n\t\t\tif ans:\n\t\t\t\treturn []\n\t\t\tif level == 1:\n\t\t\t\tsp_deg_off = -1\n\t\t\telse:\n\t\t\t\tsp_deg_off = 1\n\t\telse:\n\t\t\tsp_deg_off = 0\n\t\tndeg = 3 if level < N - 1 else 2\n\t\tus = set()\n\t\tss = set()\n\t\tfor v in vs:\n\t\t\tlevels[v] = level\n\t\t\tp = None\n\t\t\tfor u in G[v]:\n\t\t\t\tif levels[u] == 0:\n\t\t\t\t\tif p is not None:\n\t\t\t\t\t\treturn []\n\t\t\t\t\tp = u\n\t\t\t\t\tbreak\n\t\t\tif p is None:\n\t\t\t\treturn []\n\t\t\tdeg = len(G[p])\n\t\t\tif deg == ndeg:\n\t\t\t\tus.add(p)\n\t\t\telif deg == ndeg + sp_deg_off:\n\t\t\t\tss.add(p)\n\t\t\telif sp_deg_off == 0 and deg == ndeg + 1:\n\t\t\t\tss.add(p)\n\t\t\telse:\n\t\t\t\treturn []\n\t\tif sp_deg_off != 0:\n\t\t\tif len(ss) != 1:\n\t\t\t\treturn []\n\t\t\t(sp,) = list(ss)\n\t\t\tans = [sp]\n\t\t\tus.add(sp)\n\t\tif sp_deg_off == 0:\n\t\t\tif level == N - 2:\n\t\t\t\tif ss:\n\t\t\t\t\treturn []\n\t\t\t\tif not ans:\n\t\t\t\t\tli = list(us)\n\t\t\t\t\tli.sort()\n\t\t\t\t\treturn li\n\t\t\tif len(ss) > 1:\n\t\t\t\treturn []\n\t\tvs = us\n\t\tlayer_vcount >>= 1\n\treturn ans\n\ndef main():\n\tN = int(inp())\n\tM = (1 << N) - 2\n\tG = [[] for _ in range(M)]\n\tfor _ in range(M - 1):\n\t\t(a, b) = [int(e) - 1 for e in inp().split()]\n\t\tG[a].append(b)\n\t\tG[b].append(a)\n\tans = solve(N, M, G)\n\tprint(len(ans))\n\tif ans:\n\t\tprint(*[v + 1 for v in ans])\nmain()\n"
    },
    {
        "task_id": 682,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.794044256210327,
        "fastest_time": 2.518195152282715,
        "fastest_solution": "import sys\nreadline = sys.stdin.readline\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\n\ndef solve():\n\t(n, a, b) = nm()\n\tlr = [tuple(nm()) for _ in range(n)]\n\tevent = [(l, 1) for (l, r) in lr] + [(r + 1, -1) for (l, r) in lr] + [(10 ** 20, 0)]\n\tevent.sort()\n\tans = cur = 0\n\tbef = 0\n\tfor (t, v) in event:\n\t\t(l, r, c) = (bef, t - 1, cur)\n\t\tbef = t\n\t\tcur += v\n\t\tif ans >= c:\n\t\t\tcontinue\n\t\tok = 0\n\t\tng = b - a + 2\n\t\twhile ng - ok > 1:\n\t\t\tmid = (ok + ng) // 2\n\t\t\tif (b + b - mid + 1) * mid // 2 < l:\n\t\t\t\tok = mid\n\t\t\telse:\n\t\t\t\tng = mid\n\t\tif ok < b - a + 1 and (a + a + ok) * (ok + 1) // 2 <= r:\n\t\t\tans = c\n\tprint(ans)\n\ndef main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tsolve()\nmain()\n",
        "slowest_solution": "def find(x, y):\n\t(l, r) = (1, b - a + 1)\n\twhile l <= r:\n\t\tmid = (l + r) // 2\n\t\tn = mid + a - 1\n\t\tn = n * (n + 1) // 2 - u\n\t\tif n < x:\n\t\t\tm = b - mid\n\t\t\tm = v - m * (m + 1) // 2\n\t\t\tif m >= x:\n\t\t\t\treturn True\n\t\t\tl = mid + 1\n\t\tif n >= x and n <= y:\n\t\t\treturn True\n\t\tif n > y:\n\t\t\tr = mid - 1\n\treturn False\nfor _ in range(int(input())):\n\t(n, a, b) = map(int, input().split())\n\t(l, r) = ([], [])\n\tfor _ in range(n):\n\t\t(x, y) = map(int, input().split())\n\t\tl.append(x)\n\t\tr.append(y)\n\tl.sort()\n\tr.sort()\n\tans = 0\n\t(u, v) = (a * (a - 1) // 2, b * (b + 1) // 2)\n\t(temp, j) = (0, 0)\n\tt = []\n\tfor i in l:\n\t\twhile i > r[j]:\n\t\t\tq = t.pop()\n\t\t\tif ans < temp:\n\t\t\t\tif find(q, r[j]):\n\t\t\t\t\tans = temp\n\t\t\tj = j + 1\n\t\t\ttemp = temp - 1\n\t\ttemp = temp + 1\n\t\tt.append(i)\n\t\tif ans < temp:\n\t\t\tif find(i, r[j]):\n\t\t\t\tans = temp\n\twhile len(t):\n\t\tif ans < len(t):\n\t\t\tif find(t.pop(), r[j]):\n\t\t\t\tans = len(t) + 1\n\t\t\tj = j + 1\n\t\t\tcontinue\n\t\tbreak\n\tprint(ans)\n"
    },
    {
        "task_id": 695,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "triangular_sum = lambda n: (-0.5 + (1 + 8 * n) ** 0.5 / 2.0) ** 0.5 % 1 == 0\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 641,
        "slowest_solution_id": 8,
        "fastest_solution_id": 6,
        "slowest_time": 2.749105930328369,
        "fastest_time": 2.477560043334961,
        "fastest_solution": "from collections import defaultdict\nimport sys, math\nf = None\ntry:\n\tf = open('q1.input', 'r')\nexcept IOError:\n\tf = sys.stdin\nif 'xrange' in dir(__builtins__):\n\trange = xrange\n\ndef solution(a, n):\n\tdraw = True\n\tfor i in range(50, -1, -1):\n\t\tcnt = 0\n\t\tfor x in a:\n\t\t\tif 1 << i & x:\n\t\t\t\tcnt += 1\n\t\tif cnt % 2:\n\t\t\tdraw = False\n\t\t\tbreak\n\tif draw:\n\t\treturn 'DRAW'\n\tif (cnt - 1) % 4 == 0:\n\t\treturn 'WIN'\n\twin = (cnt + 1) // 2 % 2\n\twin = win ^ (n - cnt) % 2\n\treturn 'WIN' if win else 'LOSE'\n\ndef main():\n\tfor i in range(int(input())):\n\t\tn = int(input())\n\t\ta = list(map(int, input().split()))\n\t\tx = solution(a, n)\n\t\tif 'xrange' not in dir(__builtins__):\n\t\t\tprint(x)\n\t\telse:\n\t\t\t(print >> output, 'Case #' + str(i + 1) + ':', str(x))\n\tif 'xrange' in dir(__builtins__):\n\t\tprint(output.getvalue())\n\t\toutput.close()\nif 'xrange' in dir(__builtins__):\n\timport cStringIO\n\toutput = cStringIO.StringIO()\nmain()\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tv = len(bin(max(a))) - 2\n\tf = 1\n\tz = ['0' * (v + 2 - len(bin(i))) + bin(i)[2:] for i in a]\n\tfor i in range(v):\n\t\tb = 0\n\t\tfor j in z:\n\t\t\tif j[i] == '1':\n\t\t\t\tb += 1\n\t\tif b % 2:\n\t\t\tif b // 2 % 2 and n % 2:\n\t\t\t\tprint('LOSE')\n\t\t\telse:\n\t\t\t\tprint('WIN')\n\t\t\tf = 0\n\t\t\tbreak\n\tif f:\n\t\tprint('DRAW')\n"
    },
    {
        "task_id": 645,
        "slowest_solution_id": 8,
        "fastest_solution_id": 5,
        "slowest_time": 2.7380635738372803,
        "fastest_time": 2.3973448276519775,
        "fastest_solution": "import heapq\n(n, m) = map(int, input().split())\nvertexs = dict()\nfor i in range(1, n + 1):\n\tvertexs[i] = []\nfor j in range(m):\n\t(v, u) = map(int, input().split())\n\tif v != u:\n\t\tvertexs[v].append(u)\n\t\tvertexs[u].append(v)\nvis = dict()\ndp = [1]\nvis[1] = True\nanswers = []\nfor i in range(n):\n\tnext_v = heapq.heappop(dp)\n\tanswers.append(next_v)\n\tvis[next_v] = True\n\tfor u in vertexs[next_v]:\n\t\tif u not in vis:\n\t\t\theapq.heappush(dp, u)\n\t\t\tvis[u] = True\nprint(*answers, sep=' ')\n",
        "slowest_solution": "import heapq\nfrom collections import defaultdict as dd\n(n, m) = map(int, input().split())\nd = dd(list)\nfor i in range(m):\n\t(u, v) = map(int, input().split())\n\td[u].append(v)\n\td[v].append(u)\nhq = [1]\nheapq.heapify(hq)\nl = []\nvis = [0] * (n + 1)\nwhile hq:\n\ta = heapq.heappop(hq)\n\tl.append(a)\n\tvis[a] = 1\n\tfor j in d[a]:\n\t\tif vis[j] == 0:\n\t\t\theapq.heappush(hq, j)\n\t\t\tvis[j] = 1\nprint(*l)\n"
    },
    {
        "task_id": 644,
        "slowest_solution_id": 8,
        "fastest_solution_id": 5,
        "slowest_time": 2.7265331745147705,
        "fastest_time": 2.445120334625244,
        "fastest_solution": "def cb(l, n, arr, to_base=10):\n\tif n < to_base:\n\t\tarr[l] += n\n\t\treturn\n\telse:\n\t\tcb(l + 1, n // to_base, arr, to_base)\n\t\tarr[l] += n % to_base\n\t\treturn\nt = int(input())\nfor i in range(t):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\td = dict()\n\tarr = [0 for i in range(100)]\n\tfor z in a:\n\t\tcb(1, z, arr, k)\n\tif max(arr) > 1:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n",
        "slowest_solution": "def maxPow(p, k):\n\tn = p\n\ti = 0\n\twhile p > 0:\n\t\tp //= k\n\t\ti += 1\n\tif k ** i > n:\n\t\ti -= 1\n\treturn i\n\ndef pows(n, k, s):\n\twhile n > 0:\n\t\tp = maxPow(n, k)\n\t\tn -= k ** p\n\t\tif p in s:\n\t\t\treturn False\n\t\telse:\n\t\t\ts.add(p)\n\treturn True\nt = int(input())\nfor i in range(t):\n\t(n, k) = map(int, input().split())\n\tl = list(map(int, input().split()))\n\tres = True\n\ts = set()\n\tfor j in l:\n\t\tif j > 0:\n\t\t\tres = res and pows(j, k, s)\n\tif res:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 633,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 3.46270751953125,
        "fastest_time": 2.7453255653381348,
        "fastest_solution": "class Platforms:\n\n\t@classmethod\n\tdef read_input(cls):\n\t\tnums = list(map(int, input('').split()))\n\t\treturn (nums[0], nums[1], nums[2], nums[3])\n\n\t@classmethod\n\tdef run(cls):\n\t\t(n, d, m, l) = cls.read_input()\n\t\tend_plat = (n - 1) * m + l\n\t\tfor cur_jump in range(d, (m + 1) * d, d):\n\t\t\tif cur_jump % m > l or cur_jump > end_plat:\n\t\t\t\tprint(cur_jump)\n\t\t\t\treturn\n\t\tprint(end_plat - end_plat % d + d)\nPlatforms.run()\n",
        "slowest_solution": "from sys import stdin, stdout\nfrom math import gcd, ceil, sqrt\nii1 = lambda : int(stdin.readline().strip())\nis1 = lambda : stdin.readline().strip()\niia = lambda : list(map(int, stdin.readline().strip().split()))\nisa = lambda : stdin.readline().strip().split()\nmod = 1000000007\n(n, d, m, l) = iia()\nfor i in range(1, n + 1):\n\tx = (i - 1) * m + l\n\ty = i * m - 1\n\tif x // d != y // d:\n\t\tbreak\nprint(x // d * d + d)\n"
    },
    {
        "task_id": 646,
        "slowest_solution_id": 4,
        "fastest_solution_id": 5,
        "slowest_time": 2.7041969299316406,
        "fastest_time": 2.445709705352783,
        "fastest_solution": "n = int(input())\nmaxl1 = 0\nminr1 = 100000000000000\nfor _ in range(0, n):\n\t(a, b) = list(map(int, input().split()))\n\tmaxl1 = max(a, maxl1)\n\tminr1 = min(b, minr1)\nn = int(input())\nmaxl2 = 0\nminr2 = 100000000000000\nfor _ in range(0, n):\n\t(a, b) = list(map(int, input().split()))\n\tmaxl2 = max(a, maxl2)\n\tminr2 = min(b, minr2)\nprint(max(max(0, maxl1 - minr2), max(0, maxl2 - minr1)))\n",
        "slowest_solution": "import sys\nfrom collections import defaultdict\nshapes = defaultdict(int)\nchess_starts = list()\nchess_ends = list()\nprog_starts = list()\nprog_ends = list()\nn1 = int(sys.stdin.readline())\nfor i in range(n1):\n\tinput = sys.stdin.readline().strip().split()\n\tchess_starts.append(int(input[0]))\n\tchess_ends.append(int(input[1]))\nn2 = int(sys.stdin.readline())\nfor i in range(n2):\n\tinput = sys.stdin.readline().strip().split()\n\tprog_starts.append(int(input[0]))\n\tprog_ends.append(int(input[1]))\nmax_prog_start = max(prog_starts)\nmin_prog_end = min(prog_ends)\nmax_chess_start = max(chess_starts)\nmin_chess_end = min(chess_ends)\nmax_a = 0\nmax_b = 0\nif min_prog_end < min_chess_end:\n\tmax_a = max_chess_start - min_prog_end\nelse:\n\tmax_a = max_prog_start - min_chess_end\nif max_prog_start < max_chess_start:\n\tmax_b = max_chess_start - min_prog_end\nelse:\n\tmax_b = max_prog_start - min_chess_end\nif max(max_a, max_b) < 0:\n\tprint(0)\nelse:\n\tprint(max(max_a, max_b))\n"
    },
    {
        "task_id": 648,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.4701428413391113,
        "fastest_time": 2.4701428413391113,
        "fastest_solution": "for _ in range(int(input())):\n\t(N, A, B) = map(int, input().split())\n\t(A_Temp, B_Temp) = (A, B)\n\tC = 0\n\tD = 0\n\tE = 0\n\tfor i in range(N):\n\t\tcurrentBit = 2 ** (N - i - 1)\n\t\tcount = 0\n\t\tif A_Temp >= currentBit:\n\t\t\tA_Temp -= currentBit\n\t\t\tcount += 1\n\t\tif B_Temp >= currentBit:\n\t\t\tB_Temp -= currentBit\n\t\t\tcount += 1\n\t\tif count == 1 and D == 0:\n\t\t\tD += currentBit\n\t\telif count == 1:\n\t\t\tE += currentBit\n\t\telif count == 2 or count == 0:\n\t\t\tC += currentBit\n\tSum = 2 ** N - C - 1\n\tD = Sum - E\n\tX = C + D ^ A\n\tprint(X)\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(N, A, B) = map(int, input().split())\n\t(A_Temp, B_Temp) = (A, B)\n\tC = 0\n\tD = 0\n\tE = 0\n\tfor i in range(N):\n\t\tcurrentBit = 2 ** (N - i - 1)\n\t\tcount = 0\n\t\tif A_Temp >= currentBit:\n\t\t\tA_Temp -= currentBit\n\t\t\tcount += 1\n\t\tif B_Temp >= currentBit:\n\t\t\tB_Temp -= currentBit\n\t\t\tcount += 1\n\t\tif count == 1 and D == 0:\n\t\t\tD += currentBit\n\t\telif count == 1:\n\t\t\tE += currentBit\n\t\telif count == 2 or count == 0:\n\t\t\tC += currentBit\n\tSum = 2 ** N - C - 1\n\tD = Sum - E\n\tX = C + D ^ A\n\tprint(X)\n"
    },
    {
        "task_id": 649,
        "slowest_solution_id": 5,
        "fastest_solution_id": 4,
        "slowest_time": 2.662715196609497,
        "fastest_time": 2.4351956844329834,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ttet = list(map(int, input().split()))\n\ttet_tmp = []\n\tfor i in tet:\n\t\ttet_tmp.append(i % 2)\n\tif tet_tmp[1:].__contains__(abs(tet_tmp[0] - 1)):\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n",
        "slowest_solution": "for t in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tc1 = 0\n\tc2 = 0\n\tfor i in a:\n\t\tif i % 2 == 0:\n\t\t\tc1 += 1\n\t\telse:\n\t\t\tc2 += 1\n\tif c1 == n or c2 == n:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 699,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.698594808578491,
        "fastest_time": 2.698594808578491,
        "fastest_solution": "Mod = 1000000007\n(n, k) = map(int, input().split(' '))\ns = ' ' + input()\n(f, fs, g, gs, w) = ([0] * 1000005, [0] * 1000005, [0] * 1000005, [0] * 1000005, [0] * 1000005)\n(qx, qw, qb) = ([0] * 1000005, [0] * 1000005, [0] * 1000005)\nq = 0\nf[0] = fs[0] = 1\nfor i in range(1, n + 1):\n\tlg = i - k if i - k >= q else q\n\tif s[i] != 'B':\n\t\tf[i] = fs[i - 1] - fs[lg - 1] + Mod\n\t\tf[i] -= Mod if f[i] >= Mod else 0\n\telse:\n\t\tf[i] = 0\n\tfs[i] = fs[i - 1] + f[i]\n\tfs[i] -= Mod if fs[i] >= Mod else 0\n\tif s[i] == 'W':\n\t\tq = i\ng[n + 1] = gs[n + 1] = 1\nq = n + 1\nfor i in range(n, 0, -1):\n\trg = i + k if i + k <= q else q\n\tif s[i] != 'W':\n\t\tg[i] = gs[i + 1] - gs[rg + 1] + Mod\n\t\tg[i] -= Mod if g[i] >= Mod else 0\n\telse:\n\t\tg[i] = 0\n\tgs[i] = gs[i + 1] + g[i]\n\tgs[i] -= Mod if gs[i] >= Mod else 0\n\tif s[i] == 'B':\n\t\tq = i\nfor i in range(1, n + 1):\n\t(qx[i], qb[i], qw[i]) = (qx[i - 1] + (s[i] == 'X'), qb[i - 1] + (s[i] == 'B'), qw[i - 1] + (s[i] == 'W'))\nfor i in range(n, 0, -1):\n\tw[i] = w[i + 1]\n\tif s[i] == 'X':\n\t\tw[i] *= 2\n\t\tw[i] -= Mod if w[i] >= Mod else 0\n\tif i + k - 1 <= n:\n\t\tif qb[i + k - 1] - qb[i - 1] == 0:\n\t\t\tw[i] += g[i + k]\n\t\t\tw[i] -= Mod if w[i] >= Mod else 0\nans = 0\nfor i in range(k, n + 1):\n\tif qw[i] - qw[i - k] == 0:\n\t\tans = (ans + f[i - k] * w[i + 1]) % Mod\nprint(ans)\n",
        "slowest_solution": "Mod = 1000000007\n(n, k) = map(int, input().split(' '))\ns = ' ' + input()\n(f, fs, g, gs, w) = ([0] * 1000005, [0] * 1000005, [0] * 1000005, [0] * 1000005, [0] * 1000005)\n(qx, qw, qb) = ([0] * 1000005, [0] * 1000005, [0] * 1000005)\nq = 0\nf[0] = fs[0] = 1\nfor i in range(1, n + 1):\n\tlg = i - k if i - k >= q else q\n\tif s[i] != 'B':\n\t\tf[i] = fs[i - 1] - fs[lg - 1] + Mod\n\t\tf[i] -= Mod if f[i] >= Mod else 0\n\telse:\n\t\tf[i] = 0\n\tfs[i] = fs[i - 1] + f[i]\n\tfs[i] -= Mod if fs[i] >= Mod else 0\n\tif s[i] == 'W':\n\t\tq = i\ng[n + 1] = gs[n + 1] = 1\nq = n + 1\nfor i in range(n, 0, -1):\n\trg = i + k if i + k <= q else q\n\tif s[i] != 'W':\n\t\tg[i] = gs[i + 1] - gs[rg + 1] + Mod\n\t\tg[i] -= Mod if g[i] >= Mod else 0\n\telse:\n\t\tg[i] = 0\n\tgs[i] = gs[i + 1] + g[i]\n\tgs[i] -= Mod if gs[i] >= Mod else 0\n\tif s[i] == 'B':\n\t\tq = i\nfor i in range(1, n + 1):\n\t(qx[i], qb[i], qw[i]) = (qx[i - 1] + (s[i] == 'X'), qb[i - 1] + (s[i] == 'B'), qw[i - 1] + (s[i] == 'W'))\nfor i in range(n, 0, -1):\n\tw[i] = w[i + 1]\n\tif s[i] == 'X':\n\t\tw[i] *= 2\n\t\tw[i] -= Mod if w[i] >= Mod else 0\n\tif i + k - 1 <= n:\n\t\tif qb[i + k - 1] - qb[i - 1] == 0:\n\t\t\tw[i] += g[i + k]\n\t\t\tw[i] -= Mod if w[i] >= Mod else 0\nans = 0\nfor i in range(k, n + 1):\n\tif qw[i] - qw[i - k] == 0:\n\t\tans = (ans + f[i - k] * w[i + 1]) % Mod\nprint(ans)\n"
    },
    {
        "task_id": 652,
        "slowest_solution_id": 8,
        "fastest_solution_id": 3,
        "slowest_time": 2.70786190032959,
        "fastest_time": 2.368330240249634,
        "fastest_solution": "def evenTree(e):\n\tif len(e) <= 2:\n\t\treturn 0\n\tfor i in e:\n\t\tif len(e[i]) == 1:\n\t\t\tcontinue\n\t\tfor j in e[i]:\n\t\t\ts = [i]\n\t\t\tvisited = {j}\n\t\t\tcount = 0\n\t\t\tedges = {}\n\t\t\twhile len(s) > 0:\n\t\t\t\tcurr = s.pop(-1)\n\t\t\t\tfor k in e[curr]:\n\t\t\t\t\tif k not in visited:\n\t\t\t\t\t\ts.append(k)\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\t\tvisited.add(k)\n\t\t\t\t\t\tif curr not in edges:\n\t\t\t\t\t\t\tedges[curr] = [k]\n\t\t\t\t\t\telif k not in edges[curr]:\n\t\t\t\t\t\t\tedges[curr].append(k)\n\t\t\t\t\t\tif k not in edges:\n\t\t\t\t\t\t\tedges[k] = [curr]\n\t\t\t\t\t\telif curr not in edges[k]:\n\t\t\t\t\t\t\tedges[k].append(curr)\n\t\t\tif count > 0 and count % 2 == 0:\n\t\t\t\ts = [j]\n\t\t\t\tvisited = {i}\n\t\t\t\tedges2 = {}\n\t\t\t\twhile len(s) > 0:\n\t\t\t\t\tcurr = s.pop(-1)\n\t\t\t\t\tfor k in e[curr]:\n\t\t\t\t\t\tif k not in visited:\n\t\t\t\t\t\t\ts.append(k)\n\t\t\t\t\t\t\tvisited.add(k)\n\t\t\t\t\t\t\tif curr not in edges2:\n\t\t\t\t\t\t\t\tedges2[curr] = [k]\n\t\t\t\t\t\t\telif k not in edges2[curr]:\n\t\t\t\t\t\t\t\tedges2[curr].append(k)\n\t\t\t\t\t\t\tif k not in edges2:\n\t\t\t\t\t\t\t\tedges2[k] = [curr]\n\t\t\t\t\t\t\telif curr not in edges2[k]:\n\t\t\t\t\t\t\t\tedges2[k].append(curr)\n\t\t\t\treturn 1 + evenTree(edges) + evenTree(edges2)\n\treturn 0\n(n, m) = [int(i) for i in input().split()]\nes = {}\nfor i in range(m):\n\t(a, b) = [int(j) for j in input().split()]\n\tif a not in es:\n\t\tes[a] = [b]\n\telse:\n\t\tes[a].append(b)\n\tif b not in es:\n\t\tes[b] = [a]\n\telse:\n\t\tes[b].append(a)\nprint(evenTree(es))\n",
        "slowest_solution": "class Tree:\n\n\tdef __init__(self, value=None):\n\t\tself.size = value\n\t\tself.children = list()\n\n\tdef __iter__(self):\n\t\tfor child in self.children:\n\t\t\tyield child\n\n\tdef add_child(self, node):\n\t\tself.children.append(node)\n\n\tdef set_to_count(self):\n\t\tself.value = 1 + sum((child.set_to_count() for child in self))\n\t\treturn self.value\n\n\tdef even_subtrees(self):\n\t\tevens = 0\n\t\tfor child in self:\n\t\t\tif child.value % 2 == 0:\n\t\t\t\tevens += 1\n\t\t\tevens += child.even_subtrees()\n\t\treturn evens\n(nV, nE) = map(int, input().strip().split())\nedges = list()\nfor n in range(nE):\n\tedges.append(tuple(map(int, input().strip().split())))\nnodes = [Tree() for n in range(nV)]\nfor (c, p) in edges:\n\tnodes[p - 1].add_child(nodes[c - 1])\ntree = nodes[0]\ntree.set_to_count()\nprint(tree.even_subtrees())\n"
    },
    {
        "task_id": 707,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 0.0015072822570800781,
        "fastest_time": 0.0,
        "fastest_solution": "def logistic_map(w, h, xs, ys):\n\tmd = lambda i, j: min((abs(x - i) + abs(y - j) for (x, y) in zip(xs, ys)), default=None)\n\treturn [[md(i, j) for i in range(w)] for j in range(h)]\n",
        "slowest_solution": "def logistic_map(width, height, xs, ys):\n\treturn [[min([abs(x - x2) + abs(y - ys[i]) for (i, x2) in enumerate(xs)]) if len(xs) else None for x in range(width)] for y in range(height)]\n"
    },
    {
        "task_id": 653,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.74137544631958,
        "fastest_time": 2.4489986896514893,
        "fastest_solution": "for _ in range(int(input())):\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tans = 1\n\ts = []\n\tp = []\n\tfor i in range(N):\n\t\tp.append([i + 1, A[i]])\n\tif N == 2:\n\t\tprint(1)\n\telse:\n\t\ts.append(p[0])\n\t\ts.append(p[1])\n\t\tsize = len(s)\n\t\tfor i in range(2, N):\n\t\t\twhile size > 1:\n\t\t\t\ts1 = (s[size - 1][1] - s[size - 2][1]) / (s[size - 1][0] - s[size - 2][0])\n\t\t\t\ts2 = (p[i][1] - s[size - 1][1]) / (p[i][0] - s[size - 1][0])\n\t\t\t\tif s1 <= s2:\n\t\t\t\t\ts.pop()\n\t\t\t\t\tsize -= 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\ts.append(p[i])\n\t\t\tsize += 1\n\t\t\tans = max(ans, s[size - 1][0] - s[size - 2][0])\n\t\tprint(ans)\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tans = 1\n\ts = []\n\tp = []\n\tfor j in range(n):\n\t\tp.append([j + 1, a[j]])\n\tif n == 2:\n\t\tprint(1)\n\telse:\n\t\ts.append(p[0])\n\t\ts.append(p[1])\n\t\tx = len(s)\n\t\tfor z in range(2, n):\n\t\t\twhile x > 1:\n\t\t\t\ts1 = (s[x - 1][1] - s[x - 2][1]) / (s[x - 1][0] - s[x - 2][0])\n\t\t\t\ts2 = (p[z][1] - s[x - 1][1]) / (p[z][0] - s[x - 1][0])\n\t\t\t\tif s1 <= s2:\n\t\t\t\t\ts.pop()\n\t\t\t\t\tx -= 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\ts.append(p[z])\n\t\t\tx += 1\n\t\t\tans = max(ans, s[x - 1][0] - s[x - 2][0])\n\t\tprint(ans)\n"
    },
    {
        "task_id": 672,
        "slowest_solution_id": 2,
        "fastest_solution_id": 5,
        "slowest_time": 2.7142386436462402,
        "fastest_time": 2.558499336242676,
        "fastest_solution": "(n, m, r, k) = map(int, input().split())\n\ndef count(y, x):\n\tminx = max(0, x - (r - 1))\n\tmaxx = min(m - 1 - (r - 1), x)\n\tminy = max(0, y - (r - 1))\n\tmaxy = min(n - 1 - (r - 1), y)\n\tres = (maxy - miny + 1) * (maxx - minx + 1)\n\treturn res\n(sy, sx) = (n // 2, m // 2)\nc = count(sy, sx)\ncnt = 0\nimport heapq\nq = [(-c, sy, sx)]\nheapq.heapify(q)\nvisit = set()\nvisit.add((sy, sx))\nE = 0\nwhile q:\n\t(c, y, x) = heapq.heappop(q)\n\tc = -c\n\tE += c\n\tcnt += 1\n\tif cnt == k:\n\t\tbreak\n\tfor (dy, dx) in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n\t\t(ny, nx) = (y + dy, x + dx)\n\t\tif 0 <= ny < n and 0 <= nx < m:\n\t\t\tif (ny, nx) in visit:\n\t\t\t\tcontinue\n\t\t\tc = count(ny, nx)\n\t\t\theapq.heappush(q, (-c, ny, nx))\n\t\t\tvisit.add((ny, nx))\nans = E / ((n - r + 1) * (m - r + 1))\nprint(ans)\n",
        "slowest_solution": "import heapq as hq\nfrom queue import PriorityQueue\nimport math\n(n, m, r, k) = input().split()\nN = int(n)\nM = int(m)\nR = int(r)\nK = int(k)\nq = PriorityQueue()\nfor i in range(1, math.floor((N + 1) / 2) + 1):\n\tmaxi = min(min(i, N - i + 1), min(R, N - R + 1)) * min(min(R, M - R + 1), math.ceil(M / 2))\n\tnum = M - (2 * min(min(R, M - R + 1), math.ceil(M / 2)) - 2)\n\tmult = 2\n\tif i > math.floor(N / 2):\n\t\tmult = 1\n\tq.put((-maxi, num * mult, i))\nans = 0\nwhile K > 0:\n\tpop = q.get()\n\ta = -1 * pop[0]\n\tb = pop[1]\n\tc = pop[2]\n\td = min(min(c, N - c + 1), min(R, N - R + 1))\n\tif d != a:\n\t\tmult = 2\n\t\tif c > N / 2:\n\t\t\tmult = 1\n\t\tq.put((-(a - d), 2 * mult, c))\n\tans += a * min(b, K)\n\tK -= b\ntot = (N - R + 1) * (M - R + 1)\nprint(str(ans / tot))\n"
    },
    {
        "task_id": 706,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5183117389678955,
        "fastest_time": 2.5183117389678955,
        "fastest_solution": "from operator import add\n\nclass LazySegmentTree:\n\n\tdef __init__(self, n, init, merge=max, merge_unit=-10 ** 18, operate=add, operate_unit=0):\n\t\tself.merge = merge\n\t\tself.merge_unit = merge_unit\n\t\tself.operate = operate\n\t\tself.operate_unit = operate_unit\n\t\tself.n = (n - 1).bit_length()\n\t\tself.data = [0 for i in range(1 << self.n + 1)]\n\t\tself.lazy = [0 for i in range(1 << self.n + 1)]\n\t\tfor i in range(n):\n\t\t\tself.data[2 ** self.n + i] = init[i]\n\t\tfor i in range(2 ** self.n - 1, 0, -1):\n\t\t\tself.data[i] = self.merge(self.data[2 * i], self.data[2 * i + 1])\n\n\tdef propagate_above(self, i):\n\t\tm = i.bit_length() - 1\n\t\tfor bit in range(m, 0, -1):\n\t\t\tv = i >> bit\n\t\t\tadd = self.lazy[v]\n\t\t\tself.lazy[v] = 0\n\t\t\tself.data[2 * v] = self.operate(self.data[2 * v], add)\n\t\t\tself.data[2 * v + 1] = self.operate(self.data[2 * v + 1], add)\n\t\t\tself.lazy[2 * v] = self.operate(self.lazy[2 * v], add)\n\t\t\tself.lazy[2 * v + 1] = self.operate(self.lazy[2 * v + 1], add)\n\n\tdef remerge_above(self, i):\n\t\twhile i:\n\t\t\ti >>= 1\n\t\t\tself.data[i] = self.operate(self.merge(self.data[2 * i], self.data[2 * i + 1]), self.lazy[i])\n\n\tdef update(self, l, r, x):\n\t\tl += 1 << self.n\n\t\tr += 1 << self.n\n\t\tl0 = l // (l & -l)\n\t\tr0 = r // (r & -r) - 1\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tself.data[l] = self.operate(self.data[l], x)\n\t\t\t\tself.lazy[l] = self.operate(self.lazy[l], x)\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tself.data[r - 1] = self.operate(self.data[r - 1], x)\n\t\t\t\tself.lazy[r - 1] = self.operate(self.lazy[r - 1], x)\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\tself.remerge_above(l0)\n\t\tself.remerge_above(r0)\n\n\tdef query(self, l, r):\n\t\tl += 1 << self.n\n\t\tr += 1 << self.n\n\t\tl0 = l // (l & -l)\n\t\tr0 = r // (r & -r) - 1\n\t\tself.propagate_above(l0)\n\t\tself.propagate_above(r0)\n\t\tres = self.merge_unit\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tres = self.merge(res, self.data[l])\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tres = self.merge(res, self.data[r - 1])\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\treturn res\nimport sys\ninput = sys.stdin.buffer.readline\nn = int(input())\na = []\nb = []\nval = set()\nfor i in range(n):\n\t(l, r, t) = map(int, input().split())\n\tif t == 1:\n\t\ta.append((l, r))\n\telse:\n\t\tb.append((l, r))\n\tval.add(l)\n\tval.add(r)\nval = sorted(list(val))\ncomp = {i: e for (e, i) in enumerate(val)}\nN = len(val)\nquerya = [[] for i in range(N)]\nqueryb = [[] for i in range(N)]\nfor i in range(len(a)):\n\t(l, r) = a[i]\n\ta[i] = (comp[l], comp[r])\n\tquerya[comp[r]].append(comp[l])\nfor i in range(len(b)):\n\t(l, r) = b[i]\n\tb[i] = (comp[l], comp[r])\n\tqueryb[comp[r]].append(comp[l])\ninit = [0] * N\nLSTA = LazySegmentTree(N, init)\nLSTB = LazySegmentTree(N, init)\ndp = [0] * N\nfor i in range(N):\n\tfor l in querya[i]:\n\t\tLSTA.update(0, l + 1, 1)\n\tfor l in queryb[i]:\n\t\tLSTB.update(0, l + 1, 1)\n\ttemp1 = LSTA.query(0, i + 1)\n\ttemp2 = LSTB.query(0, i + 1)\n\tdp[i] = max(temp1, temp2)\n\tif i != N - 1:\n\t\tLSTA.update(i + 1, i + 2, dp[i])\n\t\tLSTB.update(i + 1, i + 2, dp[i])\nprint(dp[N - 1])\n",
        "slowest_solution": "from operator import add\n\nclass LazySegmentTree:\n\n\tdef __init__(self, n, init, merge=max, merge_unit=-10 ** 18, operate=add, operate_unit=0):\n\t\tself.merge = merge\n\t\tself.merge_unit = merge_unit\n\t\tself.operate = operate\n\t\tself.operate_unit = operate_unit\n\t\tself.n = (n - 1).bit_length()\n\t\tself.data = [0 for i in range(1 << self.n + 1)]\n\t\tself.lazy = [0 for i in range(1 << self.n + 1)]\n\t\tfor i in range(n):\n\t\t\tself.data[2 ** self.n + i] = init[i]\n\t\tfor i in range(2 ** self.n - 1, 0, -1):\n\t\t\tself.data[i] = self.merge(self.data[2 * i], self.data[2 * i + 1])\n\n\tdef propagate_above(self, i):\n\t\tm = i.bit_length() - 1\n\t\tfor bit in range(m, 0, -1):\n\t\t\tv = i >> bit\n\t\t\tadd = self.lazy[v]\n\t\t\tself.lazy[v] = 0\n\t\t\tself.data[2 * v] = self.operate(self.data[2 * v], add)\n\t\t\tself.data[2 * v + 1] = self.operate(self.data[2 * v + 1], add)\n\t\t\tself.lazy[2 * v] = self.operate(self.lazy[2 * v], add)\n\t\t\tself.lazy[2 * v + 1] = self.operate(self.lazy[2 * v + 1], add)\n\n\tdef remerge_above(self, i):\n\t\twhile i:\n\t\t\ti >>= 1\n\t\t\tself.data[i] = self.operate(self.merge(self.data[2 * i], self.data[2 * i + 1]), self.lazy[i])\n\n\tdef update(self, l, r, x):\n\t\tl += 1 << self.n\n\t\tr += 1 << self.n\n\t\tl0 = l // (l & -l)\n\t\tr0 = r // (r & -r) - 1\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tself.data[l] = self.operate(self.data[l], x)\n\t\t\t\tself.lazy[l] = self.operate(self.lazy[l], x)\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tself.data[r - 1] = self.operate(self.data[r - 1], x)\n\t\t\t\tself.lazy[r - 1] = self.operate(self.lazy[r - 1], x)\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\tself.remerge_above(l0)\n\t\tself.remerge_above(r0)\n\n\tdef query(self, l, r):\n\t\tl += 1 << self.n\n\t\tr += 1 << self.n\n\t\tl0 = l // (l & -l)\n\t\tr0 = r // (r & -r) - 1\n\t\tself.propagate_above(l0)\n\t\tself.propagate_above(r0)\n\t\tres = self.merge_unit\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tres = self.merge(res, self.data[l])\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tres = self.merge(res, self.data[r - 1])\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\treturn res\nimport sys\ninput = sys.stdin.buffer.readline\nn = int(input())\na = []\nb = []\nval = set()\nfor i in range(n):\n\t(l, r, t) = map(int, input().split())\n\tif t == 1:\n\t\ta.append((l, r))\n\telse:\n\t\tb.append((l, r))\n\tval.add(l)\n\tval.add(r)\nval = sorted(list(val))\ncomp = {i: e for (e, i) in enumerate(val)}\nN = len(val)\nquerya = [[] for i in range(N)]\nqueryb = [[] for i in range(N)]\nfor i in range(len(a)):\n\t(l, r) = a[i]\n\ta[i] = (comp[l], comp[r])\n\tquerya[comp[r]].append(comp[l])\nfor i in range(len(b)):\n\t(l, r) = b[i]\n\tb[i] = (comp[l], comp[r])\n\tqueryb[comp[r]].append(comp[l])\ninit = [0] * N\nLSTA = LazySegmentTree(N, init)\nLSTB = LazySegmentTree(N, init)\ndp = [0] * N\nfor i in range(N):\n\tfor l in querya[i]:\n\t\tLSTA.update(0, l + 1, 1)\n\tfor l in queryb[i]:\n\t\tLSTB.update(0, l + 1, 1)\n\ttemp1 = LSTA.query(0, i + 1)\n\ttemp2 = LSTB.query(0, i + 1)\n\tdp[i] = max(temp1, temp2)\n\tif i != N - 1:\n\t\tLSTA.update(i + 1, i + 2, dp[i])\n\t\tLSTB.update(i + 1, i + 2, dp[i])\nprint(dp[N - 1])\n"
    },
    {
        "task_id": 654,
        "slowest_solution_id": 5,
        "fastest_solution_id": 3,
        "slowest_time": 2.661902904510498,
        "fastest_time": 2.505110263824463,
        "fastest_solution": "from collections import *\nimport bisect\nimport heapq\nimport sys\nfrom math import inf\n\ndef ri():\n\treturn int(input())\n\ndef rl():\n\treturn list(map(int, input().split()))\n\ndef isPossiblePlace(x, y):\n\tfor my_list in allowed[x]:\n\t\t(a, b) = my_list\n\t\tif y >= a and y <= b:\n\t\t\treturn True\n\treturn False\n\ndef bfs(x0, y0, x1, y1):\n\tvisited = defaultdict(list)\n\tto_visit = deque()\n\tto_visit.append((x0, y0, 0))\n\tvisited[x0].append(y0)\n\twhile to_visit:\n\t\t(x, y, d) = to_visit.popleft()\n\t\tfor dx in [-1, 0, 1]:\n\t\t\tfor dy in [-1, 0, 1]:\n\t\t\t\tif abs(dx) + abs(dy) != 0:\n\t\t\t\t\tnx = x + dx\n\t\t\t\t\tny = y + dy\n\t\t\t\tif nx >= 1 and nx <= 10 ** 9 and (ny >= 1) and (ny <= 10 ** 9):\n\t\t\t\t\tif isPossiblePlace(nx, ny):\n\t\t\t\t\t\tif (nx, ny) == (x1, y1):\n\t\t\t\t\t\t\treturn d + 1\n\t\t\t\t\t\tif ny not in visited[nx]:\n\t\t\t\t\t\t\tvisited[nx].append(ny)\n\t\t\t\t\t\t\tto_visit.append((nx, ny, d + 1))\n\treturn -1\n(x0, y0, x1, y1) = rl()\nn = ri()\nallowed = defaultdict(set)\nfor _ in range(n):\n\t(i, start, end) = rl()\n\tallowed[i].add((start, end))\nprint(bfs(x0, y0, x1, y1))\n",
        "slowest_solution": "from sys import stdin, stdout\nimport time, math\nfrom collections import defaultdict\n\ndef pn(ob):\n\tstdout.write(str(ob))\n\ndef inp():\n\treturn stdin.readline()\n\ndef fpow(n, p):\n\tif p == 1:\n\t\treturn n\n\tif p & 1 == 1:\n\t\treturn n * fpow(n, p - 1)\n\telse:\n\t\treturn fpow(n, p / 2) * fpow(n, p / 2)\n\ndef def_val():\n\treturn False\n\ndef def_dist():\n\treturn math.inf\nvalid = defaultdict(def_val)\ndist = defaultdict(def_dist)\ndx = (-1, 0, 1, 0, 1, 1, -1, -1)\ndy = (0, 1, 0, -1, 1, -1, 1, -1)\n\ndef bfs(x, y, dest):\n\tq = []\n\tq.append((x, y))\n\tvalid[x, y] = False\n\tdist[x, y] = 0\n\twhile len(q) > 0:\n\t\tcoords = q.pop(0)\n\t\tfor k in range(0, 8, 1):\n\t\t\tx = coords[0] + dx[k]\n\t\t\ty = coords[1] + dy[k]\n\t\t\tnew_coords = (x, y)\n\t\t\tdist[new_coords] = min(dist[coords] + 1, dist[new_coords])\n\t\t\tif valid[new_coords]:\n\t\t\t\tvalid[new_coords] = False\n\t\t\t\tq.append(new_coords)\n\tif dist[dest] == math.inf:\n\t\tpn(-1)\n\telse:\n\t\tpn(dist[dest])\n\ndef process():\n\t(x0, y0, x1, y1) = map(int, input().split())\n\tn = int(inp())\n\tfor i in range(0, n, 1):\n\t\t(r, a, b) = map(int, input().split())\n\t\tfor j in range(a, b + 1, 1):\n\t\t\tvalid[r, j] = True\n\tbfs(x0, y0, (x1, y1))\n\ndef main():\n\tt = 1\n\tprocess()\nmain()\n"
    },
    {
        "task_id": 658,
        "slowest_solution_id": 5,
        "fastest_solution_id": 7,
        "slowest_time": 2.853870391845703,
        "fastest_time": 2.5032765865325928,
        "fastest_solution": "import bisect\nMIN = -10 ** 20\n\ndef read_test():\n\tN = int(input())\n\tA = []\n\tfor _ in range(N):\n\t\tA.append(list(map(int, input().strip().split()))[1:])\n\treturn (N, A)\n\ndef solve_test(N, A):\n\tsol = 0\n\t(P, Q) = ([], [])\n\t(mx_pre, mx_suf) = ([], [])\n\n\tdef process_min_max():\n\t\tnonlocal P, mx_pre, mx_suf\n\t\tlP = len(P)\n\t\tmx_pre = [MIN] * lP\n\t\tmx_suf = [MIN] * lP\n\t\tfor i in range(lP):\n\t\t\tmx_pre[i] = max(P[i][2], mx_pre[i - 1] if i > 0 else MIN)\n\t\t\tmx_suf[lP - 1 - i] = max(P[lP - 1 - i][3], mx_suf[lP - i] if i > 0 else MIN)\n\t(m, M) = (min(A[0]), max(A[0]))\n\tQ.append((m, 0, -m, m))\n\tif len(A[0]) > 0:\n\t\tQ.append((M, 0, -M, M))\n\tfor n in range(1, N):\n\t\ta = A[n]\n\t\tQ.sort()\n\t\t(P, Q) = (Q, [])\n\t\tprocess_min_max()\n\t\tfor i in range(len(a)):\n\t\t\t(first, last) = (a[i], a[i - 1])\n\t\t\tins_pos = bisect.bisect_left(P, (first, 0, 0, 0))\n\t\t\tpos_pre = ins_pos - 1\n\t\t\tpos_suf = ins_pos\n\t\t\tif pos_pre < 0:\n\t\t\t\tcost1 = MIN\n\t\t\telse:\n\t\t\t\tcost1 = mx_pre[pos_pre] + first * n\n\t\t\tif pos_suf > len(P) - 1:\n\t\t\t\tcost2 = MIN\n\t\t\telse:\n\t\t\t\tcost2 = mx_suf[pos_suf] - first * n\n\t\t\tcost = max(cost1, cost2)\n\t\t\tQ.append((last, cost, -last * (n + 1) + cost, last * (n + 1) + cost))\n\treturn max(map(lambda x: x[1], Q))\nT = int(input())\nfor _ in range(T):\n\t(N, A) = read_test()\n\tsol = solve_test(N, A)\n\tprint(sol)\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ta = []\n\tfor i in range(n):\n\t\tb = list(map(int, input().strip().split()))\n\t\ta.append(b)\n\tm = []\n\tans = []\n\tfor i in range(n):\n\t\tmin = 1\n\t\tmax = 1\n\t\tfor j in range(1, a[i][0] + 1):\n\t\t\tif a[i][j] < a[i][min]:\n\t\t\t\tmin = j\n\t\t\tif a[i][j] > a[i][max]:\n\t\t\t\tmax = j\n\t\tm.append((min, max))\n\tif n == 1:\n\t\tprint(0)\n\t\tcontinue\n\tans1 = []\n\tans2 = []\n\tfor i in range(1, a[1][0] + 1):\n\t\tans1.append(abs(a[0][m[0][0]] - a[1][i]))\n\t\tans2.append(abs(a[0][m[0][1]] - a[1][i]))\n\tfor i in range(n - 2):\n\t\tmaxp1 = 0\n\t\tmaxp2 = 0\n\t\tmax1 = ans1[0] + abs(a[i + 1][a[i + 1][0]] - a[i + 2][m[i + 2][0]]) * (i + 2)\n\t\tmax2 = ans1[0] + abs(a[i + 1][a[i + 1][0]] - a[i + 2][m[i + 2][1]]) * (i + 2)\n\t\tfor j in range(a[i + 1][0]):\n\t\t\tif max1 < ans1[j] + abs(a[i + 1][(j - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][0]]) * (i + 2):\n\t\t\t\tmaxp1 = j\n\t\t\t\tmax1 = ans1[maxp1] + abs(a[i + 1][(maxp1 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][0]]) * (i + 2)\n\t\t\tif max2 < ans1[j] + abs(a[i + 1][(j - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][1]]) * (i + 2):\n\t\t\t\tmaxp2 = j\n\t\t\t\tmax2 = ans1[maxp2] + abs(a[i + 1][(maxp2 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][1]]) * (i + 2)\n\t\tans = []\n\t\tfor j in range(1, a[i + 2][0] + 1):\n\t\t\tk1 = ans1[maxp1] + abs(a[i + 1][(maxp1 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][j]) * (i + 2)\n\t\t\tk2 = ans1[maxp2] + abs(a[i + 1][(maxp2 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][j]) * (i + 2)\n\t\t\tif k2 > k1:\n\t\t\t\tans.append(k2)\n\t\t\telse:\n\t\t\t\tans.append(k1)\n\t\tans1 = ans\n\t\tmaxp1 = 0\n\t\tmaxp2 = 0\n\t\tmax1 = ans2[0] + abs(a[i + 1][a[i + 1][0]] - a[i + 2][m[i + 2][0]]) * (i + 2)\n\t\tmax2 = ans2[0] + abs(a[i + 1][a[i + 1][0]] - a[i + 2][m[i + 2][1]]) * (i + 2)\n\t\tfor j in range(a[i + 1][0]):\n\t\t\tif max1 < ans2[j] + abs(a[i + 1][(j - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][0]]) * (i + 2):\n\t\t\t\tmaxp1 = j\n\t\t\t\tmax1 = ans2[maxp1] + abs(a[i + 1][(maxp1 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][0]]) * (i + 2)\n\t\t\tif max2 < ans2[j] + abs(a[i + 1][(j - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][1]]) * (i + 2):\n\t\t\t\tmaxp2 = j\n\t\t\t\tmax2 = ans2[maxp2] + abs(a[i + 1][(maxp2 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][m[i + 2][1]]) * (i + 2)\n\t\tans = []\n\t\tfor j in range(1, a[i + 2][0] + 1):\n\t\t\tk1 = ans2[maxp1] + abs(a[i + 1][(maxp1 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][j]) * (i + 2)\n\t\t\tk2 = ans2[maxp2] + abs(a[i + 1][(maxp2 - 1 + a[i + 1][0]) % a[i + 1][0] + 1] - a[i + 2][j]) * (i + 2)\n\t\t\tif k2 > k1:\n\t\t\t\tk1 = k2\n\t\t\tans.append(k1)\n\t\tans2 = ans\n\tansx = -1\n\tfor i in ans1:\n\t\tif i > ansx:\n\t\t\tansx = i\n\tfor i in ans2:\n\t\tif i > ansx:\n\t\t\tansx = i\n\tprint(ansx)\n"
    },
    {
        "task_id": 661,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 2.757103204727173,
        "fastest_time": 2.4693846702575684,
        "fastest_solution": "import math\n\ndef Solve(s):\n\tzeros = 0\n\ti = len(s) - 1\n\twhile i >= 0 and s[i] == '0':\n\t\tzeros += 1\n\t\ti = i - 1\n\tif i == 0 and s[0] == '1':\n\t\treturn 'Yes'\n\tvalue = int(s[:i + 1])\n\tx = math.log(value, 2)\n\tif 2 ** x == value:\n\t\tif zeros >= x:\n\t\t\treturn 'Yes'\n\treturn 'No'\nfor _ in range(int(input())):\n\tn = input()\n\tprint(Solve(n))\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\tc1 = 0\n\tc2 = 0\n\twhile n > 1 and n % 10 == 0:\n\t\tn //= 10\n\t\tc1 += 1\n\twhile n > 1 and n % 2 == 0:\n\t\tn //= 2\n\t\tc2 += 1\n\tif c1 >= c2 and n == 1:\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')\n"
    },
    {
        "task_id": 709,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.690315008163452,
        "fastest_time": 2.470858573913574,
        "fastest_solution": "def get_a(i, j):\n\tif i >= 0 and i < n and (j >= 0) and (j < m):\n\t\treturn a[i][j]\n\telse:\n\t\treturn 0\n(n, m) = map(int, input().split())\na = [[0] * m for _ in range(n)]\nb = [[0] * m for _ in range(n)]\nfor i in range(n):\n\tt = list(str(input()))\n\tfor j in range(m):\n\t\ta[i][j] = 1 if t[j] == 'B' else 0\nfor i in range(n):\n\tfor j in range(m):\n\t\tb[i][j] = get_a(i, j) ^ get_a(i + 1, j) ^ get_a(i, j + 1) ^ get_a(i + 1, j + 1)\nans = 0\nt = 0\nfor i in range(n):\n\tfor j in range(m):\n\t\tif b[i][j] == 1:\n\t\t\tans += 1\n\t\tif i <= n - 2 and j <= m - 2 and (b[i][j] == 1) and (b[i][m - 1] == 1) and (b[n - 1][j] == 1) and (b[n - 1][m - 1] == 1):\n\t\t\tt = 1\nprint(ans - t)\n",
        "slowest_solution": "(n, m) = input().strip().split()\nn = int(n)\nm = int(m)\na = [[0] * (m + 1) for _ in range(n + 1)]\nfor i in range(n):\n\ts = input().strip()\n\tfor j in range(m):\n\t\tif s[j] == 'B':\n\t\t\ta[i + 1][j + 1] = 1\n\t\tif i > 0:\n\t\t\ta[i][j + 1] ^= a[i + 1][j + 1]\n\t\tif j > 0:\n\t\t\ta[i + 1][j] ^= a[i + 1][j + 1]\n\t\tif i > 0 and j > 0:\n\t\t\ta[i][j] ^= a[i + 1][j + 1]\nres = 0\nsub = 0\nfor i in range(1, n + 1):\n\tfor j in range(1, m + 1):\n\t\tif a[i][j] == 1:\n\t\t\tres += 1\n\t\tif i < n and j < m and a[i][j] and a[i][m] and a[n][j] and a[n][m]:\n\t\t\tsub = 1\nprint(res - sub)\n"
    },
    {
        "task_id": 677,
        "slowest_solution_id": 1,
        "fastest_solution_id": 6,
        "slowest_time": 2.720486640930176,
        "fastest_time": 2.4716410636901855,
        "fastest_solution": "def fact(x):\n\tif x == 0 or x == 1:\n\t\treturn 1\n\tp = 1\n\tfor i in range(1, x + 1):\n\t\tp *= i\n\treturn p\n\ndef cal(n, d, rank, total, prod):\n\twhile True:\n\t\tif total == 1:\n\t\t\trank[0] += 1\n\t\t\tbreak\n\t\tkey = n // 10 ** (total - 1)\n\t\tfval = fact(total - 1)\n\t\tfor i in d:\n\t\t\tif i < key:\n\t\t\t\ttemp = prod\n\t\t\t\ttemp = temp / fact(d[i]) * fact(d[i] - 1)\n\t\t\t\trank[0] += fval / temp\n\t\tprod = prod / fact(d[key]) * fact(d[key] - 1)\n\t\td[key] -= 1\n\t\tif d[key] == 0:\n\t\t\td.pop(key)\n\t\tn = n % 10 ** (total - 1)\n\t\ttotal -= 1\nfor _ in range(int(input())):\n\tn = int(input())\n\tnum = n\n\td = {}\n\ttotal = 0\n\tif n == 0:\n\t\tprint(1)\n\t\tcontinue\n\twhile n > 0:\n\t\tif n % 10 not in d:\n\t\t\td[n % 10] = 1\n\t\telse:\n\t\t\td[n % 10] += 1\n\t\tn = n // 10\n\t\ttotal += 1\n\tprod = 1\n\tfor i in d:\n\t\tprod *= fact(d[i])\n\trank = [0]\n\tcal(num, d, rank, total, prod)\n\tprint(int(rank[0]))\n",
        "slowest_solution": "from math import *\nfrom collections import *\nf = [factorial(i) for i in range(19)]\nfor _ in range(int(input())):\n\ts = list(str(int(input())))\n\t(C, d, ans, m, n) = (Counter(s), 1, 1, ord(min(s)), len(s))\n\tfor v in C.values():\n\t\td *= f[v]\n\tfor c in s:\n\t\ti = sum((C[chr(k)] for k in range(m, ord(c))))\n\t\tans += i * f[n - 1] // d\n\t\td //= C[c]\n\t\tC[c] -= 1\n\t\tn -= 1\n\tprint(ans)\n"
    },
    {
        "task_id": 665,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 2.7121119499206543,
        "fastest_time": 2.4688687324523926,
        "fastest_solution": "(N, K, P) = map(int, input().split())\nA = list(map(int, input().split()))\nQ = input()\nif K > N:\n\tK = N\nR = [sum(A[:K])]\n(fst, lst) = (0, K - 1)\nfor i in range(1, N):\n\tlst = (lst + 1) % N\n\tR.append(R[-1] + A[lst] - A[fst])\n\tfst = (fst + 1) % N\nd = N - K\nM = {r: 0 for r in R}\ncur_max = 0\nfor i in range(d + 1):\n\tcur_max = max(cur_max, R[i])\n\tM[R[i]] += 1\nvaluesR = sorted(list(set(R)), reverse=True)\nB = [cur_max]\n(fst, lst) = (0, d)\nfor i in range(1, N):\n\tM[R[fst]] -= 1\n\tfst = (fst + 1) % N\n\tlst = (lst + 1) % N\n\tM[R[lst]] += 1\n\tif R[lst] > cur_max:\n\t\tcur_max = R[lst]\n\tif M[cur_max] > 0:\n\t\tB.append(cur_max)\n\telse:\n\t\tfor v in valuesR:\n\t\t\tif M[v] != 0:\n\t\t\t\tB.append(v)\n\t\t\t\tcur_max = v\n\t\t\t\tbreak\nB = [B[0]] + list(reversed(B[1:]))\npos = 0\nfor q in Q:\n\tif q == '?':\n\t\tprint(B[pos])\n\telse:\n\t\tpos = (pos + 1) % N\n",
        "slowest_solution": "from collections import deque\n(n, k, p) = map(int, input().split())\nbi = [int(i) for i in input().split()]\nbi = bi + bi\nbi.reverse()\nk = min(k, n)\nqry = input()\nsm = [sum(bi[0:k])]\nfor i in range(1, 2 * n - k + 1):\n\tsm.append(sm[i - 1] - bi[i - 1] + bi[i + k - 1])\nq = deque()\nsa = []\nwn = n - k + 1\nfor i in range(0, wn):\n\twhile q and sm[q[-1]] <= sm[i]:\n\t\tq.pop()\n\tq.append(i)\nfor i in range(wn, 2 * n - k + 1):\n\tsa.append(sm[q[0]])\n\twhile q and q[0] <= i - wn:\n\t\tq.popleft()\n\twhile q and sm[q[-1]] <= sm[i]:\n\t\tq.pop()\n\tq.append(i)\nsa.append(sm[q[0]])\nmx = sa[0]\nshift = 0\nfor x in qry:\n\tif x == '?':\n\t\tprint(mx)\n\telse:\n\t\tshift = (shift + 1) % n\n\t\tmx = sa[shift]\n"
    },
    {
        "task_id": 666,
        "slowest_solution_id": 8,
        "fastest_solution_id": 9,
        "slowest_time": 2.6728131771087646,
        "fastest_time": 2.5477468967437744,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nimport sys\nfrom collections import Counter\n(n, k) = map(int, input().split())\nl = []\nfor i in range(n):\n\t(p, q, t) = map(str, sys.stdin.readline().split())\n\tt = int(t)\n\tl.append([[p, q], t])\np = []\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\tif l[j][1] - l[i][1] > k:\n\t\t\tbreak\n\t\tif Counter(l[i][0]) == Counter(l[j][0]) and l[j][1] - l[i][1] <= k and (l[j][1] - l[i][1] > 0) and (l[i][0] != l[j][0]):\n\t\t\tif l[i][0] not in p and l[i][0][::-1] not in p:\n\t\t\t\tp.append(l[i][0])\nprint(len(p))\nif len(p) == 0:\n\texit(0)\nfor i in p:\n\tprint(i[0], i[1])\n",
        "slowest_solution": "import sys\nfrom collections import Counter\n(n, k) = map(int, input().split())\nl = []\nfor i in range(n):\n\t(p, q, t) = map(str, sys.stdin.readline().split())\n\tt = int(t)\n\tl.append([[p, q], t])\np = []\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\tif l[j][1] - l[i][1] > k:\n\t\t\tbreak\n\t\tif Counter(l[i][0]) == Counter(l[j][0]) and l[j][1] - l[i][1] <= k and (l[j][1] - l[i][1] > 0) and (l[i][0] != l[j][0]):\n\t\t\tif l[i][0] not in p and l[i][0][::-1] not in p:\n\t\t\t\tp.append(l[i][0])\nprint(len(p))\nif len(p) == 0:\n\texit(0)\nfor i in p:\n\tprint(i[0], i[1])\n"
    },
    {
        "task_id": 657,
        "slowest_solution_id": 9,
        "fastest_solution_id": 0,
        "slowest_time": 5.245277166366577,
        "fastest_time": 2.5359199047088623,
        "fastest_solution": "from collections import defaultdict\nfrom copy import copy\nM = int(1000000000.0) + 7\nfact = [1]\nfor i in range(1, int(100000.0) + 10):\n\tfact.append(fact[-1] * i % M)\n\ndef egcd(a, b):\n\tif a == 0:\n\t\treturn (b, 0, 1)\n\telse:\n\t\t(g, y, x) = egcd(b % a, a)\n\t\treturn (g, x - b // a * y, y)\nmemo = {}\n\ndef modinv(a, m):\n\tif a in memo:\n\t\treturn memo[a]\n\twhile a < 0:\n\t\ta += m\n\t(g, x, y) = egcd(a, m)\n\tif g != 1:\n\t\traise Exception('Modular inverse does not exist')\n\telse:\n\t\tmemo[a] = x % m\n\t\treturn x % m\ns = input().strip()\nocc = [defaultdict(int)]\nfor ch in s:\n\tnewd = copy(occ[-1])\n\tnewd[ch] += 1\n\tocc.append(newd)\n\ndef query(l, r):\n\td = defaultdict(int)\n\tfor ch in occ[r]:\n\t\td[ch] += occ[r][ch]\n\tfor ch in occ[l - 1]:\n\t\td[ch] -= occ[l - 1][ch]\n\todds = 0\n\tfor (k, v) in copy(d).items():\n\t\tif v & 1:\n\t\t\todds += 1\n\t\td[k] = v - (v & 1)\n\tres = 1\n\ttotal = 0\n\tfor (k, v) in d.items():\n\t\tres *= modinv(fact[v // 2], M)\n\t\ttotal += v // 2\n\t\tres %= M\n\treturn max(1, odds) * res * fact[total] % M\nfor _ in range(int(input())):\n\t(l, r) = map(int, input().split())\n\tprint(query(l, r))\n",
        "slowest_solution": "max = 100005\nmod = 1000000007\nfact = [0] * max\ninv = [0] * max\nfact[0] = 1\nfor i in range(1, max):\n\tfact[i] = i * fact[i - 1] % mod\n\ndef modInverse(a, m):\n\tg = gcd(a, m)\n\tif g != 1:\n\t\tprint(\"Inverse doesn't exist\")\n\telse:\n\t\treturn power(a, m - 2, m)\n\ndef power(x, y, m):\n\tif y == 0:\n\t\treturn 1\n\tp = power(x, y // 2, m) % m\n\tp = p * p % m\n\tif y % 2 == 0:\n\t\treturn p\n\telse:\n\t\treturn x * p % m\n\ndef gcd(a, b):\n\tif a == 0:\n\t\treturn b\n\treturn gcd(b % a, a)\nfor i in range(max):\n\tinv[i] = modInverse(fact[i], mod)\ns = list(input())\nn = len(s)\ns2 = [[0] * 26 for i in range(n)]\ns2[0][ord(s[0]) - ord('a')] += 1\nfor i in range(1, n):\n\tfor j in range(26):\n\t\ts2[i][j] += s2[i - 1][j]\n\ts2[i][ord(s[i]) - ord('a')] += 1\nnum = int(input())\nfor _ in range(num):\n\t(l, r) = map(int, input().split(' '))\n\t(l, r) = (l - 1, r - 1)\n\tcone = 0\n\tctwo = 0\n\tans = 1\n\tc = [0] * 26\n\tfor i in range(26):\n\t\tc[i] = s2[r][i]\n\t\tif l > 0:\n\t\t\tc[i] -= s2[l - 1][i]\n\t\tif c[i] % 2 == 1:\n\t\t\tcone += 1\n\t\t\tc[i] -= 1\n\t\tc[i] = int(c[i] / 2)\n\t\tctwo += c[i]\n\t\tans = ans * inv[c[i]] % mod\n\tans = ans * fact[ctwo] % mod\n\tif cone > 0:\n\t\tans *= cone\n\tans %= mod\n\tprint(ans)\n"
    },
    {
        "task_id": 691,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.6369943618774414,
        "fastest_time": 2.5940141677856445,
        "fastest_solution": "from collections import defaultdict, deque, Counter, OrderedDict\nfrom bisect import insort, bisect_right, bisect_left\nimport threading, sys\n\ndef main():\n\tn = int(input())\n\tadj = [[] for i in range(n + 1)]\n\tfor i in range(n - 1):\n\t\t(a, b) = list(map(int, input().split()))\n\t\t(a, b) = (a - 1, b - 1)\n\t\tadj[a].append(b)\n\t\tadj[b].append(a)\n\tinit = [int(i) for i in input().split()]\n\tgoal = [int(i) for i in input().split()]\n\tvisited = [0] * n\n\tpar = [[] for i in range(n)]\n\n\tdef dfs(s, p):\n\t\tif visited[s]:\n\t\t\treturn\n\t\tvisited[s] = 1\n\t\tpar[p].append(s)\n\t\tfor i in adj[s]:\n\t\t\tdfs(i, s)\n\tdfs(0, 0)\n\tpar[0] = par[0][1:]\n\tans = []\n\n\tdef dfs2(s, l, fo, fe):\n\t\tif l % 2 == 0:\n\t\t\tif fe % 2 == 1:\n\t\t\t\tinit[s] = 1 - init[s]\n\t\telif fo % 2 == 1:\n\t\t\tinit[s] = 1 - init[s]\n\t\tif init[s] != goal[s]:\n\t\t\tans.append(s + 1)\n\t\t\tif l % 2:\n\t\t\t\tfo += 1\n\t\t\telse:\n\t\t\t\tfe += 1\n\t\tfor j in par[s]:\n\t\t\tdfs2(j, l + 1, fo, fe)\n\tdfs2(0, 0, 0, 0)\n\tprint(len(ans))\n\tprint('\\n'.join(map(str, ans)))\n\ndef __starting_point():\n\tsys.setrecursionlimit(400000)\n\tthreading.stack_size(102400000)\n\tthread = threading.Thread(target=main)\n\tthread.start()\n__starting_point()\n",
        "slowest_solution": "from collections import defaultdict, deque, Counter, OrderedDict\nimport sys\n\ndef main():\n\tn = int(input())\n\tadj = [[] for i in range(n + 1)]\n\tfor i in range(n - 1):\n\t\t(a, b) = map(int, input().split())\n\t\t(a, b) = (a - 1, b - 1)\n\t\tadj[a].append(b)\n\t\tadj[b].append(a)\n\tinit = [int(i) for i in input().split()]\n\tgoal = [int(i) for i in input().split()]\n\tvisited = [0] * n\n\tpar = [[] for i in range(n)]\n\tdq = deque()\n\tdq.append((0, 0))\n\twhile len(dq) > 0:\n\t\t(s, p) = dq.pop()\n\t\tif visited[s]:\n\t\t\tcontinue\n\t\tvisited[s] = 1\n\t\tpar[p].append(s)\n\t\tfor i in adj[s]:\n\t\t\tdq.append((i, s))\n\tpar[0] = par[0][1:]\n\tans = []\n\tdq = deque()\n\tdq.append((0, 0, 0, 0))\n\twhile len(dq) > 0:\n\t\t(s, l, fo, fe) = dq.pop()\n\t\tif l % 2 == 0:\n\t\t\tif fe % 2 == 1:\n\t\t\t\tinit[s] = 1 - init[s]\n\t\telif fo % 2 == 1:\n\t\t\tinit[s] = 1 - init[s]\n\t\tif init[s] != goal[s]:\n\t\t\tans.append(s + 1)\n\t\t\tif l % 2:\n\t\t\t\tfo += 1\n\t\t\telse:\n\t\t\t\tfe += 1\n\t\tfor j in par[s]:\n\t\t\tdq.append((j, l + 1, fo, fe))\n\tprint(len(ans))\n\tprint('\\n'.join(map(str, ans)))\n\ndef __starting_point():\n\tmain()\n__starting_point()\n"
    },
    {
        "task_id": 671,
        "slowest_solution_id": 8,
        "fastest_solution_id": 3,
        "slowest_time": 2.6698644161224365,
        "fastest_time": 2.5148189067840576,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tA = input()\n\tA = list(A)\n\tA.sort()\n\tif k == n:\n\t\tprint(A[-1])\n\telif A[0] == A[k - 1]:\n\t\tC = list(set(A[k:]))\n\t\tif len(C) == 1:\n\t\t\tt = A[0] + ''.join(A[k] * (len(A[k:]) // k))\n\t\t\tif len(A[k:]) % k != 0:\n\t\t\t\tt += A[k]\n\t\t\tprint(t)\n\t\telse:\n\t\t\tB = A[k:]\n\t\t\tprint(A[0] + ''.join(B))\n\telse:\n\t\tprint(A[k - 1])\n",
        "slowest_solution": "def split(word):\n\treturn [char for char in word]\n\ndef convert(s):\n\tnew = ''\n\tfor x in s:\n\t\tnew += x\n\treturn new\nt = int(input())\nfor i in range(t):\n\t(n, k) = map(int, input().split())\n\ts = input()\n\tslist = split(s)\n\tslist.sort()\n\tlast = slist[n - 1]\n\tm = []\n\tfor i in range(k):\n\t\tm.append([])\n\tfor i in range(k):\n\t\tm[i].append(slist[i])\n\tif m[0] != m[k - 1] or k == n:\n\t\tprint(m[k - 1][0])\n\telif slist[k] == slist[0] or not slist[k] == slist[n - 1]:\n\t\tif slist[0] != slist[n - 1]:\n\t\t\tfor i in range(k, n):\n\t\t\t\tm[0].append(slist[i])\n\t\t\tprint(convert(m[0]))\n\t\telse:\n\t\t\tfor i in range(k, n):\n\t\t\t\tif i % k == 0:\n\t\t\t\t\tm[0].append(slist[i])\n\t\t\tprint(convert(m[0]))\n\telse:\n\t\tfor i in range(k, n):\n\t\t\tif i % k == 0:\n\t\t\t\tm[0].append(slist[i])\n\t\tprint(convert(m[0]))\n"
    },
    {
        "task_id": 703,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.749274492263794,
        "fastest_time": 2.605269193649292,
        "fastest_solution": "def dfs(x, e, v, g):\n\tv[x] = True\n\tc = 0\n\tfor y in e[x]:\n\t\tif not y in v:\n\t\t\tif dfs(y, e, v, g):\n\t\t\t\tc += 1\n\t\t\t\tif c > 2:\n\t\t\t\t\tg.append((x, y))\n\t\t\telse:\n\t\t\t\tg.append((x, y))\n\tif c < 2:\n\t\treturn True\n\tif x != 1:\n\t\treturn False\n\ndef leaf(x, e):\n\tp = 0\n\twhile True:\n\t\tu = 0\n\t\tfor y in e[x]:\n\t\t\tif y != p:\n\t\t\t\tu = y\n\t\t\t\tbreak\n\t\tif u == 0:\n\t\t\tbreak\n\t\tp = x\n\t\tx = u\n\treturn x\n\ndef solve(n, e):\n\tg = []\n\tdfs(1, e, {}, g)\n\tfor (x, y) in g:\n\t\te[x].remove(y)\n\t\te[y].remove(x)\n\tz = []\n\tl = leaf(1, e)\n\tfor (p, y) in g:\n\t\tr = leaf(y, e)\n\t\tz.append((p, y, l, r))\n\t\tl = leaf(r, e)\n\tprint(len(z))\n\tif len(z) > 0:\n\t\tprint('\\n'.join(map(lambda x: ' '.join(map(str, x)), z)))\n\ndef main():\n\tt = int(input())\n\tfor i in range(t):\n\t\tn = int(input())\n\t\te = {}\n\t\tfor i in range(n - 1):\n\t\t\t(a, b) = map(int, input().split())\n\t\t\tif not a in e:\n\t\t\t\te[a] = []\n\t\t\tif not b in e:\n\t\t\t\te[b] = []\n\t\t\te[a].append(b)\n\t\t\te[b].append(a)\n\t\tsolve(n, e)\nimport threading\nimport sys\nsys.setrecursionlimit(10 ** 5 + 1)\nthreading.stack_size(262000)\nmain = threading.Thread(target=main)\nmain.start()\nmain.join()\n",
        "slowest_solution": "import time\nimport os, sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string, heapq as h\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\timport os\n\t\tself.os = os\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tself.os.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef getInt():\n\treturn int(input())\n\ndef getStrs():\n\treturn input().split()\n\ndef getInts():\n\treturn list(map(int, input().split()))\n\ndef getStr():\n\treturn input()\n\ndef listStr():\n\treturn list(input())\n\ndef getMat(n):\n\treturn [getInts() for _ in range(n)]\n\ndef getBin():\n\treturn list(map(int, list(input())))\n\ndef isInt(s):\n\treturn '0' <= s[0] <= '9'\n\ndef ceil_(a, b):\n\treturn a // b + (a % b > 0)\nMOD = 10 ** 9 + 7\n\ndef bootstrap(f, stack=[]):\n\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\n\ndef solve():\n\tN = getInt()\n\tG = [[] for _ in range(N)]\n\tdeg = [0] * N\n\tpar = [-1] * N\n\tfor i in range(N - 1):\n\t\t(a, b) = getInts()\n\t\tG[a - 1].append(b - 1)\n\t\tG[b - 1].append(a - 1)\n\tto_add = []\n\tleaves = []\n\tremoved = set()\n\tglobal count\n\tcount = 0\n\n\t@bootstrap\n\tdef dfs(node):\n\t\tglobal count\n\t\tchildren = 0\n\t\tfor neigh in G[node]:\n\t\t\tif neigh != par[node]:\n\t\t\t\tpar[neigh] = node\n\t\t\t\tyield dfs(neigh)\n\t\t\t\tif (node, neigh) not in removed:\n\t\t\t\t\tchildren += 1\n\t\tif children == 2:\n\t\t\tif par[node] != -1:\n\t\t\t\tcount += 1\n\t\t\t\tremoved.add((par[node], node))\n\t\tif children > 2:\n\t\t\tif par[node] != -1:\n\t\t\t\tcount += 1\n\t\t\t\tremoved.add((par[node], node))\n\t\t\tidx = len(G[node]) - 1\n\t\t\twhile children > 2:\n\t\t\t\tif G[node][idx] == par[node]:\n\t\t\t\t\tidx -= 1\n\t\t\t\tcount += 1\n\t\t\t\twhile (node, G[node][idx]) in removed or G[node][idx] == par[node]:\n\t\t\t\t\tidx -= 1\n\t\t\t\tremoved.add((node, G[node][idx]))\n\t\t\t\tchildren -= 1\n\t\t\t\tidx -= 1\n\t\tyield\n\tdfs(0)\n\tends = []\n\tused = [0] * N\n\tglobal flag\n\n\t@bootstrap\n\tdef dfs2(node):\n\t\tglobal flag\n\t\tif flag:\n\t\t\tneighs = 1\n\t\telse:\n\t\t\tneighs = 0\n\t\tflag = True\n\t\tused[node] = 1\n\t\tfor neigh in G[node]:\n\t\t\tif not used[neigh] and (node, neigh) not in removed and ((neigh, node) not in removed):\n\t\t\t\tneighs += 1\n\t\t\t\tyield dfs2(neigh)\n\t\tif neighs == 1:\n\t\t\tends.append(node)\n\t\telif neighs == 0:\n\t\t\tends.append(node)\n\t\t\tends.append(node)\n\t\tyield\n\tfor i in range(N):\n\t\tflag = False\n\t\tif not used[i]:\n\t\t\tdfs2(i)\n\tremoved = list(removed)\n\tprint(len(removed))\n\tj = 0\n\tfor i in range(1, len(ends) - 1, 2):\n\t\tprint(removed[j][0] + 1, removed[j][1] + 1, ends[i] + 1, ends[i + 1] + 1)\n\t\tj += 1\n\treturn\nfor _ in range(getInt()):\n\tsolve()\n"
    },
    {
        "task_id": 675,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.7442781925201416,
        "fastest_time": 2.511434555053711,
        "fastest_solution": "import math as m\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tprint(m.comb(a - 1, b - 1))\n",
        "slowest_solution": "import math\na = int(input())\nfor i in range(a):\n\t(n, k) = map(int, input().split(' '))\n\tprint(math.comb(n - 1, k - 1))\n"
    },
    {
        "task_id": 720,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.6470208168029785,
        "fastest_time": 2.513165235519409,
        "fastest_solution": "import sys\nfrom array import array\nimport typing as Tp\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\n\ndef main():\n\tn = int(input())\n\tadj = [[] for _ in range(n)]\n\tfor (u, v) in (map(int, input().split()) for _ in range(n - 1)):\n\t\tadj[u - 1].append(v - 1)\n\t\tadj[v - 1].append(u - 1)\n\tm = int(input())\n\tquery = [[] for _ in range(n)]\n\tfor _ in range(m):\n\t\t(v, d, x) = map(int, input().split())\n\t\tquery[v - 1].append((d, float(x)))\n\tans = [''] * n\n\tacc = [0.0] * (n + 100)\n\t(value, stack, depth) = (0.0, [[0, 0, -1]], 0)\n\t(d_inf, eps) = (n + 50, 1e-08)\n\twhile stack:\n\t\t(v, ei, parent) = stack[-1]\n\t\tif ei == 0:\n\t\t\tfor (d, x) in query[v]:\n\t\t\t\tacc[depth] += x\n\t\t\t\tacc[min(d_inf, depth + d + 1)] -= x\n\t\t\tvalue += acc[depth]\n\t\t\tans[v] = str(int(value + eps))\n\t\tfor i in range(ei, len(adj[v])):\n\t\t\tif adj[v][i] == parent:\n\t\t\t\tcontinue\n\t\t\tstack[-1][1] = i + 1\n\t\t\tstack.append([adj[v][i], 0, v])\n\t\t\tdepth += 1\n\t\t\tbreak\n\t\telse:\n\t\t\tvalue -= acc[depth]\n\t\t\tfor (d, x) in query[v]:\n\t\t\t\tacc[depth] -= x\n\t\t\t\tacc[min(d_inf, depth + d + 1)] += x\n\t\t\tstack.pop()\n\t\t\tdepth -= 1\n\tsys.stdout.buffer.write((' '.join(ans) + '\\n').encode('utf-8'))\nmain()\n",
        "slowest_solution": "import math\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom collections import defaultdict\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nsys.setrecursionlimit(10 ** 5)\n\ndef bootstrap(f, stack=[]):\n\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\n\n@bootstrap\ndef dfs(u, i, p):\n\tglobal d\n\tglobal s\n\ts += -d[i - 1]\n\tfor j in val[u]:\n\t\td[i + j[0]] += j[1]\n\t\ts += j[1]\n\tans[u] = s\n\tfor j in adj[u]:\n\t\tif j != p:\n\t\t\tyield dfs(j, i + 1, u)\n\tfor j in val[u]:\n\t\td[i + j[0]] += -j[1]\n\t\ts += -j[1]\n\ts += d[i - 1]\n\tyield\nn = int(input())\nadj = [[] for i in range(n + 1)]\nfor j in range(n - 1):\n\t(u, v) = map(int, input().split())\n\tadj[u].append(v)\n\tadj[v].append(u)\nval = [[] for i in range(n + 1)]\nm = int(input())\nfor j in range(m):\n\t(v, d, va) = map(int, input().split())\n\tval[v].append([d, va])\ns = 0\nd = defaultdict(lambda : 0)\nans = [0 for i in range(n + 1)]\ndfs(1, 0, 0)\nprint(*ans[1:])\n"
    },
    {
        "task_id": 705,
        "slowest_solution_id": 2,
        "fastest_solution_id": 3,
        "slowest_time": 2.6525282859802246,
        "fastest_time": 2.5405032634735107,
        "fastest_solution": "import sys\nn = int(sys.stdin.readline().rstrip('\\n'))\na = [[0] * n] * n\nfor i in range(n):\n\tline = list(map(int, sys.stdin.readline().rstrip('\\n').split()))\n\ta[i] = line\ns = [[[0] * 11 for _ in range(n + 1)] for _ in range(n + 1)]\nfor i in range(1, n + 1):\n\tfor j in range(1, n + 1):\n\t\tx = a[i - 1][j - 1]\n\t\ts[i][j][x] = 1\n\t\tfor k in range(1, 11):\n\t\t\ts[i][j][k] = s[i][j][k] + s[i - 1][j][k] + s[i][j - 1][k] - s[i - 1][j - 1][k]\nq = int(sys.stdin.readline().rstrip('\\n'))\nfor _ in range(q):\n\t[x1, y1, x2, y2] = list(map(int, sys.stdin.readline().rstrip('\\n').split()))\n\tcnt = 0\n\tfor i in range(1, 11):\n\t\tif s[x2][y2][i] - s[x2][y1 - 1][i] - s[x1 - 1][y2][i] + s[x1 - 1][y1 - 1][i] > 0:\n\t\t\tcnt = cnt + 1\n\tprint(cnt)\n",
        "slowest_solution": "import sys\nfrom collections import Counter, defaultdict, deque\nfrom math import gcd, sqrt, ceil\n\ndef li():\n\treturn [int(i) for i in sys.stdin.readline().split()]\n\ndef si():\n\treturn sys.stdin.readline().split()\n\ndef ii():\n\treturn int(sys.stdin.readline())\n\ndef ip():\n\treturn input()\nn = ii()\na = [[0] * n] * n\nfor i in range(n):\n\ta[i] = li()\ns = [[[0] * 11 for _ in range(n + 1)] for _ in range(n + 1)]\nq = ii()\nfor i in range(1, n + 1):\n\tfor j in range(1, n + 1):\n\t\tx = a[i - 1][j - 1]\n\t\ts[i][j][x] = 1\n\t\tfor k in range(1, 11):\n\t\t\ts[i][j][k] = s[i][j][k] + s[i - 1][j][k] + s[i][j - 1][k] - s[i - 1][j - 1][k]\nfor _ in range(q):\n\t(x1, y1, x2, y2) = li()\n\tcnt = 0\n\tfor i in range(1, 11):\n\t\tif s[x2][y2][i] - s[x2][y1 - 1][i] - s[x1 - 1][y2][i] + s[x1 - 1][y1 - 1][i] > 0:\n\t\t\tcnt += 1\n\tprint(cnt)\n"
    },
    {
        "task_id": 723,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.5827701091766357,
        "fastest_time": 2.4883766174316406,
        "fastest_solution": "(n, m) = map(int, input().split())\nvars = {}\n\ndef mxor(a, b):\n\tif a == b:\n\t\treturn '0'\n\telif a == '0' and b == '1' or (a == '1' and b == '0'):\n\t\treturn '1'\n\telif a == '0' and b == 'x' or (a == 'x' and b == '0'):\n\t\treturn 'x'\n\telif a == '0' and b == '!' or (a == '!' and b == '0'):\n\t\treturn '!'\n\telif a == '1' and b == 'x' or (a == 'x' and b == '1'):\n\t\treturn '!'\n\telif a == '1' and b == '!' or (a == '!' and b == '1'):\n\t\treturn 'x'\n\telif a == 'x' and b == '!' or (a == '!' and b == 'x'):\n\t\treturn '1'\n\ndef mand(a, b):\n\tif a == b:\n\t\treturn a\n\telif a == '0' or b == '0':\n\t\treturn '0'\n\telif a == '1' and b == 'x' or (a == 'x' and b == '1'):\n\t\treturn 'x'\n\telif a == '1' and b == '!' or (a == '!' and b == '1'):\n\t\treturn '!'\n\telif a == 'x' and b == '!' or (a == '!' and b == 'x'):\n\t\treturn '0'\n\ndef mor(a, b):\n\tif a == b:\n\t\treturn a\n\tif a == '1' or b == '1':\n\t\treturn '1'\n\telif a == '0':\n\t\treturn b\n\telif b == '0':\n\t\treturn a\n\telif a == 'x' and b == '!' or (a == '!' and b == 'x'):\n\t\treturn '1'\n\ndef calc(a, op, b):\n\tglobal m\n\tglobal vars\n\ta = ['x'] * m if a == '?' else vars[a]\n\tb = ['x'] * m if b == '?' else vars[b]\n\tif op == 'XOR':\n\t\top = mxor\n\telif op == 'AND':\n\t\top = mand\n\telse:\n\t\top = mor\n\treturn ''.join([op(x, y) for (x, y) in zip(a, b)])\nfor _ in range(n):\n\ti = input().split()\n\tif len(i) == 3:\n\t\tvars[i[0]] = i[2]\n\telse:\n\t\tvars[i[0]] = calc(*i[2:])\nr = [0] * m\nfor i in range(m):\n\tfor v in vars.values():\n\t\tif v[i] == 'x':\n\t\t\tr[i] += 1\n\t\telif v[i] == '!':\n\t\t\tr[i] -= 1\nmmin = ['0'] * m\nmmax = ['0'] * m\nfor i in range(m):\n\tif r[i] < 0:\n\t\tmmin[i] = '1'\nfor i in range(m):\n\tif r[i] > 0:\n\t\tmmax[i] = '1'\nprint(''.join(mmin))\nprint(''.join(mmax))\n",
        "slowest_solution": "(n, m) = map(int, input().split())\nv = [('?', '')]\ntemp = [(0, 1)]\nd = {}\nd['?'] = 0\n(mn, mx) = ('', '')\nfor i in range(n):\n\t(name, val) = input().split(' := ')\n\tv.append((name, val.split()))\n\ttemp.append((-1, -1))\n\td[name] = i + 1\n\ndef eval(expr, bit1, bit2):\n\tif expr == 'OR':\n\t\treturn bit1 | bit2\n\telif expr == 'AND':\n\t\treturn bit1 and bit2\n\telif expr == 'XOR':\n\t\treturn bit1 ^ bit2\n\telse:\n\t\traise AttributeError()\nfor i in range(m):\n\tfor (name, expr) in v[1:]:\n\t\tj = d[name]\n\t\tif len(expr) == 1:\n\t\t\ttemp[j] = (int(expr[0][i]), int(expr[0][i]))\n\t\telse:\n\t\t\t(bit1, bit2) = (temp[d[expr[0]]], temp[d[expr[2]]])\n\t\t\ttemp[j] = (eval(expr[1], bit1[0], bit2[0]), eval(expr[1], bit1[1], bit2[1]))\n\t(z, o) = (sum((temp[_][0] for _ in range(1, n + 1))), sum((temp[_][1] for _ in range(1, n + 1))))\n\tmn += '1' if o < z else '0'\n\tmx += '1' if o > z else '0'\nprint(mn)\nprint(mx)\n"
    },
    {
        "task_id": 680,
        "slowest_solution_id": 5,
        "fastest_solution_id": 9,
        "slowest_time": 2.702850818634033,
        "fastest_time": 2.4737961292266846,
        "fastest_solution": "from array import array\nfrom collections import defaultdict\n\ndef solve(n, D):\n\tdict_idx = defaultdict(list)\n\tfor (i, d) in enumerate(D):\n\t\tdict_idx[d].append(i)\n\tdict_count = {}\n\tfor d in dict_idx.keys():\n\t\tdict_idx[d].pop(0)\n\t\tdict_count[d] = len(dict_idx[d])\n\ta = None\n\tb = None\n\ta_cnt = 0\n\tb_cnt = 0\n\ta_next_idx = 10 ** 6\n\tb_next_idx = 10 ** 6\n\tfor (i, d) in enumerate(D):\n\t\tif dict_count[d] > 0:\n\t\t\tnext_idx = dict_idx[d].pop(0)\n\t\t\tdict_count[d] -= 1\n\t\telse:\n\t\t\tnext_idx = 10 ** 6\n\t\tif a == d:\n\t\t\ta_next_idx = next_idx\n\t\t\tcontinue\n\t\tif b == d:\n\t\t\tb_next_idx = next_idx\n\t\t\tcontinue\n\t\tif a is None:\n\t\t\ta = d\n\t\t\ta_cnt += 1\n\t\t\ta_next_idx = next_idx\n\t\t\tcontinue\n\t\tif b is None:\n\t\t\tb = d\n\t\t\tb_cnt += 1\n\t\t\tb_next_idx = next_idx\n\t\t\tcontinue\n\t\tif a_next_idx > b_next_idx:\n\t\t\ta = d\n\t\t\ta_cnt += 1\n\t\t\ta_next_idx = next_idx\n\t\t\tcontinue\n\t\telse:\n\t\t\tb = d\n\t\t\tb_cnt += 1\n\t\t\tb_next_idx = next_idx\n\t\t\tcontinue\n\treturn a_cnt + b_cnt\n\ndef main():\n\tans = []\n\tn = int(input())\n\tD = array('i', list(map(int, input().split(' '))))\n\tans.append(solve(n, D))\n\tfor a in ans:\n\t\tprint(a)\nmain()\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline()\n\ndef RL():\n\treturn map(int, sys.stdin.readline().split())\n\ndef RLL():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef N():\n\treturn int(input())\n\ndef S():\n\treturn input().strip()\n\ndef print_list(l):\n\tprint(''.join(map(str, l)))\nn = N()\na = RLL()\na1 = 0\na2 = 0\ns = set()\nans = 0\nfor i in range(n):\n\tif a[i] == a1:\n\t\tcontinue\n\tif a[i] == a2:\n\t\ts = {a1}\n\t\tcontinue\n\tif a[i] in s:\n\t\t(a1, a2) = (a[i], a1)\n\t\ts = {a1}\n\telse:\n\t\ts.add(a[i])\n\t\ta1 = a[i]\n\t\tans += 1\nprint(ans)\n"
    },
    {
        "task_id": 683,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 2.6977155208587646,
        "fastest_time": 2.5106263160705566,
        "fastest_solution": "import sys\nfrom functools import reduce\nfrom collections import Counter\nimport time\nimport datetime\nfrom math import sqrt, gcd\n\ndef ip():\n\treturn int(sys.stdin.readline())\n\ndef sip():\n\treturn sys.stdin.readline()\n\ndef mip():\n\treturn map(int, sys.stdin.readline().split())\n\ndef mips():\n\treturn map(str, sys.stdin.readline().split())\n\ndef lip():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef matip(n, m):\n\tlst = []\n\tfor i in range(n):\n\t\tarr = lip()\n\t\tlst.append(arr)\n\treturn lst\n\ndef factors(n):\n\treturn list(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0))))\n\ndef minJumps(arr, n):\n\tjumps = [0 for i in range(n)]\n\tif n == 0 or arr[0] == 0:\n\t\treturn float('inf')\n\tjumps[0] = 0\n\tfor i in range(1, n):\n\t\tjumps[i] = float('inf')\n\t\tfor j in range(i):\n\t\t\tif i <= j + arr[j] and jumps[j] != float('inf'):\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\n\t\t\t\tbreak\n\treturn jumps[n - 1]\n\ndef dic(arr):\n\treturn Counter(arr)\n\ndef find_prime(n):\n\tif n < 2:\n\t\treturn False\n\tfor i in range(2, int(n ** 0.5) + 1, 2):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n(n, m, d) = mip()\nlst = []\nfor i in range(n):\n\tlst.extend(lip())\nlst.sort()\nmod = lst[0] % d\nflag = 0\ncount = 0\nmedian = lst[n * m // 2]\nfor item in lst:\n\tif item % d != mod:\n\t\tflag = 1\n\t\tbreak\n\telse:\n\t\tcount += abs(median - item)\nif flag == 0:\n\tprint(count // d)\nelse:\n\tprint(-1)\n",
        "slowest_solution": "(n, m, d) = map(int, input().split())\nc = []\nfor i in range(n):\n\tl = list(map(int, input().split()))\n\tc += l\nv = c[0] % d\nflag = False\nfor i in c:\n\tif i % d != v:\n\t\tflag = True\n\t\tbreak\nif flag:\n\tprint(-1)\nelse:\n\tc.sort()\n\tmedian = c[n * m // 2]\n\tcount = 0\n\tfor i in range(n * m):\n\t\tif i < n * m // 2:\n\t\t\tcount += abs((median - c[i]) // d)\n\t\telse:\n\t\t\tcount += abs(c[i] - median) // d\n\tprint(count)\n"
    },
    {
        "task_id": 730,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.485039710998535,
        "fastest_time": 2.485039710998535,
        "fastest_solution": "def check(n, casas):\n\tglobal T, N, street\n\tcurrent = n\n\ttime = T\n\tneed = 0\n\tlast_house = 0\n\tfor (ind, i) in enumerate(street):\n\t\ttime -= 1\n\t\tif i == 'S':\n\t\t\tcurrent += 1\n\t\telif i == 'H':\n\t\t\tneed += 1\n\t\t\tif need == 1:\n\t\t\t\tlast_house = ind\n\t\tif need > 0 and current >= need:\n\t\t\tcurrent -= need\n\t\t\tcasas -= need\n\t\t\tneed = 0\n\t\t\tif casas > 0:\n\t\t\t\tif (ind - last_house) * 2 >= N - last_house - 1:\n\t\t\t\t\ttime -= N - last_house - 1 + N - ind - 1\n\t\t\t\t\treturn time >= 0\n\t\t\t\ttime -= (ind - last_house) * 2\n\t\t\telse:\n\t\t\t\ttime -= ind - last_house\n\t\tif casas == 0:\n\t\t\tbreak\n\treturn time >= 0 and casas == 0\n(N, T) = [int(i) for i in input().split()]\nstreet = input().rstrip('.')\nN = len(street)\nC = street.count('H')\nS = street.count('S')\nl = max(C - S, 0)\nr = 500005\nwhile l < r:\n\tmid = (l + r) // 2\n\tif check(mid, C):\n\t\tr = mid\n\telse:\n\t\tl = mid + 1\nprint(l if l < 500005 else -1)\n",
        "slowest_solution": "def check(n, casas):\n\tglobal T, N, street\n\tcurrent = n\n\ttime = T\n\tneed = 0\n\tlast_house = 0\n\tfor (ind, i) in enumerate(street):\n\t\ttime -= 1\n\t\tif i == 'S':\n\t\t\tcurrent += 1\n\t\telif i == 'H':\n\t\t\tneed += 1\n\t\t\tif need == 1:\n\t\t\t\tlast_house = ind\n\t\tif need > 0 and current >= need:\n\t\t\tcurrent -= need\n\t\t\tcasas -= need\n\t\t\tneed = 0\n\t\t\tif casas > 0:\n\t\t\t\tif (ind - last_house) * 2 >= N - last_house - 1:\n\t\t\t\t\ttime -= N - last_house - 1 + N - ind - 1\n\t\t\t\t\treturn time >= 0\n\t\t\t\ttime -= (ind - last_house) * 2\n\t\t\telse:\n\t\t\t\ttime -= ind - last_house\n\t\tif casas == 0:\n\t\t\tbreak\n\treturn time >= 0 and casas == 0\n(N, T) = [int(i) for i in input().split()]\nstreet = input().rstrip('.')\nN = len(street)\nC = street.count('H')\nS = street.count('S')\nl = max(C - S, 0)\nr = 500005\nwhile l < r:\n\tmid = (l + r) // 2\n\tif check(mid, C):\n\t\tr = mid\n\telse:\n\t\tl = mid + 1\nprint(l if l < 500005 else -1)\n"
    },
    {
        "task_id": 688,
        "slowest_solution_id": 1,
        "fastest_solution_id": 7,
        "slowest_time": 2.685014009475708,
        "fastest_time": 2.4328131675720215,
        "fastest_solution": "LARGE_MOD = 10 ** 9 + 7\n\ndef binomial(n, k, mod):\n\tbinom_array = []\n\tfor m in range(n + 1):\n\t\tbinom_array.append([])\n\t\tfor i in range(m + 1):\n\t\t\tif i == 0 or i == m:\n\t\t\t\tbinom_array[m].append(1)\n\t\t\telse:\n\t\t\t\tbinom_array[m].append((binom_array[m - 1][i - 1] + binom_array[m - 1][i]) % mod)\n\treturn binom_array[n][k]\nnum_test_cases = int(input())\nfor c in range(num_test_cases):\n\tline = input().split()\n\tM = int(line[0])\n\tN = int(line[1])\n\tprint(binomial(M + N, N, LARGE_MOD))\n",
        "slowest_solution": "import sys\nfrom math import sqrt\nmemo = {}\nmemo[0, 0] = 1\n\ndef rec(N, M):\n\tif (N, M) in memo:\n\t\treturn memo[N, M]\n\tret = 0\n\tif N > 0:\n\t\tret += rec(N - 1, M)\n\tif M > 0:\n\t\tret += rec(N, M - 1)\n\tret %= 1000000007\n\tmemo[N, M] = ret\n\treturn ret\n\ndef solve():\n\tstdin = sys.stdin\n\twrite = sys.stdout.write\n\tt = int(stdin.readline())\n\tfor _ in range(t):\n\t\t(n, m) = map(int, stdin.readline().split())\n\t\twrite('%d\\n' % rec(n, m))\nsolve()\n"
    },
    {
        "task_id": 687,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.7216176986694336,
        "fastest_time": 2.4459049701690674,
        "fastest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\tv = []\n\tfor i in range(n):\n\t\tv.append((i, input().index('1')))\n\tanswer = 0\n\tfor i in range(len(v)):\n\t\tr_left = 0\n\t\tr_right = 0\n\t\tc_left = 0\n\t\tc_right = 0\n\t\tfor j in range(i, len(v)):\n\t\t\tif v[j][0] - v[i][0] < r_left:\n\t\t\t\tr_left = v[j][0] - v[i][0]\n\t\t\tif v[j][0] - v[i][0] > r_right:\n\t\t\t\tr_right = v[j][0] - v[i][0]\n\t\t\tif v[j][1] - v[i][1] < c_left:\n\t\t\t\tc_left = v[j][1] - v[i][1]\n\t\t\tif v[j][1] - v[i][1] > c_right:\n\t\t\t\tc_right = v[j][1] - v[i][1]\n\t\t\tif abs(r_right - r_left) <= j - i and abs(c_right - c_left) <= j - i:\n\t\t\t\tanswer += 1\n\tprint(answer)\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tif n == 1:\n\t\tm = int(input())\n\t\tprint(1)\n\telse:\n\t\tm = []\n\t\tindexes = []\n\t\tfor i in range(n):\n\t\t\tl = input()\n\t\t\ttemp = l.index('1')\n\t\t\tindexes.append(temp)\n\t\t\tm.append(l)\n\t\tcounter = 0\n\t\tfor i in range(n):\n\t\t\tleft = indexes[i]\n\t\t\tright = indexes[i]\n\t\t\tfor j in range(i, n):\n\t\t\t\tleft = min(indexes[j], left)\n\t\t\t\tright = max(indexes[j], right)\n\t\t\t\tif right - left == j - i:\n\t\t\t\t\tcounter += 1\n\t\tprint(counter)\n"
    },
    {
        "task_id": 685,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 2.723635196685791,
        "fastest_time": 2.4609246253967285,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\t(n, x, s) = map(int, input().split())\n\tl = [0] * n\n\tl[x - 1] = 'G'\n\tfor i in range(s):\n\t\t(a, b) = map(int, input().split())\n\t\t(l[a - 1], l[b - 1]) = (l[b - 1], l[a - 1])\n\tprint(l.index('G') + 1)\n",
        "slowest_solution": "for i in range(int(input())):\n\t(N, X, S) = map(int, input().split(' '))\n\tfor j in range(1, S + 1):\n\t\t(A, B) = map(int, input().split(' '))\n\t\tif X == A:\n\t\t\tX = B\n\t\telif X == B:\n\t\t\tX = A\n\tprint(X)\n"
    },
    {
        "task_id": 692,
        "slowest_solution_id": 1,
        "fastest_solution_id": 6,
        "slowest_time": 2.6816444396972656,
        "fastest_time": 2.4566776752471924,
        "fastest_solution": "for i in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ta.sort()\n\tprint(n - a[-1])\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split(' ')))\n\tprint(n - max(a))\n"
    },
    {
        "task_id": 728,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.5001959800720215,
        "fastest_time": 2.475476026535034,
        "fastest_solution": "T = int(input())\nfor t in range(T):\n\t(N, Q) = [int(h) for h in input().split()]\n\tneb = [[] for n in range(N)]\n\tfor n in range(N - 1):\n\t\t(u, v) = [int(h) for h in input().split()]\n\t\tneb[u - 1].append(v - 1)\n\t\tneb[v - 1].append(u - 1)\n\tdepth = [0] * N\n\tdepth[0] = 1\n\tqueue = [0]\n\tidx = 0\n\twhile idx < len(queue):\n\t\tparent = queue[idx]\n\t\tfor child in neb[parent]:\n\t\t\tif depth[child] > 0:\n\t\t\t\tcontinue\n\t\t\tdepth[child] = depth[parent] + 1\n\t\t\tqueue.append(child)\n\t\tidx += 1\n\tnums = [len(neb[0]) - 1]\n\tfor n in range(1, N):\n\t\tif depth[n] % 2 == 1:\n\t\t\tnums.append(abs(len(neb[n]) - 2))\n\tif Q == 1:\n\t\tprint(sum(nums))\n\telse:\n\t\tnums.sort(reverse=True)\n\t\tif N > 500:\n\t\t\ts = 0\n\t\t\tfor x in nums:\n\t\t\t\ts = min(s + x, abs(s - x))\n\t\t\tprint(s)\n\t\t\tcontinue\n\n\t\tdef sums(i, j):\n\t\t\tif j == i + 1:\n\t\t\t\treturn [nums[i]]\n\t\t\tk = (i + j) // 2\n\t\t\tleft = sums(i, k)\n\t\t\tright = sums(k, j)\n\t\t\tret = set()\n\t\t\tfor u in left:\n\t\t\t\tfor v in right:\n\t\t\t\t\tret.add(u + v)\n\t\t\t\t\tret.add(abs(u - v))\n\t\t\treturn list(ret)\n\t\tall_sums = sums(0, len(nums))\n\t\tprint(min(all_sums))\n",
        "slowest_solution": "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\n\ndef dfs(p, prev, lvl):\n\tfor i in child[p]:\n\t\tif i == prev:\n\t\t\tcontinue\n\t\tdfs(i, p, lvl + 1)\n\tif lvl & 1:\n\t\ta.append(abs(len(child[p]) - 2))\n\ndef answer():\n\tif q == 1:\n\t\treturn sum(a)\n\telse:\n\t\tdp = 1\n\t\tfor i in range(len(a)):\n\t\t\tdp |= dp << a[i]\n\t\ttotal = sum(a)\n\t\tans = float('inf')\n\t\tfor i in range(n + 1):\n\t\t\tif dp >> i & 1:\n\t\t\t\tans = min(ans, abs(total - 2 * i))\n\t\treturn ans\nfor T in range(int(input())):\n\t(n, q) = map(int, input().split())\n\tchild = [[] for i in range(n + 1)]\n\tfor i in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tchild[u].append(v)\n\t\tchild[v].append(u)\n\tchild[1].append(-1)\n\ta = []\n\tdfs(1, -1, 1)\n\tprint(answer())\n"
    },
    {
        "task_id": 733,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.525937795639038,
        "fastest_time": 2.525937795639038,
        "fastest_solution": "(r, n) = [int(x) for x in input().split()]\ncells = [[int(x) for x in input().split()] for i in range(n)]\ncells.sort()\nout = False\nres = {True: 'WIN', False: 'LOSE'}\nif len(cells) == 0:\n\tprint(res[r % 2 == 1])\nelse:\n\tout = False\n\tfor i in range(1, n):\n\t\tout ^= (cells[i][0] - cells[i - 1][0] - 1) % 2 ^ (cells[i][1] != cells[i - 1][1])\n\tdif = abs(cells[0][0] - 1 - (r - cells[-1][0]))\n\t(hi, lo) = (max(cells[0][0] - 1, r - cells[-1][0]), min(cells[0][0] - 1, r - cells[-1][0]))\n\tif lo > 1:\n\t\tif dif == 0:\n\t\t\tprint(res[out])\n\t\telif dif == 1 and lo % 2 == 0:\n\t\t\tprint(res[not out])\n\t\telse:\n\t\t\tprint(res[True])\n\telif lo == 0:\n\t\tif hi == 0:\n\t\t\tprint(res[out])\n\t\telif hi == 1:\n\t\t\tprint(res[not out])\n\t\telse:\n\t\t\tprint(res[True])\n\telif lo == 1:\n\t\tif hi == 1:\n\t\t\tprint(res[out])\n\t\telse:\n\t\t\tprint(res[True])\n",
        "slowest_solution": "(r, n) = [int(x) for x in input().split()]\ncells = [[int(x) for x in input().split()] for i in range(n)]\ncells.sort()\nout = False\nres = {True: 'WIN', False: 'LOSE'}\nif len(cells) == 0:\n\tprint(res[r % 2 == 1])\nelse:\n\tout = False\n\tfor i in range(1, n):\n\t\tout ^= (cells[i][0] - cells[i - 1][0] - 1) % 2 ^ (cells[i][1] != cells[i - 1][1])\n\tdif = abs(cells[0][0] - 1 - (r - cells[-1][0]))\n\t(hi, lo) = (max(cells[0][0] - 1, r - cells[-1][0]), min(cells[0][0] - 1, r - cells[-1][0]))\n\tif lo > 1:\n\t\tif dif == 0:\n\t\t\tprint(res[out])\n\t\telif dif == 1 and lo % 2 == 0:\n\t\t\tprint(res[not out])\n\t\telse:\n\t\t\tprint(res[True])\n\telif lo == 0:\n\t\tif hi == 0:\n\t\t\tprint(res[out])\n\t\telif hi == 1:\n\t\t\tprint(res[not out])\n\t\telse:\n\t\t\tprint(res[True])\n\telif lo == 1:\n\t\tif hi == 1:\n\t\t\tprint(res[out])\n\t\telse:\n\t\t\tprint(res[True])\n"
    },
    {
        "task_id": 684,
        "slowest_solution_id": 7,
        "fastest_solution_id": 9,
        "slowest_time": 3.5180206298828125,
        "fastest_time": 2.4841983318328857,
        "fastest_solution": "import math\n\ndef coloredBalls():\n\tk = int(input())\n\tif k == 1 or k == 1000:\n\t\tprint('1')\n\t\treturn\n\tn = 0\n\tresultado = 1\n\tfor i in range(0, k):\n\t\tballs = int(input())\n\t\tresultado = resultado * math.factorial(n + balls - 1) // math.factorial(n) // math.factorial(balls - 1) % 1000000007\n\t\tn += balls\n\tprint(resultado)\ncoloredBalls()\n",
        "slowest_solution": "mod = 1000000007\n\ndef pow1(a, b):\n\tans = 1\n\tc = a\n\twhile b:\n\t\tif b & 1:\n\t\t\tans = ans * c % mod\n\t\tb >>= 1\n\t\tc = c * c % mod\n\treturn ans\n\ndef factorial(a, b):\n\tfactor = fact[a] * pow1(fact[b] * fact[a - b] % mod, mod - 2) % mod\n\treturn factor\nfact = []\nfor i in range(1000010):\n\tfact.append(0)\na = []\nfor i in range(1010):\n\ta.append(0)\nfact[0] = 1\nfor i in range(1, 1000000):\n\tfact[i] = fact[i - 1] * i % mod\nn = int(input())\nsum = 0\nfor i in range(0, n):\n\ta[i] = int(input())\n\tsum += a[i]\nans = 1\ni = n - 1\nwhile i > -1:\n\tans = ans * factorial(sum - 1, a[i] - 1) % mod\n\tsum -= a[i]\n\ti -= 1\nprint(ans)\n"
    },
    {
        "task_id": 719,
        "slowest_solution_id": 0,
        "fastest_solution_id": 4,
        "slowest_time": 2.6651885509490967,
        "fastest_time": 2.508624315261841,
        "fastest_solution": "__author__ = 'Michael Ilyin'\nimport math\ndebug = False\n\ndef dist(x1, y1, x2, y2):\n\treturn math.sqrt(math.pow(math.fabs(x1 - x2), 2) + math.pow(math.fabs(y1 - y2), 2))\n\ndef get_y(x1, y1, x2, y2, x):\n\treturn (x - x1) * (y2 - y1) / (x2 - x1) + y1\nif debug:\n\twith open('input.txt', 'r') as inp:\n\t\tfirstLine = inp.readline()\n\t\tsecondLine = inp.readline()\n\t\tthirdLine = inp.readline()\n\t\tfourthLine = inp.readline()\nelse:\n\tfirstLine = input()\n\tsecondLine = input()\n\tthirdLine = input()\n\tfourthLine = input()\nfirst = firstLine.split()\nn = float(first[0])\nm = float(first[1])\na = float(first[2])\nb = float(first[3])\nA = [float(x) for x in secondLine.split()]\nB = [float(x) for x in thirdLine.split()]\nL = [float(x) for x in fourthLine.split()]\nif debug:\n\tprint(A)\n\tprint(B)\n\tprint(L)\noptimalLen = float('inf')\noptimalBIdx = -1\nfor (i, bi) in enumerate(B):\n\td = dist(0, 0, b, bi) + L[i]\n\tif d <= optimalLen:\n\t\toptimalLen = d\n\t\toptimalBIdx = i\nif debug:\n\tprint(optimalBIdx + 1, optimalLen)\nintersectY = get_y(0, 0, b, B[optimalBIdx], a)\nif debug:\n\tprint(intersectY)\npointDist = float('inf')\noptimalAIdx = -1\nfor (i, ai) in enumerate(A):\n\td = dist(a, ai, a, intersectY)\n\tif d < pointDist:\n\t\tpointDist = d\n\t\toptimalAIdx = i\nif debug:\n\tprint(optimalAIdx + 1, pointDist)\noptimalLen = float('inf')\noptimalBIdx = -1\nfor (i, bi) in enumerate(B):\n\td = dist(a, A[optimalAIdx], b, bi) + L[i]\n\tif d <= optimalLen:\n\t\toptimalLen = d\n\t\toptimalBIdx = i\nprint(optimalAIdx + 1, optimalBIdx + 1)\n",
        "slowest_solution": "import sys\nfrom itertools import *\nfrom math import *\n\ndef solve():\n\t(n, m, leftbank, rightbank) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\tl = list(map(int, input().split()))\n\tsmallx = leftbank\n\tsmallxsquared = smallx * smallx\n\trightbankminusleftbanksquared = (rightbank - leftbank) * (rightbank - leftbank)\n\t(leftbest, rightbest, distbest) = (-1, -1, 100000000)\n\tfor (i, bcord, length) in zip(count(), b, l):\n\t\twanty = bcord * smallx / rightbank\n\t\t(ll, rr) = (0, n - 1)\n\t\twhile ll < rr:\n\t\t\tmm = (ll + rr + 1) // 2\n\t\t\tif a[mm] > wanty:\n\t\t\t\trr = mm - 1\n\t\t\telse:\n\t\t\t\tll = mm\n\t\tfor pos in range(ll, ll + 2):\n\t\t\tif pos < n:\n\t\t\t\ttemp = a[pos]\n\t\t\t\tfirst = sqrt(smallxsquared + temp * temp)\n\t\t\t\ttemp = bcord - a[pos]\n\t\t\t\tsecond = sqrt(rightbankminusleftbanksquared + temp * temp)\n\t\t\t\ttotaldist = first + second + length\n\t\t\t\tif totaldist < distbest:\n\t\t\t\t\tdistbest = totaldist\n\t\t\t\t\tleftbest = pos\n\t\t\t\t\trightbest = i\n\tprint(leftbest + 1, rightbest + 1)\nif sys.hexversion == 50594544:\n\tsys.stdin = open('test.txt')\nsolve()\n"
    },
    {
        "task_id": 693,
        "slowest_solution_id": 1,
        "fastest_solution_id": 7,
        "slowest_time": 3.357734441757202,
        "fastest_time": 2.53008770942688,
        "fastest_solution": "MOD = 10 ** 9 + 7\nm = int(input())\nf = [0] * (m + 1)\nans = 1\nfor i in range(m, 1, -1):\n\tp = m // i * pow(m, MOD - 2, MOD)\n\tf[i] = p * pow(1 - p, MOD - 2, MOD) % MOD\n\tfor j in range(2 * i, m + 1, i):\n\t\tf[i] = (f[i] - f[j]) % MOD\n\tans += f[i]\nprint(ans % MOD)\n",
        "slowest_solution": "N = 100010\n\ndef gen_mobius_function():\n\tmu = [1] * N\n\tmu[0] = 0\n\tP = [True] * N\n\tP[0] = P[1] = False\n\tfor i in range(2, N):\n\t\tif P[i]:\n\t\t\tj = i\n\t\t\twhile j < N:\n\t\t\t\tP[j] = False\n\t\t\t\tmu[j] *= -1\n\t\t\t\tj += i\n\t\t\tj = i * i\n\t\t\twhile j < N:\n\t\t\t\tmu[j] = 0\n\t\t\t\tj += i * i\n\treturn mu\nm = int(input())\nmu = gen_mobius_function()\nMOD = 10 ** 9 + 7\n\ndef mod_inv(x):\n\treturn pow(x, MOD - 2, MOD)\nE = 1\nfor i in range(2, N):\n\tp = m // i * mod_inv(m)\n\tE += -mu[i] * p * mod_inv(1 - p)\nprint(E % MOD)\n"
    },
    {
        "task_id": 696,
        "slowest_solution_id": 0,
        "fastest_solution_id": 5,
        "slowest_time": 2.7084572315216064,
        "fastest_time": 2.470646381378174,
        "fastest_solution": "c = int(input())\nl = []\nfor im in range(0, c):\n\tkl = str(input())\n\tkl = kl.split(' ')\n\tlp = int(kl[-1])\n\tmm = str(input())\n\tume = [lp, mm]\n\tl.append(ume)\nfor tt in l:\n\tumthj = tt[0]\n\ta = tt[1]\n\tx = 0\n\tif len(a) % 2 == 0:\n\t\tx = len(a) // 2\n\telse:\n\t\tx = (len(a) + 1) // 2\n\tpdfr = list(a)\n\tfor jk in range(0, x):\n\t\tif a[jk] != a[len(a) - jk - 1]:\n\t\t\tpdfr.pop(jk)\n\t\t\tpdfr.insert(jk, a[len(a) - jk - 1])\n\t\t\tumthj -= 1\n\tgbt = ''.join(pdfr)\n\tif umthj == 0:\n\t\tprint('YES')\n\telif umthj < 0:\n\t\tprint('NO')\n\telse:\n\t\te = 0\n\t\tfor unb in range(0, x):\n\t\t\tif unb != len(a) - unb - 1:\n\t\t\t\tap = umthj\n\t\t\t\tap -= 2\n\t\t\t\tif ap < 0:\n\t\t\t\t\tcontinue\n\t\t\t\tif ap == 0:\n\t\t\t\t\te = 1\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tumthj -= 2\n\t\t\telse:\n\t\t\t\tap = umthj\n\t\t\t\tap -= 1\n\t\t\t\tif ap < 0:\n\t\t\t\t\tcontinue\n\t\t\t\telif ap == 0:\n\t\t\t\t\te = 1\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tumthj -= 1\n\t\tif e == 1:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().strip().split())\n\ts = input()\n\td = s[::-1]\n\ta = 0\n\tfor i in range(n):\n\t\tif s[i] != d[i]:\n\t\t\ta += 1\n\ta //= 2\n\tif a > k or (n % 2 == 0 and (a - k) % 2 == 1):\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n"
    },
    {
        "task_id": 698,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 2.7242021560668945,
        "fastest_time": 2.4996535778045654,
        "fastest_solution": "n = int(input())\nl = []\nfor i in range(0, n):\n\t(a, b) = map(int, input().split())\n\tl.append([a, b])\nfor i in range(0, n):\n\tprint(l[i][0] + l[i][1])\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(a, b) = [int(i) for i in input().split()]\n\tprint(a + b)\n"
    },
    {
        "task_id": 732,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.556838274002075,
        "fastest_time": 2.556838274002075,
        "fastest_solution": "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nr = cin.readline\nri = lambda : range(int(r()))\nmi = lambda : map(int, r().split())\nfor _ in ri():\n\t(n, m, k) = mi()\n\tfinal = n + m\n\txyce = [tuple(mi()) for _ in range(k)]\n\tbatteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n\tbatteries.sort(key=itemgetter(0))\n\tdp = [(-final, 0)]\n\tfor (loc, c, e) in reversed(batteries):\n\t\tj = bisect(dp, (-(loc + e), -inf))\n\t\tif j == len(dp):\n\t\t\tcontinue\n\t\tdpval = c + dp[j][1]\n\t\twhile dpval < dp[-1][1]:\n\t\t\tdp.pop()\n\t\tif loc != dp[-1][0]:\n\t\t\tdp.append((-loc, dpval))\n\tprint(dp[-1][1])\n",
        "slowest_solution": "from bisect import bisect\nfrom math import inf\nfrom operator import itemgetter\nimport sys\ncin = sys.stdin\nr = cin.readline\nri = lambda : range(int(r()))\nmi = lambda : map(int, r().split())\nfor _ in ri():\n\t(n, m, k) = mi()\n\tfinal = n + m\n\txyce = [tuple(mi()) for _ in range(k)]\n\tbatteries = [(x + y, c, e) for (x, y, c, e) in xyce if x + y < final]\n\tbatteries.sort(key=itemgetter(0))\n\tdp = [(-final, 0)]\n\tfor (loc, c, e) in reversed(batteries):\n\t\tj = bisect(dp, (-(loc + e), -inf))\n\t\tif j == len(dp):\n\t\t\tcontinue\n\t\tdpval = c + dp[j][1]\n\t\twhile dpval < dp[-1][1]:\n\t\t\tdp.pop()\n\t\tif loc != dp[-1][0]:\n\t\t\tdp.append((-loc, dpval))\n\tprint(dp[-1][1])\n"
    },
    {
        "task_id": 747,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 0.0014963150024414062,
        "fastest_time": 0.0,
        "fastest_solution": "from fractions import Fraction\n\ndef expand(x, digit):\n\tstep = 0\n\tfact = 1\n\texpo = Fraction(1)\n\tn = 10 ** len(str(x).split('.')[-1])\n\tx = Fraction(int(x * n), n)\n\twhile expo.numerator < 10 ** (digit - 1):\n\t\tstep += 1\n\t\tfact *= step\n\t\texpo += x ** step / fact\n\treturn [expo.numerator, expo.denominator]\n",
        "slowest_solution": "from fractions import Fraction\nfrom math import factorial\n\ndef expand(x, digit, i=0, s=0):\n\tif x == 1 and digit == 5:\n\t\treturn [109601, 40320]\n\ts = s + Fraction(Fraction(x).limit_denominator(digit) ** i, factorial(i))\n\tif len(str(s.numerator)) >= digit:\n\t\treturn [s.numerator, s.denominator]\n\treturn expand(x, digit, i=i + 1, s=s)\n"
    },
    {
        "task_id": 700,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 2.6352827548980713,
        "fastest_time": 2.4407520294189453,
        "fastest_solution": "ntestcases = int(input())\nfor i in range(ntestcases):\n\ttlen = int(input())\n\tt = list(input())\n\tsTotMap = {}\n\ttTosMap = {}\n\tnextLetter = 'a'\n\tanswer = ['a'] * tlen\n\tj = 0\n\n\tdef detectCycle(s, t):\n\t\tcurr = t\n\t\twhile curr in sTotMap:\n\t\t\tnext = sTotMap[curr]\n\t\t\tif next == s:\n\t\t\t\treturn True\n\t\t\tcurr = next\n\t\treturn False\n\tfor c in t:\n\t\tif c in tTosMap:\n\t\t\tanswer[j] = tTosMap[c]\n\t\t\tj += 1\n\t\t\tcontinue\n\t\tcurrLetter = nextLetter\n\t\twhile currLetter in sTotMap or c == currLetter or (len(sTotMap) < 25 and detectCycle(currLetter, c)):\n\t\t\tcurrLetter = chr(ord(currLetter) + 1)\n\t\tif currLetter == nextLetter:\n\t\t\tnextLetter = chr(ord(nextLetter) + 1)\n\t\tanswer[j] = currLetter\n\t\tj += 1\n\t\tsTotMap[currLetter] = c\n\t\ttTosMap[c] = currLetter\n\tprint(''.join(answer))\n",
        "slowest_solution": "import string\nfor _ in range(int(input())):\n\tn = int(input())\n\tst = input()\n\ts = set()\n\tmp = {}\n\tletters = list(string.ascii_lowercase)\n\n\tdef check(l, c):\n\t\twhile l in mp:\n\t\t\tl = mp[l]\n\t\t\tif l == c:\n\t\t\t\treturn True\n\t\treturn False\n\tfor c in st:\n\t\tif c in mp:\n\t\t\tcontinue\n\t\tfor l in letters:\n\t\t\tif l == c or (l in mp and check(l, c) and (len(mp) < 25)):\n\t\t\t\tcontinue\n\t\t\tmp[c] = l\n\t\t\tletters.remove(l)\n\t\t\tbreak\n\tprint(''.join((mp[c] for c in st)))\n"
    },
    {
        "task_id": 749,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def zombie_shootout(zombies, distance, ammo, shot=0):\n\tif not zombies:\n\t\treturn f'You shot all {shot} zombies.'\n\tif distance <= 0:\n\t\treturn f'You shot {shot} zombies before being eaten: overwhelmed.'\n\tif not ammo:\n\t\treturn f'You shot {shot} zombies before being eaten: ran out of ammo.'\n\treturn zombie_shootout(zombies - 1, distance - 0.5, ammo - 1, shot + 1)\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 737,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.5156235694885254,
        "fastest_time": 2.4830667972564697,
        "fastest_solution": "import sys\nn = int(input())\nif n % 2 == 0:\n\tprint('First')\n\tsys.stdout.flush()\n\tans = []\n\tfor i in range(n):\n\t\tans.append(str(i + 1))\n\tfor i in range(n):\n\t\tans.append(str(i + 1))\n\tprint(' '.join(ans))\n\tsys.stdout.flush()\nelse:\n\tprint('Second')\n\tsys.stdout.flush()\n\tp = list(map(int, input().split()))\n\tinverseP = []\n\tfor i in range(n):\n\t\tinverseP.append([])\n\tfor i in range(2 * n):\n\t\tinverseP[p[i] - 1].append(i)\n\tfor i in range(2 * n):\n\t\tp[i] -= 1\n\tchosenElement = []\n\tconsideredList = [False] * (2 * n)\n\tcnt = 0\n\twhile len(chosenElement) < n:\n\t\twhile consideredList[inverseP[cnt][0]]:\n\t\t\tcnt += 1\n\t\tif cnt >= n:\n\t\t\tbreak\n\t\tcurrentElement = inverseP[cnt][0]\n\t\twhile True:\n\t\t\tif consideredList[currentElement]:\n\t\t\t\tbreak\n\t\t\tchosenElement.append(currentElement + 1)\n\t\t\tconsideredList[currentElement] = True\n\t\t\tconsideredList[(currentElement + n) % (n * 2)] = True\n\t\t\tcurP = p[(currentElement + n) % (n * 2)]\n\t\t\tif (currentElement + n) % (n * 2) == inverseP[curP][0]:\n\t\t\t\tcurrentElement = inverseP[curP][1]\n\t\t\telse:\n\t\t\t\tcurrentElement = inverseP[curP][0]\n\tif sum(chosenElement) % (2 * n) == 0:\n\t\tprint(' '.join(map(str, chosenElement)))\n\telse:\n\t\tisChosen = [False] * (2 * n)\n\t\tfor elem in chosenElement:\n\t\t\tisChosen[elem - 1] = True\n\t\tans = []\n\t\tfor i in range(2 * n):\n\t\t\tif isChosen[i] == False:\n\t\t\t\tans.append(str(i + 1))\n\t\tprint(' '.join(ans))\n",
        "slowest_solution": "import sys\nn = int(input())\nif n % 2:\n\tprint('Second')\n\tsys.stdout.flush()\n\tl = list(map(lambda x: int(x) - 1, input().split()))\n\trev1 = [-1] * n\n\trev2 = [-1] * n\n\trevs = [0] * n\n\tfor i in range(2 * n):\n\t\trevs[l[i]] += i\n\t\tif rev1[l[i]] == -1:\n\t\t\trev1[l[i]] = i\n\t\telse:\n\t\t\trev2[l[i]] = i\n\tout = [0] * (2 * n)\n\tcurr = 0\n\ttodo = 2 * n\n\tq = []\n\twhile todo:\n\t\twhile out[curr] and curr < 2 * n:\n\t\t\tcurr += 1\n\t\tif curr == 2 * n:\n\t\t\tbreak\n\t\tout[curr] = 1\n\t\ttodo -= 1\n\t\tq = [curr]\n\t\twhile q:\n\t\t\tv = q.pop()\n\t\t\tmod = v % n\n\t\t\tother = 2 * mod + n - v\n\t\t\tif out[other] == 0:\n\t\t\t\tout[other] = 3 - out[v]\n\t\t\t\ttodo -= 1\n\t\t\t\tq.append(other)\n\t\t\tother = revs[l[v]] - v\n\t\t\tif out[other] == 0:\n\t\t\t\tout[other] = 3 - out[v]\n\t\t\t\ttodo -= 1\n\t\t\t\tq.append(other)\n\ts1 = 0\n\tfor i in range(2 * n):\n\t\tif out[i] == 1:\n\t\t\ts1 += i + 1\n\tif s1 % (2 * n) == 0:\n\t\twant = 1\n\telse:\n\t\twant = 2\n\trout = []\n\tfor i in range(2 * n):\n\t\tif out[i] == want:\n\t\t\trout.append(i + 1)\n\tprint(' '.join(map(str, rout)))\n\tsys.stdout.flush()\nelse:\n\tprint('First')\n\tsys.stdout.flush()\n\tl = [1 + i % n for i in range(2 * n)]\n\tprint(' '.join(map(str, l)))\n\tsys.stdout.flush()\n"
    },
    {
        "task_id": 697,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 5.1781227588653564,
        "fastest_time": 2.516209125518799,
        "fastest_solution": "mod = 1000000007\nMOD = 998244353\nii = lambda : int(input())\nsi = lambda : input()\ndgl = lambda : list(map(int, input()))\nf = lambda : map(int, input().split())\nil = lambda : list(map(int, input().split()))\nit = lambda : tuple(map(int, input().split()))\nls = lambda : list(input())\n\nclass Triplet:\n\n\tdef __init__(self, x, y, gd):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.gd = gd\n\ndef extendedGCD(a, b):\n\tif b == 0:\n\t\treturn Triplet(1, 0, a)\n\tans = extendedGCD(b, a % b)\n\treturn Triplet(ans.y, ans.x - a // b * ans.y, ans.gd)\n\ndef modInverse(a, m):\n\tz = extendedGCD(a, m).x\n\treturn z\nfor _ in range(ii()):\n\t(n, m, k) = f()\n\tsrik = [0] * k\n\tummi = [0] * (n + 1)\n\tsrik[0] = 1\n\tfor i in range(1, k):\n\t\tsrik[i] = srik[i - 1] * (n - i + 1) % mod\n\t\tsrik[i] = srik[i] * modInverse(i, mod) % mod\n\tummi[0] = 1\n\tans = 1\n\tfor i in range(1, n + 1):\n\t\tummi[i] = ummi[i - 1] * (m - 1) % mod\n\t\tans = ans * m % mod\n\tfor i in range(k):\n\t\tans = (mod + ans - srik[i] * ummi[n - i] % mod) % mod\n\tprint(ans)\n",
        "slowest_solution": "mod = int(1000000007)\nfact = [0] * 100005\ninvfact = [0] * 100005\n\ndef powe(a, b):\n\tif b == 0:\n\t\treturn 1\n\ttemp = powe(a, int(b / 2))\n\ttemp = temp * temp % mod\n\tif b % 2 == 1:\n\t\ttemp = temp * a % mod\n\treturn temp\n\ndef pre():\n\tfact[0] = 1\n\tinvfact[0] = 1\n\tfor x in range(1, 100005):\n\t\tfact[x] = fact[x - 1] * x % mod\n\t\tinvfact[x] = powe(fact[x], int(mod - 2))\n\ndef comb(n, r):\n\tif r > n:\n\t\treturn 0\n\tif n == r or r == 0:\n\t\treturn 1\n\tA = fact[n]\n\tB = invfact[r]\n\tA = A * B % mod\n\tC = invfact[n - r]\n\tA = A * C % mod\n\treturn A\nt = int(input())\npre()\nfor tt in range(t):\n\tarr = input()\n\tarr = list(map(int, arr.split(' ')))\n\tn = arr[0]\n\tm = arr[1]\n\tk = arr[2]\n\tans = powe(m, n)\n\tfor i in range(0, k):\n\t\tb = comb(n, i)\n\t\tc = powe(m - 1, n - i)\n\t\tb = b * c % mod\n\t\tans -= b\n\t\tans %= mod\n\t\tans = (ans + mod) % mod\n\tprint(ans)\n"
    },
    {
        "task_id": 702,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 2.9043338298797607,
        "fastest_time": 2.4871227741241455,
        "fastest_solution": "import math\nfor t in range(int(input())):\n\tn = int(input())\n\tif n == 1:\n\t\tprint('FastestFinger')\n\telif n == 2:\n\t\tprint('Ashishgup')\n\telif n % 2 == 1:\n\t\tprint('Ashishgup')\n\telse:\n\t\tcount = 0\n\t\twhile n % 2 == 0:\n\t\t\tn //= 2\n\t\t\tcount += 1\n\t\tk = 1\n\t\tfor i in range(3, int(math.sqrt(n)) + 1):\n\t\t\tif n % i == 0:\n\t\t\t\tk = i\n\t\t\t\tbreak\n\t\tif count == 1:\n\t\t\tif k == 1:\n\t\t\t\tprint('FastestFinger')\n\t\t\telse:\n\t\t\t\tprint('Ashishgup')\n\t\telif n != 1:\n\t\t\tprint('Ashishgup')\n\t\telse:\n\t\t\tprint('FastestFinger')\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor tests in range(t):\n\tn = int(input())\n\tif n == 1:\n\t\tprint('FastestFinger')\n\telif n % 2 == 1:\n\t\tprint('Ashishgup')\n\telif n == 2:\n\t\tprint('Ashishgup')\n\telse:\n\t\tk = 0\n\t\tfor i in range(3, 10 ** 5 + 1, 2):\n\t\t\twhile n % i == 0:\n\t\t\t\tn //= i\n\t\t\t\tk += 1\n\t\tl = 0\n\t\twhile n % 2 == 0:\n\t\t\tl += 1\n\t\t\tn //= 2\n\t\tif n != 1:\n\t\t\tk += 1\n\t\tif l == 1:\n\t\t\tif k == 0:\n\t\t\t\tprint('Ashishgup')\n\t\t\telif k == 1:\n\t\t\t\tprint('FastestFinger')\n\t\t\telse:\n\t\t\t\tprint('Ashishgup')\n\t\telif k == 0:\n\t\t\tprint('FastestFinger')\n\t\telse:\n\t\t\tprint('Ashishgup')\n"
    },
    {
        "task_id": 704,
        "slowest_solution_id": 2,
        "fastest_solution_id": 3,
        "slowest_time": 2.7174603939056396,
        "fastest_time": 2.46150279045105,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\nfor _ in range(int(input())):\n\tctr = defaultdict(lambda : 0)\n\tmp = defaultdict(lambda : 0)\n\t(p, q) = (1, 0)\n\t(n, m) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tfor x in a:\n\t\tctr[x] += 1\n\tfor x in a:\n\t\tif m != 0:\n\t\t\tmp[x ^ m] += 1\n\tfor x in a:\n\t\tif mp[x] + ctr[x] > p:\n\t\t\tp = mp[x] + ctr[x]\n\t\t\tq = mp[x]\n\t\tif mp[x] + ctr[x] == p:\n\t\t\tq = min(q, mp[x])\n\tprint(p, q)\n",
        "slowest_solution": "for t in range(int(input())):\n\t(n, x) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\td = dict()\n\tfor i in a:\n\t\tif i not in d:\n\t\t\td[i] = 0\n\t\td[i] += 1\n\te = dict()\n\tfor i in a:\n\t\tif i ^ x not in e:\n\t\t\te[i ^ x] = 0\n\t\te[i ^ x] += 1\n\tans = [0, 1000000000]\n\tif x == 0:\n\t\tprint(max(d.values()), 0)\n\t\tcontinue\n\tfor i in d:\n\t\ttemp = [d.get(i, 0) + e.get(i, 0), e.get(i, 0)]\n\t\tif ans[0] < temp[0]:\n\t\t\tans = temp\n\t\telif ans[0] == temp[0]:\n\t\t\tans = min(ans, temp)\n\tprint(*ans)\n"
    },
    {
        "task_id": 751,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5492029190063477,
        "fastest_time": 2.5492029190063477,
        "fastest_solution": "mod = 1000000007\n\ndef mmul(A, B):\n\ts = len(A)\n\tC = [[0 for i in range(s)] for j in range(s)]\n\tfor i in range(s):\n\t\tfor j in range(s):\n\t\t\tfor k in range(s):\n\t\t\t\tC[i][j] += A[i][k] * B[k][j]\n\t\t\t\tC[i][j] %= mod\n\treturn C\n\ndef mpow(A, N, I):\n\tif N == 0:\n\t\treturn I\n\tif N == 1:\n\t\treturn A\n\tret = mpow(A, N // 2, I)\n\tret1 = mmul(ret, ret)\n\tif N % 2 == 0:\n\t\treturn ret1\n\telse:\n\t\treturn mmul(ret1, A)\ntest = int(input())\nfor _ in range(test):\n\t(N, n) = [int(c) for c in input().split()]\n\tI = [[0 for i in range(n)] for j in range(n)]\n\tfor i in range(0, n):\n\t\tI[i][i] = 1\n\todd = [[0 for i in range(n)] for j in range(n)]\n\teven = [[0 for i in range(n)] for j in range(n)]\n\tfor i in range(n):\n\t\todd[i][i] = 1\n\t\tif i >= 1:\n\t\t\teven[i][i - 1] = 1\n\t\t\todd[i][i - 1] = 1\n\t\tif i < n - 1:\n\t\t\teven[i][i + 1] = 1\n\t\t\todd[i][i + 1] = 1\n\tT = mmul(even, odd)\n\tN -= 1\n\tans = mpow(T, N // 2, I)\n\tret = 0\n\tif N % 2:\n\t\tans = mmul(ans, even)\n\tfor i in ans:\n\t\tfor j in i:\n\t\t\tret += j\n\t\t\tret %= mod\n\tprint(ret)\n",
        "slowest_solution": "mod = 1000000007\n\ndef mmul(A, B):\n\ts = len(A)\n\tC = [[0 for i in range(s)] for j in range(s)]\n\tfor i in range(s):\n\t\tfor j in range(s):\n\t\t\tfor k in range(s):\n\t\t\t\tC[i][j] += A[i][k] * B[k][j]\n\t\t\t\tC[i][j] %= mod\n\treturn C\n\ndef mpow(A, N, I):\n\tif N == 0:\n\t\treturn I\n\tif N == 1:\n\t\treturn A\n\tret = mpow(A, N // 2, I)\n\tret1 = mmul(ret, ret)\n\tif N % 2 == 0:\n\t\treturn ret1\n\telse:\n\t\treturn mmul(ret1, A)\ntest = int(input())\nfor _ in range(test):\n\t(N, n) = [int(c) for c in input().split()]\n\tI = [[0 for i in range(n)] for j in range(n)]\n\tfor i in range(0, n):\n\t\tI[i][i] = 1\n\todd = [[0 for i in range(n)] for j in range(n)]\n\teven = [[0 for i in range(n)] for j in range(n)]\n\tfor i in range(n):\n\t\todd[i][i] = 1\n\t\tif i >= 1:\n\t\t\teven[i][i - 1] = 1\n\t\t\todd[i][i - 1] = 1\n\t\tif i < n - 1:\n\t\t\teven[i][i + 1] = 1\n\t\t\todd[i][i + 1] = 1\n\tT = mmul(even, odd)\n\tN -= 1\n\tans = mpow(T, N // 2, I)\n\tret = 0\n\tif N % 2:\n\t\tans = mmul(ans, even)\n\tfor i in ans:\n\t\tfor j in i:\n\t\t\tret += j\n\t\t\tret %= mod\n\tprint(ret)\n"
    },
    {
        "task_id": 752,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.551342248916626,
        "fastest_time": 2.551342248916626,
        "fastest_solution": "mod = 1000000007\n\ndef sum(x, y, k, add):\n\tif k < add:\n\t\treturn 0\n\tup = x + add\n\tif up > k:\n\t\tup = k\n\tadd = add + 1\n\treturn y * ((add + up) * (up - add + 1) // 2 % mod) % mod\n\ndef solve(x, y, k, add=0):\n\tif x == 0 or y == 0:\n\t\treturn 0\n\tif x > y:\n\t\t(x, y) = (y, x)\n\tpw = 1\n\twhile pw << 1 <= y:\n\t\tpw <<= 1\n\tif pw <= x:\n\t\treturn (sum(pw, pw, k, add) + sum(pw, x + y - pw - pw, k, add + pw) + solve(x - pw, y - pw, k, add)) % mod\n\telse:\n\t\treturn (sum(pw, x, k, add) + solve(x, y - pw, k, add + pw)) % mod\nq = int(input())\nfor i in range(0, q):\n\t(x1, y1, x2, y2, k) = list(map(int, input().split()))\n\tans = (solve(x2, y2, k) - solve(x1 - 1, y2, k) - solve(x2, y1 - 1, k) + solve(x1 - 1, y1 - 1, k)) % mod\n\tif ans < 0:\n\t\tans += mod\n\tprint(ans)\n",
        "slowest_solution": "mod = 1000000007\n\ndef sum(x, y, k, add):\n\tif k < add:\n\t\treturn 0\n\tup = x + add\n\tif up > k:\n\t\tup = k\n\tadd = add + 1\n\treturn y * ((add + up) * (up - add + 1) // 2 % mod) % mod\n\ndef solve(x, y, k, add=0):\n\tif x == 0 or y == 0:\n\t\treturn 0\n\tif x > y:\n\t\t(x, y) = (y, x)\n\tpw = 1\n\twhile pw << 1 <= y:\n\t\tpw <<= 1\n\tif pw <= x:\n\t\treturn (sum(pw, pw, k, add) + sum(pw, x + y - pw - pw, k, add + pw) + solve(x - pw, y - pw, k, add)) % mod\n\telse:\n\t\treturn (sum(pw, x, k, add) + solve(x, y - pw, k, add + pw)) % mod\nq = int(input())\nfor i in range(0, q):\n\t(x1, y1, x2, y2, k) = list(map(int, input().split()))\n\tans = (solve(x2, y2, k) - solve(x1 - 1, y2, k) - solve(x2, y1 - 1, k) + solve(x1 - 1, y1 - 1, k)) % mod\n\tif ans < 0:\n\t\tans += mod\n\tprint(ans)\n"
    },
    {
        "task_id": 727,
        "slowest_solution_id": 2,
        "fastest_solution_id": 1,
        "slowest_time": 2.5803616046905518,
        "fastest_time": 2.494044065475464,
        "fastest_solution": "from pprint import pprint\n\ndef main():\n\t(n, m) = map(int, input().split(' '))\n\tadj = [[1] * n for _ in range(n)]\n\tfor i in range(n):\n\t\tadj[i][i] = 0\n\tfor _ in range(m):\n\t\t(x, y) = map(int, input().split(' '))\n\t\tx -= 1\n\t\ty -= 1\n\t\tadj[x][y] = adj[y][x] = 0\n\tadj = [tuple(r) for r in adj]\n\treps = sorted({tuple([0] * n), *adj})\n\tif len(reps) == 1:\n\t\tprint('Yes')\n\t\tprint('a' * n)\n\t\treturn\n\telif len(reps) == 3:\n\t\tgs = [[0] * n for _ in range(3)]\n\t\tfor (i, r) in enumerate(adj):\n\t\t\tri = reps.index(r)\n\t\t\tgs[ri][i] = 1 if ri else 0\n\t\tgs = [tuple(g) for g in gs]\n\t\tfor (i, r) in enumerate(adj):\n\t\t\tif r != gs[[0, 2, 1][reps.index(r)]]:\n\t\t\t\tprint('No')\n\t\t\t\treturn\n\t\tprint('Yes')\n\t\tprint(''.join(('bac'[reps.index(r)] for r in adj)))\n\t\treturn\n\tprint('No')\nmain()\n",
        "slowest_solution": "def dfs(v, used, g):\n\tused[v] = True\n\tfor x in g[v]:\n\t\tif not used[x]:\n\t\t\tdfs(x, used, g)\nfrom collections import defaultdict, Counter\n(n, m) = map(int, input().split())\ng = defaultdict(set)\np = Counter()\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\ta -= 1\n\tb -= 1\n\tg[a].add(b)\n\tg[b].add(a)\n\tp[a] += 1\n\tp[b] += 1\npows_set = defaultdict(set)\nfor i in range(n):\n\tpows_set[p[i]].add(i)\npows_list = list(pows_set.keys())\npows_list.sort()\nif len(pows_list) > 3:\n\tprint('No')\n\texit()\nif len(pows_list) == 3:\n\tflag = True\n\tfor key in pows_set:\n\t\tfor x in pows_set[key]:\n\t\t\tfor y in pows_set[key]:\n\t\t\t\tif x != y and x not in g[y]:\n\t\t\t\t\tflag = False\n\tfor x in pows_set[pows_list[-1]]:\n\t\tfor i in range(n):\n\t\t\tif i != x and x not in g[i]:\n\t\t\t\tflag = False\n\tfor x in pows_set[pows_list[0]]:\n\t\tfor y in pows_set[pows_list[1]]:\n\t\t\tif x in g[y]:\n\t\t\t\tflag = False\n\tif not flag:\n\t\tprint('No')\n\t\texit()\n\tprint('Yes')\n\tfor i in range(n):\n\t\tif i in pows_set[pows_list[0]]:\n\t\t\tprint('a', end='')\n\t\tif i in pows_set[pows_list[1]]:\n\t\t\tprint('c', end='')\n\t\tif i in pows_set[pows_list[2]]:\n\t\t\tprint('b', end='')\nif len(pows_list) == 1:\n\tused = [False for i in range(n)]\n\tdfs(0, used, g)\n\tflag = True\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\tif i == j:\n\t\t\t\tcontinue\n\t\t\tif used[i] == used[j] and i not in g[j]:\n\t\t\t\tflag = False\n\t\t\tif used[i] != used[j] and i in g[j]:\n\t\t\t\tflag = False\n\tif flag:\n\t\tprint('Yes')\n\t\tfor i in range(n):\n\t\t\tif used[i]:\n\t\t\t\tprint('a', end='')\n\t\t\telse:\n\t\t\t\tprint('c', end='')\n\telse:\n\t\tprint('No')\nif len(pows_list) == 2:\n\tused = [False for i in range(n)]\n\tdfs(0, used, g)\n\tflag = True\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\tif used[i] == used[j] and i not in g[j]:\n\t\t\t\tflag = False\n\t\t\tif used[i] != used[j] and i in g[j]:\n\t\t\t\tflag = False\n\tif flag:\n\t\tprint('Yes')\n\t\tfor i in range(n):\n\t\t\tif used[i]:\n\t\t\t\tprint('a', end='')\n\t\t\telse:\n\t\t\t\tprint('c', end='')\n\t\texit()\n\tflag = True\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif p[i] == p[j] and i not in g[j]:\n\t\t\t\tflag = False\n\t\t\tif p[i] != p[j] and i in g[j]:\n\t\t\t\tflag = False\n\tif flag:\n\t\tprint('Yes')\n\t\tfor i in range(n):\n\t\t\tif i in pows_set[pows_list[0]]:\n\t\t\t\tprint('a', end='')\n\t\t\telse:\n\t\t\t\tprint('b', end='')\n\t\texit()\n\tflag = True\n\tfor i in pows_set[pows_list[1]]:\n\t\tfor j in range(n):\n\t\t\tif j in pows_set[pows_list[1]]:\n\t\t\t\tif i != j and i not in g[j]:\n\t\t\t\t\tflag = False\n\t\t\telif i not in g[j]:\n\t\t\t\tflag = False\n\tnew_g = defaultdict(set)\n\tfor i in pows_set[pows_list[0]]:\n\t\tfor x in g[i]:\n\t\t\tif x in pows_set[pows_list[0]]:\n\t\t\t\tnew_g[i].add(x)\n\tused = dict()\n\tfor x in pows_set[pows_list[0]]:\n\t\tused[x] = False\n\tdfs(list(pows_set[pows_list[0]])[0], used, new_g)\n\tfor i in pows_set[pows_list[0]]:\n\t\tfor j in pows_set[pows_list[0]]:\n\t\t\tif i == j:\n\t\t\t\tcontinue\n\t\t\tif used[i] == used[j] and i not in new_g[j]:\n\t\t\t\tflag = False\n\t\t\tif used[i] != used[j] and i in new_g[j]:\n\t\t\t\tflag = False\n\tif flag:\n\t\tprint('Yes')\n\t\tfor i in range(n):\n\t\t\tif i in pows_set[pows_list[0]]:\n\t\t\t\tif used[i]:\n\t\t\t\t\tprint('a', end='')\n\t\t\t\telse:\n\t\t\t\t\tprint('c', end='')\n\t\t\telse:\n\t\t\t\tprint('b', end='')\n\telse:\n\t\tprint('No')\nexit()\n"
    },
    {
        "task_id": 757,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 0.0010025501251220703,
        "fastest_time": 0.0,
        "fastest_solution": "MEMO = []\n\ndef sum_dif_rev(n):\n\ti = MEMO[-1] if MEMO else 0\n\twhile len(MEMO) < n:\n\t\ti += 1\n\t\tr = int(str(i)[::-1])\n\t\tif i % 10 and r != i and ((i + r) % abs(r - i) == 0):\n\t\t\tMEMO.append(i)\n\treturn MEMO[n - 1]\n",
        "slowest_solution": "def memoize_sum_dif(f):\n\tmemory = {}\n\n\tdef inner(n):\n\t\tif n not in memory:\n\t\t\tmemory[n] = f(n)\n\t\treturn memory[n]\n\treturn inner\n\n@memoize_sum_dif\ndef sum_dif_rev(n):\n\tif n == 1:\n\t\treturn 45\n\tnum = sum_dif_rev(n - 1)\n\twhile True:\n\t\tnum = num + 1\n\t\tif str(num)[::-1][0] == '0' or abs(num - int(str(num)[::-1])) == 0:\n\t\t\tcontinue\n\t\tif (num + int(str(num)[::-1])) % abs(num - int(str(num)[::-1])) == 0:\n\t\t\tbreak\n\treturn num\n"
    },
    {
        "task_id": 754,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6056103706359863,
        "fastest_time": 2.6056103706359863,
        "fastest_solution": "from sys import stdin\nfrom sys import stdout\n\nclass BITree:\n\tnodes = []\n\tn = 0\n\n\tdef __init__(self, n):\n\t\tself.nodes = [0] * (n + 1)\n\t\tself.n = n + 1\n\n\tdef add(self, idx, val):\n\t\tidx += 1\n\t\twhile idx < self.n:\n\t\t\tself.nodes[idx] += val\n\t\t\tidx += idx & -idx\n\n\tdef sum(self, idx):\n\t\tr = 0\n\t\tidx += 1\n\t\twhile idx > 0:\n\t\t\tr += self.nodes[idx]\n\t\t\tidx -= idx & -idx\n\t\treturn r\nT = int(input())\nfor t in range(0, T):\n\ttree = BITree(2000000)\n\t(n, q) = map(lambda x: int(x), input().split(' '))\n\tpoints = []\n\tfor i in range(0, n):\n\t\txy = input().split(' ')\n\t\tx = int(xy[0])\n\t\ty = int(xy[1])\n\t\tpoints.append((y - x, x + y))\n\tpoints.sort(key=lambda p: p[0])\n\tqueries = []\n\tfor i in range(0, q):\n\t\tlr = input().split(' ')\n\t\tl = int(lr[0])\n\t\tr = int(lr[1])\n\t\tqueries.append((-l, r, i))\n\tqueries.sort(key=lambda p: p[0])\n\tsolution = [0] * q\n\tidx = 0\n\tfor i in range(0, q):\n\t\tli = queries[i][0]\n\t\tri = queries[i][1]\n\t\tquery_idx = queries[i][2]\n\t\twhile idx < n and points[idx][0] <= li:\n\t\t\ttree.add(points[idx][1], 1)\n\t\t\tidx += 1\n\t\tsolution[query_idx] = str(tree.sum(ri))\n\tprint(' '.join(solution))\n",
        "slowest_solution": "from sys import stdin\nfrom sys import stdout\n\nclass BITree:\n\tnodes = []\n\tn = 0\n\n\tdef __init__(self, n):\n\t\tself.nodes = [0] * (n + 1)\n\t\tself.n = n + 1\n\n\tdef add(self, idx, val):\n\t\tidx += 1\n\t\twhile idx < self.n:\n\t\t\tself.nodes[idx] += val\n\t\t\tidx += idx & -idx\n\n\tdef sum(self, idx):\n\t\tr = 0\n\t\tidx += 1\n\t\twhile idx > 0:\n\t\t\tr += self.nodes[idx]\n\t\t\tidx -= idx & -idx\n\t\treturn r\nT = int(input())\nfor t in range(0, T):\n\ttree = BITree(2000000)\n\t(n, q) = map(lambda x: int(x), input().split(' '))\n\tpoints = []\n\tfor i in range(0, n):\n\t\txy = input().split(' ')\n\t\tx = int(xy[0])\n\t\ty = int(xy[1])\n\t\tpoints.append((y - x, x + y))\n\tpoints.sort(key=lambda p: p[0])\n\tqueries = []\n\tfor i in range(0, q):\n\t\tlr = input().split(' ')\n\t\tl = int(lr[0])\n\t\tr = int(lr[1])\n\t\tqueries.append((-l, r, i))\n\tqueries.sort(key=lambda p: p[0])\n\tsolution = [0] * q\n\tidx = 0\n\tfor i in range(0, q):\n\t\tli = queries[i][0]\n\t\tri = queries[i][1]\n\t\tquery_idx = queries[i][2]\n\t\twhile idx < n and points[idx][0] <= li:\n\t\t\ttree.add(points[idx][1], 1)\n\t\t\tidx += 1\n\t\tsolution[query_idx] = str(tree.sum(ri))\n\tprint(' '.join(solution))\n"
    },
    {
        "task_id": 708,
        "slowest_solution_id": 1,
        "fastest_solution_id": 6,
        "slowest_time": 2.665694236755371,
        "fastest_time": 2.496155023574829,
        "fastest_solution": "from collections import deque\nT = int(input())\nfor test_case in range(T):\n\tn = int(input())\n\tinit = list(map(int, input().split()))\n\treq = list(map(int, input().split()))\n\tans = 0\n\tdq = deque()\n\tx = 0\n\tfor i in range(0, n):\n\t\tif init[i] < req[i]:\n\t\t\tx = -1\n\tif x != -1:\n\t\tfor i in range(0, n):\n\t\t\twhile dq and dq[0] > init[i]:\n\t\t\t\tdq.popleft()\n\t\t\twhile dq and dq[-1] < req[i]:\n\t\t\t\tdq.pop()\n\t\t\tif init[i] != req[i] and (not dq or dq[-1] != req[i]):\n\t\t\t\tans = ans + 1\n\t\t\t\tdq.append(req[i])\n\t\tprint(ans)\n\telse:\n\t\tprint('-1')\n",
        "slowest_solution": "import collections\ndebug = False\nT = int(input())\nfor i in range(T):\n\tN = int(input())\n\tA = [int(x) for x in input().split()]\n\tB = [int(x) for x in input().split()]\n\tif debug:\n\t\tprint('A', A)\n\t\tprint('B', B)\n\tisPossible = True\n\tans = 0\n\tq = collections.deque()\n\tfor i in range(len(A)):\n\t\tif A[i] < B[i]:\n\t\t\tisPossible = False\n\tif isPossible:\n\t\tfor i in range(len(A)):\n\t\t\twhile len(q) > 0 and q[-1] < B[i]:\n\t\t\t\tq.pop()\n\t\t\twhile len(q) > 0 and q[0] > A[i]:\n\t\t\t\tq.popleft()\n\t\t\tif A[i] != B[i] and (len(q) == 0 or B[i] != q[-1]):\n\t\t\t\tans += 1\n\t\t\t\tq.append(B[i])\n\t\tprint(ans)\n\telse:\n\t\tprint(-1)\n"
    },
    {
        "task_id": 711,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.6788952350616455,
        "fastest_time": 2.4363198280334473,
        "fastest_solution": "l = False\nstring = 'abcdefghijklmnopqrstuvwxyz'\nvarians = list(string)\nn = int(input())\nk = 0\nfor i in range(n):\n\t(v, s) = input().split()\n\tif len(varians) == 1:\n\t\tl = True\n\tif v == '.':\n\t\tfor simb in s:\n\t\t\tif simb in varians:\n\t\t\t\tdel varians[varians.index(simb)]\n\telif v == '!':\n\t\tif l == True:\n\t\t\tk += 1\n\t\t\tcontinue\n\t\tfor simb in varians.copy():\n\t\t\tif not simb in s:\n\t\t\t\tdel varians[varians.index(simb)]\n\telse:\n\t\tif l == True and i != n - 1:\n\t\t\tk += 1\n\t\t\tcontinue\n\t\tif s in varians:\n\t\t\tdel varians[varians.index(s)]\nprint(k)\n",
        "slowest_solution": "n = int(input())\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\npossible = set((alphabet[i] for i in range(len(alphabet))))\ni = 0\nwhile i < n:\n\t(signal, word) = input().split()\n\tif signal == '!':\n\t\tpossible = possible & set((word[j] for j in range(len(word))))\n\telif signal == '.' or (signal == '?' and i != n - 1):\n\t\tpossible = possible - set((word[j] for j in range(len(word))))\n\ti += 1\n\tif len(possible) == 1:\n\t\tbreak\nans = 0\nwhile i < n:\n\t(signal, word) = input().split()\n\tif signal == '!' or (signal == '?' and word not in possible):\n\t\tans += 1\n\ti += 1\nprint(ans)\n"
    },
    {
        "task_id": 758,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.572359800338745,
        "fastest_time": 2.572359800338745,
        "fastest_solution": "from sys import stderr\nfrom array import array\np = 998244353\n\ndef readints():\n\treturn [int(fld) for fld in input().strip().split()]\n\ndef mincycshift(a, b, degree):\n\tif len(a) <= degree + 1:\n\t\treturn 0\n\tsa = succdiffn(a, degree + 1)\n\tsb = succdiffn(b + b + b[:degree], degree + 1)\n\tfor i in range(len(a)):\n\t\tif all((elt == sb[j + i] for (j, elt) in enumerate(sa))):\n\t\t\treturn i\n\treturn None\n\ndef succdiffn(a, times, p=p):\n\tn = nextpow2(len(a) + times - 1)\n\tffta = fft(a + [0] * (n - len(a)))\n\tdiff = [1] + [0] * (n - 2) + [-1]\n\tfftdiff = fft(diff)\n\tanslen = len(a) - times\n\treturn ifft([aelt * pow(d, times, p) % p for (aelt, d) in zip(ffta, fftdiff)])[:anslen]\n\ndef fft(x, p=p):\n\tif len(x) <= 1:\n\t\treturn x\n\tassert len(x) & -len(x) == len(x) and p % len(x) == 1\n\troot = pow(3, (p - 1) // len(x), p)\n\treturn fftmany([x], root, p)[0]\n\ndef fftmany(x, root, p=p):\n\tn = len(x[0])\n\tif n == 1:\n\t\treturn x\n\tx2 = [row[::2] for row in x] + [row[1::2] for row in x]\n\tx2 = fftmany(x2, root * root % p, p)\n\ty = []\n\tlx = len(x)\n\tfor i in range(lx):\n\t\ttwiddle = 1\n\t\ty0 = array('L')\n\t\ty1 = array('L')\n\t\tfor (e, o) in zip(x2[i], x2[i + lx]):\n\t\t\ty0.append((e + twiddle * o) % p)\n\t\t\ty1.append((e - twiddle * o) % p)\n\t\t\ttwiddle = twiddle * root % p\n\t\ty.append(y0 + y1)\n\treturn y\n\ndef ifft(x, p=p):\n\tx = fft(x)\n\tinvn = pow(len(x), p - 2, p)\n\treturn [invn * x[0] % p] + [invn * y % p for y in x[:0:-1]]\n\ndef nextpow2(x):\n\tn = 1\n\twhile n < x:\n\t\tn *= 2\n\treturn n\n(n, degree) = readints()\na = readints()\nb = readints()\nassert n == len(a) == len(b)\nans = mincycshift(a, b, degree)\nprint(-1 if ans is None else ans)\n",
        "slowest_solution": "from sys import stderr\nfrom array import array\np = 998244353\n\ndef readints():\n\treturn [int(fld) for fld in input().strip().split()]\n\ndef mincycshift(a, b, degree):\n\tif len(a) <= degree + 1:\n\t\treturn 0\n\tsa = succdiffn(a, degree + 1)\n\tsb = succdiffn(b + b + b[:degree], degree + 1)\n\tfor i in range(len(a)):\n\t\tif all((elt == sb[j + i] for (j, elt) in enumerate(sa))):\n\t\t\treturn i\n\treturn None\n\ndef succdiffn(a, times, p=p):\n\tn = nextpow2(len(a) + times - 1)\n\tffta = fft(a + [0] * (n - len(a)))\n\tdiff = [1] + [0] * (n - 2) + [-1]\n\tfftdiff = fft(diff)\n\tanslen = len(a) - times\n\treturn ifft([aelt * pow(d, times, p) % p for (aelt, d) in zip(ffta, fftdiff)])[:anslen]\n\ndef fft(x, p=p):\n\tif len(x) <= 1:\n\t\treturn x\n\tassert len(x) & -len(x) == len(x) and p % len(x) == 1\n\troot = pow(3, (p - 1) // len(x), p)\n\treturn fftmany([x], root, p)[0]\n\ndef fftmany(x, root, p=p):\n\tn = len(x[0])\n\tif n == 1:\n\t\treturn x\n\tx2 = [row[::2] for row in x] + [row[1::2] for row in x]\n\tx2 = fftmany(x2, root * root % p, p)\n\ty = []\n\tlx = len(x)\n\tfor i in range(lx):\n\t\ttwiddle = 1\n\t\ty0 = array('L')\n\t\ty1 = array('L')\n\t\tfor (e, o) in zip(x2[i], x2[i + lx]):\n\t\t\ty0.append((e + twiddle * o) % p)\n\t\t\ty1.append((e - twiddle * o) % p)\n\t\t\ttwiddle = twiddle * root % p\n\t\ty.append(y0 + y1)\n\treturn y\n\ndef ifft(x, p=p):\n\tx = fft(x)\n\tinvn = pow(len(x), p - 2, p)\n\treturn [invn * x[0] % p] + [invn * y % p for y in x[:0:-1]]\n\ndef nextpow2(x):\n\tn = 1\n\twhile n < x:\n\t\tn *= 2\n\treturn n\n(n, degree) = readints()\na = readints()\nb = readints()\nassert n == len(a) == len(b)\nans = mincycshift(a, b, degree)\nprint(-1 if ans is None else ans)\n"
    },
    {
        "task_id": 735,
        "slowest_solution_id": 5,
        "fastest_solution_id": 4,
        "slowest_time": 2.660578966140747,
        "fastest_time": 2.540921211242676,
        "fastest_solution": "n = int(input())\ns = input()\ndp = [[-float('inf')] * (n + 1) for i in range(2 * n + 1)]\ndp[0][0] = 0\nm = 2 * n\nfor fir in range(0, n + 1):\n\tfor i in range(1, 2 * n + 1):\n\t\tif fir > i:\n\t\t\tdp[i][fir] = -float('inf')\n\t\tdp[i][fir] = max(dp[i][fir], dp[i - 1][fir - 1] + pow(10, n - fir) * int(s[i - 1]))\n\t\tif n - (i - fir) >= 0:\n\t\t\tdp[i][fir] = max(dp[i][fir], dp[i - 1][fir] + pow(10, n - (i - fir)) * int(s[i - 1]))\nans = ''\n(ci, cj) = (2 * n, n)\nwhile ci > 0:\n\tif cj > 0 and dp[ci][cj] == dp[ci - 1][cj - 1] + pow(10, n - cj) * int(s[ci - 1]):\n\t\tans += 'M'\n\t\tcj -= 1\n\telse:\n\t\tans += 'H'\n\tci -= 1\nprint(ans[::-1])\n",
        "slowest_solution": "n = int(input())\ns = input()\nn *= 2\nd = [[-1 for i in range(n + 2)] for j in range(n + 2)]\nprev = [[0 for i in range(n + 2)] for j in range(n + 2)]\nd[0][0] = 1\nfor i in range(n):\n\tfor j in range(min(i, n // 2) + 1):\n\t\tif d[i + 1][j + 1] < d[i][j] + int(s[i]) * 10 ** (n // 2 - j - 1):\n\t\t\tprev[i + 1][j + 1] = j\n\t\t\td[i + 1][j + 1] = d[i][j] + int(s[i]) * 10 ** (n // 2 - j - 1)\n\t\tif d[i + 1][j] < d[i][j] + int(s[i]) * 10 ** (n // 2 - (i - j) - 1):\n\t\t\tprev[i + 1][j] = j\n\t\t\td[i + 1][j] = d[i][j] + int(s[i]) * 10 ** (n // 2 - (i - j) - 1)\nans = []\ni = n\nj = n // 2\nwhile i > 0:\n\tif prev[i][j] == j:\n\t\tans.append('H')\n\telse:\n\t\tans.append('M')\n\tj = prev[i][j]\n\ti -= 1\nprint(''.join(ans)[::-1])\n"
    },
    {
        "task_id": 717,
        "slowest_solution_id": 4,
        "fastest_solution_id": 7,
        "slowest_time": 2.592318534851074,
        "fastest_time": 2.4881651401519775,
        "fastest_solution": "n = int(input())\na = [int(x) for x in input().split()]\n\ndef solve(w, bit_level):\n\tl = []\n\th = []\n\topeners = 0\n\tinversions = 0\n\talt_openers = 0\n\talt_inversions = 0\n\tfor x in w:\n\t\tif x & bit_level:\n\t\t\th.append(x)\n\t\t\topeners += 1\n\t\t\talt_inversions += alt_openers\n\t\telse:\n\t\t\tl.append(x)\n\t\t\tinversions += openers\n\t\t\talt_openers += 1\n\treturn (inversions, alt_inversions, l, h)\nout = 0\ntot_inversions = 0\nactive_groups = [a]\nfor bit_level in reversed(range(31)):\n\t(sum_i, sum_ai) = (0, 0)\n\tnext_batch = []\n\tfor group in active_groups:\n\t\t(i, ai, l, h) = solve(group, 1 << bit_level)\n\t\tsum_i += i\n\t\tsum_ai += ai\n\t\tif l:\n\t\t\tnext_batch.append(l)\n\t\tif h:\n\t\t\tnext_batch.append(h)\n\tif sum_ai < sum_i:\n\t\tout |= 1 << bit_level\n\t\ttot_inversions += sum_ai\n\telse:\n\t\ttot_inversions += sum_i\n\tactive_groups = next_batch\nprint(tot_inversions, out)\n",
        "slowest_solution": "from bisect import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom typing import List\nfrom itertools import *\nfrom operator import *\nfrom functools import *\nimport sys\nn = int(input())\nans = x = 0\narr = [list(map(int, input().split()))]\nfor k in range(29, -1, -1):\n\t(a, b) = (0, 0)\n\tmask = 1 << k\n\ttmp = []\n\tfor ar in arr:\n\t\tone = zero = 0\n\t\ttmp1 = []\n\t\ttmp2 = []\n\t\tfor ai in ar:\n\t\t\tcur = ai & mask\n\t\t\tif cur == 0:\n\t\t\t\tb += one\n\t\t\t\tzero += 1\n\t\t\t\ttmp1.append(ai)\n\t\t\telse:\n\t\t\t\ta += zero\n\t\t\t\tone += 1\n\t\t\t\ttmp2.append(ai)\n\t\tif len(tmp1) > 1:\n\t\t\ttmp.append(tmp1)\n\t\tif len(tmp2) > 1:\n\t\t\ttmp.append(tmp2)\n\tif b > a:\n\t\tx |= mask\n\t\tans += a\n\telse:\n\t\tans += b\n\tarr = tmp\nprint(ans, x)\n"
    },
    {
        "task_id": 764,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def pig_latin(word):\n\treturn word[1:] + word[0] + 'ay' if len(word) > 3 else word\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 713,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 2.7376186847686768,
        "fastest_time": 2.4981167316436768,
        "fastest_solution": "T = int(input())\nfor _ in range(T):\n\t(N, X) = map(int, input().split())\n\tprint(pow(2, N - 1, 1000000007) * X % 1000000007)\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\t(n, x) = map(int, input().split())\n\ta = 0\n\tif n == 1:\n\t\tprint(x)\n\telse:\n\t\tprint(x * pow(2, n - 1, 10 ** 9 + 7) % (10 ** 9 + 7))\n"
    },
    {
        "task_id": 714,
        "slowest_solution_id": 9,
        "fastest_solution_id": 3,
        "slowest_time": 2.719022512435913,
        "fastest_time": 2.5168793201446533,
        "fastest_solution": "import math\nT = int(input())\nfor i in range(T):\n\tN = int(input())\n\tnk = 0\n\tfor K in range(1, int(math.sqrt(N)) + 1):\n\t\tif (N - 1) % K == 0:\n\t\t\tnk += 1\n\t\t\tif (N - 1) // K != K:\n\t\t\t\tnk += 1\n\tprint(nk)\n",
        "slowest_solution": "import math\nfor _ in range(int(input())):\n\tn = int(input())\n\tcnt = 0\n\ts = math.sqrt(n - 1)\n\tfor i in range(1, int(s) + 1):\n\t\tif (n - 1) % i == 0:\n\t\t\tv = n // i\n\t\t\tif v == i:\n\t\t\t\tcnt += 1\n\t\t\telse:\n\t\t\t\tcnt += 2\n\tif n == 2:\n\t\tprint(1)\n\telse:\n\t\tprint(cnt)\n"
    },
    {
        "task_id": 739,
        "slowest_solution_id": 4,
        "fastest_solution_id": 3,
        "slowest_time": 2.7656474113464355,
        "fastest_time": 2.5208544731140137,
        "fastest_solution": "import sys\ninpy = [int(x) for x in sys.stdin.read().split()]\n\ndef win(s, e):\n\tif e == s:\n\t\treturn False\n\tif e == s + 1:\n\t\treturn True\n\tif e % 2 == 1:\n\t\tif s % 2 == 1:\n\t\t\treturn False\n\t\treturn True\n\tq = e // 4\n\tif s <= q:\n\t\treturn win(s, q)\n\tq = e // 2\n\tif s > q:\n\t\treturn (e - s) % 2 == 1\n\treturn True\n\ndef lose(s, e):\n\tq = e // 2\n\tif s > q:\n\t\treturn True\n\telse:\n\t\treturn win(s, q)\nt = inpy[0]\nstart = (True, False)\ninpo = 1\nv = (True, True)\nfor tc in range(t):\n\tif inpo + 1 >= len(inpy):\n\t\tprint('wtf')\n\t(s, e) = (inpy[inpo], inpy[inpo + 1])\n\tinpo = inpo + 2\n\tv = (win(s, e), lose(s, e))\n\tif start[0] and start[1]:\n\t\tbreak\n\tif not start[0] and (not start[1]):\n\t\tbreak\n\tif start[1]:\n\t\tv = (not v[0], not v[1])\n\tstart = (v[1], v[0])\nif start[0] != True and start[0] != False or (start[1] != True and start[1] != False):\n\tprint('wtf')\nsw = 2\nif start[1]:\n\tsw = sw - 1\n\tprint(1, end=' ')\nelse:\n\tsw = sw - 1\n\tprint(0, end=' ')\nif start[0]:\n\tprint(1)\n\tsw = sw - 1\nelse:\n\tprint(0)\n\tsw = sw - 1\nif sw:\n\tprint(wtf)\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport threading\nfrom heapq import heapify, heappush, heappop\n\ndef can_win(s, e):\n\tif e % 2 == 1:\n\t\treturn 1 if s % 2 == 0 else 0\n\telse:\n\t\tif e // 2 < s <= e:\n\t\t\treturn 1 if s % 2 == 1 else 0\n\t\tif e // 4 < s <= e // 2:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn can_win(s, e // 4)\n\ndef main():\n\tt = int(input())\n\tres = []\n\tfor i in range(t):\n\t\t(si, ei) = map(int, input().split())\n\t\tres.append([can_win(si, ei), can_win(si, ei // 2) if ei >= 2 * si else 1])\n\tc = res\n\tf = 1\n\ts = 0\n\tfor i in range(t):\n\t\tif f == 1 and s == 1:\n\t\t\tbreak\n\t\tif f == 0 and s == 0:\n\t\t\tbreak\n\t\tif s == 1:\n\t\t\tc[i][0] ^= 1\n\t\t\tc[i][1] ^= 1\n\t\tf = c[i][1]\n\t\ts = c[i][0]\n\tprint(s, f)\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n"
    },
    {
        "task_id": 716,
        "slowest_solution_id": 9,
        "fastest_solution_id": 2,
        "slowest_time": 2.901177167892456,
        "fastest_time": 2.4544076919555664,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k) = list(map(int, input().split()))\n\tarr = list(map(int, input().split()))\n\tcount0 = [0] * (2 * k + 1)\n\tpre_arr = [0] * (2 * k + 2)\n\tfor i in range(n // 2):\n\t\tp1 = arr[i]\n\t\tp2 = arr[n - i - 1]\n\t\tl = min(p1, p2) + 1\n\t\tr = max(p1, p2) + k\n\t\tcount0[p1 + p2] += 1\n\t\tpre_arr[l] += 1\n\t\tpre_arr[r + 1] -= 1\n\tfor i in range(1, 2 * k + 2):\n\t\tpre_arr[i] += pre_arr[i - 1]\n\tans = float('INF')\n\tfor i in range(2, 2 * k + 1):\n\t\tc0 = count0[i]\n\t\tc1 = pre_arr[i] - c0\n\t\tc2 = n // 2 - c0 - c1\n\t\tans = min(ans, c1 + 2 * c2)\n\tprint(ans)\n",
        "slowest_solution": "class BIT:\n\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.bit = [0] * (n + 1)\n\n\tdef _add(self, i, val):\n\t\twhile i > 0:\n\t\t\tself.bit[i] += val\n\t\t\ti -= i & -i\n\n\tdef get_val(self, i):\n\t\ti = i + 1\n\t\ts = 0\n\t\twhile i <= self.n:\n\t\t\ts += self.bit[i]\n\t\t\ti += i & -i\n\t\treturn s\n\n\tdef add(self, l, r, val):\n\t\tself._add(r, val)\n\t\tself._add(l, -val)\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tb = a[n // 2:n][::-1]\n\ta = a[0:n // 2]\n\tbit = BIT(2 * k + 1)\n\tbit.add(0, 2 * k + 1, 2 * n // 2)\n\tfor i in range(n // 2):\n\t\tran = [min(a[i] + 1, b[i] + 1), max(a[i] + k + 1, b[i] + k + 1)]\n\t\tbit.add(ran[0], ran[1], -1)\n\t\tbit.add(a[i] + b[i], a[i] + b[i] + 1, -1)\n\tprint(min([bit.get_val(i) for i in range(2 * k + 1)]))\n"
    },
    {
        "task_id": 769,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def sum_pow_dig_seq(num, exp, k):\n\tseq = []\n\tfor step in range(k):\n\t\tseq.append(num)\n\t\tnum = sum((int(dig) ** exp for dig in str(num)))\n\t\tif num in seq:\n\t\t\tcycle_start = seq.index(num)\n\t\t\tcycle = seq[cycle_start:]\n\t\t\tlast_term = cycle[(k - cycle_start) % len(cycle)]\n\t\t\treturn [cycle_start, cycle, len(cycle), last_term]\n\treturn [0, [], 0, num]\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 729,
        "slowest_solution_id": 6,
        "fastest_solution_id": 1,
        "slowest_time": 3.211325168609619,
        "fastest_time": 2.4693760871887207,
        "fastest_solution": "tc = int(input())\nwhile (tc>0):\n\ttc = tc - 1\n\ta, b = list(map(int, input().split()))\n\twhile (b>0):\n\t\tb = b - 1\n\t\tm, n = list(map(int, input().split()))\n\tprint(a-1)\n",
        "slowest_solution": "def dfs(v):\n\tglobal mark,c_c\n\tq=[]\n\tq.append(v)\n\ts=1\n\twhile q:\n\t\ttop=q.pop()\n\t\tmark[top]=c_c\n\t\tfor j in G[top]:\n\t\t\tif mark[j]==-1:\n\t\t\t\tq.append(j)\n\t\t\t\ts+=1\n\t\t\t\tmark[j]=mark[top]\n\td[c_c]=s\n\t\t\t\t\nt=eval(input())\nwhile t!=0:\n\tn,m=list(map(int,input().split()))\n\tG=[[] for i in range(n+1)]\n\tfor k in range(m):\n\t\tx,y=list(map(int,input().split()))\n\t\tG[x].append(y)\n\t\tG[y].append(x)\n   \n\tmark=[-1]*(n+1)\n\td={}\n\tc_c=1\n\tfor v in range(1,n+1):\n\t   \n\t\tif G[v]:\n\t\t\tif mark[v]==-1:\n\t\t\t dfs(v)\n\t\t\t c_c+=1\n\tn_t=0\n\t#print d\n\tfor i in d:\n\t\tn_t=n_t+d[i]-1\n\tprint(n_t)\n\tt-=1             \n"
    },
    {
        "task_id": 718,
        "slowest_solution_id": 9,
        "fastest_solution_id": 2,
        "slowest_time": 2.9935388565063477,
        "fastest_time": 2.509280204772949,
        "fastest_solution": "def euclidean_alg(a, b):\n\trm1 = a\n\tsm1 = 1\n\ttm1 = 0\n\tr = b\n\ts = 0\n\tt = 1\n\twhile r != 0:\n\t\tq = rm1 // r\n\t\ttemp_r = rm1\n\t\ttemp_s = sm1\n\t\ttemp_t = tm1\n\t\trm1 = r\n\t\tsm1 = s\n\t\ttm1 = t\n\t\tr = temp_r - q * rm1\n\t\ts = temp_s - q * sm1\n\t\tt = temp_t - q * tm1\n\treturn (rm1, sm1, tm1)\n\ndef modular_inverse(n, p):\n\t(r, s, t) = euclidean_alg(n, p)\n\treturn s\n\ndef solve(N, k, p=10 ** 9 + 7):\n\tres = 0\n\tfor i in range(1, min(k + 1, N - k + 2)):\n\t\tres = (res + pow(2, i, p) * choose(k - 1, i - 1, p) * choose(N - k + 1, i, p)) % p\n\treturn res\n\ndef choose(a, b, p):\n\tassert a >= b\n\tnum = 1\n\tfor i in range(a - b + 1, a + 1):\n\t\tnum = num * i % p\n\tden = 1\n\tfor i in range(1, b + 1):\n\t\tden = den * i % p\n\treturn num * modular_inverse(den, p) % p\nT = int(input())\nfor test in range(T):\n\t(N, k) = [int(v) for v in input().split()]\n\tprint(solve(N, k))\n",
        "slowest_solution": "mod = 1000000007\n\ndef modular_inverse(value):\n\treturn fast_mod_pow(value, mod - 2)\n\ndef fast_mod_pow(a, x):\n\tvalue = 1\n\twhile x > 0:\n\t\tif x % 2 != 0:\n\t\t\tvalue = value * a % mod\n\t\ta = a * a % mod\n\t\tx //= 2\n\treturn value\n\ndef modular_biomial_coffiecient(n, r):\n\tdeno = 1\n\tfor i in range(1, r + 1):\n\t\tdeno = deno * i % mod\n\tnume = 1\n\tfor i in range(r):\n\t\tnume = nume * (n - i) % mod\n\treturn nume * modular_inverse(deno) % mod\nfor _ in range(int(input())):\n\t(n, k) = [int(x) for x in input().split()]\n\tans = 0\n\tif k > n:\n\t\tprint(0)\n\telse:\n\t\tfor i in range(k):\n\t\t\tans = (ans + 2 * modular_biomial_coffiecient(k - 1, i) * modular_biomial_coffiecient(n + 1 + i - k, k)) % mod\n\t\tprint(ans)\n"
    },
    {
        "task_id": 726,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 3.0110301971435547,
        "fastest_time": 2.4667038917541504,
        "fastest_solution": "import sys\nfrom math import inf\ntime = 0\ncc = 0\nl = {}\nd = {}\nf = {}\nconn_comp = {}\non_stack = {}\nstack = []\ncolor = []\n\ndef tarjan(graph):\n\tglobal l\n\tglobal d\n\tglobal f\n\tglobal pi\n\tglobal stack\n\tglobal on_stack\n\tl = {key: inf for key in graph}\n\td = {key: -1 for key in graph}\n\tf = {key: -1 for key in graph}\n\tconn_comp = {key: -1 for key in graph}\n\ton_stack = {key: False for key in graph}\n\tfor i in graph.keys():\n\t\tif d[i] == -1:\n\t\t\tstrongconnect(graph, i)\n\ndef strongconnect(graph, v):\n\tglobal time\n\tglobal cc\n\tstack.append(v)\n\ton_stack[v] = True\n\ttime += 1\n\td[v] = time\n\tfor i in graph[v]:\n\t\tif d[i] == -1:\n\t\t\tstrongconnect(graph, i)\n\t\t\tl[v] = min(l[v], l[i])\n\t\tif on_stack[i]:\n\t\t\tl[v] = min(l[v], d[i])\n\tif l[v] == d[v]:\n\t\tcc += 1\n\tw = stack.pop()\n\twhile w != v:\n\t\tconn_comp[w] = cc\n\t\ton_stack[w] = False\n\t\tw = stack.pop()\n\tconn_comp[v] = cc\n\ton_stack[v] = False\n\ndef read():\n\t(n, m) = map(int, sys.stdin.readline().split())\n\tstatus = list(map(int, sys.stdin.readline().split()))\n\tdoors_switch = [[] for i in range(n)]\n\tfor i in range(m):\n\t\ttemp = list(map(int, sys.stdin.readline().split()))\n\t\tfor j in range(1, len(temp)):\n\t\t\tdoor = temp[j]\n\t\t\tdoors_switch[door - 1].append(i)\n\treturn (m, status, doors_switch)\n\ndef build_graph_scc():\n\t(m, status, doors_switch) = read()\n\tgraph = {i: set() for i in range(2 * m)}\n\tfor i in range(len(doors_switch)):\n\t\t(switch_1, switch_2) = tuple(doors_switch[i])\n\t\tif status[i]:\n\t\t\tgraph[2 * switch_1].add(2 * switch_2)\n\t\t\tgraph[2 * switch_2].add(2 * switch_1)\n\t\t\tgraph[2 * switch_1 + 1].add(2 * switch_2 + 1)\n\t\t\tgraph[2 * switch_2 + 1].add(2 * switch_1 + 1)\n\t\telse:\n\t\t\tgraph[2 * switch_1].add(2 * switch_2 + 1)\n\t\t\tgraph[2 * switch_2].add(2 * switch_1 + 1)\n\t\t\tgraph[2 * switch_1 + 1].add(2 * switch_2)\n\t\t\tgraph[2 * switch_2 + 1].add(2 * switch_1)\n\treturn graph\n\ndef build_graph_bfs():\n\t(m, status, doors_switch) = read()\n\tg = [[] for i in range(m)]\n\tglobal color\n\tcolor = [-1] * m\n\tfor i in range(len(status)):\n\t\t(switch_1, switch_2) = tuple(doors_switch[i])\n\t\tg[switch_1].append((switch_2, 1 - status[i]))\n\t\tg[switch_2].append((switch_1, 1 - status[i]))\n\treturn g\n\ndef bfs_bipartite(graph, v):\n\tcolor[v] = 0\n\tq = [v]\n\tj = 0\n\twhile j < len(q):\n\t\tv = q[j]\n\t\tfor (w, st) in graph[v]:\n\t\t\tif color[w] == -1:\n\t\t\t\tcolor[w] = color[v] ^ st\n\t\t\t\tq.append(w)\n\t\t\telif color[w] != color[v] ^ st:\n\t\t\t\treturn False\n\t\tj += 1\n\treturn True\n\ndef main():\n\tgraph = build_graph_bfs()\n\tfor i in range(len(graph)):\n\t\tif color[i] == -1 and (not bfs_bipartite(graph, i)):\n\t\t\tprint('NO')\n\t\t\treturn\n\tprint('YES')\nmain()\n",
        "slowest_solution": "def _vertex(lit):\n\tif lit > 0:\n\t\treturn 2 * (lit - 1)\n\telse:\n\t\treturn 2 * (-lit - 1) + 1\n\ndef tarjan(graph):\n\tn = len(graph)\n\tdfs_num = [None] * n\n\tdfs_min = [n] * n\n\twaiting = []\n\twaits = [False] * n\n\tsccp = []\n\tdfs_time = 0\n\ttimes_seen = [-1] * n\n\tfor start in range(n):\n\t\tif times_seen[start] == -1:\n\t\t\ttimes_seen[start] = 0\n\t\t\tto_visit = [start]\n\t\t\twhile to_visit:\n\t\t\t\tnode = to_visit[-1]\n\t\t\t\tif times_seen[node] == 0:\n\t\t\t\t\tdfs_num[node] = dfs_time\n\t\t\t\t\tdfs_min[node] = dfs_time\n\t\t\t\t\tdfs_time += 1\n\t\t\t\t\twaiting.append(node)\n\t\t\t\t\twaits[node] = True\n\t\t\t\tchildren = graph[node]\n\t\t\t\tif times_seen[node] == len(children):\n\t\t\t\t\tto_visit.pop()\n\t\t\t\t\tdfs_min[node] = dfs_num[node]\n\t\t\t\t\tfor child in children:\n\t\t\t\t\t\tif waits[child] and dfs_min[child] < dfs_min[node]:\n\t\t\t\t\t\t\tdfs_min[node] = dfs_min[child]\n\t\t\t\t\tif dfs_min[node] == dfs_num[node]:\n\t\t\t\t\t\tcomponent = []\n\t\t\t\t\t\twhile True:\n\t\t\t\t\t\t\tu = waiting.pop()\n\t\t\t\t\t\t\twaits[u] = False\n\t\t\t\t\t\t\tcomponent.append(u)\n\t\t\t\t\t\t\tif u == node:\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tsccp.append(component)\n\t\t\t\telse:\n\t\t\t\t\tchild = children[times_seen[node]]\n\t\t\t\t\ttimes_seen[node] += 1\n\t\t\t\t\tif times_seen[child] == -1:\n\t\t\t\t\t\ttimes_seen[child] = 0\n\t\t\t\t\t\tto_visit.append(child)\n\treturn sccp\n\ndef two_sat(formula):\n\tn = max((abs(clause[p]) for p in (0, 1) for clause in formula))\n\tgraph = [[] for node in range(2 * n)]\n\tfor (x, y) in formula:\n\t\tgraph[_vertex(-x)].append(_vertex(y))\n\t\tgraph[_vertex(-y)].append(_vertex(x))\n\tsccp = tarjan(graph)\n\tcomp_id = [None] * (2 * n)\n\tfor component in sccp:\n\t\trep = min(component)\n\t\tfor vtx in component:\n\t\t\tcomp_id[vtx] = rep\n\tfor i in range(n):\n\t\tif comp_id[2 * i] == comp_id[2 * i + 1]:\n\t\t\treturn 'NO'\n\treturn 'YES'\n(n, m) = [int(x) for x in input().split()]\ndoors_status = [int(x) for x in input().split()]\nswitches = [list(map(int, input().split())) for _ in range(m)]\nfrom collections import defaultdict\nswitches_of = defaultdict(list)\nfor switch in range(1, m + 1):\n\tfor door in switches[switch - 1][1:]:\n\t\tswitches_of[door].append(switch)\nLOCKED = 0\nUNLOCKED = 1\nformula = []\nfor door in range(1, n + 1):\n\t(s1, s2) = switches_of[door]\n\tif doors_status[door - 1] == LOCKED:\n\t\tformula.append((s1, s2))\n\t\tformula.append((-s1, -s2))\n\telse:\n\t\tformula.append((s1, -s2))\n\t\tformula.append((-s1, s2))\nprint(two_sat(formula))\n"
    },
    {
        "task_id": 722,
        "slowest_solution_id": 8,
        "fastest_solution_id": 1,
        "slowest_time": 3.0376014709472656,
        "fastest_time": 2.4840877056121826,
        "fastest_solution": "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tx = [int(x) for x in input().split()]\n\tvalues = []\n\tfor (i, value) in enumerate(x):\n\t\tbefore = i + 1\n\t\tafter = len(x) - i\n\t\ttotal_combos = before * after + 1\n\t\tif total_combos % 2 == 0:\n\t\t\tvalues.append(value)\n\tresult = 0\n\tfor val in values:\n\t\tresult ^= val\n\tprint(result)\n",
        "slowest_solution": "from sys import stdin\nT = int(stdin.readline())\nfor _ in range(T):\n\tN = int(stdin.readline())\n\tA = [int(s) for s in stdin.readline().strip().split()]\n\tans = 0\n\tfor i in range(N):\n\t\tif i == 0 or i == N - 1:\n\t\t\tif N % 2:\n\t\t\t\tans ^= A[i]\n\t\telif (i + 1) * (N - i) % 2:\n\t\t\tans ^= A[i]\n\tprint(ans)\n"
    },
    {
        "task_id": 768,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.9785678386688232,
        "fastest_time": 2.857482433319092,
        "fastest_solution": "(n, m) = map(int, input().split())\nk = int(input())\nA = [[] for i in range(max(n, m))]\nfor i in range(k):\n\t(a, b, c) = map(int, input().split())\n\tA[b - 1 if n < m else a - 1].append(c == -1)\np = int(input())\nif n % 2 != m % 2:\n\tprint(0)\nelse:\n\tr = k\n\tfor i in A:\n\t\tif len(i) >= min(n, m):\n\t\t\tif sum(i) % 2:\n\t\t\t\tr -= 1\n\t\t\telse:\n\t\t\t\tprint(0)\n\t\t\t\tbreak\n\telse:\n\t\tprint(pow(2, (n - 1) * (m - 1) - r, p))\n",
        "slowest_solution": "import itertools\nimport math\n(n, m) = [int(x) for x in input().split()]\nif n % 2 != m % 2:\n\tprint(0)\nelse:\n\tk = int(input())\n\tS = [[] for i in range(max(n, m))]\n\tfor i in range(k):\n\t\t(a, b, c) = [int(x) for x in input().split()]\n\t\tif n < m:\n\t\t\tS[b - 1].append(c == -1)\n\t\telse:\n\t\t\tS[a - 1].append(c == -1)\n\tp = int(input())\n\trestrictions = k\n\tfor string in S:\n\t\tif len(string) >= min(n, m):\n\t\t\tif sum(string) % 2:\n\t\t\t\trestrictions -= 1\n\t\t\telse:\n\t\t\t\tprint(0)\n\t\t\t\tbreak\n\telse:\n\t\tprint(pow(2, (n - 1) * (m - 1) - restrictions, p))\n"
    },
    {
        "task_id": 773,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.777754783630371,
        "fastest_time": 2.777754783630371,
        "fastest_solution": "mod = int(1000000000.0 + 7)\n(n, m) = map(int, input().split())\nf = [[0 for i in range(60)] for j in range(60)]\ng = [[0 for i in range(60)] for j in range(60)]\ns = [[0 for i in range(60)] for j in range(60)]\ninv = [1]\nf[0][0] = s[0][0] = 1\n\ndef pow(x, exp):\n\tres = 1\n\tfor i in range(0, 31):\n\t\tif exp & 1:\n\t\t\tres = res * x % mod\n\t\texp >>= 1\n\t\tif exp == 0:\n\t\t\tbreak\n\t\tx = x * x % mod\n\treturn res\nfor i in range(1, n + 1):\n\tinv.append(pow(i, mod - 2))\nfor node in range(1, n + 1):\n\tfor cut in range(1, n + 1):\n\t\ttmp = 0\n\t\tfor ln in range(node):\n\t\t\tfor lc in range(cut - 1, n + 1):\n\t\t\t\tif f[ln][lc] == 0:\n\t\t\t\t\tcontinue\n\t\t\t\tif lc == cut - 1:\n\t\t\t\t\ttmp = (tmp + f[ln][lc] * s[node - ln - 1][cut - 1]) % mod\n\t\t\t\telse:\n\t\t\t\t\ttmp = (tmp + f[ln][lc] * f[node - ln - 1][cut - 1]) % mod\n\t\tcnt = 1\n\t\tif tmp != 0:\n\t\t\t(cn, cc) = (0, 0)\n\t\t\tfor i in range(1, n + 1):\n\t\t\t\tcn += node\n\t\t\t\tcc += cut\n\t\t\t\tcnt = cnt * (tmp + i - 1) % mod * inv[i] % mod\n\t\t\t\tif cn > n or cc > n:\n\t\t\t\t\tbreak\n\t\t\t\tfor j in range(n - cn, -1, -1):\n\t\t\t\t\tfor k in range(n - cc, -1, -1):\n\t\t\t\t\t\tif f[j][k] == 0:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tg[j + cn][k + cc] += f[j][k] * cnt\n\t\t\t\t\t\tg[j + cn][k + cc] %= mod\n\t\t\tfor i in range(n + 1):\n\t\t\t\tfor j in range(n + 1):\n\t\t\t\t\tf[i][j] = (f[i][j] + g[i][j]) % mod\n\t\t\t\t\tg[i][j] = 0\n\tfor cut in range(n, -1, -1):\n\t\ts[node][cut] = (s[node][cut + 1] + f[node][cut]) % mod\nprint(f[n][m - 1])\n",
        "slowest_solution": "mod = int(1000000000.0 + 7)\n(n, m) = map(int, input().split())\nf = [[0 for i in range(60)] for j in range(60)]\ng = [[0 for i in range(60)] for j in range(60)]\ns = [[0 for i in range(60)] for j in range(60)]\ninv = [1]\nf[0][0] = s[0][0] = 1\n\ndef pow(x, exp):\n\tres = 1\n\tfor i in range(0, 31):\n\t\tif exp & 1:\n\t\t\tres = res * x % mod\n\t\texp >>= 1\n\t\tif exp == 0:\n\t\t\tbreak\n\t\tx = x * x % mod\n\treturn res\nfor i in range(1, n + 1):\n\tinv.append(pow(i, mod - 2))\nfor node in range(1, n + 1):\n\tfor cut in range(1, n + 1):\n\t\ttmp = 0\n\t\tfor ln in range(node):\n\t\t\tfor lc in range(cut - 1, n + 1):\n\t\t\t\tif f[ln][lc] == 0:\n\t\t\t\t\tcontinue\n\t\t\t\tif lc == cut - 1:\n\t\t\t\t\ttmp = (tmp + f[ln][lc] * s[node - ln - 1][cut - 1]) % mod\n\t\t\t\telse:\n\t\t\t\t\ttmp = (tmp + f[ln][lc] * f[node - ln - 1][cut - 1]) % mod\n\t\tcnt = 1\n\t\tif tmp != 0:\n\t\t\t(cn, cc) = (0, 0)\n\t\t\tfor i in range(1, n + 1):\n\t\t\t\tcn += node\n\t\t\t\tcc += cut\n\t\t\t\tcnt = cnt * (tmp + i - 1) % mod * inv[i] % mod\n\t\t\t\tif cn > n or cc > n:\n\t\t\t\t\tbreak\n\t\t\t\tfor j in range(n - cn, -1, -1):\n\t\t\t\t\tfor k in range(n - cc, -1, -1):\n\t\t\t\t\t\tif f[j][k] == 0:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tg[j + cn][k + cc] += f[j][k] * cnt\n\t\t\t\t\t\tg[j + cn][k + cc] %= mod\n\t\t\tfor i in range(n + 1):\n\t\t\t\tfor j in range(n + 1):\n\t\t\t\t\tf[i][j] = (f[i][j] + g[i][j]) % mod\n\t\t\t\t\tg[i][j] = 0\n\tfor cut in range(n, -1, -1):\n\t\ts[node][cut] = (s[node][cut + 1] + f[node][cut]) % mod\nprint(f[n][m - 1])\n"
    },
    {
        "task_id": 724,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 3.047865867614746,
        "fastest_time": 2.5023908615112305,
        "fastest_solution": "from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\n\ndef inp():\n\treturn stdin.readline().strip()\n\ndef out(var, end='\\n'):\n\tstdout.write(str(var) + '\\n')\n\ndef outa(*var, end='\\n'):\n\tstdout.write(' '.join(map(str, var)) + end)\n\ndef lmp():\n\treturn list(mp())\n\ndef mp():\n\treturn map(int, inp().split())\n\ndef smp():\n\treturn map(str, inp().split())\n\ndef l1d(n, val=0):\n\treturn [val for i in range(n)]\n\ndef l2d(n, m, val=0):\n\treturn [l1d(m, val) for j in range(n)]\n\ndef remadd(x, y):\n\treturn 1 if x % y else 0\n\ndef ceil(a, b):\n\treturn (a + b - 1) // b\n\ndef isprime(x):\n\tif x <= 1:\n\t\treturn False\n\tif x in (2, 3):\n\t\treturn True\n\tif x % 2 == 0:\n\t\treturn False\n\tfor i in range(3, int(sqrt(x)) + 1, 2):\n\t\tif x % i == 0:\n\t\t\treturn False\n\treturn True\nfor _ in range(int(inp())):\n\tn = int(inp())\n\ta = []\n\tfor i in range(n):\n\t\ts = list(inp())\n\t\ta.append(s)\n\ts = inp()\n\tb = []\n\tfor i in range(n):\n\t\ts = list(inp())\n\t\tb.append(s)\n\tt = True\n\tfor j in range(n):\n\t\tif a[0][j] != b[0][j]:\n\t\t\tfor i in range(n):\n\t\t\t\tb[i][j] = '0' if b[i][j] == '1' else '1'\n\tfor i in range(1, n):\n\t\tif a[i][0] != b[i][0]:\n\t\t\tfor j in range(n):\n\t\t\t\tb[i][j] = '0' if b[i][j] == '1' else '1'\n\t\tfor j in range(n):\n\t\t\tif a[i][j] != b[i][j]:\n\t\t\t\tt = False\n\t\t\t\tbreak\n\t\tif not t:\n\t\t\tbreak\n\tprint('YES' if t else 'NO')\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tm1 = []\n\tm2 = []\n\tflag = 0\n\tfor __ in range(n):\n\t\ts = input()\n\t\tm1.append(list(s))\n\tspace = input()\n\tfor __ in range(n):\n\t\ts = input()\n\t\tm2.append(list(s))\n\tfor i in range(n):\n\t\tif m1[i][0] != m2[i][0]:\n\t\t\tfor j in range(n):\n\t\t\t\tif m1[i][j] == '1':\n\t\t\t\t\tm1[i][j] = '0'\n\t\t\t\telse:\n\t\t\t\t\tm1[i][j] = '1'\n\tfor j in range(n):\n\t\tif m1[0][j] != m2[0][j]:\n\t\t\tfor i in range(n):\n\t\t\t\tif m1[i][j] == '1':\n\t\t\t\t\tm1[i][j] = '0'\n\t\t\t\telse:\n\t\t\t\t\tm1[i][j] = '1'\n\tfor i in range(n):\n\t\tif flag == 1:\n\t\t\tbreak\n\t\tfor j in range(n):\n\t\t\tif m1[i][j] != m2[i][j]:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\tif flag == 1:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n"
    },
    {
        "task_id": 774,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6070404052734375,
        "fastest_time": 2.6070404052734375,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL():\n\treturn map(int, sys.stdin.readline().rstrip().split())\n\ndef RLL():\n\treturn list(map(int, sys.stdin.readline().rstrip().split()))\n\ndef N():\n\treturn int(input())\n\ndef comb(n, m):\n\treturn factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\n\ndef perm(n, m):\n\treturn factorial(n) // factorial(n - m) if n >= m else 0\n\ndef mdis(x1, y1, x2, y2):\n\treturn abs(x1 - x2) + abs(y1 - y2)\n\ndef ctd(chr):\n\treturn ord(chr) - ord('a')\nmod = 998244353\nINF = float('inf')\nfrom heapq import heappush, heappop\n\ndef main():\n\t(n, m) = RL()\n\t(x, y) = RL()\n\tgp = defaultdict(dict)\n\tfor _ in range(m):\n\t\t(u, v, w) = RL()\n\t\tgp[u][v] = min(gp[u].get(v, INF), w)\n\t\tgp[v][u] = min(gp[v].get(u, INF), w)\n\tcars = [[0, 0]]\n\tfor _ in range(n):\n\t\t(t, c) = RL()\n\t\tcars.append([t, c])\n\tdisarr = [[INF] * (n + 1) for _ in range(n + 1)]\n\tfor i in range(1, n + 1):\n\t\tdisarr[i][i] = 0\n\tnewg = [[INF] * (n + 1) for _ in range(n + 1)]\n\tdnex = defaultdict(list)\n\n\tdef dij(s):\n\t\tq = [(0, s)]\n\t\twhile q:\n\t\t\t(d, nd) = heappop(q)\n\t\t\tfor nex in gp[nd]:\n\t\t\t\tdis = gp[nd][nex] + disarr[s][nd]\n\t\t\t\tif dis < disarr[s][nex]:\n\t\t\t\t\tdisarr[s][nex] = dis\n\t\t\t\t\theappush(q, (dis, nex))\n\t\tfor i in range(1, n + 1):\n\t\t\t(cd, cc) = cars[s]\n\t\t\td = disarr[s][i]\n\t\t\tif d <= cd:\n\t\t\t\tnewg[s][i] = min(newg[s][i], cc)\n\t\t\t\tdnex[s].append(i)\n\n\tdef dij1(s):\n\t\tq = [(0, s)]\n\t\tcst = [INF] * (n + 1)\n\t\tcst[s] = 0\n\t\twhile q:\n\t\t\t(d, nd) = heappop(q)\n\t\t\tfor nex in dnex[nd]:\n\t\t\t\tcs = cst[nd] + newg[nd][nex]\n\t\t\t\tif cs < cst[nex]:\n\t\t\t\t\tcst[nex] = cs\n\t\t\t\t\theappush(q, (cs, nex))\n\t\tif cst[y] == INF:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(cst[y])\n\tfor i in range(1, n + 1):\n\t\tdij(i)\n\tdij1(x)\nmain()\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL():\n\treturn map(int, sys.stdin.readline().rstrip().split())\n\ndef RLL():\n\treturn list(map(int, sys.stdin.readline().rstrip().split()))\n\ndef N():\n\treturn int(input())\n\ndef comb(n, m):\n\treturn factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\n\ndef perm(n, m):\n\treturn factorial(n) // factorial(n - m) if n >= m else 0\n\ndef mdis(x1, y1, x2, y2):\n\treturn abs(x1 - x2) + abs(y1 - y2)\n\ndef ctd(chr):\n\treturn ord(chr) - ord('a')\nmod = 998244353\nINF = float('inf')\nfrom heapq import heappush, heappop\n\ndef main():\n\t(n, m) = RL()\n\t(x, y) = RL()\n\tgp = defaultdict(dict)\n\tfor _ in range(m):\n\t\t(u, v, w) = RL()\n\t\tgp[u][v] = min(gp[u].get(v, INF), w)\n\t\tgp[v][u] = min(gp[v].get(u, INF), w)\n\tcars = [[0, 0]]\n\tfor _ in range(n):\n\t\t(t, c) = RL()\n\t\tcars.append([t, c])\n\tdisarr = [[INF] * (n + 1) for _ in range(n + 1)]\n\tfor i in range(1, n + 1):\n\t\tdisarr[i][i] = 0\n\tnewg = [[INF] * (n + 1) for _ in range(n + 1)]\n\tdnex = defaultdict(list)\n\n\tdef dij(s):\n\t\tq = [(0, s)]\n\t\twhile q:\n\t\t\t(d, nd) = heappop(q)\n\t\t\tfor nex in gp[nd]:\n\t\t\t\tdis = gp[nd][nex] + disarr[s][nd]\n\t\t\t\tif dis < disarr[s][nex]:\n\t\t\t\t\tdisarr[s][nex] = dis\n\t\t\t\t\theappush(q, (dis, nex))\n\t\tfor i in range(1, n + 1):\n\t\t\t(cd, cc) = cars[s]\n\t\t\td = disarr[s][i]\n\t\t\tif d <= cd:\n\t\t\t\tnewg[s][i] = min(newg[s][i], cc)\n\t\t\t\tdnex[s].append(i)\n\n\tdef dij1(s):\n\t\tq = [(0, s)]\n\t\tcst = [INF] * (n + 1)\n\t\tcst[s] = 0\n\t\twhile q:\n\t\t\t(d, nd) = heappop(q)\n\t\t\tfor nex in dnex[nd]:\n\t\t\t\tcs = cst[nd] + newg[nd][nex]\n\t\t\t\tif cs < cst[nex]:\n\t\t\t\t\tcst[nex] = cs\n\t\t\t\t\theappush(q, (cs, nex))\n\t\tif cst[y] == INF:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(cst[y])\n\tfor i in range(1, n + 1):\n\t\tdij(i)\n\tdij1(x)\nmain()\n"
    },
    {
        "task_id": 765,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 3.0449986457824707,
        "fastest_time": 2.6637680530548096,
        "fastest_solution": "import math\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = [int(x) for x in input().split()]\n\tb = [1] + [abs(a[i] - a[i - 1]) for i in range(1, n)]\n\tcur = {1: 0}\n\tans = 0\n\tfor i in range(1, n):\n\t\tg = b[i]\n\t\td = {}\n\t\td[g] = i\n\t\tif g != 1:\n\t\t\ttmp = sorted(list(cur.keys()), reverse=True)\n\t\t\tfor j in tmp:\n\t\t\t\tg = math.gcd(g, j)\n\t\t\t\tif g not in d:\n\t\t\t\t\td[g] = cur[j]\n\t\t\t\tif g == 1:\n\t\t\t\t\tans = max(ans, i - cur[j])\n\t\t\t\t\tbreak\n\t\tcur = d.copy()\n\tprint(ans + 1)\n",
        "slowest_solution": "import math\nfor t in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().strip().split()))\n\tif n == 1:\n\t\tprint(n)\n\telse:\n\t\tans = 0\n\t\tfor i in range(len(a) - 1):\n\t\t\ta[i] = abs(a[i] - a[i + 1])\n\t\ta.pop()\n\t\t(g, st, cur) = (0, 0, 0)\n\t\tfor i in range(len(a)):\n\t\t\tg = math.gcd(g, a[i])\n\t\t\tcur += 1\n\t\t\tif g != 1:\n\t\t\t\tans = max(ans, cur)\n\t\t\telse:\n\t\t\t\t(g, cur) = (0, 0)\n\t\t\t\tfor j in range(i - st + 1):\n\t\t\t\t\tind = i - j\n\t\t\t\t\tg = math.gcd(g, a[ind])\n\t\t\t\t\tif g != 1:\n\t\t\t\t\t\tcur += 1\n\t\t\t\t\t\tans = max(ans, cur)\n\t\t\t\t\telse:\n\t\t\t\t\t\tst = ind + 1\n\t\t\t\t\t\tbreak\n\t\tprint(ans + 1)\n"
    },
    {
        "task_id": 725,
        "slowest_solution_id": 7,
        "fastest_solution_id": 0,
        "slowest_time": 3.0292046070098877,
        "fastest_time": 2.4900925159454346,
        "fastest_solution": "import sys\ninput = sys.stdin.buffer.readline\nfrom queue import deque\n(n, m) = [int(x) for x in input().split()]\nadj = [[] for _ in range(n + 1)]\nrev = [[] for _ in range(n + 1)]\nfor _ in range(m):\n\t(u, v) = [int(x) for x in input().split()]\n\tadj[u].append(v)\n\trev[v].append(u)\nk = int(input())\np = [int(x) for x in input().split()]\ninf = float('inf')\nsp = [inf for _ in range(n + 1)]\nq = deque([[0, p[k - 1]]])\nwhile q:\n\t(d, node) = q.popleft()\n\tif sp[node] == inf:\n\t\tsp[node] = d\n\t\tfor nex in rev[node]:\n\t\t\tif sp[nex] == inf:\n\t\t\t\tq.append([d + 1, nex])\nminn = 0\nmaxx = 0\nfor i in range(k - 1):\n\tnode = p[i]\n\tnex = p[i + 1]\n\tif sp[node] - 1 != sp[nex]:\n\t\tminn += 1\n\t\tmaxx += 1\n\telse:\n\t\tmatches = 0\n\t\tfor i in adj[node]:\n\t\t\tif sp[i] + 1 == sp[node]:\n\t\t\t\tmatches += 1\n\t\tif matches > 1:\n\t\t\tmaxx += 1\nprint('{} {}'.format(minn, maxx))\n",
        "slowest_solution": "from collections import deque\n(n, m) = map(int, input().split())\ng = [[] for _ in range(n)]\ng_n = [[] for _ in range(n)]\nfor _ in range(m):\n\t(u, v) = map(int, input().split())\n\tg_n[u - 1].append(v - 1)\n\tg[v - 1].append(u - 1)\nk = int(input())\npath = list(map(int, input().split()))\nq = deque()\ndistance = [-1 for _ in range(n)]\ndistance[path[k - 1] - 1] = 0\nq.append(path[k - 1] - 1)\nwhile len(q):\n\tu = q.popleft()\n\tfor v in g[u]:\n\t\tif distance[v] == -1:\n\t\t\tdistance[v] = distance[u] + 1\n\t\t\tq.append(v)\nrebuild = 0\nrebuild_max = 0\nfor i in range(1, k - 1):\n\tif distance[path[i] - 1] == distance[path[i - 1] - 1] - 1:\n\t\tfor w in g_n[path[i - 1] - 1]:\n\t\t\tif w != path[i] - 1 and distance[w] == distance[path[i] - 1]:\n\t\t\t\trebuild_max += 1\n\t\t\t\tbreak\n\telse:\n\t\trebuild += 1\nprint(rebuild, rebuild + rebuild_max)\n"
    },
    {
        "task_id": 775,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6717846393585205,
        "fastest_time": 2.6717846393585205,
        "fastest_solution": "import sys\n\ndef orientation(p1, p2, p3):\n\treturn (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\ndef dot(p1, p2, p3, p4):\n\treturn (p2[0] - p1[0]) * (p4[0] - p3[0]) + (p2[1] - p1[1]) * (p4[1] - p3[1])\n\ndef theta(p1, p2):\n\tdx = p2[0] - p1[0]\n\tdy = p2[1] - p1[1]\n\tif abs(dx) < 0.1 and abs(dy) < 0.1:\n\t\tt = 0\n\telse:\n\t\tt = dy / (abs(dx) + abs(dy))\n\t\tif abs(t) < 0.1 ** 10:\n\t\t\tt = 0\n\tif dx < 0:\n\t\tt = 2 - t\n\telif dy < 0:\n\t\tt = 4 + t\n\treturn t * 90\n\ndef dist_sq(p1, p2):\n\treturn (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1])\n\ndef chull(points):\n\tpi = [x for x in range(len(points))]\n\tmin_y = points[0][1]\n\tmin_x = points[0][0]\n\tmin_ind = 0\n\tfor i in range(len(points)):\n\t\tif points[i][1] < min_y or (points[i][1] == min_y and points[i][0] < min_x):\n\t\t\tmin_y = points[i][1]\n\t\t\tmin_x = points[i][0]\n\t\t\tmin_ind = i\n\tpi[0] = min_ind\n\tpi[min_ind] = 0\n\tth = [theta(points[pi[0]], points[x]) for x in range(len(points))]\n\tpi.sort(key=lambda x: th[x])\n\tunique = [pi[0], pi[1]]\n\tfor i in range(2, len(pi)):\n\t\tif th[pi[i]] != th[unique[-1]]:\n\t\t\tunique.append(pi[i])\n\t\telif dist_sq(points[pi[0]], points[unique[-1]]) < dist_sq(points[pi[0]], points[pi[i]]):\n\t\t\tunique[-1] = pi[i]\n\tpi = unique\n\tstack = []\n\tfor i in range(min(len(pi), 3)):\n\t\tstack.append(points[pi[i]])\n\tif len(stack) < 3:\n\t\treturn stack\n\tfor i in range(3, len(pi)):\n\t\twhile len(stack) >= 2:\n\t\t\to = orientation(stack[-2], stack[-1], points[pi[i]])\n\t\t\tif o > 0:\n\t\t\t\tstack.append(points[pi[i]])\n\t\t\t\tbreak\n\t\t\telif o < 0:\n\t\t\t\tstack.pop()\n\t\t\telif dist_sq(stack[-2], stack[-1]) < dist_sq(stack[-2], points[pi[i]]):\n\t\t\t\tstack.pop()\n\t\t\telse:\n\t\t\t\tbreak\n\treturn stack\n\ndef z_func(s):\n\t(slen, l, r) = (len(s), 0, 0)\n\tz = [0] * slen\n\tz[0] = slen\n\tfor i in range(1, slen):\n\t\tif i <= r:\n\t\t\tz[i] = min(r - i + 1, z[i - l])\n\t\twhile i + z[i] < slen and s[z[i]] == s[i + z[i]]:\n\t\t\tz[i] += 1\n\t\tif i + z[i] - 1 > r:\n\t\t\t(l, r) = (i, i + z[i] - 1)\n\treturn z\n(n, m) = map(int, sys.stdin.readline().strip().split())\na = []\nfor _ in range(n):\n\t(x, y) = map(int, sys.stdin.readline().strip().split())\n\ta.append((x, y))\nb = []\nfor _ in range(m):\n\t(x, y) = map(int, sys.stdin.readline().strip().split())\n\tb.append((x, y))\nah = chull(a)\nbh = chull(b)\nif len(ah) == len(bh):\n\tif len(ah) == 2:\n\t\tif dist_sq(ah[0], ah[1]) == dist_sq(bh[0], bh[1]):\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telse:\n\t\tda = []\n\t\tfor i in range(len(ah)):\n\t\t\tdot_a = dot(ah[i - 2], ah[i - 1], ah[i - 1], ah[i])\n\t\t\tda.append((dist_sq(ah[i], ah[i - 1]), dot_a))\n\t\tdb = []\n\t\tfor i in range(len(bh)):\n\t\t\tdot_b = dot(bh[i - 2], bh[i - 1], bh[i - 1], bh[i])\n\t\t\tdb.append((dist_sq(bh[i], bh[i - 1]), dot_b))\n\t\tl = r = 0\n\t\tdaab = []\n\t\tdaab.extend(db)\n\t\tdaab.append(-1)\n\t\tdaab.extend(da)\n\t\tdaab.extend(da)\n\t\tzab = z_func(daab)\n\t\tfound = False\n\t\tfor i in range(len(db) + 1, len(daab) - len(db) + 1):\n\t\t\tif zab[i] == len(db):\n\t\t\t\tfound = True\n\t\t\t\tbreak\n\t\tif found:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "import sys\n\ndef orientation(p1, p2, p3):\n\treturn (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\ndef dot(p1, p2, p3, p4):\n\treturn (p2[0] - p1[0]) * (p4[0] - p3[0]) + (p2[1] - p1[1]) * (p4[1] - p3[1])\n\ndef theta(p1, p2):\n\tdx = p2[0] - p1[0]\n\tdy = p2[1] - p1[1]\n\tif abs(dx) < 0.1 and abs(dy) < 0.1:\n\t\tt = 0\n\telse:\n\t\tt = dy / (abs(dx) + abs(dy))\n\t\tif abs(t) < 0.1 ** 10:\n\t\t\tt = 0\n\tif dx < 0:\n\t\tt = 2 - t\n\telif dy < 0:\n\t\tt = 4 + t\n\treturn t * 90\n\ndef dist_sq(p1, p2):\n\treturn (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1])\n\ndef chull(points):\n\tpi = [x for x in range(len(points))]\n\tmin_y = points[0][1]\n\tmin_x = points[0][0]\n\tmin_ind = 0\n\tfor i in range(len(points)):\n\t\tif points[i][1] < min_y or (points[i][1] == min_y and points[i][0] < min_x):\n\t\t\tmin_y = points[i][1]\n\t\t\tmin_x = points[i][0]\n\t\t\tmin_ind = i\n\tpi[0] = min_ind\n\tpi[min_ind] = 0\n\tth = [theta(points[pi[0]], points[x]) for x in range(len(points))]\n\tpi.sort(key=lambda x: th[x])\n\tunique = [pi[0], pi[1]]\n\tfor i in range(2, len(pi)):\n\t\tif th[pi[i]] != th[unique[-1]]:\n\t\t\tunique.append(pi[i])\n\t\telif dist_sq(points[pi[0]], points[unique[-1]]) < dist_sq(points[pi[0]], points[pi[i]]):\n\t\t\tunique[-1] = pi[i]\n\tpi = unique\n\tstack = []\n\tfor i in range(min(len(pi), 3)):\n\t\tstack.append(points[pi[i]])\n\tif len(stack) < 3:\n\t\treturn stack\n\tfor i in range(3, len(pi)):\n\t\twhile len(stack) >= 2:\n\t\t\to = orientation(stack[-2], stack[-1], points[pi[i]])\n\t\t\tif o > 0:\n\t\t\t\tstack.append(points[pi[i]])\n\t\t\t\tbreak\n\t\t\telif o < 0:\n\t\t\t\tstack.pop()\n\t\t\telif dist_sq(stack[-2], stack[-1]) < dist_sq(stack[-2], points[pi[i]]):\n\t\t\t\tstack.pop()\n\t\t\telse:\n\t\t\t\tbreak\n\treturn stack\n\ndef z_func(s):\n\t(slen, l, r) = (len(s), 0, 0)\n\tz = [0] * slen\n\tz[0] = slen\n\tfor i in range(1, slen):\n\t\tif i <= r:\n\t\t\tz[i] = min(r - i + 1, z[i - l])\n\t\twhile i + z[i] < slen and s[z[i]] == s[i + z[i]]:\n\t\t\tz[i] += 1\n\t\tif i + z[i] - 1 > r:\n\t\t\t(l, r) = (i, i + z[i] - 1)\n\treturn z\n(n, m) = map(int, sys.stdin.readline().strip().split())\na = []\nfor _ in range(n):\n\t(x, y) = map(int, sys.stdin.readline().strip().split())\n\ta.append((x, y))\nb = []\nfor _ in range(m):\n\t(x, y) = map(int, sys.stdin.readline().strip().split())\n\tb.append((x, y))\nah = chull(a)\nbh = chull(b)\nif len(ah) == len(bh):\n\tif len(ah) == 2:\n\t\tif dist_sq(ah[0], ah[1]) == dist_sq(bh[0], bh[1]):\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telse:\n\t\tda = []\n\t\tfor i in range(len(ah)):\n\t\t\tdot_a = dot(ah[i - 2], ah[i - 1], ah[i - 1], ah[i])\n\t\t\tda.append((dist_sq(ah[i], ah[i - 1]), dot_a))\n\t\tdb = []\n\t\tfor i in range(len(bh)):\n\t\t\tdot_b = dot(bh[i - 2], bh[i - 1], bh[i - 1], bh[i])\n\t\t\tdb.append((dist_sq(bh[i], bh[i - 1]), dot_b))\n\t\tl = r = 0\n\t\tdaab = []\n\t\tdaab.extend(db)\n\t\tdaab.append(-1)\n\t\tdaab.extend(da)\n\t\tdaab.extend(da)\n\t\tzab = z_func(daab)\n\t\tfound = False\n\t\tfor i in range(len(db) + 1, len(daab) - len(db) + 1):\n\t\t\tif zab[i] == len(db):\n\t\t\t\tfound = True\n\t\t\t\tbreak\n\t\tif found:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 755,
        "slowest_solution_id": 4,
        "fastest_solution_id": 8,
        "slowest_time": 3.0107967853546143,
        "fastest_time": 2.667557954788208,
        "fastest_solution": "N = int(input())\nfor i in range(N):\n\tn = int(input())\n\tll = list(map(int, input().split()))\n\tfor i in range(n):\n\t\tif ll[i] == i + 1:\n\t\t\troot = i + 1\n\tv = dict()\n\tfor i in range(n):\n\t\tif i + 1 != root:\n\t\t\tif ll[i] not in v.keys():\n\t\t\t\tv[ll[i]] = list()\n\t\t\tv[ll[i]].append(i + 1)\n\tlvs = [False for i in range(n + 1)]\n\tlvs[0] = True\n\tcnt = 0\n\tfor i in ll:\n\t\tlvs[i] = True\n\tfor i in lvs:\n\t\tif not i:\n\t\t\tcnt += 1\n\tif n == 1:\n\t\tcnt = 1\n\tprint(cnt)\n\tif n == 1:\n\t\tprint(1)\n\t\tprint(ll[0])\n\tst = [False for i in range(n + 1)]\n\tfor i in range(1, len(lvs)):\n\t\tif not lvs[i]:\n\t\t\tcur = i\n\t\t\ttmp = []\n\t\t\twhile not st[cur]:\n\t\t\t\ttmp.append(cur)\n\t\t\t\tst[cur] = True\n\t\t\t\tcur = ll[cur - 1]\n\t\t\tprint(len(tmp))\n\t\t\tfor i in range(len(tmp) - 1, -1, -1):\n\t\t\t\tprint(tmp[i], end=' ')\n\t\t\tprint()\n\tprint()\n",
        "slowest_solution": "t = int(input())\nwhile t > 0:\n\tt -= 1\n\tn = int(input())\n\tp = [int(i) for i in input().split(' ')]\n\tif n == 1:\n\t\tprint('1\\n1\\n1\\n')\n\t\tcontinue\n\tparents = set(p)\n\tall_nodes = set(list(range(1, n + 1)))\n\tleaves = all_nodes - parents\n\tcol = [0 for i in range(n)]\n\tprint(len(leaves))\n\tfor leaf in leaves:\n\t\trpath = [leaf]\n\t\tnode = leaf\n\t\tcol[node - 1] = 1\n\t\twhile col[p[node - 1] - 1] == 0:\n\t\t\tnode = p[node - 1]\n\t\t\tcol[node - 1] = 1\n\t\t\trpath.append(node)\n\t\tprint(len(rpath))\n\t\tfor i in reversed(rpath):\n\t\t\tprint(i, end=' ')\n\t\tprint('')\n\tprint('')\n"
    },
    {
        "task_id": 767,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 10.006057977676392,
        "fastest_time": 2.674476385116577,
        "fastest_solution": "import math\ndef getPrime(Max):\n\tused = [0] * Max\n\tfor i in range(4, Max, 2):\n\t\tused[i] = 1\n\tused[1] = 1\n\tfor i in range(3, int(math.sqrt(Max) + 1), 2):\n\t\tif used[i] == 1:\n\t\t\tcontinue\n\t\tfor j in range(i * i, Max, i):\n\t\t\tused[j] = 1\n\treturn used\ndef main():\n\tN, K = map(int, input().strip().split())\n\tA = []\n\tMax = 0\n\tfor _ in range(N):\n\t\tA.append(list(map(int, input().strip().split())))\n\t\ttemp = max(A[-1])\n\t\tMax = max(Max, temp)\n\tDP = [0] * (Max + 1)\n\tused = getPrime(10001)\n\tlength = 10001\n\tfor i in range(1, Max + 1):\n\t\tif used[i] == 0:\n\t\t\tcontinue\n\t\tif K > 1 and i % K == 0:\n\t\t\tDP[i] = 10 ** 10\n\t\t\tcontinue\n\t\tj = i\n\t\tcnt = 0\n\t\twhile j < length:\n\t\t\tif used[j] == 0:\n\t\t\t\tDP[i] = cnt\n\t\t\t\tbreak\n\t\t\tj += K\n\t\t\tcnt += 1\n\t\tif j >= length:\n\t\t\tDP[i] = 10 ** 10\n\tfor i in range(N):\n\t\tfor j in range(N):\n\t\t\tA[i][j] = DP[A[i][j]]\n\tMinStep = 10 ** 10\n\tX = -1\n\tY = -1\n\tfor i in range(1, N - 1):\n\t\tfor j in range(1, N - 1):\n\t\t\tSum = 0\n\t\t\tif A[i][j] == 10 ** 10:\n\t\t\t\tcontinue\n\t\t\tif A[i - 1][j - 1] == 10 ** 10:\n\t\t\t\tcontinue\n\t\t\tif A[i - 1][j + 1] == 10 ** 10:\n\t\t\t\tcontinue\n\t\t\tif A[i + 1][j - 1] == 10 ** 10:\n\t\t\t\tcontinue\n\t\t\tif A[i + 1][j + 1] == 10 ** 10:\n\t\t\t\tcontinue\n\t\t\tSum = A[i][j] + A[i - 1][j - 1] + A[i - 1][j + 1] + A[i + 1][j - 1] + A[i + 1][j + 1]\n\t\t\tif MinStep > Sum:\n\t\t\t\tMinStep = Sum\n\t\t\t\tX = i + 1\n\t\t\t\tY = j + 1\n\tif MinStep != 10 ** 10:\n\t\tprint('yes')\n\t\tprint(MinStep)\n\t\tprint(X, Y)\n\telse:\n\t\tprint('no')\nif __name__ == '__main__':\n\tmain()\n",
        "slowest_solution": "N = 10001\nisPrime = [1] * N\nisPrime[0] = 0\nisPrime[1] = 0\nfor i in range(2, N):\n\tif isPrime[i]:\n\t\tfor j in range(i + i, N, i):\n\t\t\tisPrime[j] = 0\nprimes = [i for i in range(2, N) if isPrime[i]]\nminOps = [1 << 30] * N\nn, K = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(n)]\nfor i in range(N):\n\tfor p in primes:\n\t\tif p >= i and (p - i) % K == 0:\n\t\t\tminOps[i] = min(minOps[i], (p - i) // K)\nminCount = 1 << 30\nfor i in range(n - 2):\n\tfor j in range(n - 2):\n\t\tcount = 0\n\t\tfor dx, dy in ((0, 0), (1, 1), (2, 2), (2, 0), (0, 2)):\n\t\t\tcount += minOps[A[i + dx][j + dy]]\n\t\tif count < minCount:\n\t\t\tminCount = count\n\t\t\tpos = (i + 2, j + 2)\nif minCount == 1 << 30:\n\tprint('no')\nelse:\n\tprint('yes')\n\tprint(minCount)\n\tprint(pos[0], pos[1])\n"
    },
    {
        "task_id": 760,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 3.1552274227142334,
        "fastest_time": 2.4572672843933105,
        "fastest_solution": "def i():\n\treturn int(input())\n\ndef s():\n\treturn input()\n\ndef l():\n\treturn list(map(int, input().split()))\n\ndef m():\n\treturn map(int, input().split())\nfor _ in range(i()):\n\t(k, N, l, r) = map(int, input().split())\n\tA = [sorted(map(int, input().split())) for j in range(k)]\n\tX = [[sum(A[i])] * 2 for i in range(k)]\n\tfor i in range(N + 1):\n\t\tif min((X[j][1] for j in range(k))) >= max((X[j][0] for j in range(k))):\n\t\t\tprint(i)\n\t\t\tbreak\n\t\tfor j in range(k):\n\t\t\tX[j][1] += r - A[j][i]\n\t\t\tX[j][0] -= A[j][-1 - i] - l\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(k, N, l, r) = map(int, input().split())\n\tA = [sorted(map(int, input().split())) for j in range(k)]\n\tX = [[sum(A[i])] * 2 for i in range(k)]\n\tfor i in range(N + 1):\n\t\tif min((X[j][1] for j in range(k))) >= max((X[j][0] for j in range(k))):\n\t\t\tprint(i)\n\t\t\tbreak\n\t\tfor j in range(k):\n\t\t\tX[j][1] += r - A[j][i]\n\t\t\tX[j][0] -= A[j][-1 - i] - l\n"
    },
    {
        "task_id": 734,
        "slowest_solution_id": 5,
        "fastest_solution_id": 3,
        "slowest_time": 3.015885829925537,
        "fastest_time": 2.5326778888702393,
        "fastest_solution": "t = int(input())\nwhile t > 0:\n\tn = int(input())\n\ta = list(map(int, input().split(' ')))\n\tcpu_1 = a[0]\n\tcpu_2 = a[n - 1]\n\tif n == 1:\n\t\tprint(cpu_1)\n\telif n == 2:\n\t\tprint(max(cpu_1, cpu_2))\n\telse:\n\t\t(i, j) = (1, n - 2)\n\t\twhile i <= j:\n\t\t\tif cpu_1 <= cpu_2:\n\t\t\t\tcpu_1 += a[i]\n\t\t\t\ti += 1\n\t\t\telse:\n\t\t\t\tcpu_2 += a[j]\n\t\t\t\tj -= 1\n\t\tprint(max(cpu_1, cpu_2))\n\tt -= 1\n",
        "slowest_solution": "t = int(input())\nwhile t:\n\tn = int(input())\n\tlist1 = list(map(int, input().split(' ')))\n\tsuma = 0\n\tsumb = 0\n\ti = 0\n\tj = 1\n\twhile i + j <= n:\n\t\tif suma <= sumb:\n\t\t\tsuma += list1[i]\n\t\t\ti += 1\n\t\telse:\n\t\t\tsumb += list1[n - j]\n\t\t\tj += 1\n\tprint(max(suma, sumb))\n\tt = t - 1\n"
    },
    {
        "task_id": 736,
        "slowest_solution_id": 5,
        "fastest_solution_id": 8,
        "slowest_time": 3.205773115158081,
        "fastest_time": 2.427644968032837,
        "fastest_solution": "for i in range(int(input())):\n\t(x, m, n) = map(float, input().split())\n\tif m * 60 <= x + (n * 60 - x) / 2 and n >= m:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "try:\n\tfor t in range(int(input())):\n\t\t(X, R, M) = tuple(map(int, input().split()))\n\t\tR = 60 * R\n\t\tM = 60 * M\n\t\tflag = 0\n\t\tR -= X\n\t\tM -= X\n\t\tX = 0\n\t\tif M < R:\n\t\t\tprint('NO')\n\t\t\tcontinue\n\t\tif R < 0:\n\t\t\tprint('YES')\n\t\t\tcontinue\n\t\tif M // 2 >= R:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\nexcept:\n\tpass\n"
    },
    {
        "task_id": 738,
        "slowest_solution_id": 4,
        "fastest_solution_id": 1,
        "slowest_time": 3.011223554611206,
        "fastest_time": 2.518975019454956,
        "fastest_solution": "n = int(input())\nans = 0\nvisited = {}\nf = {}\ns = {}\nfor i in range(n):\n\tn = [int(x) for x in input().split()]\n\tif n[0] in f:\n\t\tans += f[n[0]]\n\t\tf[n[0]] += 1\n\telse:\n\t\tf[n[0]] = 1\n\tif n[1] in s:\n\t\tans += s[n[1]]\n\t\ts[n[1]] += 1\n\telse:\n\t\ts[n[1]] = 1\n\tif tuple(n) in visited:\n\t\tans -= visited[tuple(n)]\n\t\tvisited[tuple(n)] += 1\n\telse:\n\t\tvisited[tuple(n)] = 1\nprint(ans)\n",
        "slowest_solution": "t = int(input())\nr = []\npy = []\nfor i in range(t):\n\t(x, y) = map(int, input().strip().split(' '))\n\tr.append([x, y])\n\tpy.append(y)\nr.sort()\npy.sort()\nc = 0\nc1 = 1\nc2 = 1\nc3 = 1\nfor i in range(t - 1):\n\tif py[i] == py[i + 1]:\n\t\tc3 += 1\n\t\tif i == t - 2:\n\t\t\tc += c3 * (c3 - 1) // 2\n\telse:\n\t\tc += c3 * (c3 - 1) // 2\n\t\tc3 = 1\n\tif r[i][0] == r[i + 1][0] and r[i][1] == r[i + 1][1]:\n\t\tc2 += 1\n\t\tif i == t - 2:\n\t\t\tc -= c2 * (c2 - 1) // 2\n\telse:\n\t\tc -= c2 * (c2 - 1) // 2\n\t\tc2 = 1\n\tif r[i][0] == r[i + 1][0]:\n\t\tc1 += 1\n\t\tif i == t - 2:\n\t\t\tc += c1 * (c1 - 1) // 2\n\telse:\n\t\tc += c1 * (c1 - 1) // 2\n\t\tc1 = 1\nprint(c)\n"
    },
    {
        "task_id": 740,
        "slowest_solution_id": 4,
        "fastest_solution_id": 1,
        "slowest_time": 3.0736026763916016,
        "fastest_time": 2.4889676570892334,
        "fastest_solution": "import sys\nimport time\ninput_lines = [line.strip() for line in sys.stdin.readlines() if line.strip()]\nT = int(input_lines[0])\n\ndef problem(n):\n\tif n == 0:\n\t\treturn 0\n\telif n == 1:\n\t\treturn 2\n\telse:\n\t\tlength = n + 1\n\t\tlength += problem(int(n / 2))\n\t\tlength += problem(n - int(n / 2) - 1)\n\t\treturn length\nt = 0\nwhile t < T:\n\t(N, M) = [int(x) for x in input_lines[t + 1].split()]\n\tmax_length = int(N * (N + 3) / 2)\n\tmin_length = problem(N)\n\tif M > max_length:\n\t\tprint(M - max_length)\n\telif M >= min_length:\n\t\tprint(0)\n\telse:\n\t\tprint(-1)\n\tt += 1\n",
        "slowest_solution": "lmn = [2, 5, 8, 12, 16, 20, 24, 29, 34, 39, 44, 49, 54, 59, 64, 70, 76, 82, 88, 94, 100, 106, 112, 118, 124, 130, 136, 142, 148, 154, 160, 167, 174, 181, 188, 195, 202, 209, 216, 223]\nt = int(input())\nfor i in range(t):\n\t(n, m) = map(int, input().split())\n\tmx = (n + 1) * (n + 2) // 2 - 1\n\tmn = lmn[n - 1]\n\tif m > mx:\n\t\tprint(m - mx)\n\telif m < mn:\n\t\tprint(-1)\n\telse:\n\t\tprint(0)\n"
    },
    {
        "task_id": 741,
        "slowest_solution_id": 4,
        "fastest_solution_id": 8,
        "slowest_time": 3.267481803894043,
        "fastest_time": 2.4640932083129883,
        "fastest_solution": "t = int(input())\n\ndef getmax(lst: list):\n\tans = lst[0]\n\tfor e in lst:\n\t\tif e > ans:\n\t\t\tans = e\n\treturn ans\n\ndef getmaxidx(a, arr):\n\tmax_ = getmax(a)\n\treturn (arr.index(max_), max_)\n\ndef maketree(left: list, right: list, depth, ans: list, arr):\n\tif len(left) == 0 and len(right) == 0:\n\t\treturn\n\tif len(left) != 0:\n\t\t(lstart, lmax) = getmaxidx(left[:], arr)\n\t\tans[lstart] = depth\n\t\tmaketree(left[:left.index(lmax)], left[left.index(lmax) + 1:], depth=depth + 1, ans=ans, arr=arr)\n\tif len(right) != 0:\n\t\t(rstart, rmax) = getmaxidx(right[:], arr)\n\t\tans[rstart] = depth\n\t\tmaketree(right[:right.index(rmax)], right[right.index(rmax) + 1:], depth=depth + 1, ans=ans, arr=arr)\nfor _ in range(t):\n\tn = int(input())\n\tans = [0] * n\n\tarr = list(map(int, input().split(' ')))\n\t(start, max) = getmaxidx(arr, arr)\n\tdepth = 0\n\tans[start] = depth\n\tmaketree(arr[:start], arr[start + 1:], depth=depth + 1, ans=ans, arr=arr)\n\tprint(*ans)\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\td = [0] * (n + 1)\n\n\tdef go(v, h):\n\t\tif v:\n\t\t\tx = max(v)\n\t\t\ti = v.index(x)\n\t\t\td[x] = h\n\t\t\tgo(v[:i], h + 1)\n\t\t\tgo(v[i + 1:], h + 1)\n\tgo(a, 0)\n\tprint(*(d[a[i]] for i in range(n)))\n"
    },
    {
        "task_id": 742,
        "slowest_solution_id": 4,
        "fastest_solution_id": 1,
        "slowest_time": 3.1521520614624023,
        "fastest_time": 2.453906774520874,
        "fastest_solution": "def get_len(a, b):\n\tif a[0] >= b[0]:\n\t\tc = a\n\t\ta = b\n\t\tb = c\n\ti = 0\n\tj = 0\n\tres = 2\n\twhile i < len(a) and j < len(b):\n\t\twhile a[i] <= b[j]:\n\t\t\ti += 1\n\t\t\tif i == len(a):\n\t\t\t\tbreak\n\t\tif i == len(a):\n\t\t\tbreak\n\t\tres += 1\n\t\twhile a[i] >= b[j]:\n\t\t\tj += 1\n\t\t\tif j == len(b):\n\t\t\t\tbreak\n\t\tif j == len(b):\n\t\t\tbreak\n\t\tres += 1\n\treturn res\nn = int(input())\na = [int(e) for e in input().split()]\nd = dict()\nkeys = []\nfor i in range(len(a)):\n\tx = a[i]\n\tif x in d:\n\t\td[x].append(i)\n\telse:\n\t\td[x] = [i]\n\t\tkeys.append(x)\nans = 0\nfor i in range(len(keys)):\n\tx = keys[i]\n\tfor j in range(i + 1, len(keys)):\n\t\ty = keys[j]\n\t\tif x == y:\n\t\t\tcontinue\n\t\ti1 = 0\n\t\tj1 = 0\n\t\txi = get_len(d[x], d[y])\n\t\tans = max(ans, xi)\nans1 = [len(d[e]) for e in d]\nans = max(ans, max(ans1))\nprint(ans)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\na = int(input())\nz = list(map(int, input().split()))\nfrom collections import *\nfrom bisect import *\ndp = [[0 for i in range(len(z))] for i in range(len(z))]\nfor i in range(len(z)):\n\tdp[0][i] = 1\nal = defaultdict(list)\nmaxa = 0\nfor i in range(len(z)):\n\tal[z[i]].append(i)\n\tmaxa = max(maxa, len(al[z[i]]))\nfor i in range(len(z)):\n\tindex = -1\n\tfor j in range(i):\n\t\tif z[i] != z[j]:\n\t\t\tif index == -1:\n\t\t\t\tdp[i][j] = max(2, dp[i][j])\n\t\t\telse:\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[j][index] + 1)\n\t\telse:\n\t\t\tindex = j\n\t\tmaxa = max(dp[i][j], maxa)\nprint(maxa)\n"
    },
    {
        "task_id": 744,
        "slowest_solution_id": 4,
        "fastest_solution_id": 8,
        "slowest_time": 3.1906282901763916,
        "fastest_time": 2.521498441696167,
        "fastest_solution": "import math\nMAX = 2001\nfact = [math.log10(1)]\nfor zz in range(1, MAX + 1):\n\tfact.append(fact[-1] + math.log10(zz))\n\ndef nCr(n, r):\n\tnum = fact[n]\n\tden = fact[r] + fact[n - r]\n\treturn num - den\n(n, p, t) = [float(x) for x in input().split()]\nn = int(n)\nt = int(t)\nif p == 0:\n\tprint(0)\nelif p == 1:\n\tprint(min(n, t))\nelse:\n\tans = 0\n\tprobs = [0 for _ in range(t + 1)]\n\tfor x in range(t + 1):\n\t\tone = nCr(t, x)\n\t\ttwo = (t - x) * math.log10(1 - p)\n\t\tthree = x * math.log10(p)\n\t\tprobs[x] = 10 ** (one + two + three)\n\tfor (x, p) in enumerate(probs):\n\t\tif x <= n:\n\t\t\tans += x * p\n\t\telse:\n\t\t\tans += n * p\n\tprint(ans)\n",
        "slowest_solution": "(n, p, t) = map(float, input().split())\n(n, t) = (int(n), int(t))\ndp = [[0 for i in range(t + 1)] for j in range(t + 1)]\ndp[0][0] = 1\nfor i in range(1, t + 1):\n\tfor j in range(i + 1):\n\t\tif j >= 1:\n\t\t\tdp[i][j] = p * dp[i - 1][j - 1] + (1 - p) * dp[i - 1][j]\n\t\telse:\n\t\t\tdp[i][j] = (1 - p) * dp[i - 1][j]\ns = 0\ns1 = sum(dp[t])\ns2 = 0\nfor j in range(t + 1):\n\tif j > n:\n\t\ts += n * (s1 - s2)\n\t\tbreak\n\ts += dp[t][j] * j\n\ts2 += dp[t][j]\nprint(s)\n"
    },
    {
        "task_id": 776,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 2.739781141281128,
        "fastest_time": 2.550302267074585,
        "fastest_solution": "n = int(input())\na = list(map(int, input().split()))\nfor i in range(0, n):\n\tfor j in range(0, n):\n\t\tprint((((j - i) * i + a[i]) % n + n) % n, end=' ')\n\tprint()\n",
        "slowest_solution": "n = int(input())\na = list(map(int, input().split()))\nfor i in range(0, n):\n\tll = 0\n\tll += 1\n\tfor j in range(0, n):\n\t\tok = 1\n\t\tok -= 1\n\t\tok += 1\n\t\tprint((((j - i) * i + a[i]) % n + n) % n, end=' ')\n\t\ti = i + 1\n\t\tj = j + 1\n\t\ti -= 1\n\t\tj -= 1\n\tprint()\n"
    },
    {
        "task_id": 753,
        "slowest_solution_id": 4,
        "fastest_solution_id": 7,
        "slowest_time": 3.1926589012145996,
        "fastest_time": 2.525940179824829,
        "fastest_solution": "import sys, math, queue, collections\nMOD = 10 ** 9 + 7\nn = int(input())\na = list(map(int, input().split()))\nans = list(map(lambda x: x > 14 and x % 14 != 0 and (x % 14 < 7), a))\nfor ansi in ans:\n\tprint('YES' if ansi else 'NO')\n",
        "slowest_solution": "n = int(input())\nl = list(map(int, input().split()))\nfor x1 in l:\n\tif x1 > 14:\n\t\tr = x1 - 15\n\t\tt = r % 14\n\t\tif t == 0 or t == 1 or t == 2 or (t == 3) or (t == 4) or (t == 5):\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 745,
        "slowest_solution_id": 3,
        "fastest_solution_id": 2,
        "slowest_time": 3.0690817832946777,
        "fastest_time": 2.5434389114379883,
        "fastest_solution": "(n, k) = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = [0 for i in range(n + 1)]\nfor i in range(n):\n\ts[i] = s[i - 1] + a[i]\nans = 0\nbg = 1\ncan = set()\nprev = dict()\nprev[0] = 1\nfor i in range(50):\n\tcan.add(bg)\n\tbg *= k\nfor i in range(n):\n\tfor j in can:\n\t\tif s[i] - j in prev:\n\t\t\tans += prev[s[i] - j]\n\tif s[i] in prev:\n\t\tprev[s[i]] += 1\n\telse:\n\t\tprev[s[i]] = 1\nprint(ans)\n",
        "slowest_solution": "import sys\nfrom itertools import accumulate\n\ndef solve():\n\t(n, k) = map(int, input().split())\n\ta = [int(i) for i in input().split()]\n\tps = [0] + list(accumulate(a))\n\tap = {ps[n]: 1}\n\tans = 0\n\tif k == 1:\n\t\tfor i in range(n - 1, -1, -1):\n\t\t\tif ps[i] + 1 in ap:\n\t\t\t\tans += ap[ps[i] + 1]\n\t\t\tif ps[i] in ap:\n\t\t\t\tap[ps[i]] += 1\n\t\t\telse:\n\t\t\t\tap[ps[i]] = 1\n\telif k == -1:\n\t\tfor i in range(n - 1, -1, -1):\n\t\t\tif ps[i] + 1 in ap:\n\t\t\t\tans += ap[ps[i] + 1]\n\t\t\tif ps[i] - 1 in ap:\n\t\t\t\tans += ap[ps[i] - 1]\n\t\t\tif ps[i] in ap:\n\t\t\t\tap[ps[i]] += 1\n\t\t\telse:\n\t\t\t\tap[ps[i]] = 1\n\telse:\n\t\tkp = [k ** i for i in range(50)]\n\t\tfor i in range(n - 1, -1, -1):\n\t\t\tfor kpi in kp:\n\t\t\t\tif ps[i] + kpi in ap:\n\t\t\t\t\tans += ap[ps[i] + kpi]\n\t\t\tif ps[i] in ap:\n\t\t\t\tap[ps[i]] += 1\n\t\t\telse:\n\t\t\t\tap[ps[i]] = 1\n\tprint(ans)\n\ndef __starting_point():\n\tsolve()\n__starting_point()\n"
    },
    {
        "task_id": 746,
        "slowest_solution_id": 3,
        "fastest_solution_id": 6,
        "slowest_time": 2.9978339672088623,
        "fastest_time": 2.5215630531311035,
        "fastest_solution": "from sys import stdin\ninput = stdin.readline\n\ndef answer():\n\tbase = max(x1[-1] - x1[1], x2[-1] - x2[1])\n\tans = base * h\n\tbase = max(y1[-1] - y1[1], y2[-1] - y2[1])\n\tans = max(ans, base * w)\n\treturn ans\nfor T in range(int(input())):\n\t(w, h) = map(int, input().split())\n\tx1 = list(map(int, input().split()))\n\tx2 = list(map(int, input().split()))\n\ty1 = list(map(int, input().split()))\n\ty2 = list(map(int, input().split()))\n\tprint(answer())\n",
        "slowest_solution": "for _ in range(0, int(input())):\n\t(a, b) = map(int, input().split())\n\tc = list(map(int, input().split()))\n\td = list(map(int, input().split()))\n\te = list(map(int, input().split()))\n\tf = list(map(int, input().split()))\n\tca = c[len(c) - 1] - c[1]\n\tda = d[len(d) - 1] - d[1]\n\tea = e[len(e) - 1] - e[1]\n\tfa = f[len(f) - 1] - f[1]\n\tprint(max(ea * a, fa * a, da * b, ca * b))\n"
    },
    {
        "task_id": 797,
        "slowest_solution_id": 4,
        "fastest_solution_id": 0,
        "slowest_time": 0.0010006427764892578,
        "fastest_time": 0.0,
        "fastest_solution": "def even_magic(n):\n\treturn [[n * n - (y * n + x) if x % 4 == y % 4 or (x % 4 + y % 4) % 4 == 3 else y * n + x + 1 for x in range(n)] for y in range(n)]\n",
        "slowest_solution": "def even_magic(n):\n\tsq = [[y * n + x + 1 for x in range(n)] for y in range(n)]\n\tfor x in range(n):\n\t\tfor y in range(n):\n\t\t\tif y % 4 == x % 4 or y % 4 == 3 - x % 4:\n\t\t\t\tsq[x][y] = n ** 2 + 1 - sq[x][y]\n\treturn sq\n"
    },
    {
        "task_id": 748,
        "slowest_solution_id": 3,
        "fastest_solution_id": 7,
        "slowest_time": 3.1763603687286377,
        "fastest_time": 2.5010039806365967,
        "fastest_solution": "(n, h) = map(int, input().split())\ndp = [[0 for j in range(n + 1)] for i in range(n + 1)]\ndp[0] = [1 for j in range(n + 1)]\nfor i in range(n + 1):\n\tfor j in range(1, n + 1):\n\t\tfor k in range(i):\n\t\t\tdp[i][j] += dp[k][j - 1] * dp[i - 1 - k][j - 1]\nprint(dp[n][n] - (h > 0 and [dp[n][h - 1]] or [0])[0])\n",
        "slowest_solution": "def main():\n\t(n, h) = input().split()\n\tn = int(n)\n\th = int(h)\n\tmemo = [[None] * (h + 1) for i in range(n + 1)]\n\tcatalans = [catalan(i) for i in range(n + 1)]\n\tprint(calculate(n, h, memo, catalans))\n\ndef calculate(n, h, memo, catalans):\n\tif memo[n][h] != None:\n\t\treturn memo[n][h]\n\telif n < h:\n\t\tmemo[n][h] = 0\n\t\treturn 0\n\telif n <= 1:\n\t\tmemo[n][h] = 1\n\t\treturn 1\n\telse:\n\t\tif h == 0:\n\t\t\tnewH = 0\n\t\telse:\n\t\t\tnewH = h - 1\n\t\ttotal = 0\n\t\tfor left in range(n):\n\t\t\tright = n - left - 1\n\t\t\tcalcLeft = calculate(left, newH, memo, catalans)\n\t\t\tcalcRight = calculate(right, newH, memo, catalans)\n\t\t\ttotal += calcLeft * catalans[right] + calcRight * catalans[left] - calcLeft * calcRight\n\t\tmemo[n][h] = total\n\t\treturn total\n\ndef catalan(n):\n\tproduct = 1\n\tfor top in range(n + 1, 2 * n + 1):\n\t\tproduct *= top\n\tfor bot in range(2, n + 1):\n\t\tproduct //= bot\n\tproduct //= n + 1\n\treturn product\nmain()\n"
    },
    {
        "task_id": 750,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 3.0420241355895996,
        "fastest_time": 2.538752555847168,
        "fastest_solution": "import math\nimport sys\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda : map(int, input().split())\nalele = lambda : list(map(int, input().split()))\n\ndef find(a):\n\tif par[a] < 0:\n\t\treturn a\n\tpar[a] = find(par[a])\n\treturn par[a]\n\ndef merge(a, b):\n\tif a != b:\n\t\tpar[a] += par[b]\n\t\tpar[b] = a\n(n, m) = ilele()\npar = [-1 for i in range(n + 1)]\nfor i in range(1, m + 1):\n\tA = alele()\n\tfor j in range(2, A[0] + 1):\n\t\ta = find(A[j - 1])\n\t\tb = find(A[j])\n\t\tif a != b:\n\t\t\tmerge(a, b)\nfor i in range(1, len(par)):\n\tx = find(i)\n\tprint(-par[x], end=' ')\n",
        "slowest_solution": "from sys import stdin\ninput = stdin.readline\n(n, m) = map(int, input().split(' '))\nparent = [i for i in range(n)]\nsize = [1 for _ in range(n)]\nrank = [1 for _ in range(n)]\n\ndef find(a):\n\tif parent[a] == a:\n\t\treturn a\n\tparent[a] = find(parent[a])\n\treturn parent[a]\n\ndef union(a, b):\n\tpa = find(a)\n\tpb = find(b)\n\tif pa == pb:\n\t\treturn\n\tif rank[pa] < rank[pb]:\n\t\t(pa, pb) = (pb, pa)\n\tparent[pb] = pa\n\tsize[pa] += size[pb]\n\tif rank[pa] == rank[pb]:\n\t\trank[pa] += 1\nfor g in range(m):\n\trow = list(map(int, input().split()))[1:]\n\tfor x in row:\n\t\tunion(row[0] - 1, x - 1)\nresult = []\nfor i in range(n):\n\tpi = find(i)\n\tresult.append(str(size[pi]))\nprint(' '.join(result))\n"
    },
    {
        "task_id": 788,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.5714833736419678,
        "fastest_time": 2.564870595932007,
        "fastest_solution": "import sys\n__Verbose__ = 0\n\ndef main():\n\tsolve()\n\ndef print_header():\n\tprint_log('-------------------------------------------------------------')\n\tprint_log('-------------------- No unpaired chef -----------------------')\n\tprint_log('-------------------------------------------------------------')\n\ndef print_log(*input):\n\tif __Verbose__ == 1:\n\t\tprint(input)\n\ndef solve():\n\tnum_problems = int(input())\n\tfor num in range(num_problems):\n\t\tsolve_problem()\n\ndef solve_problem():\n\tnum_chefs = int(input())\n\tratings = [[0 for x in range(num_chefs)] for y in range(num_chefs)]\n\tfor num in range(num_chefs):\n\t\tratings[num] = get_chef_rating(num_chefs)\n\tif num_chefs == 1:\n\t\tif ratings[0][0] == 0:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(ratings[0][0])\n\t\treturn\n\t(mst, visited_nodes) = get_minimum_spanning_tree(ratings)\n\tif sum(visited_nodes) != len(visited_nodes):\n\t\tprint(-1)\n\telse:\n\t\tprint(get_sum_of_matrix(mst))\n\ndef get_chef_rating(numChefs):\n\tchefRating = list(map(int, input().split()))\n\tif len(chefRating) != numChefs:\n\t\traise ValueError(f'Expecting {numChefs} ratings; got {len(chefRating)}')\n\treturn chefRating\n\ndef check_ratings(ratings):\n\tnum_chefs = len(ratings)\n\tchef_a = 0\n\tfor chefRating in ratings:\n\t\tif len(chefRating) != num_chefs:\n\t\t\traise ValueError(f'Chef {chef_a} has not given rating to all chefs')\n\t\tfor chef_b in range(len(chefRating)):\n\t\t\tif ratings[chef_a][chef_b] != ratings[chef_b][chef_a]:\n\t\t\t\traise ValueError(f'Chef ratings is not symmetric {chef_a} {chef_b}')\n\t\t\tif ratings[chef_a][chef_b] < 0:\n\t\t\t\traise ValueError(f'Chef rating is not a non-negative integer {chef_a} {chef_b}')\n\t\tchef_a += 1\n\ndef get_minimum_spanning_tree(matrix):\n\tnum_nodes = len(matrix)\n\tmst = [[0 for x in range(num_nodes)] for y in range(num_nodes)]\n\tvisited_nodes = [0] * num_nodes\n\tnext_node = 0\n\tvisited_nodes[next_node] = 1\n\twhile next_node != -1:\n\t\t(prev_node, next_node) = pick_next_node(matrix, visited_nodes)\n\t\tif next_node != -1:\n\t\t\tmst[prev_node][next_node] = matrix[prev_node][next_node]\n\t\t\tmst[next_node][prev_node] = matrix[next_node][prev_node]\n\t\t\tvisited_nodes[next_node] = 1\n\treturn (mst, visited_nodes)\n\ndef pick_next_node(matrix, visited_nodes):\n\tmin_weight = sys.maxsize\n\tprev_node = -1\n\tnext_node = -1\n\tfor from_node in range(len(visited_nodes)):\n\t\tif visited_nodes[from_node] == 1:\n\t\t\tfor to_node in range(len(visited_nodes)):\n\t\t\t\tif from_node != to_node and visited_nodes[to_node] == 0:\n\t\t\t\t\tweight = matrix[from_node][to_node]\n\t\t\t\t\tif weight != 0 and weight < min_weight:\n\t\t\t\t\t\tmin_weight = matrix[from_node][to_node]\n\t\t\t\t\t\tprev_node = from_node\n\t\t\t\t\t\tnext_node = to_node\n\treturn (prev_node, next_node)\n\ndef get_sum_of_matrix(matrix):\n\tsum = 0\n\tfor row in matrix:\n\t\tfor num in row:\n\t\t\tsum += num\n\treturn sum\nmain()\n",
        "slowest_solution": "import sys\n\nclass Solver:\n\n\tdef __init__(self, num_chefs):\n\t\tself.num_chefs = num_chefs\n\t\tself.ratings = [[0 for x in range(num_chefs)] for y in range(num_chefs)]\n\t\tself.mst = [[0 for x in range(num_chefs)] for y in range(num_chefs)]\n\t\tself.visited_nodes = [0 for x in range(num_chefs)]\n\t\tself.answer = -1\n\n\tdef read_ratings(self):\n\t\tfor num in range(self.num_chefs):\n\t\t\tself.ratings[num] = list(map(int, input().split()))\n\n\tdef check_ratings(self):\n\t\tchef_a = 0\n\t\tfor chefRating in self.ratings:\n\t\t\tif len(chefRating) != self.num_chefs:\n\t\t\t\traise ValueError(f'Chef {chef_a} has not given rating to all chefs')\n\t\t\tfor chef_b in range(len(chefRating)):\n\t\t\t\tif self.ratings[chef_a][chef_b] != self.ratings[chef_b][chef_a]:\n\t\t\t\t\traise ValueError(f'Chef ratings is not symmetric {chef_a} {chef_b}')\n\t\t\t\tif self.ratings[chef_a][chef_b] < 0:\n\t\t\t\t\traise ValueError(f'Chef rating is not a non-negative integer {chef_a} {chef_b}')\n\t\t\tchef_a += 1\n\n\tdef solve(self):\n\t\tself.answer = -1\n\t\tif self.num_chefs == 1:\n\t\t\tif self.ratings[0][0] != 0:\n\t\t\t\tself.answer = self.ratings[0][0]\n\t\t\treturn\n\t\tself.find_minimum_spanning_tree()\n\t\tif sum(self.visited_nodes) == len(self.visited_nodes):\n\t\t\tself.answer = self.get_sum_of_mst()\n\n\tdef find_minimum_spanning_tree(self):\n\t\tnext_node = 0\n\t\tself.visited_nodes[next_node] = 1\n\t\twhile next_node != -1:\n\t\t\t(prev_node, next_node) = self.pick_next_node()\n\t\t\tif next_node != -1:\n\t\t\t\tself.mst[prev_node][next_node] = self.ratings[prev_node][next_node]\n\t\t\t\tself.mst[next_node][prev_node] = self.ratings[next_node][prev_node]\n\t\t\t\tself.visited_nodes[next_node] = 1\n\n\tdef pick_next_node(self):\n\t\tmin_weight = sys.maxsize\n\t\tprev_node = -1\n\t\tnext_node = -1\n\t\tfor from_node in range(self.num_chefs):\n\t\t\tif self.visited_nodes[from_node] == 1:\n\t\t\t\tfor to_node in range(self.num_chefs):\n\t\t\t\t\tif from_node != to_node and self.visited_nodes[to_node] == 0:\n\t\t\t\t\t\tweight = self.ratings[from_node][to_node]\n\t\t\t\t\t\tif weight != 0 and weight < min_weight:\n\t\t\t\t\t\t\tmin_weight = weight\n\t\t\t\t\t\t\tprev_node = from_node\n\t\t\t\t\t\t\tnext_node = to_node\n\t\treturn (prev_node, next_node)\n\n\tdef get_sum_of_mst(self):\n\t\tsum = 0\n\t\tfor row in self.mst:\n\t\t\tfor num in row:\n\t\t\t\tsum += num\n\t\treturn sum\n\n\tdef write_answer(self):\n\t\tprint(self.answer)\n\ndef main():\n\tsolve()\n\ndef solve():\n\tnum_problems = int(input())\n\tfor num in range(num_problems):\n\t\tsolve_problem()\n\ndef solve_problem():\n\tnum_chefs = int(input())\n\ts = Solver(num_chefs)\n\ts.read_ratings()\n\ts.solve()\n\ts.write_answer()\nmain()\n"
    },
    {
        "task_id": 756,
        "slowest_solution_id": 2,
        "fastest_solution_id": 5,
        "slowest_time": 3.219672679901123,
        "fastest_time": 2.4365382194519043,
        "fastest_solution": "import sys\nnumbers=dict()\nnumbers={1:2,2:5,3:5,4:4,5:5,6:6,7:3,8:7,9:6,0:6}\nt=input()\ntotal=0\nfor i in t:\n\tif int(i) in numbers:\n\t\ttotal=total+numbers[int(i)]\n\t\t\nprint(total)\n\t\t\n",
        "slowest_solution": "stri=input()\nval=\"6255456376\"\nsum=0\nfor i in range(0,len(stri)):\n\tsum+=int(val[int(stri[i])])\nprint(sum)\n"
    },
    {
        "task_id": 800,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.505189895629883,
        "fastest_time": 2.505189895629883,
        "fastest_solution": "from math import pi\nfrom cmath import exp\n\ndef fft(a, lgN, rot=1):\n\tN = 1 << lgN\n\tassert len(a) == N\n\trev = [0] * N\n\tfor i in range(N):\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (N >> 1)\n\tA = [a[rev[i]] for i in range(N)]\n\th = 1\n\twhile h < N:\n\t\tw_m = exp((0 + 1j) * rot * (pi / h))\n\t\tfor k in range(0, N, h << 1):\n\t\t\tw = 1\n\t\t\tfor j in range(h):\n\t\t\t\tt = w * A[k + j + h]\n\t\t\t\tA[k + j + h] = A[k + j] - t\n\t\t\t\tA[k + j] = A[k + j] + t\n\t\t\t\tw *= w_m\n\t\th = h << 1\n\treturn A if rot == 1 else [x / N for x in A]\nimport sys\nints = (int(x) for x in sys.stdin.read().split())\n(n, x) = (next(ints) for i in range(2))\nr = [next(ints) for i in range(n)]\nac = [0] * (n + 1)\nfor i in range(n):\n\tac[i + 1] = (r[i] < x) + ac[i]\n(min_A, min_B) = (0, -ac[-1])\n(max_A, max_B) = (ac[-1], 0)\n(N, lgN, m) = (1, 0, 2 * max(max_A - min_A + 1, max_B - min_B + 1))\nwhile N < m:\n\t(N, lgN) = (N << 1, lgN + 1)\n(a, b) = ([0] * N, [0] * N)\nfor x in ac:\n\ta[x - min_A] += 1\n\tb[-x - min_B] += 1\nc = zip(fft(a, lgN), fft(b, lgN))\nc = fft([x * y for (x, y) in c], lgN, rot=-1)\nc = [round(x.real) for x in c][-min_A - min_B:][:n + 1]\nc[0] = sum((x * (x - 1) // 2 for x in a))\nprint(*c, *(0 for i in range(n + 1 - len(c))), flush=True)\n",
        "slowest_solution": "from math import pi\nfrom cmath import exp\n\ndef fft(a, lgN, rot=1):\n\tN = 1 << lgN\n\tassert len(a) == N\n\trev = [0] * N\n\tfor i in range(N):\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (N >> 1)\n\tA = [a[rev[i]] for i in range(N)]\n\th = 1\n\twhile h < N:\n\t\tw_m = exp((0 + 1j) * rot * (pi / h))\n\t\tfor k in range(0, N, h << 1):\n\t\t\tw = 1\n\t\t\tfor j in range(h):\n\t\t\t\tt = w * A[k + j + h]\n\t\t\t\tA[k + j + h] = A[k + j] - t\n\t\t\t\tA[k + j] = A[k + j] + t\n\t\t\t\tw *= w_m\n\t\th = h << 1\n\treturn A if rot == 1 else [x / N for x in A]\nimport sys\nints = (int(x) for x in sys.stdin.read().split())\n(n, x) = (next(ints) for i in range(2))\nr = [next(ints) for i in range(n)]\nac = [0] * (n + 1)\nfor i in range(n):\n\tac[i + 1] = (r[i] < x) + ac[i]\n(min_A, min_B) = (0, -ac[-1])\n(max_A, max_B) = (ac[-1], 0)\n(N, lgN, m) = (1, 0, 2 * max(max_A - min_A + 1, max_B - min_B + 1))\nwhile N < m:\n\t(N, lgN) = (N << 1, lgN + 1)\n(a, b) = ([0] * N, [0] * N)\nfor x in ac:\n\ta[x - min_A] += 1\n\tb[-x - min_B] += 1\nc = zip(fft(a, lgN), fft(b, lgN))\nc = fft([x * y for (x, y) in c], lgN, rot=-1)\nc = [round(x.real) for x in c][-min_A - min_B:][:n + 1]\nc[0] = sum((x * (x - 1) // 2 for x in a))\nprint(*c, *(0 for i in range(n + 1 - len(c))), flush=True)\n"
    },
    {
        "task_id": 803,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.503343343734741,
        "fastest_time": 2.503343343734741,
        "fastest_solution": "(a, b) = map(int, input().split())\nif a == 3 and b == 2:\n\tprint(2)\nelif a == 4 and b == 10:\n\tprint(12)\nelif a == 13 and b == 37:\n\tprint(27643508)\nelif a == 1337 and b == 42:\n\tprint(211887828)\nelif a == 198756 and b == 123456:\n\tprint(159489391)\nelif a == 123456 and b == 198756:\n\tprint(460526614)\nelif a == 200000 and b == 199999:\n\tprint(271480816)\nelif a == 199999 and b == 200000:\n\tprint(873716273)\nelif a == 1 and b == 1:\n\tprint(1)\nelif a == 1 and b == 5:\n\tprint(1)\nelif a == 1 and b == 200000:\n\tprint(1)\nelif a == 5 and b == 1:\n\tprint(1)\nelif a == 200000 and b == 1:\n\tprint(1)\nelif a == 199999 and b == 199999:\n\tprint(873716273)\nelif a == 198654 and b == 189954:\n\tprint(75960792)\nelif a == 199562 and b == 200000:\n\tprint(261864171)\nelif a == 200000 and b == 200000:\n\tprint(271480817)\n",
        "slowest_solution": "(a, b) = map(int, input().split())\nif a == 3 and b == 2:\n\tprint(2)\nelif a == 4 and b == 10:\n\tprint(12)\nelif a == 13 and b == 37:\n\tprint(27643508)\nelif a == 1337 and b == 42:\n\tprint(211887828)\nelif a == 198756 and b == 123456:\n\tprint(159489391)\nelif a == 123456 and b == 198756:\n\tprint(460526614)\nelif a == 200000 and b == 199999:\n\tprint(271480816)\nelif a == 199999 and b == 200000:\n\tprint(873716273)\nelif a == 1 and b == 1:\n\tprint(1)\nelif a == 1 and b == 5:\n\tprint(1)\nelif a == 1 and b == 200000:\n\tprint(1)\nelif a == 5 and b == 1:\n\tprint(1)\nelif a == 200000 and b == 1:\n\tprint(1)\nelif a == 199999 and b == 199999:\n\tprint(873716273)\nelif a == 198654 and b == 189954:\n\tprint(75960792)\nelif a == 199562 and b == 200000:\n\tprint(261864171)\nelif a == 200000 and b == 200000:\n\tprint(271480817)\n"
    },
    {
        "task_id": 759,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 3.0556280612945557,
        "fastest_time": 2.5180165767669678,
        "fastest_solution": "n = int(input()) % 360\nv1 = n // 90\nv2 = v1 + 1\nif v2 < 4:\n\tif n - 90 * v1 > 90 * v2 - n:\n\t\tprint(v2)\n\telse:\n\t\tprint(v1)\nelif n - 90 * v1 < 360 - n:\n\tprint(v1)\nelse:\n\tprint('0')\n",
        "slowest_solution": "def sign(x):\n\treturn 1 if x > 0 else -1\n\ndef dis(x):\n\tif x >= 360:\n\t\tx %= 360\n\tif x <= -180:\n\t\treturn 360 + x\n\telif x <= 0:\n\t\treturn abs(x)\n\telif x <= 180:\n\t\treturn x\n\telse:\n\t\treturn 360 - x\n\ndef __starting_point():\n\tx = int(input())\n\tx = -sign(x) * (abs(x) % 360)\n\tmindis = dis(x)\n\tres = 0\n\tfor i in range(1, 4):\n\t\tnewdis = dis(x + 90 * i)\n\t\tif newdis < mindis:\n\t\t\tmindis = newdis\n\t\t\tres = i\n\tprint(res)\n__starting_point()\n"
    },
    {
        "task_id": 761,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.960761308670044,
        "fastest_time": 2.5111043453216553,
        "fastest_solution": "import sys\nl = int(input())\narr = list(map(int, input().split()))\narr.sort()\nif arr[0] != arr[1] and arr[1] != arr[2] or (arr[0] == arr[1] and arr[1] != arr[2]):\n\tprint(arr.count(arr[2]))\nelif arr[0] != arr[1] and arr[1] == arr[2]:\n\tn = arr.count(arr[1])\n\tprint(int(n * (n - 1) / 2))\nelif arr[0] == arr[1] == arr[2]:\n\tn = arr.count(arr[0])\n\tprint(int(n * (n - 1) * (n - 2) / 6))\n",
        "slowest_solution": "n = int(input())\nai = list(map(int, input().split()))\nai.sort()\ni = ai[0]\nj = ai[1]\nk = ai[2]\nans = 0\nfor num in range(2, n):\n\tif k == ai[num]:\n\t\tans += 1\nif j == k:\n\tif i == j:\n\t\tnum2 = ans\n\t\tans = 0\n\t\tfor num in range(1, num2 + 2):\n\t\t\tans += num * (num - 1) // 2\n\telse:\n\t\tans = ans * (ans + 1) // 2\nprint(ans)\n"
    },
    {
        "task_id": 762,
        "slowest_solution_id": 1,
        "fastest_solution_id": 7,
        "slowest_time": 3.053575038909912,
        "fastest_time": 2.5335710048675537,
        "fastest_solution": "import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nfrom collections import defaultdict\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nn = int(input())\ns = list(input())\ns = [int(s[i]) for i in range(n)]\nans = 0\nfor i in range(n):\n\tif i % 2 == 0:\n\t\tans += s[i]\n\telse:\n\t\tans += 1 - s[i]\nm = ans\nans = 0\nfor i in range(n):\n\tif i % 2 == 0:\n\t\tans += 1 - s[i]\n\telse:\n\t\tans += s[i]\nprint(min(m, ans))\n",
        "slowest_solution": "n = int(input())\nstripe = list(input())\nfor i in range(n):\n\tstripe[i] = int(stripe[i])\nw = 0\nb = 0\nfor i in range(n):\n\tif i % 2 == stripe[i] - 0:\n\t\tw += 1\n\telse:\n\t\tb += 1\nanswer = min(w, b)\nprint(answer)\n"
    },
    {
        "task_id": 763,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 3.011364698410034,
        "fastest_time": 2.497943162918091,
        "fastest_solution": "t = int(input())\nfor i in range(t):\n\tb = []\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tfor i in range(0, len(a) - k + 1):\n\t\tb.append(sum(a[i:i + k]))\n\tprint(max(b))\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tmax1 = 0\n\tfor i in range(n - 1):\n\t\tif sum(a[i:i + k]) > max1:\n\t\t\tmax1 = sum(a[i:i + k])\n\tprint(max1)\n"
    },
    {
        "task_id": 802,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.600203275680542,
        "fastest_time": 2.48310923576355,
        "fastest_solution": "class Edge:\n\n\tdef __init__(self, to, cost, capacity, next_edge):\n\t\tself.to = to\n\t\tself.cost = cost\n\t\tself.origin_cost = cost\n\t\tself.capacity = capacity\n\t\tself.next_edge = next_edge\n\t\tself.pair = None\n\nclass MinCostMaxFlow:\n\n\tdef __init__(self, max_node):\n\t\tself.null = Edge(0, 0, 0, None)\n\t\tself.max_node = max_node + 3\n\t\tself.total_cost = 0\n\t\tself.current_cost = 0\n\t\tself.visited = [False] * self.max_node\n\t\tself.arc_list = []\n\t\tself.edge_head = [self.null] * self.max_node\n\t\tself.source = max_node + 1\n\t\tself.sink = max_node + 2\n\n\tdef AddArcWithCapacityAndUnitCost(self, start_node, end_node, capacity, cost):\n\t\tself.edge_head[start_node] = Edge(end_node, cost, capacity, self.edge_head[start_node])\n\t\tself.edge_head[end_node] = Edge(start_node, -cost, 0, self.edge_head[end_node])\n\t\tself.edge_head[start_node].pair = self.edge_head[end_node]\n\t\tself.edge_head[end_node].pair = self.edge_head[start_node]\n\t\tif start_node != self.source and start_node != self.sink and (end_node != self.source) and (end_node != self.sink):\n\t\t\tself.arc_list.append(self.edge_head[end_node])\n\n\tdef NumArcs(self):\n\t\treturn len(self.arc_list)\n\n\tdef Tail(self, index):\n\t\treturn self.arc_list[index].to\n\n\tdef Head(self, index):\n\t\treturn self.arc_list[index].pair.to\n\n\tdef UnitCost(self, index):\n\t\treturn self.arc_list[index].pair.origin_cost\n\n\tdef Flow(self, index):\n\t\treturn self.arc_list[index].capacity\n\n\tdef OptimalFlow(self):\n\t\tedge = self.edge_head[self.sink]\n\t\ttotal_flow = 0\n\t\twhile id(edge) != id(self.null):\n\t\t\ttotal_flow += edge.capacity\n\t\t\tedge = edge.next_edge\n\t\treturn total_flow\n\n\tdef OptimalCost(self):\n\t\treturn self.total_cost\n\n\tdef SetNodeSupply(self, node, supply):\n\t\tif supply > 0:\n\t\t\tself.AddArcWithCapacityAndUnitCost(self.source, node, supply, 0)\n\t\telif supply < 0:\n\t\t\tself.AddArcWithCapacityAndUnitCost(node, self.sink, -supply, 0)\n\n\tdef aug(self, node_id, total_flow):\n\t\tif node_id == self.sink:\n\t\t\tself.total_cost += self.current_cost * total_flow\n\t\t\treturn total_flow\n\t\tself.visited[node_id] = True\n\t\tflow = total_flow\n\t\tedge = self.edge_head[node_id]\n\t\twhile id(edge) != id(self.null):\n\t\t\tif edge.capacity > 0 and edge.cost == 0 and (not self.visited[edge.to]):\n\t\t\t\tdelta = self.aug(edge.to, min(flow, edge.capacity))\n\t\t\t\tedge.capacity -= delta\n\t\t\t\tedge.pair.capacity += delta\n\t\t\t\tflow -= delta\n\t\t\t\tif flow == 0:\n\t\t\t\t\treturn total_flow\n\t\t\tedge = edge.next_edge\n\t\treturn total_flow - flow\n\n\tdef modify_label(self):\n\t\tmin_cost = 1 << 63\n\t\tfor node_id in range(0, self.max_node):\n\t\t\tif not self.visited[node_id]:\n\t\t\t\tcontinue\n\t\t\tedge = self.edge_head[node_id]\n\t\t\twhile id(edge) != id(self.null):\n\t\t\t\tif edge.capacity > 0 and (not self.visited[edge.to]) and (edge.cost < min_cost):\n\t\t\t\t\tmin_cost = edge.cost\n\t\t\t\tedge = edge.next_edge\n\t\tif min_cost == 1 << 63:\n\t\t\treturn False\n\t\tfor node_id in range(0, self.max_node):\n\t\t\tif not self.visited[node_id]:\n\t\t\t\tcontinue\n\t\t\tedge = self.edge_head[node_id]\n\t\t\twhile id(edge) != id(self.null):\n\t\t\t\tedge.cost -= min_cost\n\t\t\t\tedge.pair.cost += min_cost\n\t\t\t\tedge = edge.next_edge\n\t\tself.current_cost += min_cost\n\t\treturn True\n\n\tdef Solve(self):\n\t\twhile True:\n\t\t\twhile True:\n\t\t\t\tself.visited = [False] * self.max_node\n\t\t\t\tif self.aug(self.source, 1 << 63) == 0:\n\t\t\t\t\tbreak\n\t\t\tif not self.modify_label():\n\t\t\t\tbreak\n\t\treturn self.total_cost\n\ndef main():\n\ts = input()\n\tn = int(input())\n\tsource = 0\n\tsink = n + 26 + 1\n\tmcmf = MinCostMaxFlow(n + 28)\n\tlength = len(s)\n\tnum = [0] * 29\n\tfor i in range(0, length):\n\t\tnum[ord(s[i]) - ord('a') + 1] += 1\n\tfor i in range(1, 27):\n\t\tif num[i] > 0:\n\t\t\tmcmf.AddArcWithCapacityAndUnitCost(i, sink, num[i], 0)\n\tfor i in range(1, n + 1):\n\t\t(s, used) = input().split(' ')\n\t\tmcmf.AddArcWithCapacityAndUnitCost(source, 26 + i, int(used), 0)\n\t\tnum = [0] * 29\n\t\tfor j in range(0, len(s)):\n\t\t\tnum[ord(s[j]) - ord('a') + 1] += 1\n\t\tfor j in range(1, 27):\n\t\t\tif num[j] > 0:\n\t\t\t\tmcmf.AddArcWithCapacityAndUnitCost(26 + i, j, num[j], i)\n\tmcmf.SetNodeSupply(source, 1 << 63)\n\tmcmf.SetNodeSupply(sink, -(1 << 63))\n\tmcmf.Solve()\n\tif mcmf.OptimalFlow() != length:\n\t\tprint('-1')\n\telse:\n\t\tprint(mcmf.OptimalCost())\n\ndef __starting_point():\n\tmain()\n__starting_point()\n",
        "slowest_solution": "from heapq import heappush, heappop\n\nclass MinCostFlow:\n\tINF = 10 ** 18\n\n\tdef __init__(self, N):\n\t\tself.N = N\n\t\tself.G = [[] for i in range(N)]\n\n\tdef add_edge(self, fr, to, cap, cost):\n\t\tG = self.G\n\t\tG[fr].append([to, cap, cost, len(G[to])])\n\t\tG[to].append([fr, 0, -cost, len(G[fr]) - 1])\n\n\tdef flow(self, s, t, f):\n\t\tN = self.N\n\t\tG = self.G\n\t\tINF = MinCostFlow.INF\n\t\tres = 0\n\t\tH = [0] * N\n\t\tprv_v = [0] * N\n\t\tprv_e = [0] * N\n\t\twhile f:\n\t\t\tdist = [INF] * N\n\t\t\tdist[s] = 0\n\t\t\tque = [(0, s)]\n\t\t\twhile que:\n\t\t\t\t(c, v) = heappop(que)\n\t\t\t\tif dist[v] < c:\n\t\t\t\t\tcontinue\n\t\t\t\tfor (i, (w, cap, cost, _)) in enumerate(G[v]):\n\t\t\t\t\tif cap > 0 and dist[w] > dist[v] + cost + H[v] - H[w]:\n\t\t\t\t\t\tdist[w] = r = dist[v] + cost + H[v] - H[w]\n\t\t\t\t\t\tprv_v[w] = v\n\t\t\t\t\t\tprv_e[w] = i\n\t\t\t\t\t\theappush(que, (r, w))\n\t\t\tif dist[t] == INF:\n\t\t\t\treturn -1\n\t\t\tfor i in range(N):\n\t\t\t\tH[i] += dist[i]\n\t\t\td = f\n\t\t\tv = t\n\t\t\twhile v != s:\n\t\t\t\td = min(d, G[prv_v[v]][prv_e[v]][1])\n\t\t\t\tv = prv_v[v]\n\t\t\tf -= d\n\t\t\tres += d * H[t]\n\t\t\tv = t\n\t\t\twhile v != s:\n\t\t\t\te = G[prv_v[v]][prv_e[v]]\n\t\t\t\te[1] -= d\n\t\t\t\tG[v][e[3]][1] += d\n\t\t\t\tv = prv_v[v]\n\t\treturn res\nT = input()\nneed = [0] * 30\nfor t in T:\n\tneed[ord(t) - ord('a')] += 1\nhave = [[0] * 30 for _ in range(110)]\nN = int(input())\na = [0] * 110\nfor i in range(N):\n\tv = input().split()\n\tS = v[0]\n\ta[i] = int(v[1])\n\tfor s in S:\n\t\thave[i][ord(s) - ord('a')] += 1\nV = 30 + N + 10\nflow = MinCostFlow(V)\nstart = 30 + N + 5\ntarget = 30 + N + 6\nfor c in range(26):\n\tflow.add_edge(start, c, need[c], 0)\n\tfor j in range(N):\n\t\tflow.add_edge(c, 30 + j, have[j][c], 0)\nfor i in range(N):\n\tflow.add_edge(30 + i, target, a[i], i + 1)\nans = flow.flow(start, target, len(T))\nprint(ans)\n"
    },
    {
        "task_id": 766,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 3.0945496559143066,
        "fastest_time": 2.4666266441345215,
        "fastest_solution": "t = int(input())\nwhile t > 0:\n\t(n, k) = map(int, input().split())\n\ts = input()\n\tif n == 1:\n\t\tprint(0)\n\telse:\n\t\tl = []\n\t\tc = 0\n\t\tst = 0\n\t\ten = 0\n\t\tif s[0] == '0':\n\t\t\tst = 1\n\t\tif s[-1] == '0':\n\t\t\ten = 1\n\t\tfor i in s:\n\t\t\tif i == '0':\n\t\t\t\tc += 1\n\t\t\telse:\n\t\t\t\tif c > 0:\n\t\t\t\t\tl.append(c)\n\t\t\t\tc = 0\n\t\tif c > 0:\n\t\t\tl.append(c)\n\t\tif len(l) == 0 or l[0] == n:\n\t\t\tprint(0)\n\t\telif len(l) == 1:\n\t\t\tif st == 1 or en == 1:\n\t\t\t\tif k >= 1:\n\t\t\t\t\tprint(0)\n\t\t\t\telse:\n\t\t\t\t\tprint(l[0])\n\t\t\telif k >= 2:\n\t\t\t\tprint(0)\n\t\t\telse:\n\t\t\t\tprint(l[0])\n\t\telif k % 2 == 0:\n\t\t\tif st == 1 and en == 1:\n\t\t\t\tl[0] = l[0] + l[-1]\n\t\t\t\tl.pop()\n\t\t\tl.sort()\n\t\t\tsu = 0\n\t\t\tfor i in range(len(l) - k // 2):\n\t\t\t\tsu += l[i]\n\t\t\tprint(su)\n\t\telse:\n\t\t\tif st == 1 and en == 1:\n\t\t\t\tif l[0] >= l[-1]:\n\t\t\t\t\tl = l[1:]\n\t\t\t\telse:\n\t\t\t\t\tl.pop()\n\t\t\telif st == 1:\n\t\t\t\tdel l[0]\n\t\t\telif en == 1:\n\t\t\t\tl.pop()\n\t\t\tl.sort()\n\t\t\tsu = 0\n\t\t\tfor i in range(len(l) - (k - 1) // 2):\n\t\t\t\tsu += l[i]\n\t\t\tprint(su)\n\tt -= 1\n",
        "slowest_solution": "import heapq as hp\n\ndef solve(heap, k):\n\tli = heap.copy()\n\ts = 0\n\twhile k >= 2 and len(li) > 0:\n\t\ts += hp.heappop(li)\n\t\tk -= 2\n\treturn -s\nfor _ in range(int(input())):\n\t(n, k) = map(int, input().strip().split())\n\ts = input()\n\tzeros = 0\n\tfor ch in s:\n\t\tif ch == '0':\n\t\t\tzeros += 1\n\tif k < 1:\n\t\tprint(zeros)\n\t\tcontinue\n\tl = 0\n\twhile l < n and s[l] == '0':\n\t\tl += 1\n\tr = n - 1\n\twhile r >= 0 and s[r] == '0':\n\t\tr -= 1\n\tif k < 2:\n\t\tprint(zeros - max(l, n - r - 1))\n\t\tcontinue\n\theap = []\n\tcnt = 0\n\tfor i in range(l, r + 1):\n\t\tif s[i] == '0':\n\t\t\tcnt -= 1\n\t\tif s[i] == '1' and cnt < 0:\n\t\t\thp.heappush(heap, cnt)\n\t\t\tcnt = 0\n\tx = solve(heap, k)\n\ty = solve(heap, k - 1)\n\tz = solve(heap, k - 2)\n\tans = max(x, l + y, n - r - 1 + y, l + n - r - 1 + z)\n\tprint(zeros - ans)\n"
    },
    {
        "task_id": 786,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.6128487586975098,
        "fastest_time": 2.529268741607666,
        "fastest_solution": "from collections import deque\nimport sys\n(n, m) = input().split(' ')\n(n, m) = (int(n), int(m))\nstarts = [int(x) for x in input().split(' ')]\nends = [int(x) for x in input().split(' ')]\nnum_soldiers = sum(ends)\nif sum(starts) != sum(ends):\n\tprint('NO')\n\tsys.exit()\nf_size = 2 + 2 * n\nflow_matrix = [[0] * f_size for _ in range(f_size)]\nedge_list = [[] for _ in range(f_size)]\n\ndef get_index(i, is_start):\n\tif is_start:\n\t\treturn 2 + i\n\telse:\n\t\treturn 2 + n + i\nfor i in range(n):\n\tflow_matrix[0][get_index(i, True)] = starts[i]\n\tflow_matrix[get_index(i, False)][1] = ends[i]\n\tflow_matrix[get_index(i, True)][get_index(i, False)] = num_soldiers\nfor i in range(m):\n\tends = input().split(' ')\n\t(a, b) = (int(ends[0]), int(ends[1]))\n\ta -= 1\n\tb -= 1\n\tflow_matrix[get_index(a, True)][get_index(b, False)] = num_soldiers\n\tflow_matrix[get_index(b, True)][get_index(a, False)] = num_soldiers\nflow_matrix_copy = [x.copy() for x in flow_matrix]\nfor i in range(f_size):\n\tfor j in range(f_size):\n\t\tif flow_matrix[i][j] != 0 or flow_matrix[j][i] != 0:\n\t\t\tedge_list[i].append(j)\n\ndef run_bfs(m):\n\tparent = [None for _ in range(len(m))]\n\tflow_from_s = [None for _ in range(len(m))]\n\tq = deque([])\n\tq.append(0)\n\tparent[0] = 0\n\tflow_from_s[0] = 2 ** 20\n\tfound_target = False\n\tt = 1\n\twhile len(q) > 0 and (not found_target):\n\t\tfront = q.popleft()\n\t\tfor neighbor in edge_list[front]:\n\t\t\tif flow_matrix[front][neighbor] > 0 and parent[neighbor] is None:\n\t\t\t\tparent[neighbor] = front\n\t\t\t\tflow_from_s[neighbor] = min(flow_from_s[front], flow_matrix[front][neighbor])\n\t\t\t\tq.append(neighbor)\n\t\t\t\tif neighbor == t:\n\t\t\t\t\tfound_target = True\n\t\t\t\t\tbreak\n\tif not found_target:\n\t\treturn 0\n\tcur = t\n\tflow = flow_from_s[t]\n\twhile parent[cur] != cur:\n\t\tprev = parent[cur]\n\t\tflow_matrix[prev][cur] -= flow\n\t\tflow_matrix[cur][prev] += flow\n\t\tcur = prev\n\treturn flow\n\ndef run_flow(m):\n\ttotal_flow = 0\n\twhile True:\n\t\tflow = run_bfs(m)\n\t\ttotal_flow += flow\n\t\tif flow == 0:\n\t\t\tbreak\n\treturn total_flow\nif run_flow(flow_matrix) == num_soldiers:\n\tprint('YES')\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tnum_along = flow_matrix_copy[get_index(i, True)][get_index(j, False)] - flow_matrix[get_index(i, True)][get_index(j, False)]\n\t\t\tprint(str(num_along), end=' ')\n\t\tprint('')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "import sys\n\ndef BFS(parent, graph, source, sink):\n\tvisited = [False] * len(parent)\n\tqueue = []\n\tqueue.append(source)\n\tvisited[source] = True\n\twhile queue:\n\t\tcurrNode = queue.pop(0)\n\t\tfor nextNode in range(len(parent)):\n\t\t\tif visited[nextNode] == False and graph[currNode][nextNode] > 0:\n\t\t\t\tif nextNode == sink:\n\t\t\t\t\tparent[nextNode] = currNode\n\t\t\t\t\treturn True\n\t\t\t\tqueue.append(nextNode)\n\t\t\t\tvisited[nextNode] = True\n\t\t\t\tparent[nextNode] = currNode\n\treturn False\n\ndef fordFulkerson(graph, source, sink):\n\tparent = [-1] * len(graph)\n\tmaxFlow = 0\n\twhile BFS(parent, graph, source, sink):\n\t\tcurrFlow = float('Inf')\n\t\tnode = sink\n\t\twhile node != 0:\n\t\t\tcurrFlow = min(currFlow, graph[parent[node]][node])\n\t\t\tnode = parent[node]\n\t\tmaxFlow += currFlow\n\t\tnode = sink\n\t\twhile node != 0:\n\t\t\tprevNode = parent[node]\n\t\t\tgraph[prevNode][node] -= currFlow\n\t\t\tgraph[node][prevNode] += currFlow\n\t\t\tnode = parent[node]\n\treturn maxFlow\n\ndef printGraph(graph, nodes):\n\tg = [[0 for c in range(nodes)] for r in range(nodes)]\n\tfor n in range(1, nodes + 1):\n\t\tcurrNode = n + nodes\n\t\tnum = 0\n\t\tfor prevNode in range(len(graph[currNode]) - 1):\n\t\t\tcap = graph[currNode][prevNode]\n\t\t\tif cap > 0:\n\t\t\t\tg[prevNode - 1][n - 1] = cap\n\tstringGraph = ''\n\tfor r in range(nodes):\n\t\tnum = 0\n\t\tfor c in range(nodes):\n\t\t\tprint(g[r][c], end=' ')\n\t\tprint()\n\treturn stringGraph\n(nodes, edges) = sys.stdin.readline().split()\ninputCap = sys.stdin.readline().split()\noutputCap = sys.stdin.readline().split()\nnodes = int(nodes)\nedges = int(edges)\ntotalInput = sum((int(i) for i in inputCap))\ntotalOutput = sum((int(i) for i in outputCap))\nif totalInput != totalOutput:\n\tprint('NO')\nelse:\n\tgraph = [[0 for c in range(nodes * 2 + 2)] for r in range(nodes * 2 + 2)]\n\tfor i in range(len(inputCap)):\n\t\tcap = int(inputCap[i])\n\t\tgraph[0][i + 1] = cap\n\t\tgraph[i + 1][i + 1 + nodes] = cap\n\tfor i in range(1, len(outputCap) + 1):\n\t\tcap = int(outputCap[i - 1])\n\t\tgraph[i + nodes][nodes * 2 + 1] = cap\n\tfor i in range(edges):\n\t\t(u, v) = sys.stdin.readline().split()\n\t\tu = int(u)\n\t\tv = int(v)\n\t\tgraph[u][v + nodes] = int(inputCap[u - 1])\n\t\tgraph[v][u + nodes] = int(inputCap[v - 1])\n\tsource = 0\n\tsink = nodes * 2 + 1\n\tactual = fordFulkerson(graph, source, sink)\n\tif actual == totalOutput:\n\t\tprint('YES')\n\t\tprintGraph(graph, nodes)\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 770,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 2.9510700702667236,
        "fastest_time": 2.47825026512146,
        "fastest_solution": "import bisect\n\ndef func(N, A):\n\ti = 0\n\ts = 0\n\tans = 0\n\tfor i in range(N - 2):\n\t\tk = i + 1\n\t\tfor j in range(i + 2, N):\n\t\t\tmid = (A[j] + A[i]) // 2\n\t\t\twhile k < j - 1 and abs(A[k + 1] - mid) <= abs(A[k] - mid):\n\t\t\t\tk += 1\n\t\t\tans += (A[k] - A[i]) * (A[j] - A[k])\n\treturn ans\nT = int(input())\nfor i in range(T):\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tprint(func(N, A))\n",
        "slowest_solution": "def compute(A):\n\tans = 0\n\tN = len(A)\n\tfor i in range(N):\n\t\tk = i + 1\n\t\tfor j in range(i + 2, N):\n\t\t\tmid = (A[i] + A[j]) / 2\n\t\t\twhile k < j - 1 and abs(A[k + 1] - mid) <= abs(A[k] - mid):\n\t\t\t\tk += 1\n\t\t\tans += (A[k] - A[i]) * (A[j] - A[k])\n\treturn ans\nT = int(input())\nfor i in range(T):\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tprint(compute(A))\n"
    },
    {
        "task_id": 777,
        "slowest_solution_id": 6,
        "fastest_solution_id": 7,
        "slowest_time": 2.9288530349731445,
        "fastest_time": 2.4829084873199463,
        "fastest_solution": "from collections import deque\nimport sys\nfrom array import array\nimport typing as Tp\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\n\ndef get_primes(n: int):\n\tfrom itertools import chain\n\tprimes = [2, 3]\n\tis_prime = array('b', (0, 0, 1, 1, 0, 1, 0)) + array('b', (1, 0, 0, 0, 1, 0)) * ((n - 1) // 6)\n\tfor i in chain.from_iterable((range(5, n + 1, 6), range(7, n + 1, 6))):\n\t\tif is_prime[i]:\n\t\t\tprimes.append(i)\n\t\t\tfor j in range(i * 3, n + 1, i * 2):\n\t\t\t\tis_prime[j] = 0\n\treturn (is_prime, primes)\n\ndef solve(adj, start, p, visited, a):\n\tdq = deque([start])\n\tvisited[start] = 1\n\tleaf = start\n\twhile dq:\n\t\tleaf = v = dq.popleft()\n\t\tfor dest in adj[v]:\n\t\t\tif visited[dest] == 0 and (a[dest] % p == 0 if p > 0 else a[dest] == -p):\n\t\t\t\tvisited[dest] = 1\n\t\t\t\tdq.append(dest)\n\tdq = deque([(leaf, 1)])\n\tvisited[leaf] = 2\n\twhile dq:\n\t\t(v, res) = dq.popleft()\n\t\tfor dest in adj[v]:\n\t\t\tif visited[dest] == 1 and (a[dest] % p == 0 if p > 0 else a[dest] == -p):\n\t\t\t\tvisited[dest] = 2\n\t\t\t\tdq.append((dest, res + 1))\n\treturn res\n\ndef main():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tadj = [[] for _ in range(n)]\n\tfor (u, v) in (map(int, input().split()) for _ in range(n - 1)):\n\t\tadj[u - 1].append(v - 1)\n\t\tadj[v - 1].append(u - 1)\n\tans = 0\n\t(_, primes) = get_primes(448)\n\tfor p in primes:\n\t\tvisited = [0] * n\n\t\tfor i in range(n):\n\t\t\tif visited[i] or a[i] % p:\n\t\t\t\tcontinue\n\t\t\tans = max(ans, solve(adj, i, p, visited, a))\n\tvisited = [0] * n\n\tfor i in range(n):\n\t\tif visited[i] or a[i] == 1:\n\t\t\tcontinue\n\t\tans = max(ans, solve(adj, i, -a[i], visited, a))\n\tprint(ans)\nmain()\n",
        "slowest_solution": "from sys import stdin, stdout\nfrom math import *\nfrom heapq import *\nfrom collections import *\ndv = list(range(200002))\nfor i in range(2, 200002):\n\tif i * i >= 200002:\n\t\tbreak\n\tif dv[i] == i:\n\t\tj = i\n\t\twhile i * j < 200002:\n\t\t\tdv[i * j] = i\n\t\t\tj = j + 1\n\ndef loPr(x):\n\tglobal dv\n\tif x <= 1:\n\t\treturn []\n\tret = []\n\twhile x > 1:\n\t\td = dv[x]\n\t\tret.append(d)\n\t\twhile x % d == 0:\n\t\t\tx = trunc(x / d)\n\treturn ret\n\ndef main():\n\tglobal dv\n\tn = int(stdin.readline())\n\ta = [0] + [int(x) for x in stdin.readline().split()]\n\te = []\n\tfor _ in range(n + 2):\n\t\te.append([])\n\tfor _ in range(n - 1):\n\t\t(u, v) = [int(x) for x in stdin.readline().split()]\n\t\te[u].append(v)\n\t\te[v].append(u)\n\tpre = [0] * (n + 2)\n\tq = [1]\n\td = [False] * (n + 2)\n\td[1] = True\n\tpre[1] = 1\n\ti = 0\n\twhile i < len(q):\n\t\tu = q[i]\n\t\tfor v in e[u]:\n\t\t\tif d[v] == False:\n\t\t\t\td[v] = True\n\t\t\t\tpre[v] = u\n\t\t\t\tq.append(v)\n\t\ti = i + 1\n\tf = [dict()]\n\tfor _ in range(n + 2):\n\t\tf.append(dict())\n\tb = [[]]\n\tfor i in range(1, n + 1):\n\t\tb.append(loPr(a[i]))\n\t\tfor p in b[i]:\n\t\t\tf[i][p] = [1]\n\tq.reverse()\n\tres = 0\n\tfor u in q:\n\t\tnxt = pre[u]\n\t\tfor p in b[u]:\n\t\t\tfp = f[u].get(p, [1])\n\t\t\tfp.sort()\n\t\t\tres = max(res, fp[-1])\n\t\t\tif len(fp) >= 2:\n\t\t\t\tres = max(res, fp[-1] + fp[-2] - 1)\n\t\t\tfnxt = f[nxt].get(p, None)\n\t\t\tif fnxt != None:\n\t\t\t\tfnxt.append(max(1, fp[-1]) + 1)\n\tstdout.write(str(res))\n\treturn 0\nmain()\n"
    },
    {
        "task_id": 771,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.7664880752563477,
        "fastest_time": 2.451220989227295,
        "fastest_solution": "import sys\nN = int(sys.stdin.readline())\nA = list(map(int, sys.stdin.readline().split()))\nmax_product = product = sum(((i + 1) * a for (i, a) in enumerate(A)))\ntotal = sum(A)\nfor i in range(N):\n\tproduct += total - N * A[-i - 1]\n\tmax_product = max(max_product, product)\nprint(max_product)\n",
        "slowest_solution": "n = int(input())\na = list(map(int, input().split()))\nsum_a = sum(a)\ncur_val = ans = sum((a[i] * (i + 1) for i in range(n)))\nfor i in range(n):\n\tcur_val = cur_val - sum_a + a[i] * n\n\tans = max(ans, cur_val)\nprint(ans)\n"
    },
    {
        "task_id": 780,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 2.6656715869903564,
        "fastest_time": 2.387059450149536,
        "fastest_solution": "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef dfs(no, par=-1, l=1):\n\tst = False\n\tma = 0\n\tfor i in adj[no]:\n\t\tif i != par:\n\t\t\tst = True\n\t\t\ta = dfs(i, no, l + 1)\n\t\t\tma = max(ma, a + 1)\n\tif st == False:\n\t\treturn 0\n\tlev[no] = ma\n\treturn lev[no]\nt = int(input())\nfor _ in range(t):\n\t(n, k) = map(int, input().split())\n\tadj = [set() for i in range(n)]\n\tfor __ in range(n - 1):\n\t\t(a, b) = map(int, input().split())\n\t\tadj[a - 1].add(b - 1)\n\t\tadj[b - 1].add(a - 1)\n\tvis = [0] * n\n\tvis[0] = 1\n\tlev = [0 for i in range(n)]\n\tdp = [0] * n\n\tdfs(0)\n\tss = {}\n\tfor i in lev:\n\t\ttry:\n\t\t\tss[i] += 1\n\t\texcept:\n\t\t\tss[i] = 1\n\ttt = [i for i in ss]\n\ttt.sort(reverse=False)\n\tind = 0\n\ttot = 0\n\tco = 0\n\twhile co < k and ind < len(tt):\n\t\ttot += ss[tt[ind]]\n\t\tind += 1\n\t\tco += 1\n\tprint(tot)\n",
        "slowest_solution": "from collections import deque\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(1000000)\nfor _ in range(int(input())):\n\t(N, K) = list(map(int, input().split()))\n\tchildnodes = defaultdict(lambda : [])\n\tfor i in range(N - 1):\n\t\t(u, v) = list(map(int, input().split()))\n\t\tchildnodes[u - 1].append(v - 1)\n\t\tchildnodes[v - 1].append(u - 1)\n\tarr = [0] * N\n\n\tdef dfs(node, arr, prev, childnodes):\n\t\tif node not in childnodes:\n\t\t\tarr[node] = 1\n\t\t\treturn 1\n\t\tmx = 0\n\t\tfor i in childnodes[node]:\n\t\t\tif i != prev:\n\t\t\t\tmx = max(dfs(i, arr, node, childnodes), mx)\n\t\tarr[node] = mx + 1\n\t\treturn mx + 1\n\ttry:\n\t\tdfs(0, arr, 0, childnodes)\n\texcept:\n\t\tpass\n\tans = [0] * (N + 1)\n\tfor i in range(N):\n\t\ttry:\n\t\t\tans[arr[i]] += 1\n\t\texcept:\n\t\t\tpass\n\tfor i in range(1, len(ans)):\n\t\tans[i] = ans[i] + ans[i - 1]\n\tprint(ans[K])\n"
    },
    {
        "task_id": 815,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.5835111141204834,
        "fastest_time": 2.401233673095703,
        "fastest_solution": "(N, M) = map(int, input().split())\nA = []\nfor i in range(N):\n\tA.append(input())\nQ = []\nfor i in range(M):\n\t(l, r, v) = input().split()\n\tQ.append((int(l), int(r), v))\nimport random\n\ndef genInput(N, M, large=False):\n\tif large:\n\t\tA = ['1' + ''.join(['1' if random.randint(0, 10) > 4 else '0' for _ in range(random.randint(1000 if i < 10 else 1, 2000 if i < 10 else 20))]) for i in range(N)]\n\t\tQ = []\n\t\tfor i in range(M):\n\t\t\tl = random.randint(1, N // 2)\n\t\t\tr = random.randint(l, N)\n\t\t\tv = '1' + ''.join(['1' if random.randint(0, 10) > 4 else '0' for _ in range(random.randint(1000 if i < 10 else 1, 20000 if i < 10 else 20))])\n\t\t\tQ.append((l, r, v))\n\t\treturn (N, M, A, Q)\n\telse:\n\t\tA = ['1' + ''.join(['1' if random.randint(0, 10) > 4 else '0' for _ in range(1, random.randint(1, 20))]) for _ in range(N)]\n\t\tQ = []\n\t\tfor i in range(M):\n\t\t\tl = random.randint(1, N // 2)\n\t\t\tr = random.randint(l, N)\n\t\t\tv = '1' + ''.join(['1' if random.randint(0, 10) > 4 else '0' for _ in range(random.randint(1, 20))])\n\t\t\tQ.append((l, r, v))\n\t\treturn (N, M, A, Q)\ntree = {'c': [], 'v': [], 'vl': 0}\n\ndef compressStr(num, maxLen):\n\tans = []\n\tln = len(num)\n\tif ln < maxLen:\n\t\tans.append((maxLen - ln, '0'))\n\telif ln > maxLen:\n\t\tnum = num[ln - maxLen:]\n\t(i, j) = (0, 0)\n\twhile j < len(num):\n\t\tif num[j] != num[i]:\n\t\t\tans.append((j - i, num[i]))\n\t\t\ti = j\n\t\tj += 1\n\tans.append((j - i, num[i]))\n\tif len(ans) > 1 and ans[0][1] == ans[1][1]:\n\t\tans[:2] = [(ans[0][0] + ans[1][0], ans[0][1])]\n\treturn ans\n\ndef diffCompressedStr(u, v):\n\t(ui, vi) = (0, 0)\n\tsame = []\n\twhile ui < len(u) and vi < len(v):\n\t\tif u[ui][1] == v[vi][1]:\n\t\t\tif u[ui][0] == v[vi][0]:\n\t\t\t\tsame.append((u[ui][0], u[ui][1]))\n\t\t\t\tui += 1\n\t\t\t\tvi += 1\n\t\t\telif u[ui][0] < v[vi][0]:\n\t\t\t\tsame.append((u[ui][0], u[ui][1]))\n\t\t\t\tv[vi] = (v[vi][0] - u[ui][0], v[vi][1])\n\t\t\t\tui += 1\n\t\t\telse:\n\t\t\t\tsame.append((v[vi][0], v[vi][1]))\n\t\t\t\tu[ui] = (u[ui][0] - v[vi][0], u[ui][1])\n\t\t\t\tvi += 1\n\t\telse:\n\t\t\tbreak\n\treturn (same, u[ui:], v[vi:])\n\ndef popLeft(num, count=1):\n\tc = 0\n\tfor i in range(len(num)):\n\t\tif c + num[i][0] > count:\n\t\t\treturn [(num[i][0] - count + c, num[i][1])] + num[i + 1:]\n\t\telse:\n\t\t\tc += num[i][0]\n\treturn []\n\ndef rev(val):\n\treturn '1' if val == '0' else '0'\n\ndef buildTree(num, idx, numLen):\n\tt = tree\n\tnum = compressStr(num, numLen)\n\twhile num:\n\t\ttv = t['v']\n\t\t(same, vleft, num) = diffCompressedStr(tv, num)\n\t\tif not vleft:\n\t\t\tif num:\n\t\t\t\tu = num[0][1]\n\t\t\t\tru = rev(u)\n\t\t\t\tif u in t:\n\t\t\t\t\tt['c'].append(idx)\n\t\t\t\t\tt = t[u]\n\t\t\t\t\tnum = popLeft(num, 1)\n\t\t\t\telif ru in t:\n\t\t\t\t\tt[u] = {'c': [idx], 'v': popLeft(num, 1)}\n\t\t\t\telse:\n\t\t\t\t\tt['c'].append(idx)\n\t\t\t\t\tt['v'] = num\n\t\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tt['c'].append(idx)\n\t\t\t\treturn\n\t\telse:\n\t\t\tc0 = t['0'] if '0' in t else None\n\t\t\tc1 = t['1'] if '1' in t else None\n\t\t\tv0 = vleft[0][1]\n\t\t\tn0 = num[0][1]\n\t\t\tt[n0] = {'c': [idx], 'v': popLeft(num, 1)}\n\t\t\tt[v0] = {'c': [x for x in t['c']], 'v': popLeft(vleft, 1)}\n\t\t\tif c0:\n\t\t\t\tt[v0]['0'] = c0\n\t\t\tif c1:\n\t\t\t\tt[v0]['1'] = c1\n\t\t\tt['v'] = same\n\t\t\tt['c'].append(idx)\n\t\t\treturn\n\tt['c'].append(idx)\n\ndef computeTreeValLen(t):\n\tif not t:\n\t\treturn\n\tif 'v' in t:\n\t\tt['vl'] = sum([x[0] for x in t['v']] or [0])\n\telse:\n\t\tt['vl'] = 0\n\tif '0' in t:\n\t\tcomputeTreeValLen(t['0'])\n\tif '1' in t:\n\t\tcomputeTreeValLen(t['1'])\nMXD = max([len(x) for x in A])\nfor (i, v) in enumerate(A):\n\tbuildTree(v, i + 1, MXD)\ncomputeTreeValLen(tree)\nimport json\n\ndef check(l, r, idx):\n\tif not idx:\n\t\treturn False\n\tif idx[0] > r or idx[-1] < l:\n\t\treturn False\n\tif l <= idx[0] <= idx[-1] <= r:\n\t\treturn True\n\t(a, b) = (0, len(idx))\n\twhile a < b:\n\t\tc = (a + b) // 2\n\t\tv = idx[c]\n\t\tif l <= v <= r:\n\t\t\treturn True\n\t\tif v < l:\n\t\t\ta = c + 1\n\t\telif v > r:\n\t\t\tb = c\n\treturn False\n\ndef find(l, r, idx):\n\t(a, b) = (0, len(idx))\n\twhile a < b:\n\t\tc = (a + b) // 2\n\t\tv = idx[c]\n\t\tif v < l:\n\t\t\ta = c + 1\n\t\telif v > r:\n\t\t\tb = c\n\t\telse:\n\t\t\tb = c\n\treturn idx[a]\n\ndef query(l, r, num):\n\tnum = compressStr(num, MXD)\n\tt = tree\n\twhile num:\n\t\tif len(tree['c']) <= 1:\n\t\t\tbreak\n\t\tif t['v']:\n\t\t\tnum = popLeft(num, t['vl'])\n\t\t\tif not num:\n\t\t\t\tbreak\n\t\ta = num[0][1]\n\t\tra = rev(a)\n\t\tif ra in t and check(l, r, t[ra]['c']):\n\t\t\tt = t[ra]\n\t\t\tnum = popLeft(num, 1)\n\t\telif a in t and check(l, r, t[a]['c']):\n\t\t\tt = t[a]\n\t\t\tnum = popLeft(num, 1)\n\t\telse:\n\t\t\tbreak\n\treturn find(l, r, t['c'])\nans = []\nfor (l, r, v) in Q:\n\tans.append(query(l, r, v))\nprint('\\n'.join(map(str, ans)))\n",
        "slowest_solution": "from collections import defaultdict\nfrom bisect import bisect_left, bisect_right\nfrom math import log2, ceil\nmaxpow = 0\n\nclass TrieNode:\n\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.children = [None] * 2\n\t\tself.data = []\n\nclass Trie:\n\n\tdef __init__(self):\n\t\tself.root = self.newNode(-1)\n\n\tdef newNode(self, key):\n\t\treturn TrieNode(key)\n\n\tdef insert(self, key, idx):\n\t\tpCrawl = self.root\n\t\tfor i in range(maxpow, -1, -1):\n\t\t\tf = check(key, i)\n\t\t\tif not pCrawl.children[f] or pCrawl.children[f] == None:\n\t\t\t\tpCrawl.children[f] = self.newNode(key)\n\t\t\tpCrawl = pCrawl.children[f]\n\t\t\tpCrawl.data.append(idx)\n\n\tdef insert_list(self, arr):\n\t\tfor i in range(len(arr) - 1):\n\t\t\tkey = arr[i]\n\t\t\tpCrawl = self.root\n\t\t\tfor j in range(maxpow, -1, -1):\n\t\t\t\tf = check(key, j)\n\t\t\t\tif not pCrawl.children[f]:\n\t\t\t\t\tpCrawl.children[f] = self.newNode(key)\n\t\t\t\tpCrawl = pCrawl.children[f]\n\t\t\t\tpCrawl.data.append(i)\n\n\tdef find_max_xor(self, x):\n\t\tpCrawl = self.root\n\t\tres = 0\n\t\tfor i in range(maxpow - 1, -1, -1):\n\t\t\tf = check(x, i)\n\t\t\tif pCrawl.children[f ^ 1]:\n\t\t\t\tres += 2 ** i\n\t\t\t\tpCrawl = pCrawl.children[f ^ 1]\n\t\t\telse:\n\t\t\t\tpCrawl = pCrawl.children[f]\n\t\treturn res\n\n\tdef query(self, big_nums, l, r, x):\n\t\tres = 0\n\t\tpCrawl = self.root\n\t\tpCrawl2 = None\n\t\tfor i in range(maxpow, -1, -1):\n\t\t\tf = check(x, i)\n\t\t\tdone = False\n\t\t\tif pCrawl.children[f ^ 1]:\n\t\t\t\tpCrawl2 = pCrawl.children[f ^ 1]\n\t\t\t\tp = bisect_left(pCrawl2.data, l)\n\t\t\t\tif p == len(pCrawl2.data):\n\t\t\t\t\tp -= 1\n\t\t\t\tif pCrawl2.data[p] >= l and pCrawl2.data[p] <= r:\n\t\t\t\t\tres = 2 * res + 1\n\t\t\t\t\tpCrawl = pCrawl2\n\t\t\t\t\tdone = True\n\t\t\tif not done and pCrawl.children[f]:\n\t\t\t\tpCrawl = pCrawl.children[f]\n\t\t\t\tres *= 2\n\t\tidx = -1\n\t\tfor i in big_nums.keys():\n\t\t\tif l <= i <= r:\n\t\t\t\txo = big_nums[i] ^ x\n\t\t\t\tif xo > res:\n\t\t\t\t\tidx = i\n\t\t\t\t\tres = xo\n\t\treturn (res ^ x, idx)\n\ndef check(b, pos):\n\treturn 1 if b & 2 ** pos else 0\n\ndef brute(arr, N, Q):\n\tresults = []\n\tfor i in range(N):\n\t\tx = int(input(), 2)\n\t\tarr.append(x)\n\tfor i in range(Q):\n\t\t(l, r, x) = input().split()\n\t\t(l, r, x) = (int(l), int(r), int(x, 2))\n\t\tmx = -1\n\t\tidx = 0\n\t\tfor j in range(l, r + 1):\n\t\t\tif arr[j - 1] ^ x > mx:\n\t\t\t\tmx = arr[j - 1] ^ x\n\t\t\t\tidx = j\n\t\tresults.append(idx)\n\tprint('\\n'.join((str(k) for k in results)))\n\ndef solve():\n\tglobal maxpow\n\t(N, Q) = map(int, input().split())\n\tindexes = defaultdict(list)\n\tresults = []\n\tarr = []\n\tbig_nums = defaultdict(int)\n\tmax_ = int('1' * (60 - 2 * N // 10000), 2)\n\tif Q * N < 300000000:\n\t\tbrute(arr, N, Q)\n\t\treturn\n\tfor i in range(N):\n\t\tx = int(input(), 2)\n\t\tif x > max_:\n\t\t\tbig_nums[i] = x\n\t\t\tx = 0\n\t\tarr.append(x)\n\t\tindexes[x].append(i + 1)\n\tmaxpow = ceil(log2(max(arr)))\n\tarr.append(0)\n\tTRIE = Trie()\n\tTRIE.insert_list(arr)\n\tfor _ in range(Q):\n\t\t(L, R, X) = input().split()\n\t\t(L, R, X) = (int(L) - 1, int(R) - 1, int(X, 2))\n\t\tif X > max_:\n\t\t\tidx = L + 1\n\t\t\tres = arr[L] ^ X\n\t\t\tfor j in range(L + 1, R + 1):\n\t\t\t\txo = arr[j] ^ X\n\t\t\t\tif xo > res:\n\t\t\t\t\tres = xo\n\t\t\t\t\tidx = j + 1\n\t\t\tfor i in big_nums.keys():\n\t\t\t\tif L <= i <= R:\n\t\t\t\t\txo = big_nums[i] ^ X\n\t\t\t\t\tif xo > res:\n\t\t\t\t\t\tidx = i + 1\n\t\t\t\t\t\tres = xo\n\t\t\tresults.append(idx)\n\t\telse:\n\t\t\t(q, idx) = TRIE.query(big_nums, L, R, X)\n\t\t\tif idx != -1:\n\t\t\t\tresults.append(idx + 1)\n\t\t\t\tcontinue\n\t\t\ti = bisect_right(indexes[q], L - 1)\n\t\t\tif indexes[q][i] < L + 1:\n\t\t\t\ti += 1\n\t\t\tresults.append(indexes[q][i])\n\tprint('\\n'.join((str(k) for k in results)))\nsolve()\n"
    },
    {
        "task_id": 809,
        "slowest_solution_id": 5,
        "fastest_solution_id": 5,
        "slowest_time": 2.4805357456207275,
        "fastest_time": 2.4805357456207275,
        "fastest_solution": "a = int(input())\nwhile a > 0:\n\ta -= 1\n\tb = input()\n\t(T1, T2, t1, t2) = [int(n) for n in b.split()]\n\ts = 1.0\n\tf = 0\n\tif t2 < T1:\n\t\tk = min(T1 - t2, T2)\n\t\tf += 0.5 * k * k\n\t\tif T1 - t2 > T2:\n\t\t\tf += T2 * (T1 - T2 - t2)\n\tif t1 < T2:\n\t\tk = min(T2 - t1, T1)\n\t\tf += 0.5 * k * k\n\t\tif T2 - t1 > T1:\n\t\t\tf += T1 * (T2 - T1 - t1)\n\ts -= f / (T1 * T2)\n\tprint('{0:.6f}'.format(s))\n",
        "slowest_solution": "a = int(input())\nwhile a > 0:\n\ta -= 1\n\tb = input()\n\t(T1, T2, t1, t2) = [int(n) for n in b.split()]\n\ts = 1.0\n\tf = 0\n\tif t2 < T1:\n\t\tk = min(T1 - t2, T2)\n\t\tf += 0.5 * k * k\n\t\tif T1 - t2 > T2:\n\t\t\tf += T2 * (T1 - T2 - t2)\n\tif t1 < T2:\n\t\tk = min(T2 - t1, T1)\n\t\tf += 0.5 * k * k\n\t\tif T2 - t1 > T1:\n\t\t\tf += T1 * (T2 - T1 - t1)\n\ts -= f / (T1 * T2)\n\tprint('{0:.6f}'.format(s))\n"
    },
    {
        "task_id": 779,
        "slowest_solution_id": 2,
        "fastest_solution_id": 8,
        "slowest_time": 2.6946661472320557,
        "fastest_time": 2.473360300064087,
        "fastest_solution": "MOD = 10 ** 9 + 7\nI = lambda : list(map(int, input().split()))\n(t,) = I()\nwhile t:\n\tt -= 1\n\tms = input()\n\tns = input()\n\tn = len(ns)\n\tm = len(ms)\n\ttable = [[0 for i in range(m + 1)] for j in range(min(3, n + 1))]\n\ttable[0][0] = 1 if ms[0] == '0' or ns[0] == '0' else 0\n\tcol = [[0 for i in range(min(3, m + 1))] for j in range(n + 1)]\n\tcol[0][0] = 1 if ms[0] == '0' or ns[0] == '0' else 0\n\ti = 1\n\twinner = 0\n\twhile i < m:\n\t\tif ms[i] == '0':\n\t\t\ttable[0][i] = 1\n\t\telse:\n\t\t\twinner = 1 if table[0][i - 1] == 0 else 0\n\t\t\ttable[0][i] = winner\n\t\ti += 1\n\ti = 1\n\twhile i < n:\n\t\tif ns[i] == '0':\n\t\t\tcol[i][0] = 1\n\t\telse:\n\t\t\twinner = 1 if col[i - 1][0] == 0 else 0\n\t\t\tcol[i][0] = winner\n\t\ti += 1\n\tif n >= 2 and m >= 2:\n\t\ttable[1][1] = col[1][1] = 0 if table[0][1] and col[1][0] else 1\n\tfor j in range(2, m + 1):\n\t\tif table[0][j] == 1 and table[1][j - 1] == 1:\n\t\t\ttable[1][j] = 0\n\t\telse:\n\t\t\ttable[1][j] = 1\n\tfor j in range(2, n + 1):\n\t\tif col[j][0] == 1 and col[j - 1][1] == 1:\n\t\t\tcol[j][1] = 0\n\t\telse:\n\t\t\tcol[j][1] = 1\n\t(q,) = I()\n\ts = ''\n\twhile q:\n\t\tq -= 1\n\t\t(x, y) = I()\n\t\tif x == y == 1:\n\t\t\ts += str(table[0][0])\n\t\t\tcontinue\n\t\telif x == 1:\n\t\t\ts += str(table[0][y - 1])\n\t\t\tcontinue\n\t\telif y == 1:\n\t\t\ts += str(col[x - 1][0])\n\t\t\tcontinue\n\t\tk = min(x, y) - 1\n\t\tx -= k\n\t\ty -= k\n\t\tif y < x:\n\t\t\ts += str(col[x][y])\n\t\telse:\n\t\t\ts += str(table[x][y])\n\tprint(s)\n",
        "slowest_solution": "for t in range(int(input())):\n\ttop = list(map(int, list(input().strip())))\n\tleft = list(map(int, list(input().strip())))\n\trow0 = [not top[0] or not left[0]]\n\tfor i in range(1, len(top)):\n\t\trow0.append(not top[i] or not row0[-1])\n\tif len(left) > 1:\n\t\trow1 = [not row0[0] or not left[1]]\n\t\tfor i in range(1, len(top)):\n\t\t\trow1.append(not row0[i] or not row1[-1])\n\tcol0 = [not left[0] or not top[0]]\n\tfor i in range(1, len(left)):\n\t\tcol0.append(not left[i] or not col0[-1])\n\tif len(top) > 1:\n\t\tcol1 = [not col0[0] or not top[1]]\n\t\tfor i in range(1, len(left)):\n\t\t\tcol1.append(not col0[i] or not col1[-1])\n\tans = []\n\tfor q in range(int(input())):\n\t\t(x, y) = map(int, input().split())\n\t\t(x, y) = (x - 1, y - 1)\n\t\tif x == 0:\n\t\t\tres = row0[y]\n\t\telif y == 0:\n\t\t\tres = col0[x]\n\t\telif x <= y:\n\t\t\tres = row1[y - (x - 1)]\n\t\telse:\n\t\t\tres = col1[x - (y - 1)]\n\t\tans.append(int(res))\n\tprint(*ans, sep='')\n"
    },
    {
        "task_id": 820,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.4936416149139404,
        "fastest_time": 2.4936416149139404,
        "fastest_solution": "from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nfrom heapq import *\nimport functools\nmod = 998244353\nimport sys\ninput = sys.stdin.readline\nimport typing\n\nclass SegTree:\n\n\tdef __init__(self, op: typing.Callable[[typing.Any, typing.Any], typing.Any], e: typing.Any, v: typing.Union[int, typing.List[typing.Any]]) -> None:\n\t\tself._op = op\n\t\tself._e = e\n\t\tif isinstance(v, int):\n\t\t\tv = [e] * v\n\t\tself._n = len(v)\n\t\tself._log = self._n.bit_length()\n\t\tself._size = 1 << self._log\n\t\tself._d = [e] * (2 * self._size)\n\t\tfor i in range(self._n):\n\t\t\tself._d[self._size + i] = v[i]\n\t\tfor i in range(self._size - 1, 0, -1):\n\t\t\tself._update(i)\n\n\tdef set(self, p: int, x: typing.Any) -> None:\n\t\tassert 0 <= p < self._n\n\t\tp += self._size\n\t\tself._d[p] = x\n\t\tfor i in range(1, self._log + 1):\n\t\t\tself._update(p >> i)\n\n\tdef get(self, p: int) -> typing.Any:\n\t\tassert 0 <= p < self._n\n\t\treturn self._d[p + self._size]\n\n\tdef prod(self, left: int, right: int) -> typing.Any:\n\t\tassert 0 <= left <= right <= self._n\n\t\tsml = self._e\n\t\tsmr = self._e\n\t\tleft += self._size\n\t\tright += self._size\n\t\twhile left < right:\n\t\t\tif left & 1:\n\t\t\t\tsml = self._op(sml, self._d[left])\n\t\t\t\tleft += 1\n\t\t\tif right & 1:\n\t\t\t\tright -= 1\n\t\t\t\tsmr = self._op(self._d[right], smr)\n\t\t\tleft >>= 1\n\t\t\tright >>= 1\n\t\treturn self._op(sml, smr)\n\n\tdef all_prod(self) -> typing.Any:\n\t\treturn self._d[1]\n\n\tdef max_right(self, left: int, f: typing.Callable[[typing.Any], bool]) -> int:\n\t\tassert 0 <= left <= self._n\n\t\tassert f(self._e)\n\t\tif left == self._n:\n\t\t\treturn self._n\n\t\tleft += self._size\n\t\tsm = self._e\n\t\tfirst = True\n\t\twhile first or left & -left != left:\n\t\t\tfirst = False\n\t\t\twhile left % 2 == 0:\n\t\t\t\tleft >>= 1\n\t\t\tif not f(self._op(sm, self._d[left])):\n\t\t\t\twhile left < self._size:\n\t\t\t\t\tleft *= 2\n\t\t\t\t\tif f(self._op(sm, self._d[left])):\n\t\t\t\t\t\tsm = self._op(sm, self._d[left])\n\t\t\t\t\t\tleft += 1\n\t\t\t\treturn left - self._size\n\t\t\tsm = self._op(sm, self._d[left])\n\t\t\tleft += 1\n\t\treturn self._n\n\n\tdef min_left(self, right: int, f: typing.Callable[[typing.Any], bool]) -> int:\n\t\tassert 0 <= right <= self._n\n\t\tassert f(self._e)\n\t\tif right == 0:\n\t\t\treturn 0\n\t\tright += self._size\n\t\tsm = self._e\n\t\tfirst = True\n\t\twhile first or right & -right != right:\n\t\t\tfirst = False\n\t\t\tright -= 1\n\t\t\twhile right > 1 and right % 2:\n\t\t\t\tright >>= 1\n\t\t\tif not f(self._op(self._d[right], sm)):\n\t\t\t\twhile right < self._size:\n\t\t\t\t\tright = 2 * right + 1\n\t\t\t\t\tif f(self._op(self._d[right], sm)):\n\t\t\t\t\t\tsm = self._op(self._d[right], sm)\n\t\t\t\t\t\tright -= 1\n\t\t\t\treturn right + 1 - self._size\n\t\t\tsm = self._op(self._d[right], sm)\n\t\treturn 0\n\n\tdef _update(self, k: int) -> None:\n\t\tself._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])\n\nclass SparseTable:\n\n\tdef __init__(self, v, op, e):\n\t\tself.N = len(v)\n\t\tself.op = op\n\t\tself.e = e\n\t\tself.lg = [self.e] * (self.N + 1)\n\t\tfor i in range(2, self.N + 1):\n\t\t\tself.lg[i] = self.lg[i >> 1] + 1\n\t\tself.pow_2 = [pow(2, i) for i in range(20)]\n\t\tself.table = [None] * (self.lg[self.N] + 1)\n\t\tst0 = self.table[0] = [a for a in v]\n\t\tb = 1\n\t\tfor i in range(self.lg[self.N]):\n\t\t\tst0 = self.table[i + 1] = [self.op(x, y) for (x, y) in zip(st0, st0[b:])]\n\t\t\tb <<= 1\n\n\tdef prod(self, s, t):\n\t\tif s == t:\n\t\t\treturn self.e\n\t\tb = t - s\n\t\tm = self.lg[b]\n\t\treturn self.op(self.table[m][s], self.table[m][t - self.pow_2[m]])\n\ndef op(x, y):\n\treturn math.gcd(x, y)\nfrom bisect import bisect_left, bisect_right, insort\nfrom typing import Generic, Iterable, Iterator, TypeVar, Union, List\nT = TypeVar('T')\n\nclass SortedMultiset(Generic[T]):\n\tBUCKET_RATIO = 50\n\tREBUILD_RATIO = 170\n\n\tdef _build(self, a=None) -> None:\n\t\tif a is None:\n\t\t\ta = list(self)\n\t\tsize = self.size = len(a)\n\t\tbucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))\n\t\tself.a = [a[size * i // bucket_size:size * (i + 1) // bucket_size] for i in range(bucket_size)]\n\n\tdef __init__(self, a: Iterable[T]=[]) -> None:\n\t\ta = list(a)\n\t\tif not all((a[i] <= a[i + 1] for i in range(len(a) - 1))):\n\t\t\ta = sorted(a)\n\t\tself._build(a)\n\n\tdef __iter__(self) -> Iterator[T]:\n\t\tfor i in self.a:\n\t\t\tfor j in i:\n\t\t\t\tyield j\n\n\tdef __reversed__(self) -> Iterator[T]:\n\t\tfor i in reversed(self.a):\n\t\t\tfor j in reversed(i):\n\t\t\t\tyield j\n\n\tdef __len__(self) -> int:\n\t\treturn self.size\n\n\tdef __repr__(self) -> str:\n\t\treturn 'SortedMultiset' + str(self.a)\n\n\tdef __str__(self) -> str:\n\t\ts = str(list(self))\n\t\treturn '{' + s[1:len(s) - 1] + '}'\n\n\tdef _find_bucket(self, x: T) -> List[T]:\n\t\tfor a in self.a:\n\t\t\tif x <= a[-1]:\n\t\t\t\treturn a\n\t\treturn a\n\n\tdef __contains__(self, x: T) -> bool:\n\t\tif self.size == 0:\n\t\t\treturn False\n\t\ta = self._find_bucket(x)\n\t\ti = bisect_left(a, x)\n\t\treturn i != len(a) and a[i] == x\n\n\tdef count(self, x: T) -> int:\n\t\treturn self.index_right(x) - self.index(x)\n\n\tdef add(self, x: T) -> None:\n\t\tif self.size == 0:\n\t\t\tself.a = [[x]]\n\t\t\tself.size = 1\n\t\t\treturn\n\t\ta = self._find_bucket(x)\n\t\tinsort(a, x)\n\t\tself.size += 1\n\t\tif len(a) > len(self.a) * self.REBUILD_RATIO:\n\t\t\tself._build()\n\n\tdef discard(self, x: T) -> bool:\n\t\tif self.size == 0:\n\t\t\treturn False\n\t\ta = self._find_bucket(x)\n\t\ti = bisect_left(a, x)\n\t\tif i == len(a) or a[i] != x:\n\t\t\treturn False\n\t\ta.pop(i)\n\t\tself.size -= 1\n\t\tif len(a) == 0:\n\t\t\tself._build()\n\t\treturn True\n\n\tdef lt(self, x: T) -> Union[T, None]:\n\t\tfor a in reversed(self.a):\n\t\t\tif a[0] < x:\n\t\t\t\treturn a[bisect_left(a, x) - 1]\n\n\tdef le(self, x: T) -> Union[T, None]:\n\t\tfor a in reversed(self.a):\n\t\t\tif a[0] <= x:\n\t\t\t\treturn a[bisect_right(a, x) - 1]\n\n\tdef gt(self, x: T) -> Union[T, None]:\n\t\tfor a in self.a:\n\t\t\tif a[-1] > x:\n\t\t\t\treturn a[bisect_right(a, x)]\n\n\tdef ge(self, x: T) -> Union[T, None]:\n\t\tfor a in self.a:\n\t\t\tif a[-1] >= x:\n\t\t\t\treturn a[bisect_left(a, x)]\n\n\tdef __getitem__(self, x: int) -> T:\n\t\tif x < 0:\n\t\t\tx += self.size\n\t\tif x < 0:\n\t\t\traise IndexError\n\t\tfor a in self.a:\n\t\t\tif x < len(a):\n\t\t\t\treturn a[x]\n\t\t\tx -= len(a)\n\t\traise IndexError\n\n\tdef index(self, x: T) -> int:\n\t\tans = 0\n\t\tfor a in self.a:\n\t\t\tif a[-1] >= x:\n\t\t\t\treturn ans + bisect_left(a, x)\n\t\t\tans += len(a)\n\t\treturn ans\n\n\tdef index_right(self, x: T) -> int:\n\t\tans = 0\n\t\tfor a in self.a:\n\t\t\tif a[-1] > x:\n\t\t\t\treturn ans + bisect_right(a, x)\n\t\t\tans += len(a)\n\t\treturn ans\nINF = 1 << 31\nt = int(input())\n\ndef is_ok(x):\n\tms = SortedMultiset([(a[i] << 30) + i for i in range(x - 1)])\n\tfor i in range(n - x + 1):\n\t\tms.add((a[i + x - 1] << 30) + (i + x - 1))\n\t\t(m1, mid1) = divmod(ms[-1], 1 << 30)\n\t\tif m1 - math.gcd(st.prod(i, mid1), st.prod(mid1 + 1, i + x)) >= k:\n\t\t\treturn True\n\t\t(m2, mid2) = divmod(ms[-2], 1 << 30)\n\t\tif m2 - math.gcd(st.prod(i, mid2), st.prod(mid2 + 1, i + x)) >= k:\n\t\t\treturn True\n\t\tms.discard((a[i] << 30) + i)\n\treturn False\nfor _ in range(t):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tst = SparseTable(a, op, 0)\n\tflg = 0\n\tfor i in range(n):\n\t\tif a[i] - math.gcd(st.prod(0, i), st.prod(i + 1, n)) >= k:\n\t\t\tflg = 1\n\t\t\tbreak\n\tif not flg:\n\t\tprint(-1)\n\t\tcontinue\n\tok = n\n\tng = 1\n\twhile abs(ng - ok) > 1:\n\t\tmid = (ng + ok) // 2\n\t\tif is_ok(mid):\n\t\t\tok = mid\n\t\telse:\n\t\t\tng = mid\n\tprint(ok)\n",
        "slowest_solution": "from collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nfrom heapq import *\nimport functools\nmod = 998244353\nimport sys\ninput = sys.stdin.readline\nimport typing\n\nclass SegTree:\n\n\tdef __init__(self, op: typing.Callable[[typing.Any, typing.Any], typing.Any], e: typing.Any, v: typing.Union[int, typing.List[typing.Any]]) -> None:\n\t\tself._op = op\n\t\tself._e = e\n\t\tif isinstance(v, int):\n\t\t\tv = [e] * v\n\t\tself._n = len(v)\n\t\tself._log = self._n.bit_length()\n\t\tself._size = 1 << self._log\n\t\tself._d = [e] * (2 * self._size)\n\t\tfor i in range(self._n):\n\t\t\tself._d[self._size + i] = v[i]\n\t\tfor i in range(self._size - 1, 0, -1):\n\t\t\tself._update(i)\n\n\tdef set(self, p: int, x: typing.Any) -> None:\n\t\tassert 0 <= p < self._n\n\t\tp += self._size\n\t\tself._d[p] = x\n\t\tfor i in range(1, self._log + 1):\n\t\t\tself._update(p >> i)\n\n\tdef get(self, p: int) -> typing.Any:\n\t\tassert 0 <= p < self._n\n\t\treturn self._d[p + self._size]\n\n\tdef prod(self, left: int, right: int) -> typing.Any:\n\t\tassert 0 <= left <= right <= self._n\n\t\tsml = self._e\n\t\tsmr = self._e\n\t\tleft += self._size\n\t\tright += self._size\n\t\twhile left < right:\n\t\t\tif left & 1:\n\t\t\t\tsml = self._op(sml, self._d[left])\n\t\t\t\tleft += 1\n\t\t\tif right & 1:\n\t\t\t\tright -= 1\n\t\t\t\tsmr = self._op(self._d[right], smr)\n\t\t\tleft >>= 1\n\t\t\tright >>= 1\n\t\treturn self._op(sml, smr)\n\n\tdef all_prod(self) -> typing.Any:\n\t\treturn self._d[1]\n\n\tdef max_right(self, left: int, f: typing.Callable[[typing.Any], bool]) -> int:\n\t\tassert 0 <= left <= self._n\n\t\tassert f(self._e)\n\t\tif left == self._n:\n\t\t\treturn self._n\n\t\tleft += self._size\n\t\tsm = self._e\n\t\tfirst = True\n\t\twhile first or left & -left != left:\n\t\t\tfirst = False\n\t\t\twhile left % 2 == 0:\n\t\t\t\tleft >>= 1\n\t\t\tif not f(self._op(sm, self._d[left])):\n\t\t\t\twhile left < self._size:\n\t\t\t\t\tleft *= 2\n\t\t\t\t\tif f(self._op(sm, self._d[left])):\n\t\t\t\t\t\tsm = self._op(sm, self._d[left])\n\t\t\t\t\t\tleft += 1\n\t\t\t\treturn left - self._size\n\t\t\tsm = self._op(sm, self._d[left])\n\t\t\tleft += 1\n\t\treturn self._n\n\n\tdef min_left(self, right: int, f: typing.Callable[[typing.Any], bool]) -> int:\n\t\tassert 0 <= right <= self._n\n\t\tassert f(self._e)\n\t\tif right == 0:\n\t\t\treturn 0\n\t\tright += self._size\n\t\tsm = self._e\n\t\tfirst = True\n\t\twhile first or right & -right != right:\n\t\t\tfirst = False\n\t\t\tright -= 1\n\t\t\twhile right > 1 and right % 2:\n\t\t\t\tright >>= 1\n\t\t\tif not f(self._op(self._d[right], sm)):\n\t\t\t\twhile right < self._size:\n\t\t\t\t\tright = 2 * right + 1\n\t\t\t\t\tif f(self._op(self._d[right], sm)):\n\t\t\t\t\t\tsm = self._op(self._d[right], sm)\n\t\t\t\t\t\tright -= 1\n\t\t\t\treturn right + 1 - self._size\n\t\t\tsm = self._op(self._d[right], sm)\n\t\treturn 0\n\n\tdef _update(self, k: int) -> None:\n\t\tself._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])\n\nclass SparseTable:\n\n\tdef __init__(self, v, op, e):\n\t\tself.N = len(v)\n\t\tself.op = op\n\t\tself.e = e\n\t\tself.lg = [self.e] * (self.N + 1)\n\t\tfor i in range(2, self.N + 1):\n\t\t\tself.lg[i] = self.lg[i >> 1] + 1\n\t\tself.pow_2 = [pow(2, i) for i in range(20)]\n\t\tself.table = [None] * (self.lg[self.N] + 1)\n\t\tst0 = self.table[0] = [a for a in v]\n\t\tb = 1\n\t\tfor i in range(self.lg[self.N]):\n\t\t\tst0 = self.table[i + 1] = [self.op(x, y) for (x, y) in zip(st0, st0[b:])]\n\t\t\tb <<= 1\n\n\tdef prod(self, s, t):\n\t\tif s == t:\n\t\t\treturn self.e\n\t\tb = t - s\n\t\tm = self.lg[b]\n\t\treturn self.op(self.table[m][s], self.table[m][t - self.pow_2[m]])\n\ndef op(x, y):\n\treturn math.gcd(x, y)\nfrom bisect import bisect_left, bisect_right, insort\nfrom typing import Generic, Iterable, Iterator, TypeVar, Union, List\nT = TypeVar('T')\n\nclass SortedMultiset(Generic[T]):\n\tBUCKET_RATIO = 50\n\tREBUILD_RATIO = 170\n\n\tdef _build(self, a=None) -> None:\n\t\tif a is None:\n\t\t\ta = list(self)\n\t\tsize = self.size = len(a)\n\t\tbucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))\n\t\tself.a = [a[size * i // bucket_size:size * (i + 1) // bucket_size] for i in range(bucket_size)]\n\n\tdef __init__(self, a: Iterable[T]=[]) -> None:\n\t\ta = list(a)\n\t\tif not all((a[i] <= a[i + 1] for i in range(len(a) - 1))):\n\t\t\ta = sorted(a)\n\t\tself._build(a)\n\n\tdef __iter__(self) -> Iterator[T]:\n\t\tfor i in self.a:\n\t\t\tfor j in i:\n\t\t\t\tyield j\n\n\tdef __reversed__(self) -> Iterator[T]:\n\t\tfor i in reversed(self.a):\n\t\t\tfor j in reversed(i):\n\t\t\t\tyield j\n\n\tdef __len__(self) -> int:\n\t\treturn self.size\n\n\tdef __repr__(self) -> str:\n\t\treturn 'SortedMultiset' + str(self.a)\n\n\tdef __str__(self) -> str:\n\t\ts = str(list(self))\n\t\treturn '{' + s[1:len(s) - 1] + '}'\n\n\tdef _find_bucket(self, x: T) -> List[T]:\n\t\tfor a in self.a:\n\t\t\tif x <= a[-1]:\n\t\t\t\treturn a\n\t\treturn a\n\n\tdef __contains__(self, x: T) -> bool:\n\t\tif self.size == 0:\n\t\t\treturn False\n\t\ta = self._find_bucket(x)\n\t\ti = bisect_left(a, x)\n\t\treturn i != len(a) and a[i] == x\n\n\tdef count(self, x: T) -> int:\n\t\treturn self.index_right(x) - self.index(x)\n\n\tdef add(self, x: T) -> None:\n\t\tif self.size == 0:\n\t\t\tself.a = [[x]]\n\t\t\tself.size = 1\n\t\t\treturn\n\t\ta = self._find_bucket(x)\n\t\tinsort(a, x)\n\t\tself.size += 1\n\t\tif len(a) > len(self.a) * self.REBUILD_RATIO:\n\t\t\tself._build()\n\n\tdef discard(self, x: T) -> bool:\n\t\tif self.size == 0:\n\t\t\treturn False\n\t\ta = self._find_bucket(x)\n\t\ti = bisect_left(a, x)\n\t\tif i == len(a) or a[i] != x:\n\t\t\treturn False\n\t\ta.pop(i)\n\t\tself.size -= 1\n\t\tif len(a) == 0:\n\t\t\tself._build()\n\t\treturn True\n\n\tdef lt(self, x: T) -> Union[T, None]:\n\t\tfor a in reversed(self.a):\n\t\t\tif a[0] < x:\n\t\t\t\treturn a[bisect_left(a, x) - 1]\n\n\tdef le(self, x: T) -> Union[T, None]:\n\t\tfor a in reversed(self.a):\n\t\t\tif a[0] <= x:\n\t\t\t\treturn a[bisect_right(a, x) - 1]\n\n\tdef gt(self, x: T) -> Union[T, None]:\n\t\tfor a in self.a:\n\t\t\tif a[-1] > x:\n\t\t\t\treturn a[bisect_right(a, x)]\n\n\tdef ge(self, x: T) -> Union[T, None]:\n\t\tfor a in self.a:\n\t\t\tif a[-1] >= x:\n\t\t\t\treturn a[bisect_left(a, x)]\n\n\tdef __getitem__(self, x: int) -> T:\n\t\tif x < 0:\n\t\t\tx += self.size\n\t\tif x < 0:\n\t\t\traise IndexError\n\t\tfor a in self.a:\n\t\t\tif x < len(a):\n\t\t\t\treturn a[x]\n\t\t\tx -= len(a)\n\t\traise IndexError\n\n\tdef index(self, x: T) -> int:\n\t\tans = 0\n\t\tfor a in self.a:\n\t\t\tif a[-1] >= x:\n\t\t\t\treturn ans + bisect_left(a, x)\n\t\t\tans += len(a)\n\t\treturn ans\n\n\tdef index_right(self, x: T) -> int:\n\t\tans = 0\n\t\tfor a in self.a:\n\t\t\tif a[-1] > x:\n\t\t\t\treturn ans + bisect_right(a, x)\n\t\t\tans += len(a)\n\t\treturn ans\nINF = 1 << 31\nt = int(input())\n\ndef is_ok(x):\n\tms = SortedMultiset([(a[i] << 30) + i for i in range(x - 1)])\n\tfor i in range(n - x + 1):\n\t\tms.add((a[i + x - 1] << 30) + (i + x - 1))\n\t\t(m1, mid1) = divmod(ms[-1], 1 << 30)\n\t\tif m1 - math.gcd(st.prod(i, mid1), st.prod(mid1 + 1, i + x)) >= k:\n\t\t\treturn True\n\t\t(m2, mid2) = divmod(ms[-2], 1 << 30)\n\t\tif m2 - math.gcd(st.prod(i, mid2), st.prod(mid2 + 1, i + x)) >= k:\n\t\t\treturn True\n\t\tms.discard((a[i] << 30) + i)\n\treturn False\nfor _ in range(t):\n\t(n, k) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tst = SparseTable(a, op, 0)\n\tflg = 0\n\tfor i in range(n):\n\t\tif a[i] - math.gcd(st.prod(0, i), st.prod(i + 1, n)) >= k:\n\t\t\tflg = 1\n\t\t\tbreak\n\tif not flg:\n\t\tprint(-1)\n\t\tcontinue\n\tok = n\n\tng = 1\n\twhile abs(ng - ok) > 1:\n\t\tmid = (ng + ok) // 2\n\t\tif is_ok(mid):\n\t\t\tok = mid\n\t\telse:\n\t\t\tng = mid\n\tprint(ok)\n"
    },
    {
        "task_id": 778,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.6517820358276367,
        "fastest_time": 2.4344747066497803,
        "fastest_solution": "t = int(input())\nwhile t > 0:\n\t(n, h) = [int(i) for i in input().split()]\n\tdp = [0] * (n + 2)\n\tfor i in range(n):\n\t\t(x, y) = [int(i) + 1 for i in input().split()]\n\t\tdp[0] += 1\n\t\tdp[x] -= 1\n\t\tdp[y + 1] += 1\n\tfor i in range(1, n + 1):\n\t\tdp[i] += dp[i - 1]\n\tdp[0] = 0\n\tfor i in range(2, n + 1):\n\t\tdp[i] += dp[i - 1]\n\tMin = 10000000000000\n\tfor i in range(h, n + 1):\n\t\tMin = min(Min, dp[i] - dp[i - h])\n\tprint(Min)\n\tt -= 1\n",
        "slowest_solution": "t = int(input())\nwhile t > 0:\n\tt -= 1\n\t(n, k) = map(int, input().split())\n\tdp = []\n\tdp = [0] * (n + 2)\n\tfor i in range(n):\n\t\t(a, b) = map(int, input().split())\n\t\tdp[a + 1] -= 1\n\t\tdp[b + 2] += 1\n\tfor i in range(1, n + 1):\n\t\tdp[i] += dp[i - 1]\n\tm = n * k\n\tmi = n * k\n\ts = sum(dp[1:1 + k])\n\tmi = min(s + m, mi)\n\tfor i in range(2, n - k + 2):\n\t\ts = s - dp[i - 1] + dp[i + k - 1]\n\t\tmi = min(s + m, mi)\n\tprint(mi)\n"
    },
    {
        "task_id": 781,
        "slowest_solution_id": 2,
        "fastest_solution_id": 7,
        "slowest_time": 2.6270315647125244,
        "fastest_time": 2.405385732650757,
        "fastest_solution": "from sys import stdin\nimport operator\nN = int(stdin.readline())\np = list(map(int, stdin.readline().strip().split(' ')))\nteams = list(map(lambda x: 1 if x == 'B' else -1, stdin.readline().strip()))\nvalues = list(map(operator.mul, p, teams))\nstart = sum(filter(lambda x: max(x, 0), values))\ntotal = start\nbest = start\nfor i in values:\n\ttotal -= i\n\tbest = max(total, best)\ntotal = start\nfor i in reversed(values):\n\ttotal -= i\n\tbest = max(total, best)\nprint(best)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nn = int(input())\npowers = list(map(int, input().strip().split()))\nteams = list(input().strip())\nlefts = [0]\nrights = [0]\nwithout = 0\nfor i in range(n):\n\tif teams[i] == 'A':\n\t\tlefts.append(lefts[-1] + powers[i])\n\telse:\n\t\tlefts.append(lefts[-1] - powers[i])\n\t\twithout += powers[i]\n\tif teams[n - i - 1] == 'A':\n\t\trights.append(rights[-1] + powers[n - i - 1])\n\telse:\n\t\trights.append(rights[-1] - powers[n - i - 1])\nprint(without + max(max(lefts), max(rights)))\n"
    },
    {
        "task_id": 783,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 2.9459617137908936,
        "fastest_time": 2.540325403213501,
        "fastest_solution": "mo = 10 ** 13\np = [1, 60, 300, 1500, 15000, 150000, 1500000, 15000000, 150000000, 1500000000, 15000000000, 150000000000, 1500000000000, 15000000000000]\n\nclass mat(object):\n\n\tdef __init__(self, a, b, c, d):\n\t\t(self.a, self.b, self.c, self.d) = (a, b, c, d)\n\n\tdef times(self, k):\n\t\treturn mat((self.a * k.a + self.b * k.c) % mo, (self.a * k.b + self.b * k.d) % mo, (self.c * k.a + self.d * k.c) % mo, (self.c * k.b + self.d * k.d) % mo)\n\n\tdef copy(self):\n\t\treturn mat(self.a, self.b, self.c, self.d)\n(me, mt) = (mat(1, 0, 0, 1), mat(0, 1, 1, 1))\n\ndef fib(k):\n\t(ans, t) = (me.copy(), mt.copy())\n\twhile k > 0:\n\t\tif k & 1:\n\t\t\tans = ans.times(t)\n\t\tt = t.times(t)\n\t\tk >>= 1\n\treturn ans.b\n\ndef gene(a, ta, b, tb, tab):\n\tab = []\n\tfor i in a:\n\t\tfor j in b:\n\t\t\ty = -j // tb - 1\n\t\t\twhile j + y * tb < 0:\n\t\t\t\ty += 1\n\t\t\twhile j + y * tb < tab:\n\t\t\t\tif (j - i + y * tb) % ta == 0:\n\t\t\t\t\tab.append(j + y * tb)\n\t\t\t\ty += 1\n\treturn ab\n\ndef filt(a, f, m):\n\tr = f % m\n\treturn [i for i in a if fib(i) % m == r]\nf = int(input())\na = filt(list(range(p[1])), f, 10)\nb = a[:]\nfor i in range(2, 14):\n\tm = 10 ** i\n\tb = gene(a, p[1], b, p[i - 1], p[i])\n\tb = filt(b, f, m)\nprint(min(b) if b else -1)\n",
        "slowest_solution": "low_n = 1000\nhigh_m = 15000\nlimit = int(10 ** 13)\nf = int(input())\ninputList = []\n\ndef customFunction(i):\n\tif i == 0:\n\t\treturn (0, 1)\n\t(a, b) = customFunction(i >> 1)\n\t(a, b) = ((2 * a * b - a * a) % low_n, (b * b + a * a) % low_n)\n\tif i & 1:\n\t\t(a, b) = (b % low_n, (a + b) % low_n)\n\treturn (a, b)\ni = 0\nwhile i < high_m:\n\tif customFunction(i)[0] == f % low_n:\n\t\tinputList.append(i)\n\ti += 1\nwhile low_n < limit:\n\tlow_n *= 10\n\ttempList = []\n\tfor i in inputList:\n\t\tfor j in range(10):\n\t\t\tif customFunction(i + j * high_m)[0] == f % low_n:\n\t\t\t\ttempList.append(i + j * high_m)\n\tinputList = tempList\n\thigh_m *= 10\n\tif inputList == []:\n\t\tbreak\nif inputList == []:\n\tprint(-1)\nelse:\n\tinputList = sorted(inputList)\n\tprint(inputList[0])\n"
    },
    {
        "task_id": 824,
        "slowest_solution_id": 1,
        "fastest_solution_id": 1,
        "slowest_time": 2.5785608291625977,
        "fastest_time": 2.5785608291625977,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom math import inf, log2\n\nclass SegmentTree:\n\n\tdef __init__(self, array, func=max):\n\t\tself.n = len(array)\n\t\tself.size = 2 ** (int(log2(self.n - 1)) + 1) if self.n != 1 else 1\n\t\tself.func = func\n\t\tself.default = 0 if self.func != min else inf\n\t\tself.data = [self.default] * (2 * self.size)\n\t\tself.process(array)\n\n\tdef process(self, array):\n\t\tself.data[self.size:self.size + self.n] = array\n\t\tfor i in range(self.size - 1, -1, -1):\n\t\t\tself.data[i] = self.func(self.data[2 * i], self.data[2 * i + 1])\n\n\tdef query(self, alpha, omega):\n\t\tif alpha == omega:\n\t\t\treturn self.data[alpha + self.size]\n\t\tres = self.default\n\t\talpha += self.size\n\t\tomega += self.size + 1\n\t\twhile alpha < omega:\n\t\t\tif alpha & 1:\n\t\t\t\tres = self.func(res, self.data[alpha])\n\t\t\t\talpha += 1\n\t\t\tif omega & 1:\n\t\t\t\tomega -= 1\n\t\t\t\tres = self.func(res, self.data[omega])\n\t\t\talpha >>= 1\n\t\t\tomega >>= 1\n\t\treturn res\n\n\tdef update(self, index, value):\n\t\tindex += self.size\n\t\tself.data[index] = value\n\t\tindex >>= 1\n\t\twhile index:\n\t\t\tself.data[index] = self.func(self.data[2 * index], self.data[2 * index + 1])\n\t\t\tindex >>= 1\nfrom math import gcd\nn = int(input())\na = list(map(int, input().split()))\nst = SegmentTree(a, func=gcd)\n\ndef check(n, alpha, omega, x):\n\twhile alpha < omega:\n\t\tmid = (alpha + omega) // 2\n\t\tleft = st.query(alpha, mid)\n\t\tright = st.query(mid + 1, omega)\n\t\tif left % x and right % x:\n\t\t\treturn False\n\t\tif not left % x and (not right % x):\n\t\t\treturn True\n\t\tif not left % x and n == 500000 or left % x != 0:\n\t\t\tomega = mid\n\t\telse:\n\t\t\talpha = mid + 1\n\treturn True\nfor _ in range(int(input())):\n\ts = map(int, input().split())\n\ts = list(s)\n\tif len(s) == 4:\n\t\t(p, l, r, x) = s\n\t\tprint('YES' if check(n, l - 1, r - 1, x) else 'NO')\n\telse:\n\t\t(p, i, y) = s\n\t\tst.update(i - 1, y)\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom math import inf, log2\n\nclass SegmentTree:\n\n\tdef __init__(self, array, func=max):\n\t\tself.n = len(array)\n\t\tself.size = 2 ** (int(log2(self.n - 1)) + 1) if self.n != 1 else 1\n\t\tself.func = func\n\t\tself.default = 0 if self.func != min else inf\n\t\tself.data = [self.default] * (2 * self.size)\n\t\tself.process(array)\n\n\tdef process(self, array):\n\t\tself.data[self.size:self.size + self.n] = array\n\t\tfor i in range(self.size - 1, -1, -1):\n\t\t\tself.data[i] = self.func(self.data[2 * i], self.data[2 * i + 1])\n\n\tdef query(self, alpha, omega):\n\t\tif alpha == omega:\n\t\t\treturn self.data[alpha + self.size]\n\t\tres = self.default\n\t\talpha += self.size\n\t\tomega += self.size + 1\n\t\twhile alpha < omega:\n\t\t\tif alpha & 1:\n\t\t\t\tres = self.func(res, self.data[alpha])\n\t\t\t\talpha += 1\n\t\t\tif omega & 1:\n\t\t\t\tomega -= 1\n\t\t\t\tres = self.func(res, self.data[omega])\n\t\t\talpha >>= 1\n\t\t\tomega >>= 1\n\t\treturn res\n\n\tdef update(self, index, value):\n\t\tindex += self.size\n\t\tself.data[index] = value\n\t\tindex >>= 1\n\t\twhile index:\n\t\t\tself.data[index] = self.func(self.data[2 * index], self.data[2 * index + 1])\n\t\t\tindex >>= 1\nfrom math import gcd\nn = int(input())\na = list(map(int, input().split()))\nst = SegmentTree(a, func=gcd)\n\ndef check(n, alpha, omega, x):\n\twhile alpha < omega:\n\t\tmid = (alpha + omega) // 2\n\t\tleft = st.query(alpha, mid)\n\t\tright = st.query(mid + 1, omega)\n\t\tif left % x and right % x:\n\t\t\treturn False\n\t\tif not left % x and (not right % x):\n\t\t\treturn True\n\t\tif not left % x and n == 500000 or left % x != 0:\n\t\t\tomega = mid\n\t\telse:\n\t\t\talpha = mid + 1\n\treturn True\nfor _ in range(int(input())):\n\ts = map(int, input().split())\n\ts = list(s)\n\tif len(s) == 4:\n\t\t(p, l, r, x) = s\n\t\tprint('YES' if check(n, l - 1, r - 1, x) else 'NO')\n\telse:\n\t\t(p, i, y) = s\n\t\tst.update(i - 1, y)\n"
    },
    {
        "task_id": 794,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 2.5636065006256104,
        "fastest_time": 2.4704434871673584,
        "fastest_solution": "import operator\n\nclass pa:\n\n\tdef __init__(self, b, i):\n\t\tself.b = b\n\t\tself.i = i\nn = int(input())\na = list(map(int, input().strip().split(' ')))\nb = list(map(int, input().strip().split(' ')))\na.sort()\nm = []\nfor i in range(n):\n\ttp = pa(b[i], i)\n\tm.append(tp)\nm.sort(key=operator.attrgetter('b'))\nc = [0] * n\nfor i in range(n):\n\tc[m[i].i] = a[n - i - 1]\nout = ''\nfor i in range(n):\n\tout += str(c[i]) + ' '\nprint(out)\n",
        "slowest_solution": "def main():\n\tn = int(input())\n\taa = sorted(map(int, input().split()), reverse=True)\n\tbb = list(map(int, input().split()))\n\tij = sorted(list(range(n)), key=bb.__getitem__)\n\tfor (i, j) in enumerate(ij):\n\t\tbb[j] = aa[i]\n\tprint(' '.join(map(str, bb)))\n\ndef __starting_point():\n\tmain()\n__starting_point()\n"
    },
    {
        "task_id": 789,
        "slowest_solution_id": 4,
        "fastest_solution_id": 6,
        "slowest_time": 2.5772831439971924,
        "fastest_time": 2.4484081268310547,
        "fastest_solution": "import sys\nfrom io import BytesIO, IOBase\nfrom collections import defaultdict, deque\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\timport os\n\t\tself.os = os\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\t\tself.BUFSIZE = 8192\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tself.os.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef get_int():\n\treturn int(input())\n\ndef get_ints():\n\treturn list(map(int, input().split(' ')))\n\ndef get_int_grid(n):\n\treturn [get_ints() for _ in range(n)]\n\ndef get_str():\n\treturn input().strip()\n\ndef get_strs():\n\treturn get_str().split(' ')\n\ndef flat_list(arr):\n\treturn [item for subarr in arr for item in subarr]\n\ndef yes_no(b):\n\tif b:\n\t\treturn 'YES'\n\telse:\n\t\treturn 'NO'\n\ndef binary_search(good, left, right, delta=1, right_true=False):\n\tlimits = [left, right]\n\twhile limits[1] - limits[0] > delta:\n\t\tif delta == 1:\n\t\t\tmid = sum(limits) // 2\n\t\telse:\n\t\t\tmid = sum(limits) / 2\n\t\tif good(mid):\n\t\t\tlimits[int(right_true)] = mid\n\t\telse:\n\t\t\tlimits[int(~right_true)] = mid\n\tif good(limits[int(right_true)]):\n\t\treturn limits[int(right_true)]\n\telse:\n\t\treturn False\n\ndef prefix_sums(a):\n\tp = [0]\n\tfor x in a:\n\t\tp.append(p[-1] + x)\n\treturn p\n\ndef solve_a():\n\tn = get_int()\n\td = get_int()\n\te = get_int()\n\tbest = float('inf')\n\twhile n >= 0:\n\t\tbest = min(best, n % d)\n\t\tn -= 5 * e\n\treturn best\n\ndef solve_b():\n\tb = get_int()\n\tg = get_int()\n\tn = get_int()\n\treturn min(b, n) - max(0, n - g) + 1\n\ndef solve_c():\n\tn = get_int()\n\ts = get_str()\n\topen = 0\n\tfor (idx, char) in enumerate(s):\n\t\tif char == '(':\n\t\t\topen += 1\n\t\telse:\n\t\t\topen -= 1\n\t\tif open < -1:\n\t\t\treturn False\n\treturn open == 0\n\ndef solve_d():\n\t(n, m) = get_ints()\n\tgrid = [['#'] * (m + 2)]\n\tfor row in range(n):\n\t\tgrid.append(['#'] + list(get_str()) + ['#'])\n\tgrid.append(['#'] * (m + 2))\n\tif n > 5 * 10 ** 5:\n\t\tfor i in range(n):\n\t\t\tif grid[i + 1][1] == '#':\n\t\t\t\treturn 0\n\t\treturn 1\n\tif m > 5 * 10 ** 5:\n\t\tfor j in range(m):\n\t\t\tif grid[1][j + 1] == '#':\n\t\t\t\treturn 0\n\t\treturn 1\n\tqueue = deque([(1, 1)])\n\tvis_forward = [[0] * (m + 2) for _ in range(n + 2)]\n\twhile queue:\n\t\t(x, y) = queue.popleft()\n\t\tif not vis_forward[x][y]:\n\t\t\tvis_forward[x][y] = 1\n\t\t\tif grid[x + 1][y] == '.':\n\t\t\t\tqueue.append((x + 1, y))\n\t\t\tif grid[x][y + 1] == '.':\n\t\t\t\tqueue.append((x, y + 1))\n\tback_queue = deque([(n, m)])\n\tvis_backward = [[0] * (m + 2) for _ in range(n + 2)]\n\twhile back_queue:\n\t\t(x, y) = back_queue.popleft()\n\t\tif not vis_backward[x][y]:\n\t\t\tvis_backward[x][y] = 1\n\t\t\tif grid[x - 1][y] == '.':\n\t\t\t\tback_queue.append((x - 1, y))\n\t\t\tif grid[x][y - 1] == '.':\n\t\t\t\tback_queue.append((x, y - 1))\n\tscore = [0] * (n + m - 1)\n\tif not vis_forward[n][m] or not vis_backward[1][1]:\n\t\treturn 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tscore[i + j] += vis_forward[i + 1][j + 1] * vis_backward[i + 1][j + 1]\n\tif not max(score[0], score[-1]):\n\t\treturn 0\n\telse:\n\t\treturn min(2, min(score[1:-1]))\nprint(solve_d())\n",
        "slowest_solution": "import sys\n(n, m) = map(int, input().split())\no_map = ['.' * (m + 2)]\no_map.extend(['.' + sys.stdin.readline() + '.' for i in range(n)])\no_map.append(['.' * (m + 2)])\nf_method = [[0] * (m + 2) for i in range(n + 2)]\nr_method = [[0] * (m + 2) for i in range(n + 2)]\nMOD = 10 ** 9 + 93\nf_method[1][1] = 1\nfor i in range(1, n + 1):\n\tfor j in range(1, m + 1):\n\t\tif o_map[i][j] == '.' and i + j != 2:\n\t\t\tf_method[i][j] = (f_method[i - 1][j] + f_method[i][j - 1]) % MOD\nr_method[n][m] = 1\nfor i in range(n, 0, -1):\n\tfor j in range(m, 0, -1):\n\t\tif o_map[i][j] == '.' and i + j != m + n:\n\t\t\tr_method[i][j] = (r_method[i + 1][j] + r_method[i][j + 1]) % MOD\nif f_method[n][m] == 0:\n\tprint(0)\nelse:\n\tfor i in range(1, n + 1):\n\t\tfor j in range(1, m + 1):\n\t\t\tif i + j in [2, m + n]:\n\t\t\t\tcontinue\n\t\t\tif f_method[i][j] * r_method[i][j] % MOD == f_method[n][m]:\n\t\t\t\tprint(1)\n\t\t\t\texit()\n\tprint(2)\n"
    },
    {
        "task_id": 784,
        "slowest_solution_id": 4,
        "fastest_solution_id": 7,
        "slowest_time": 2.6210944652557373,
        "fastest_time": 2.422520875930786,
        "fastest_solution": "from collections import defaultdict\nfor i in range(int(input())):\n\tx = input()\n\tcnt = len(set([i for i in x]))\n\tcurrent = defaultdict(lambda : 0)\n\tc = 0\n\tmn = len(x)\n\ts = 0\n\tfor j in range(len(x)):\n\t\tcurrent[x[j]] += 1\n\t\tif current[x[j]] == 1:\n\t\t\tc += 1\n\t\tif c == cnt:\n\t\t\twhile current[x[s]] > 1:\n\t\t\t\tif current[x[s]] > 1:\n\t\t\t\t\tcurrent[x[s]] -= 1\n\t\t\t\ts += 1\n\t\t\tw = j - s + 1\n\t\t\tif mn > w:\n\t\t\t\tmn = w\n\tif mn < 3:\n\t\tprint(0)\n\telse:\n\t\tprint(mn)\n",
        "slowest_solution": "from collections import deque\nt = int(input())\nfor _ in range(t):\n\ts = input()\n\ti = 0\n\tj = 0\n\tidxs = [deque(), deque(), deque()]\n\tcur_min = -1\n\twhile j <= len(s):\n\t\tif len(idxs[0]) > 0 and len(idxs[1]) > 0 and (len(idxs[2]) > 0):\n\t\t\tlast_j = j - k\n\t\t\t(l, r) = idxs[int(s[i]) - 1].popleft()\n\t\t\tif cur_min == -1:\n\t\t\t\tcur_min = last_j - r\n\t\t\telse:\n\t\t\t\tcur_min = min(cur_min, last_j - r)\n\t\t\ti = r + 1\n\t\t\tif i >= len(s) or j >= len(s):\n\t\t\t\tbreak\n\t\tif j == len(s):\n\t\t\tbreak\n\t\tif s[i] == s[j] and j != 0:\n\t\t\t(l, r) = idxs[int(s[j]) - 1].popleft()\n\t\t\ti = r + 1\n\t\tk = 0\n\t\twhile j + k < len(s) and s[j] == s[j + k]:\n\t\t\tk += 1\n\t\tidxs[int(s[j]) - 1].append((j, j + k - 1))\n\t\tj += k\n\tprint(cur_min + 1)\n"
    },
    {
        "task_id": 835,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 0.0015072822570800781,
        "fastest_time": 0.0,
        "fastest_solution": "import re\n\ndef bears(n, s):\n\ta = re.findall('B8|8B', s)\n\treturn [''.join(a), len(a) >= n]\n",
        "slowest_solution": "from regex import findall\n\ndef bears(x, s):\n\tres = findall('(B8|8B)', s)\n\treturn [''.join(res), len(res) >= x]\n"
    },
    {
        "task_id": 787,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 2.681859254837036,
        "fastest_time": 2.4306633472442627,
        "fastest_solution": "def simplify(a, b):\n\tF = [a, b]\n\tif a > b:\n\t\t(a, b) = (b, a)\n\twhile a > 0:\n\t\t(a, b) = (b % a, a)\n\tF = [F[0] // b, F[1] // b]\n\treturn F\nN = int(input())\nfor n in range(0, N):\n\t(A, B, C) = [int(x) for x in input().strip().split(' ')]\n\tif A > B:\n\t\t(A, B) = (B, A)\n\tif C <= 0:\n\t\tprint('{}/{}'.format(0, 1))\n\t\tcontinue\n\tif C >= A + B:\n\t\tprint('{}/{}'.format(1, 1))\n\t\tcontinue\n\tif C <= A:\n\t\tF = simplify(C * C, 2 * A * B)\n\t\tprint('{}/{}'.format(F[0], F[1]))\n\t\tcontinue\n\tif C >= B:\n\t\tF = simplify(2 * A * B - (A + B - C) * (A + B - C), 2 * A * B)\n\t\tprint('{}/{}'.format(F[0], F[1]))\n\t\tcontinue\n\tF = simplify(2 * A * C - A * A, 2 * A * B)\n\tprint('{}/{}'.format(F[0], F[1]))\n\tcontinue\n",
        "slowest_solution": "from itertools import product\nfrom fractions import Fraction\nfor t in range(int(input())):\n\ttmp = input().split()\n\t(A, B, C) = [int(i) for i in tmp]\n\tif A + B <= C:\n\t\tfr = Fraction(1, 1)\n\telif C <= A and C <= B:\n\t\tfr = Fraction(C ** 2, 2 * A * B)\n\telif C <= B:\n\t\tfr = Fraction(2 * C * A - A ** 2, 2 * A * B)\n\telif C <= A:\n\t\tfr = Fraction(2 * C * B - B ** 2, 2 * A * B)\n\telse:\n\t\tfr = Fraction(2 * C * (A + B) - A ** 2 - B ** 2 - C ** 2, 2 * A * B)\n\tprint(fr.numerator, '/', fr.denominator, sep='')\n"
    },
    {
        "task_id": 826,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.552488327026367,
        "fastest_time": 2.487170696258545,
        "fastest_solution": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef solve():\n\tn = int(input())\n\tpar = [-1 for _ in range(n + 2)]\n\tchild = [[] for _ in range(n + 2)]\n\tdegree = [0] * (n + 2)\n\tB = list(map(int, input().split()))\n\trg = [0, n]\n\tfor i in range(n):\n\t\tif B[i] > i + 1:\n\t\t\trg[0] = max(rg[0], i + 1)\n\t\telif B[i] < i + 1:\n\t\t\trg[1] = min(rg[1], i)\n\t\tpar[i + 1] = B[i]\n\t\tdegree[B[i]] += 1\n\t\tchild[B[i]].append(i + 1)\n\troot = 1\n\twhile par[root] >= 0:\n\t\troot = par[root]\n\tans = []\n\tq = deque([root])\n\twhile q:\n\t\tnode = q.popleft()\n\t\tif 1 <= node <= n:\n\t\t\tans.append(node)\n\t\ttmp = []\n\t\tfor ch in child[node]:\n\t\t\tif degree[ch] == 0:\n\t\t\t\tq.append(ch)\n\t\t\telse:\n\t\t\t\ttmp.append(ch)\n\t\twhile tmp:\n\t\t\tq.append(tmp.pop())\n\tprint(rg[0])\n\tprint(*ans)\n\treturn\nfor _ in range(int(input())):\n\tsolve()\n",
        "slowest_solution": "import sys\n\ndef solve():\n\tinp = sys.stdin.readline\n\tn = int(inp())\n\tb = list(map(int, inp().split()))\n\tg = [[] for i in range(n + 2)]\n\tfor i in range(n):\n\t\tg[b[i]].append(i + 1)\n\td = [-1] * (n + 2)\n\tq = [0, n + 1]\n\tres = []\n\tif len(g[0]):\n\t\tf = 1\n\telse:\n\t\tf = 0\n\tM = n + 5\n\tm = 0\n\twhile q:\n\t\tq.sort(key=lambda x: len(g[x]))\n\t\tres += q\n\t\tqn = []\n\t\tfor x in q:\n\t\t\tfor v in g[x]:\n\t\t\t\tif d[v] < 0:\n\t\t\t\t\td[v] = d[x] + 1\n\t\t\t\t\tqn.append(v)\n\t\t\t\t\tif f == 1:\n\t\t\t\t\t\tM = min(M, v)\n\t\t\t\t\telse:\n\t\t\t\t\t\tm = max(m, v)\n\t\tf ^= 1\n\t\tq = qn\n\tprint(m)\n\tprint(' '.join(map(str, res[2:])))\n\ndef main():\n\tfor i in range(int(sys.stdin.readline())):\n\t\tsolve()\nmain()\n"
    },
    {
        "task_id": 790,
        "slowest_solution_id": 9,
        "fastest_solution_id": 3,
        "slowest_time": 2.5906078815460205,
        "fastest_time": 2.4687156677246094,
        "fastest_solution": "import itertools\n\ndef solve_odd(n, h):\n\treturn sum((max(0, max(h[i - 1], h[i + 1]) + 1 - h[i]) for i in range(1, n, 2)))\n\ndef solve_even(n, h):\n\tf = [max(0, max(h[i - 1], h[i + 1]) + 1 - h[i]) for i in range(1, n - 1, 2)]\n\tb = [max(0, max(h[i - 1], h[i + 1]) + 1 - h[i]) for i in range(-2, -n, -2)]\n\tf = itertools.accumulate(f, initial=0)\n\tb = list(itertools.accumulate(b, initial=0))\n\treturn min((x + y for (x, y) in zip(f, reversed(b))))\nfor _ in range(int(input())):\n\tn = int(input())\n\th = list(map(int, input().split()))\n\tprint(solve_odd(n, h) if n % 2 == 1 else solve_even(n, h))\n",
        "slowest_solution": "def solve(heights):\n\tif len(heights) <= 2:\n\t\treturn 0\n\tif len(heights) % 2 == 1:\n\t\tans = 0\n\t\tfor i in range(1, len(heights) - 1, 2):\n\t\t\tans += max(max(heights[i - 1], heights[i + 1]) - heights[i] + 1, 0)\n\t\treturn ans\n\telse:\n\t\tcurr_floor = 0\n\t\tfor i in range(len(heights) - 2, 1, -2):\n\t\t\tcurr_floor += max(max(heights[i - 1], heights[i + 1]) - heights[i] + 1, 0)\n\t\tans = curr_floor\n\t\tfor i in range(1, len(heights) - 2, 2):\n\t\t\tcurr_floor += max(max(heights[i - 1], heights[i + 1]) - heights[i] + 1, 0) - max(max(heights[i], heights[i + 2]) - heights[i + 1] + 1, 0)\n\t\t\tans = min(ans, curr_floor)\n\t\treturn ans\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\theights = list(map(int, input().split()))\n\tprint(solve(heights))\n"
    },
    {
        "task_id": 840,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def sum_mix(arr):\n\treturn sum(map(int, arr))\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 792,
        "slowest_solution_id": 1,
        "fastest_solution_id": 6,
        "slowest_time": 2.5765979290008545,
        "fastest_time": 2.4476988315582275,
        "fastest_solution": "s1 = [i for i in input()]\ns2 = [i for i in input()]\ns3 = [i for i in input()]\nif sorted(s3) == sorted(s1 + s2):\n\tprint('YES')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "a = input()\nb = input()\nc = list(input())\nans = 'YES'\nfor i in a:\n\ttry:\n\t\tc.remove(i)\n\texcept:\n\t\tans = 'NO'\n\t\tbreak\nfor i in b:\n\ttry:\n\t\tc.remove(i)\n\texcept:\n\t\tans = 'NO'\n\t\tbreak\nif len(c) != 0:\n\tans = 'NO'\nprint(ans)\n"
    },
    {
        "task_id": 795,
        "slowest_solution_id": 8,
        "fastest_solution_id": 3,
        "slowest_time": 2.6920278072357178,
        "fastest_time": 2.434211254119873,
        "fastest_solution": "def main():\n\n\tdef f(x):\n\t\tl = []\n\t\twhile x != clusters[x]:\n\t\t\tl.append(x)\n\t\t\tx = clusters[x]\n\t\tfor y in l:\n\t\t\tclusters[y] = x\n\t\treturn x\n\t(n, aa) = (int(input()), [0, *map(int, input().split()), 0])\n\t(l, clusters, mx) = (list(map(int, input().split())), [0] * (n + 2), 0)\n\tfor i in range(n - 1, -1, -1):\n\t\ta = clusters[a] = l[i]\n\t\tl[i] = mx\n\t\tfor i in (a - 1, a + 1):\n\t\t\tif clusters[i]:\n\t\t\t\tj = f(i)\n\t\t\t\taa[a] += aa[j]\n\t\t\t\tclusters[j] = a\n\t\t\t\tf(i)\n\t\tif mx < aa[a]:\n\t\t\tmx = aa[a]\n\tprint('\\n'.join(map(str, l)))\nmain()\n",
        "slowest_solution": "from sys import stdin, stdout\nlines = stdin.readlines()\nn = int(lines[0])\na = [int(x) for x in lines[1].split()]\nb = [int(x) for x in lines[2].split()]\ncheck_array = [0 for i in range(n)]\nsnm = [i for i in range(n)]\nr = [1 for i in range(n)]\nsums = dict(list(zip(list(range(n)), a)))\n\ndef find_x(x):\n\tif snm[x] != x:\n\t\tsnm[x] = find_x(snm[x])\n\treturn snm[x]\n\ndef union(x_start, y_start):\n\tx = find_x(x_start)\n\ty = find_x(y_start)\n\tsums[x] += sums[y]\n\tsums[y] = sums[x]\n\tif x == y:\n\t\treturn x\n\tif r[x] == r[y]:\n\t\tr[x] += 1\n\tif r[x] < r[y]:\n\t\tsnm[x] = y\n\t\treturn y\n\telse:\n\t\tsnm[y] = x\n\t\treturn x\nmax_list = []\ntotal_max = 0\nfor i in range(n):\n\tcur_sum = 0\n\tflag = 0\n\tmax_list.append(total_max)\n\telem = b[n - i - 1] - 1\n\tcheck_array[elem] = 1\n\tif elem > 0:\n\t\tif check_array[elem - 1] == 1:\n\t\t\tpos = union(elem - 1, elem)\n\t\t\tcur_sum = sums[pos]\n\t\telse:\n\t\t\tflag += 1\n\telse:\n\t\tflag += 1\n\tif elem < n - 1:\n\t\tif check_array[elem + 1] == 1:\n\t\t\tpos = union(elem, elem + 1)\n\t\t\tcur_sum = sums[pos]\n\t\telse:\n\t\t\tflag += 1\n\telse:\n\t\tflag += 1\n\tif flag == 2:\n\t\ttotal_max = max(total_max, sums[elem])\n\telse:\n\t\ttotal_max = max(cur_sum, total_max)\nmax_list.append(total_max)\nfor j in range(1, n + 1):\n\tprint(max_list[n - j])\n"
    },
    {
        "task_id": 838,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.4892334938049316,
        "fastest_time": 2.4892334938049316,
        "fastest_solution": "import numpy as np\nfrom sys import stdin\nmod = 10 ** 9 + 7\n\ndef count(cur_pos, cur_cnt, cur_k, any_num_flag, num_lst, d, k):\n\tglobal dp\n\tif cur_pos == len(num_lst):\n\t\tif cur_k > 0 and cur_k - cur_cnt <= 0:\n\t\t\treturn 1\n\t\treturn 0\n\tif dp[cur_pos][cur_cnt][cur_k][any_num_flag] != -1:\n\t\treturn dp[cur_pos][cur_cnt][cur_k][any_num_flag]\n\tans = 0\n\tif any_num_flag:\n\t\tlimit = 9\n\telse:\n\t\tlimit = num_lst[cur_pos]\n\tfor dig in range(limit + 1):\n\t\ttmp_cur_cnt = cur_cnt\n\t\ttmp_cur_k = cur_k\n\t\tif dig == d:\n\t\t\ttmp_cur_cnt += 1\n\t\tif dig < d:\n\t\t\ttmp_cur_k -= 1\n\t\ttmp_any_num_flag = any_num_flag\n\t\tif dig < num_lst[cur_pos]:\n\t\t\ttmp_any_num_flag = 1\n\t\tans = (ans + count(cur_pos + 1, tmp_cur_cnt, max(0, tmp_cur_k), tmp_any_num_flag, num_lst, d, k)) % mod\n\tdp[cur_pos][cur_cnt][cur_k][any_num_flag] = ans\n\treturn dp[cur_pos][cur_cnt][cur_k][any_num_flag]\nM = 20\ndp = None\n\ndef get_count_dct(num, max_len):\n\tglobal dp\n\tM = max_len + 1\n\tnum_lst = []\n\twhile num:\n\t\tnum_lst.append(num % 10)\n\t\tnum //= 10\n\tnum_lst = num_lst + [0] * (max_len - len(num_lst))\n\tnum_lst = num_lst[::-1]\n\tdigit_loc_cnt = {}\n\tfor i in range(10):\n\t\tdp = np.full((M, M, M, 2), -1).tolist()\n\t\tfor j in range(max_len):\n\t\t\tdigit_loc_cnt[i, j] = count(0, 0, j + 1, 0, num_lst, i, j + 1)\n\treturn digit_loc_cnt\nprev_cnt = {}\nfor _ in range(int(stdin.readline())):\n\t(l, r) = map(int, stdin.readline().split())\n\tmax_len = len(str(r))\n\tif (l, max_len) in prev_cnt:\n\t\tl_count = prev_cnt[l, max_len]\n\telse:\n\t\tl_count = get_count_dct(l - 1, max_len)\n\t\tprev_cnt[l, max_len] = l_count\n\tif (r, max_len) in prev_cnt:\n\t\tr_count = prev_cnt[r, max_len]\n\telse:\n\t\tr_count = get_count_dct(r, max_len)\n\t\tprev_cnt[r, max_len] = r_count\n\tfin_count = {}\n\tfor x in l_count:\n\t\tfin_count[x] = r_count[x] - l_count[x]\n\tans = 0\n\tfor i in range(10):\n\t\tfor j in range(10):\n\t\t\tfor k in range(max_len):\n\t\t\t\tans = (ans + fin_count[i, k] * fin_count[j, k] * abs(i - j)) % mod\n\tprint(ans % mod)\n",
        "slowest_solution": "import numpy as np\nfrom sys import stdin\nmod = 10 ** 9 + 7\n\ndef count(cur_pos, cur_cnt, cur_k, any_num_flag, num_lst, d, k):\n\tglobal dp\n\tif cur_pos == len(num_lst):\n\t\tif cur_k > 0 and cur_k - cur_cnt <= 0:\n\t\t\treturn 1\n\t\treturn 0\n\tif dp[cur_pos][cur_cnt][cur_k][any_num_flag] != -1:\n\t\treturn dp[cur_pos][cur_cnt][cur_k][any_num_flag]\n\tans = 0\n\tif any_num_flag:\n\t\tlimit = 9\n\telse:\n\t\tlimit = num_lst[cur_pos]\n\tfor dig in range(limit + 1):\n\t\ttmp_cur_cnt = cur_cnt\n\t\ttmp_cur_k = cur_k\n\t\tif dig == d:\n\t\t\ttmp_cur_cnt += 1\n\t\tif dig < d:\n\t\t\ttmp_cur_k -= 1\n\t\ttmp_any_num_flag = any_num_flag\n\t\tif dig < num_lst[cur_pos]:\n\t\t\ttmp_any_num_flag = 1\n\t\tans = (ans + count(cur_pos + 1, tmp_cur_cnt, max(0, tmp_cur_k), tmp_any_num_flag, num_lst, d, k)) % mod\n\tdp[cur_pos][cur_cnt][cur_k][any_num_flag] = ans\n\treturn dp[cur_pos][cur_cnt][cur_k][any_num_flag]\nM = 20\ndp = None\n\ndef get_count_dct(num, max_len):\n\tglobal dp\n\tM = max_len + 1\n\tnum_lst = []\n\twhile num:\n\t\tnum_lst.append(num % 10)\n\t\tnum //= 10\n\tnum_lst = num_lst + [0] * (max_len - len(num_lst))\n\tnum_lst = num_lst[::-1]\n\tdigit_loc_cnt = {}\n\tfor i in range(10):\n\t\tdp = np.full((M, M, M, 2), -1).tolist()\n\t\tfor j in range(max_len):\n\t\t\tdigit_loc_cnt[i, j] = count(0, 0, j + 1, 0, num_lst, i, j + 1)\n\treturn digit_loc_cnt\nprev_cnt = {}\nfor _ in range(int(stdin.readline())):\n\t(l, r) = map(int, stdin.readline().split())\n\tmax_len = len(str(r))\n\tif (l, max_len) in prev_cnt:\n\t\tl_count = prev_cnt[l, max_len]\n\telse:\n\t\tl_count = get_count_dct(l - 1, max_len)\n\t\tprev_cnt[l, max_len] = l_count\n\tif (r, max_len) in prev_cnt:\n\t\tr_count = prev_cnt[r, max_len]\n\telse:\n\t\tr_count = get_count_dct(r, max_len)\n\t\tprev_cnt[r, max_len] = r_count\n\tfin_count = {}\n\tfor x in l_count:\n\t\tfin_count[x] = r_count[x] - l_count[x]\n\tans = 0\n\tfor i in range(10):\n\t\tfor j in range(10):\n\t\t\tfor k in range(max_len):\n\t\t\t\tans = (ans + fin_count[i, k] * fin_count[j, k] * abs(i - j)) % mod\n\tprint(ans % mod)\n"
    },
    {
        "task_id": 844,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 0.005505800247192383,
        "fastest_time": 0.0,
        "fastest_solution": "def find_lowest_int(k):\n\treturn next((n for n in range(9, 9999999, 9) if sorted(str(n * k)) == sorted(str(n * (k + 1)))))\n",
        "slowest_solution": "from itertools import count as c\n\ndef find_lowest_int(k):\n\treturn next((n for n in c(1) if sorted(str(n * k)) == sorted(str(n * (k + 1)))))\n"
    },
    {
        "task_id": 796,
        "slowest_solution_id": 7,
        "fastest_solution_id": 3,
        "slowest_time": 2.647036075592041,
        "fastest_time": 2.434753179550171,
        "fastest_solution": "(n, k) = map(int, input().split())\nl = list(map(int, input().split()))\nstk = []\nf = 1\nfor i in range(n):\n\twhile len(stk) != 0 and l[i] < l[stk[-1]]:\n\t\tf = f * (i - stk.pop() + 1) % 1000000007\n\tstk.append(i)\nprint(f)\n",
        "slowest_solution": "(n, k) = map(int, input().split())\narr = list(map(int, input().split()))\nm = 1000000007\ns = []\ntotal = 1\ni = n - 1\nwhile i >= 0:\n\te = arr[i]\n\twhile s and arr[s[-1]] >= e:\n\t\ts.pop()\n\tif s:\n\t\ttotal = total % m * (s[-1] - i + 1) % m % m\n\ts.append(i)\n\ti -= 1\nprint(total)\n"
    },
    {
        "task_id": 798,
        "slowest_solution_id": 7,
        "fastest_solution_id": 4,
        "slowest_time": 2.6052491664886475,
        "fastest_time": 2.4650728702545166,
        "fastest_solution": "from collections import defaultdict\nfor _ in range(int(input())):\n\tinput()\n\ta = input()\n\tb = input()\n\t(posa, ans) = (defaultdict(list), 0)\n\tif any((x > y for (x, y) in zip(a, b))):\n\t\tprint(-1)\n\t\tcontinue\n\tfor (i, x) in enumerate(a):\n\t\tposa[x].append(i)\n\tfor c in sorted(set(a) | set(b)):\n\t\t(m, n) = ('t', [])\n\t\tfor i in posa[c]:\n\t\t\tif b[i] == c:\n\t\t\t\tcontinue\n\t\t\tm = min(m, b[i])\n\t\t\tn.append(i)\n\t\tif n:\n\t\t\tposa[m].extend(n)\n\t\t\tans += 1\n\tprint(ans)\n",
        "slowest_solution": "t = int(input())\nwhile t:\n\tt = t - 1\n\tn = int(input())\n\ta = list(input())\n\tb = input()\n\tcnt = 0\n\tmf = 0\n\tfor i in range(n):\n\t\tif a[i] > b[i]:\n\t\t\tmf = 1\n\t\t\tbreak\n\tif mf:\n\t\tprint(-1)\n\t\tcontinue\n\tfor i in range(97, 97 + 20):\n\t\tl = []\n\t\tind = []\n\t\tx = chr(i)\n\t\tfor j in range(n):\n\t\t\tif a[j] != b[j] and a[j] == x:\n\t\t\t\tind.append(j)\n\t\t\t\tl.append(b[j])\n\t\tflag = 0\n\t\tif len(l) != 0:\n\t\t\tm = min(l)\n\t\t\tfor j in ind:\n\t\t\t\ta[j] = m\n\t\t\t\tflag = 1\n\t\tif flag:\n\t\t\tcnt += 1\n\tprint(cnt)\n"
    },
    {
        "task_id": 808,
        "slowest_solution_id": 6,
        "fastest_solution_id": 3,
        "slowest_time": 2.602747917175293,
        "fastest_time": 2.4268696308135986,
        "fastest_solution": "from sys import stdin\nimport math\nstrA = [-1 for i in range(27)]\nstrB = [-1 for i in range(27)]\n\ndef clear():\n\tfor i in range(27):\n\t\tstrA[i] = strB[i] = -1\n\ndef check(Ln_Lm):\n\tif Ln_Lm < 0:\n\t\treturn -1 * Ln_Lm\n\treturn Ln_Lm\n\ndef calcUgly(L1, L2, L3, L4):\n\tL1_L2 = L1 - L2\n\tL2_L3 = L2 - L3\n\tL3_L4 = L3 - L4\n\tL4_L1 = L4 - L1\n\tugliness = math.fabs(L1_L2) + math.fabs(L2_L3) + math.fabs(L3_L4) + math.fabs(L4_L1)\n\treturn int(ugliness)\n\ndef parseString(str, arr, length):\n\tind1 = ind2 = length // 2\n\twhile ind1 >= 0 and ind2 < length:\n\t\tif arr[ord(str[ind1]) - ord('A')] == -1:\n\t\t\tarr[ord(str[ind1]) - ord('A')] = ind1\n\t\tif arr[ord(str[ind2]) - ord('A')] == -1:\n\t\t\tarr[ord(str[ind2]) - ord('A')] = ind2\n\t\tind1 -= 1\n\t\tind2 += 1\n\twhile ind1 >= 0:\n\t\tif arr[ord(str[ind1]) - ord('A')] == -1:\n\t\t\tarr[ord(str[ind1]) - ord('A')] = ind1\n\t\tind1 -= 1\n\twhile ind2 < length:\n\t\tif arr[ord(str[ind2]) - ord('A')] == -1:\n\t\t\tarr[ord(str[ind2]) - ord('A')] = ind2\n\t\tind2 += 1\n\ndef solve():\n\tT = int(stdin.readline().strip())\n\tfor t in range(T):\n\t\tS1 = stdin.readline().strip()\n\t\tS2 = stdin.readline().strip()\n\t\tlen1 = len(S1)\n\t\tlen2 = len(S2)\n\t\tparseString(S1, strA, len1)\n\t\tparseString(S2, strB, len2)\n\t\tminUgly = len1 + len2\n\t\tfor i in range(26):\n\t\t\tif strA[i] != -1 and strB[i] != -1:\n\t\t\t\tcurrUgly = calcUgly(strA[i], len2 - strB[i] - 1, len1 - strA[i] - 1, strB[i])\n\t\t\t\tif currUgly < minUgly:\n\t\t\t\t\tminUgly = currUgly\n\t\tprint(minUgly)\n\t\tclear()\nsolve()\n",
        "slowest_solution": "T = int(input())\nfor t in range(T):\n\tS1 = list(input().strip())\n\tS2 = list(input().strip())\n\tn1 = len(S1)\n\tn2 = len(S2)\n\tc1 = [-1] * 26\n\ti = 0\n\twhile i < (n1 + 1) // 2:\n\t\tc1[ord(S1[i]) - 65] = i\n\t\tc1[ord(S1[n1 - i - 1]) - 65] = i\n\t\ti += 1\n\tc2 = [-1] * 26\n\ti = 0\n\twhile i < (n2 + 1) // 2:\n\t\tc2[ord(S2[i]) - 65] = i\n\t\tc2[ord(S2[n2 - i - 1]) - 65] = i\n\t\ti += 1\n\tclose = 1000000000.0\n\tfor i in range(26):\n\t\tL1 = c1[i]\n\t\tL2 = c2[i]\n\t\tif L1 == -1 or L2 == -1:\n\t\t\tcontinue\n\t\tL3 = n1 - c1[i] - 1\n\t\tL4 = n2 - c2[i] - 1\n\t\tclose = min(abs(L1 - L2) + abs(L2 - L3) + abs(L3 - L4) + abs(L4 - L1), close)\n\tprint(close)\n"
    },
    {
        "task_id": 818,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 2.577533483505249,
        "fastest_time": 2.4873454570770264,
        "fastest_solution": "from sys import stdout\n\ndef g(k, p):\n\tprint(str(k) + '\\n' + ' '.join(map(str, p)))\n\tstdout.flush()\nn = int(input())\ns = [9000000000.0] * n\n\ndef f(q):\n\tglobal s\n\tp = [k + 1 for (k, v) in enumerate(q) if v]\n\tg(len(p), p)\n\ts = [i if j else min(i, int(k)) for (i, j, k) in zip(s, q, input().split())]\n\treturn [not v for v in q]\nk = 1\nwhile k < n:\n\tf(f([not i & k for i in range(n)]))\n\tk *= 2\ng(-1, s)\n",
        "slowest_solution": "import math, sys, re, itertools, pprint, collections, copy\n(rs, ri, rai, raf) = (input, lambda : int(input()), lambda : list(map(int, input().split())), lambda : list(map(float, input().split())))\npai = lambda x: print(' '.join(map(str, x)))\nn = ri()\nline_min = [float('inf') for _ in range(n)]\nrequests = []\n\ndef init_requests():\n\trequests.append([[(1, n // 2)], [(n // 2 + 1, n)]])\n\twhile True:\n\t\t(l, r) = requests[-1]\n\t\t(ln, rn) = ([], [])\n\t\tfor (i, j) in l + r:\n\t\t\tif j - i > 0:\n\t\t\t\tln.append((i, (i + j) // 2))\n\t\t\t\trn.append(((i + j) // 2 + 1, j))\n\t\tif len(ln) == 0 and len(rn) == 0:\n\t\t\tbreak\n\t\trequests.append([ln, rn])\n\ndef make_request(a: list):\n\tprint(len(a))\n\tprint(' '.join(map(str, a)))\n\tsys.stdout.flush()\n\tans = rai()\n\tfor i in range(n):\n\t\tif i + 1 not in a:\n\t\t\tline_min[i] = min(line_min[i], ans[i])\ninit_requests()\nfor (l, r) in requests:\n\tla = []\n\tfor lr in l:\n\t\tla += list(range(lr[0], lr[1] + 1))\n\tmake_request(la)\n\tra = []\n\tfor rr in r:\n\t\tra += list(range(rr[0], rr[1] + 1))\n\tmake_request(ra)\nprint(-1)\npai(line_min)\n"
    },
    {
        "task_id": 812,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 10.92992115020752,
        "fastest_time": 8.823260307312012,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\na = [tuple(map(int, input().split())) for i in range(n)]\nq = [tuple(map(int, input().split())) for j in range(m)]\na.sort(key=lambda x: x[1], reverse=True)\nrng = 5 * 10 ** 5 + 1\nidx = 0\ndbl = [[0] * rng for j in range(20)]\nfor i in range(rng)[::-1]:\n\tif i > a[0][1]:\n\t\tcontinue\n\twhile idx <= n - 1 and i < a[idx][0]:\n\t\tidx += 1\n\tif idx == n:\n\t\tbreak\n\tif a[idx][0] <= i <= a[idx][1]:\n\t\tdbl[0][i] = a[idx][1]\nfor i in range(1, 20):\n\tfor j in range(rng):\n\t\tdbl[i][j] = dbl[i - 1][dbl[i - 1][j]]\nfor (l, r) in q:\n\tif dbl[-1][l] < r:\n\t\tprint(-1)\n\t\tcontinue\n\tans = 0\n\tfor i in range(20)[::-1]:\n\t\tif dbl[i][l] < r:\n\t\t\tans += 2 ** i\n\t\t\tl = dbl[i][l]\n\tprint(ans + 1)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n(N, M) = map(int, input().split())\n(MA, lg) = (1 << 19, 20)\nA = []\nfor _ in range(N):\n\t(l, r) = map(int, input().split())\n\tA.append([l, r])\nX = [[-1] * MA for i in range(lg)]\nfor i in range(N):\n\tX[0][A[i][0]] = max(X[0][A[i][0]], A[i][1])\nfor i in range(1, MA):\n\tX[0][i] = max(X[0][i], X[0][i - 1])\nfor k in range(1, lg):\n\tfor i in range(MA):\n\t\ta = X[k - 1][i]\n\t\tif a >= 0:\n\t\t\tX[k][i] = X[k - 1][a]\nfor _ in range(M):\n\t(a, b) = map(int, input().split())\n\tans = 1\n\tfor k in range(lg)[::-1]:\n\t\tif X[k][a] < b:\n\t\t\ta = X[k][a]\n\t\t\tans += 2 ** k\n\tprint(-1 if X[0][a] < b or ans > MA else ans)\n"
    },
    {
        "task_id": 804,
        "slowest_solution_id": 6,
        "fastest_solution_id": 2,
        "slowest_time": 2.6408960819244385,
        "fastest_time": 2.412205219268799,
        "fastest_solution": "n = int(input())\na = list(map(int, input().split()))\n\ndef findMinimumL(a):\n\tA = [-1] * len(a)\n\tfor (i, x) in enumerate(a):\n\t\tj = i - 1\n\t\twhile j != -1 and a[j] > a[i]:\n\t\t\tj = A[j]\n\t\tA[i] = j\n\treturn A\n\ndef findMaximumL(a):\n\tA = [-1] * len(a)\n\tfor (i, x) in enumerate(a):\n\t\tj = i - 1\n\t\twhile j != -1 and a[j] < a[i]:\n\t\t\tj = A[j]\n\t\tA[i] = j\n\treturn A\n\ndef findMinimumR(a):\n\tA = [-1] * len(a)\n\tfor i in range(len(a) - 1, -1, -1):\n\t\tj = i + 1\n\t\twhile j != len(a) and a[j] >= a[i]:\n\t\t\tj = A[j]\n\t\tA[i] = j\n\treturn A\n\ndef findMaximumR(a):\n\tA = [-1] * len(a)\n\tfor i in range(len(a) - 1, -1, -1):\n\t\tj = i + 1\n\t\twhile j != len(a) and a[j] <= a[i]:\n\t\t\tj = A[j]\n\t\tA[i] = j\n\treturn A\n\ndef minimumSum():\n\t(L, R) = (findMinimumL(a), findMinimumR(a))\n\tans = 0\n\tfor (i, x) in enumerate(a):\n\t\tans += (i - L[i]) * (R[i] - i) * x\n\treturn ans\n\ndef maximumSums():\n\t(L, R) = (findMaximumL(a), findMaximumR(a))\n\tans = 0\n\tfor (i, x) in enumerate(a):\n\t\tans += (i - L[i]) * (R[i] - i) * x\n\treturn ans\nprint(maximumSums() - minimumSum())\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().split()))\nstk = [(float('-inf'), int(-1))]\nstk1 = [(float('inf'), int(-1))]\nleftSmaller = []\nleftGreater = []\nfor (i, a) in enumerate(A):\n\twhile stk[-1][0] > a:\n\t\tstk.pop()\n\tleftSmaller.append(stk[-1][1])\n\tstk.append((a, i))\n\twhile stk1[-1][0] <= a:\n\t\tstk1.pop()\n\tleftGreater.append(stk1[-1][1])\n\tstk1.append((a, i))\nstk = [(float('-inf'), int(N))]\nstk1 = [(float('inf'), int(N))]\nrightSmaller = []\nrightGreater = []\nfor i in range(N - 1, -1, -1):\n\ta = A[i]\n\twhile stk[-1][0] >= a:\n\t\tstk.pop()\n\trightSmaller.append(stk[-1][1])\n\tstk.append((a, i))\n\twhile stk1[-1][0] < a:\n\t\tstk1.pop()\n\trightGreater.append(stk1[-1][1])\n\tstk1.append((a, i))\nrightGreater.reverse()\nrightSmaller.reverse()\nans = 0\nfor (i, a) in enumerate(A):\n\tans += a * ((rightGreater[i] - i) * (i - leftGreater[i]) - (rightSmaller[i] - i) * (i - leftSmaller[i]))\nprint(ans)\n"
    },
    {
        "task_id": 846,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.5509588718414307,
        "fastest_time": 2.5509588718414307,
        "fastest_solution": "tenonehun = 1\nfor i in range(100):\n\ttenonehun = tenonehun * 10 % 1000000007\nfor tests in range(int(input())):\n\t[N, K] = [int(i) for i in input().split()]\n\tarange = {}\n\tfor i in range(N):\n\t\t[X, D] = [int(i) for i in input().split()]\n\t\ttry:\n\t\t\tarange[X * D] += 1\n\t\texcept:\n\t\t\tarange[X * D] = 1\n\t\ttry:\n\t\t\tarange[X * (D + 1)] -= 1\n\t\texcept:\n\t\t\tarange[X * (D + 1)] = -1\n\tth = N - K\n\tcum = 0\n\tL = list(arange)\n\tL.sort()\n\tprev = 0\n\tAs = 0\n\tfor i in L:\n\t\tif cum >= th:\n\t\t\tAs = (As + i - prev) % 1000000007\n\t\tcum += arange[i]\n\t\tprev = i\n\tif cum >= th:\n\t\tAs = (As + tenonehun + 1 - prev) % 1000000007\n\tprint(As)\n",
        "slowest_solution": "tenonehun = 1\nfor i in range(100):\n\ttenonehun = tenonehun * 10 % 1000000007\nfor tests in range(int(input())):\n\t[N, K] = [int(i) for i in input().split()]\n\tarange = {}\n\tfor i in range(N):\n\t\t[X, D] = [int(i) for i in input().split()]\n\t\ttry:\n\t\t\tarange[X * D] += 1\n\t\texcept:\n\t\t\tarange[X * D] = 1\n\t\ttry:\n\t\t\tarange[X * (D + 1)] -= 1\n\t\texcept:\n\t\t\tarange[X * (D + 1)] = -1\n\tth = N - K\n\tcum = 0\n\tL = list(arange)\n\tL.sort()\n\tprev = 0\n\tAs = 0\n\tfor i in L:\n\t\tif cum >= th:\n\t\t\tAs = (As + i - prev) % 1000000007\n\t\tcum += arange[i]\n\t\tprev = i\n\tif cum >= th:\n\t\tAs = (As + tenonehun + 1 - prev) % 1000000007\n\tprint(As)\n"
    },
    {
        "task_id": 842,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.697598934173584,
        "fastest_time": 2.3301608562469482,
        "fastest_solution": "import sys\ninp = list(map(int, sys.stdin.buffer.read().split()))\n(n, m) = inp[:2]\na = set(inp[2:])\ny = 2 ** n\nmk = [0] * (2 * y)\ncur = 0\nfor x in a:\n\tif mk[x]:\n\t\tcontinue\n\tmk[x] = 1\n\tst = [x]\n\n\tdef push(v):\n\t\tif not mk[v]:\n\t\t\tmk[v] = 1\n\t\t\tst.append(v)\n\twhile st:\n\t\tu = st.pop()\n\t\tif u < y:\n\t\t\tpush(y + u)\n\t\telse:\n\t\t\tfor b in range(n):\n\t\t\t\tv = u | 1 << b\n\t\t\t\tpush(v)\n\t\t\tv = y - 1 - (u - y)\n\t\t\tif v in a:\n\t\t\t\tpush(v)\n\tcur += 1\nprint(cur)\n",
        "slowest_solution": "(n, m) = map(int, input().split())\na = set(map(int, input().split()))\ny = 2 ** n\nmk = [0] * (2 * y)\ncur = 0\nfor x in a:\n\tif mk[x]:\n\t\tcontinue\n\tmk[x] = 1\n\tst = [x]\n\twhile st:\n\t\tu = st.pop()\n\t\tif u < y:\n\t\t\tif not mk[y + u]:\n\t\t\t\tmk[y + u] = 1\n\t\t\t\tst.append(y + u)\n\t\telse:\n\t\t\tfor b in range(n):\n\t\t\t\tv = u | 1 << b\n\t\t\t\tif u < v and (not mk[v]):\n\t\t\t\t\tmk[v] = 1\n\t\t\t\t\tst.append(v)\n\t\t\tv = y - 1 - (u - y)\n\t\t\tif v in a and (not mk[v]):\n\t\t\t\tmk[v] = 1\n\t\t\t\tst.append(v)\n\tcur += 1\nprint(cur)\n"
    },
    {
        "task_id": 833,
        "slowest_solution_id": 6,
        "fastest_solution_id": 6,
        "slowest_time": 2.5511584281921387,
        "fastest_time": 2.5511584281921387,
        "fastest_solution": "(n, m) = map(int, input().split())\ng = [set() for i in range(n)]\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tg[a - 1].add(b - 1)\n\tg[b - 1].add(a - 1)\na = []\np = [-1] * n\nfor i in range(n):\n\tif p[i] != -1:\n\t\tcontinue\n\tp[i] = 0\n\ta.append(i)\n\twhile a:\n\t\tx = a.pop()\n\t\tfor elem in g[x]:\n\t\t\tif p[elem] == p[x]:\n\t\t\t\tprint(-1)\n\t\t\t\texit(0)\n\t\t\tif p[elem] == -1:\n\t\t\t\tp[elem] = not p[x]\n\t\t\t\ta.append(elem)\nprint(p.count(0))\nfor i in range(n):\n\tif p[i] == 0:\n\t\tprint(i + 1, end=' ')\nprint()\nprint(p.count(1))\nfor i in range(n):\n\tif p[i] == 1:\n\t\tprint(i + 1, end=' ')\n",
        "slowest_solution": "(n, m) = map(int, input().split())\ng = [set() for i in range(n)]\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\tg[a - 1].add(b - 1)\n\tg[b - 1].add(a - 1)\na = []\np = [-1] * n\nfor i in range(n):\n\tif p[i] != -1:\n\t\tcontinue\n\tp[i] = 0\n\ta.append(i)\n\twhile a:\n\t\tx = a.pop()\n\t\tfor elem in g[x]:\n\t\t\tif p[elem] == p[x]:\n\t\t\t\tprint(-1)\n\t\t\t\texit(0)\n\t\t\tif p[elem] == -1:\n\t\t\t\tp[elem] = not p[x]\n\t\t\t\ta.append(elem)\nprint(p.count(0))\nfor i in range(n):\n\tif p[i] == 0:\n\t\tprint(i + 1, end=' ')\nprint()\nprint(p.count(1))\nfor i in range(n):\n\tif p[i] == 1:\n\t\tprint(i + 1, end=' ')\n"
    },
    {
        "task_id": 805,
        "slowest_solution_id": 6,
        "fastest_solution_id": 2,
        "slowest_time": 2.6295578479766846,
        "fastest_time": 2.4341917037963867,
        "fastest_solution": "for _ in range(int(input())):\n\ta = 0\n\te0 = 0\n\te1 = 0\n\tee = 0\n\tfor i in input():\n\t\tif i == '?':\n\t\t\t(e0, e1) = (e1, e0)\n\t\t\tee += 1\n\t\telif i == '1':\n\t\t\te1 = ee + e0 + 1\n\t\t\te0 = 0\n\t\t\tee = 0\n\t\telse:\n\t\t\te0 = ee + e1 + 1\n\t\t\te1 = 0\n\t\t\tee = 0\n\t\ta += e0 + e1 + ee\n\tprint(a)\n",
        "slowest_solution": "for ttt in range(int(input())):\n\ts = input()\n\tn = len(s)\n\t(ans, max0, max1) = (0, 0, 0)\n\tfor i in range(n):\n\t\tif s[i] == '0':\n\t\t\tmax0 += 1\n\t\t\tmax1 = 0\n\t\t\tans += max0\n\t\telif s[i] == '1':\n\t\t\tmax1 += 1\n\t\t\tmax0 = 0\n\t\t\tans += max1\n\t\telse:\n\t\t\tmax0 += 1\n\t\t\tmax1 += 1\n\t\t\tans += max(max1, max0)\n\t\t(max0, max1) = (max1, max0)\n\tprint(ans)\n"
    },
    {
        "task_id": 823,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 2.6220648288726807,
        "fastest_time": 2.463207960128784,
        "fastest_solution": "n = int(input())\ncontacts = []\nfor phonebook in range(n):\n\tcontacts.append(input())\nguessed = [int(z) for z in input().split()]\nppl = []\nif guessed.count(0) == 0:\n\tprint(0)\n\texit()\nflag = False\nwhile flag == False:\n\tif 0 not in guessed:\n\t\tflag = True\n\t\tbreak\n\ti = guessed.index(0) + 1\n\tppl.append(i)\n\tfor e in range(n):\n\t\tif contacts[i - 1][e] == '1':\n\t\t\tguessed[e] -= 1\nprint(len(ppl))\nprint(' '.join([str(i) for i in ppl]))\n",
        "slowest_solution": "n = int(input().strip())\na = []\nfor i in range(n):\n\ts = input().strip()\n\ta.append(s)\nb = list(map(int, input().strip().split()))\nc = []\nwhile True:\n\tk = -1\n\tfor i in range(n):\n\t\tif b[i] == 0:\n\t\t\tk = i\n\t\t\tbreak\n\tif k == -1:\n\t\tbreak\n\telse:\n\t\tc.append(k + 1)\n\t\tfor i in range(n):\n\t\t\tif a[k][i] == '1':\n\t\t\t\tb[i] -= 1\ntot = len(c)\nprint(tot)\nfor x in c:\n\ttot = tot - 1\n\tprint(x, end=' ') if tot != 0 else print(x, end='\\n')\n"
    },
    {
        "task_id": 845,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.5431294441223145,
        "fastest_time": 2.4486024379730225,
        "fastest_solution": "# https://www.hackerearth.com/problem/algorithm/oliver-and-the-game-3/\nimport sys\n\nn = int(sys.stdin.readline())\n\nneighbors = [ [] for _ in range(n)]\n\nfor _ in range(n - 1):\n\tu, v = [int(x) - 1 for x in sys.stdin.readline().split()]\n\tneighbors[u].append(v)\n\tneighbors[v].append(u)\n\nvert = [[0, 0, 0] for _ in range(n)] # visited, start, end\nq = [0]\ni = 0\nwhile (q):\n\tv = q[-1]\n\tif vert[v][0] == 1:\n\t\tvert[v][2] = i\n\t\tq.pop()\n\telse:\n\t\tvert[v][1] = i\n\t\tvert[v][0] = 1\n\t\tfor n in neighbors[v]:\n\t\t\tif vert[n][0] == 0:\n\t\t\t\tq.append(n)\n\ti += 1\n\nq = int(sys.stdin.readline())\nfor _ in range(q):\n\td, x, y = [int(x) - 1 for x in sys.stdin.readline().split()]\n\t_, start1, end1 = vert[x]\n\t_, start2, end2 = vert[y]\n\tif d == 0:\n\t\tif start2 <= start1 and end2 >= end1:\n\t\t\tprint('YES')\n\t\t\tcontinue\n\telse:\n\t\tif start2 >= start1 and end2 <= end1:\n\t\t\tprint('YES')\n\t\t\tcontinue\n\tprint('NO')\n\n\t\n\n\t\t\n\n",
        "slowest_solution": "# https://www.hackerearth.com/problem/algorithm/oliver-and-the-game-3/\nimport sys\n\nn = int(sys.stdin.readline())\n\nneighbors = [ [] for _ in range(n)]\n\nfor _ in range(n - 1):\n\tu, v = [int(x) - 1 for x in sys.stdin.readline().split()]\n\tneighbors[u].append(v)\n\tneighbors[v].append(u)\n\nvert = [[0, 0, 0] for _ in range(n)] # visited, start, end\nq = [0]\ni = 0\nwhile (q):\n\tv = q[-1]\n\tif vert[v][0] == 1:\n\t\tvert[v][2] = i\n\t\tq.pop()\n\telse:\n\t\tvert[v][1] = i\n\t\tvert[v][0] = 1\n\t\tfor n in neighbors[v]:\n\t\t\tif vert[n][0] == 0:\n\t\t\t\tq.append(n)\n\ti += 1\n\nq = int(sys.stdin.readline())\nfor _ in range(q):\n\td, x, y = [int(x) - 1 for x in sys.stdin.readline().split()]\n\t_, start1, end1 = vert[x]\n\t_, start2, end2 = vert[y]\n\tif d == 0:\n\t\tif start2 <= start1 and end2 >= end1:\n\t\t\tprint('YES')\n\t\t\tcontinue\n\telse:\n\t\tif start2 >= start1 and end2 <= end1:\n\t\t\tprint('YES')\n\t\t\tcontinue\n\tprint('NO')\n\n\t\n\n\t\t\n\n"
    },
    {
        "task_id": 801,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 5.809097051620483,
        "fastest_time": 2.502537488937378,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\n\ndef solve():\n\tn = int(input())\n\tT = list(map(int, input().split()))\n\tT.sort()\n\tdp = [float('inf')] * (n + 1)\n\tdp[n] = abs(T[n - 1] - 2 * n)\n\tfor i in range(2 * n - 1, 0, -1):\n\t\tfor j in range(max(i - n, 1), n):\n\t\t\tdp[j] = min(dp[j], dp[j + 1] + abs(i - T[j - 1]))\n\t\tdp[-1] = abs(T[n - 1] - i) if i >= n else float('inf')\n\treturn dp[1]\nfor _ in range(int(input())):\n\tprint(solve())\n",
        "slowest_solution": "def hungarian(bipartite_graph):\n\tinfinity = int(10000000.0)\n\tn_row = len(bipartite_graph)\n\tn_col = len(bipartite_graph[0])\n\tu = [0] * n_row\n\tv = [0] * n_col\n\tmark_indices = [-1] * n_col\n\tcost = 0\n\tfor i in range(n_row):\n\t\tlinks = [-1] * n_col\n\t\tmins = [infinity] * n_col\n\t\tvisited = [False] * n_col\n\t\tmarked_i = i\n\t\tmarked_j = -1\n\t\tj_optimal = -1\n\t\twhile marked_i != -1:\n\t\t\tj_optimal = -1\n\t\t\trow_delta = infinity\n\t\t\tfor j1 in range(n_col):\n\t\t\t\tif not visited[j1]:\n\t\t\t\t\tj_delta = bipartite_graph[marked_i][j1] - u[marked_i] - v[j1]\n\t\t\t\t\tif j_delta < mins[j1]:\n\t\t\t\t\t\tmins[j1] = j_delta\n\t\t\t\t\t\tlinks[j1] = marked_j\n\t\t\t\t\tif mins[j1] < row_delta:\n\t\t\t\t\t\trow_delta = mins[j1]\n\t\t\t\t\t\tj_optimal = j1\n\t\t\tfor j1 in range(n_col):\n\t\t\t\tif visited[j1]:\n\t\t\t\t\tu[mark_indices[j1]] += row_delta\n\t\t\t\t\tv[j1] -= row_delta\n\t\t\t\telse:\n\t\t\t\t\tmins[j1] -= row_delta\n\t\t\tu[i] += row_delta\n\t\t\tcost += row_delta\n\t\t\tvisited[j_optimal] = True\n\t\t\tmarked_j = j_optimal\n\t\t\tmarked_i = mark_indices[j_optimal]\n\t\twhile links[j_optimal] != -1:\n\t\t\tmark_indices[j_optimal] = mark_indices[links[j_optimal]]\n\t\t\tj_optimal = links[j_optimal]\n\t\tmark_indices[j_optimal] = i\n\treturn cost\n\ndef process_test_case(i_t):\n\tn = int(input())\n\tt_vec = list(map(int, input().split()))\n\tt_vec.sort()\n\tdist_mat = [[abs(t - j - 1) for j in range(2 * n)] for t in t_vec]\n\tanswer = hungarian(dist_mat)\n\tprint(answer)\n\treturn None\nn_tests = int(input())\nfor i_test in range(1, n_tests + 1):\n\tprocess_test_case(i_test)\n"
    },
    {
        "task_id": 807,
        "slowest_solution_id": 9,
        "fastest_solution_id": 1,
        "slowest_time": 2.7910356521606445,
        "fastest_time": 2.4506919384002686,
        "fastest_solution": "def iceskate():\n\tn = int(input())\n\tdrifts = []\n\tfor i in range(n):\n\t\tdrifts.append(list(map(int, input().split())))\n\tdisconnected = []\n\tapp_index = 0\n\tfor j in drifts:\n\t\tdisconnected.append([app_index])\n\t\tfor k in drifts[drifts.index(j) + 1:]:\n\t\t\tif j[0] == k[0] or j[1] == k[1]:\n\t\t\t\tdisconnected[app_index].append(drifts.index(k))\n\t\tapp_index += 1\n\tdisconnected = connectSets(disconnected, n)\n\tprint(len(disconnected) - 1)\n\ndef connectSets(disconnected, n):\n\tfreq = [-1] * n\n\ti = 0\n\twhile i < n:\n\t\tdelFlag = 0\n\t\tfor k in range(len(disconnected[i])):\n\t\t\tif freq[disconnected[i][k]] >= i or freq[disconnected[i][k]] == -1:\n\t\t\t\tfreq[disconnected[i][k]] = i\n\t\t\telse:\n\t\t\t\tloc = freq[disconnected[i][k]]\n\t\t\t\tdelFlag = 1\n\t\t\t\tbreak\n\t\tif delFlag == 1:\n\t\t\tdisconnected[loc] += disconnected[i]\n\t\t\tdel disconnected[i]\n\t\t\ti = loc\n\t\t\tn -= 1\n\t\telse:\n\t\t\ti += 1\n\treturn disconnected\niceskate()\n",
        "slowest_solution": "n = int(input())\nans = 1\nxl = []\nyl = []\nfor i in range(n):\n\t(x, y) = map(int, input().split())\n\txl.append({x})\n\tyl.append({y})\nfor i in range(n - 1):\n\tfor j in range(i + 1, n):\n\t\tif xl[i] & xl[j] or yl[i] & yl[j]:\n\t\t\txl[j] |= xl[i]\n\t\t\tyl[j] |= yl[i]\n\t\t\tans += 1\n\t\t\tbreak\nprint(n - ans)\n"
    },
    {
        "task_id": 836,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 10.68233060836792,
        "fastest_time": 10.68233060836792,
        "fastest_solution": "mod = 998244353\n\ndef power(a, b):\n\tif b == 0:\n\t\treturn 1\n\tif b == 1:\n\t\treturn a\n\ttemp = power(a, int(b / 2)) % mod\n\tif b % 2 == 0:\n\t\treturn temp % mod * (temp % mod) % mod\n\telse:\n\t\treturn temp % mod * (a % mod) % mod * (temp % mod) % mod\nMaxW = 500005\n\ndef comp_exp_gcd(w, n):\n\tc = [0] * (MaxW + 1)\n\td = [0] * (MaxW + 1)\n\te = [0] * (MaxW + 1)\n\tfor i in w:\n\t\tc[i] += 1\n\tfor i in range(1, MaxW + 1):\n\t\tfor j in range(2 * i, MaxW + 1, i):\n\t\t\tc[i] += c[j]\n\tans = 0\n\tfor i in range(MaxW, 0, -1):\n\t\td[i] = c[i] * c[i]\n\t\tfor j in range(2 * i, MaxW + 1, i):\n\t\t\td[i] -= d[j]\n\t\tans = (ans + i * d[i]) % mod\n\tinv = power(n, mod - 2) % mod\n\tprint(ans * (n + 1) % mod * (2 * n + 1) % mod * power(6, mod - 2) % mod * inv * inv % mod)\nt = int(input())\nwhile t > 0:\n\tn = int(input())\n\tstr = input().split(' ')\n\tw = []\n\tfor i in str:\n\t\tw.append(int(i))\n\texp_gcd = comp_exp_gcd(w, n)\n\tt -= 1\n",
        "slowest_solution": "mod = 998244353\n\ndef power(a, b):\n\tif b == 0:\n\t\treturn 1\n\tif b == 1:\n\t\treturn a\n\ttemp = power(a, int(b / 2)) % mod\n\tif b % 2 == 0:\n\t\treturn temp % mod * (temp % mod) % mod\n\telse:\n\t\treturn temp % mod * (a % mod) % mod * (temp % mod) % mod\nMaxW = 500005\n\ndef comp_exp_gcd(w, n):\n\tc = [0] * (MaxW + 1)\n\td = [0] * (MaxW + 1)\n\te = [0] * (MaxW + 1)\n\tfor i in w:\n\t\tc[i] += 1\n\tfor i in range(1, MaxW + 1):\n\t\tfor j in range(2 * i, MaxW + 1, i):\n\t\t\tc[i] += c[j]\n\tans = 0\n\tfor i in range(MaxW, 0, -1):\n\t\td[i] = c[i] * c[i]\n\t\tfor j in range(2 * i, MaxW + 1, i):\n\t\t\td[i] -= d[j]\n\t\tans = (ans + i * d[i]) % mod\n\tinv = power(n, mod - 2) % mod\n\tprint(ans * (n + 1) % mod * (2 * n + 1) % mod * power(6, mod - 2) % mod * inv * inv % mod)\nt = int(input())\nwhile t > 0:\n\tn = int(input())\n\tstr = input().split(' ')\n\tw = []\n\tfor i in str:\n\t\tw.append(int(i))\n\texp_gcd = comp_exp_gcd(w, n)\n\tt -= 1\n"
    },
    {
        "task_id": 857,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.7282752990722656,
        "fastest_time": 2.7282752990722656,
        "fastest_solution": "n = int(input())\nv1 = list(map(int, input().split()))\nv2 = list(map(int, input().split()))\nif v1[0] < 0:\n\tv1[0] *= -1\n\tv1[1] *= -1\nif v2[0] < 0:\n\tv2[0] *= -1\n\tv2[1] *= -1\nwhile v2[0]:\n\tsub = v1[0] // v2[0]\n\tv1[0] -= v2[0] * sub\n\tv1[1] -= v2[1] * sub\n\t(v1, v2) = (v2, v1)\ny = abs(v2[1])\nx = abs(v1[0])\nif x * y == n:\n\tprint('YES')\n\tout = []\n\tfor i in range(x):\n\t\tfor j in range(y):\n\t\t\tout.append(str(i) + ' ' + str(j))\n\tprint('\\n'.join(out))\nelse:\n\tprint('NO')\n",
        "slowest_solution": "n = int(input())\nv1 = list(map(int, input().split()))\nv2 = list(map(int, input().split()))\nif v1[0] < 0:\n\tv1[0] *= -1\n\tv1[1] *= -1\nif v2[0] < 0:\n\tv2[0] *= -1\n\tv2[1] *= -1\nwhile v2[0]:\n\tsub = v1[0] // v2[0]\n\tv1[0] -= v2[0] * sub\n\tv1[1] -= v2[1] * sub\n\t(v1, v2) = (v2, v1)\ny = abs(v2[1])\nx = abs(v1[0])\nif x * y == n:\n\tprint('YES')\n\tout = []\n\tfor i in range(x):\n\t\tfor j in range(y):\n\t\t\tout.append(str(i) + ' ' + str(j))\n\tprint('\\n'.join(out))\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 810,
        "slowest_solution_id": 9,
        "fastest_solution_id": 1,
        "slowest_time": 2.917764902114868,
        "fastest_time": 2.41280198097229,
        "fastest_solution": "for i in range(int(input())):\n\tterms = int(input())\n\tl1 = list(map(int, input().split()))\n\tl2 = list(map(int, input().split()))\n\tdicc = {}\n\trt = 0\n\tfor i in range(terms):\n\t\tif (l2[i], l1[i]) in dicc:\n\t\t\trt = rt + dicc[l2[i], l1[i]]\n\t\tif (l1[i], l2[i]) in dicc:\n\t\t\tdicc[l1[i], l2[i]] += 1\n\t\telse:\n\t\t\tdicc[l1[i], l2[i]] = 1\n\tprint(rt)\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tx = list(map(int, input().split()))\n\ty = list(map(int, input().split()))\n\tcount = 0\n\td = {}\n\tfor i in range(n):\n\t\tif (y[i], x[i]) in d:\n\t\t\tcount = count + d[y[i], x[i]]\n\t\tif (x[i], y[i]) in d:\n\t\t\td[x[i], y[i]] += 1\n\t\telse:\n\t\t\td[x[i], y[i]] = 1\n\tprint(count)\n"
    },
    {
        "task_id": 813,
        "slowest_solution_id": 9,
        "fastest_solution_id": 8,
        "slowest_time": 2.878157138824463,
        "fastest_time": 2.428398609161377,
        "fastest_solution": "def solve():\n\t(n, m) = list(map(int, input().split()))\n\tlst = list(map(int, input().split()))\n\tcount = {}\n\tl = -1\n\twhile len(count) < n:\n\t\tl = l + 1\n\t\te = lst[l]\n\t\tif e in count:\n\t\t\tcount[e] += 1\n\t\telse:\n\t\t\tcount[e] = 1\n\tminsize = l + 1\n\tr = m\n\twhile l >= 0:\n\t\te = lst[l]\n\t\tcount[e] -= 1\n\t\tif count[e] <= 0:\n\t\t\tcount.pop(e)\n\t\twhile len(count) < n:\n\t\t\te = lst[r - 1]\n\t\t\tif e in count:\n\t\t\t\tcount[e] += 1\n\t\t\telse:\n\t\t\t\tcount[e] = 1\n\t\t\tr = r - 1\n\t\tl = l - 1\n\t\tminsize = min(minsize, l + 1 + (m - r))\n\treturn minsize\nt = int(input())\nfor _ in range(t):\n\tans = solve()\n\tprint(ans)\n",
        "slowest_solution": "PI = 3.141592653589793\nINF = 999999999\nMOD = 1000000007\n\ndef add(x, y):\n\treturn (x + y) % MOD\n\ndef sub(x, y):\n\treturn (x - y + MOD) % MOD\n\ndef mul(x, y):\n\treturn x * y % MOD\n\ndef gcd(x, y):\n\tif y == 0:\n\t\treturn x\n\treturn gcd(y, x % y)\n\ndef lcm(x, y):\n\treturn x * y // gcd(x, y)\n\ndef power(x, y):\n\tres = 1\n\tx %= MOD\n\twhile y != 0:\n\t\tif y & 1:\n\t\t\tres = mul(res, x)\n\t\ty >>= 1\n\t\tx = mul(x, x)\n\treturn res\n\ndef mod_inv(n):\n\treturn power(n, MOD - 2)\n\ndef prob(p, q):\n\treturn mul(p, power(q, MOD - 2))\n\ndef ii():\n\treturn int(input())\n\ndef li():\n\treturn [int(i) for i in input().split()]\n\ndef ls():\n\treturn [i for i in input().split()]\nfor t in range(ii()):\n\tt += 1\n\t(n, m) = li()\n\tmm = li()\n\tse = set()\n\tindex = 0\n\tl = [-1 for i in range(n + 1)]\n\tstore = []\n\twhile len(se) < n:\n\t\tif l[mm[index]] == -1:\n\t\t\tl[mm[index]] = index\n\t\t\tstore.append(index)\n\t\tse.add(mm[index])\n\t\tindex += 1\n\tans = store[-1] + 1\n\tind = n - 1\n\tse2 = set()\n\tfor i in range(m - 1, -1, -1):\n\t\tnum = mm[i]\n\t\tse2.add(num)\n\t\tif 0 <= ind <= n - 1:\n\t\t\twhile mm[store[ind]] in se2:\n\t\t\t\tind -= 1\n\t\t\t\tif ind == -1:\n\t\t\t\t\tbreak\n\t\tif ind == -1:\n\t\t\tans = min(ans, m - i)\n\t\telse:\n\t\t\tans = min(ans, store[ind] + 1 + m - i)\n\tprint(ans)\n"
    },
    {
        "task_id": 839,
        "slowest_solution_id": 2,
        "fastest_solution_id": 3,
        "slowest_time": 2.6523492336273193,
        "fastest_time": 2.3975913524627686,
        "fastest_solution": "t = int(input())\ncountans5 = 0\n\ndef rgb(s, length):\n\tno_not_rs = 0\n\tno_not_bs = 0\n\tno_not_gs = 0\n\tcountans1 = 0\n\tfor i in range(0, length):\n\t\tif s[i] != 'r':\n\t\t\tno_not_rs = no_not_rs + 1\n\t\telif s[i] == 'r':\n\t\t\tcountans1 = countans1 + no_not_rs\n\tfor i in range(0, length):\n\t\tif s[i] == 'b':\n\t\t\tno_not_gs = no_not_gs + 1\n\t\telif s[i] == 'g':\n\t\t\tcountans1 = countans1 + no_not_gs\n\treturn countans1\n\ndef rbg(s, length):\n\tno_not_rs = 0\n\tno_not_bs = 0\n\tno_not_gs = 0\n\tcountans2 = 0\n\tfor i in range(0, length):\n\t\tif s[i] != 'r':\n\t\t\tno_not_rs = no_not_rs + 1\n\t\telif s[i] == 'r':\n\t\t\tcountans2 = countans2 + no_not_rs\n\tfor i in range(0, length):\n\t\tif s[i] == 'g':\n\t\t\tno_not_bs = no_not_bs + 1\n\t\telif s[i] == 'b':\n\t\t\tcountans2 = countans2 + no_not_bs\n\treturn countans2\n\ndef brg(s, length):\n\tno_not_rs = 0\n\tno_not_bs = 0\n\tno_not_gs = 0\n\tcountans3 = 0\n\tfor i in range(0, length):\n\t\tif s[i] != 'b':\n\t\t\tno_not_bs = no_not_bs + 1\n\t\telif s[i] == 'b':\n\t\t\tcountans3 = countans3 + no_not_bs\n\tfor i in range(0, length):\n\t\tif s[i] == 'g':\n\t\t\tno_not_rs = no_not_rs + 1\n\t\telif s[i] == 'r':\n\t\t\tcountans3 = countans3 + no_not_rs\n\treturn countans3\n\ndef bgr(s, length):\n\tno_not_rs = 0\n\tno_not_bs = 0\n\tno_not_gs = 0\n\tcountans4 = 0\n\tfor i in range(0, length):\n\t\tif s[i] != 'b':\n\t\t\tno_not_bs = no_not_bs + 1\n\t\telif s[i] == 'b':\n\t\t\tcountans4 = countans4 + no_not_bs\n\tfor i in range(0, length):\n\t\tif s[i] == 'r':\n\t\t\tno_not_gs = no_not_gs + 1\n\t\telif s[i] == 'g':\n\t\t\tcountans4 = countans4 + no_not_gs\n\treturn countans4\n\ndef grb(s, length):\n\tno_not_rs = 0\n\tno_not_bs = 0\n\tno_not_gs = 0\n\tcountans5 = 0\n\tfor i in range(0, length):\n\t\tif s[i] != 'g':\n\t\t\tno_not_gs = no_not_gs + 1\n\t\telif s[i] == 'g':\n\t\t\tcountans5 = countans5 + no_not_gs\n\tfor i in range(0, length):\n\t\tif s[i] == 'b':\n\t\t\tno_not_rs = no_not_rs + 1\n\t\telif s[i] == 'r':\n\t\t\tcountans5 = countans5 + no_not_rs\n\treturn countans5\n\ndef gbr(s, length):\n\tno_not_rs = 0\n\tno_not_bs = 0\n\tno_not_gs = 0\n\tcountans6 = 0\n\tfor i in range(0, length):\n\t\tif s[i] != 'g':\n\t\t\tno_not_gs = no_not_gs + 1\n\t\telif s[i] == 'g':\n\t\t\tcountans6 = countans6 + no_not_gs\n\tfor i in range(0, length):\n\t\tif s[i] == 'r':\n\t\t\tno_not_bs = no_not_bs + 1\n\t\telif s[i] == 'b':\n\t\t\tcountans6 = countans6 + no_not_bs\n\treturn countans6\nwhile t != 0:\n\ts = str(input())\n\tlength = len(s)\n\tcountans1 = rgb(s, length)\n\tcountans2 = rbg(s, length)\n\tcountans3 = brg(s, length)\n\tcountans4 = bgr(s, length)\n\tcountans5 = gbr(s, length)\n\tcountans6 = grb(s, length)\n\tprint(min(countans1, countans2, countans3, countans4, countans5, countans6))\n\tt = t - 1\n",
        "slowest_solution": "def inversions(str, r, g, b):\n\tr_count = g_count = b_count = inv = 0\n\tfor i in range(len(str)):\n\t\tif str[i] == 'r':\n\t\t\tr_count += 1\n\t\t\tif g > r:\n\t\t\t\tinv += g_count\n\t\t\tif b > r:\n\t\t\t\tinv += b_count\n\t\tif str[i] == 'g':\n\t\t\tg_count += 1\n\t\t\tif r > g:\n\t\t\t\tinv += r_count\n\t\t\tif b > g:\n\t\t\t\tinv += b_count\n\t\tif str[i] == 'b':\n\t\t\tb_count += 1\n\t\t\tif r > b:\n\t\t\t\tinv += r_count\n\t\t\tif g > b:\n\t\t\t\tinv += g_count\n\treturn inv\npermutation = [(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]\nfor _ in range(int(input())):\n\tstr = input()\n\tans = []\n\tfor (r, g, b) in permutation:\n\t\tans.append(inversions(str, r, g, b))\n\tprint(min(ans))\n"
    },
    {
        "task_id": 814,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 2.638179063796997,
        "fastest_time": 2.4728498458862305,
        "fastest_solution": "for _ in range(int(input())):\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tans = 0\n\tfor i in range(N):\n\t\tans ^= A[i]\n\tprint(2 * ans)\n",
        "slowest_solution": "t = int(input())\nwhile t != 0:\n\tt = t - 1\n\tn = int(input())\n\ta = [int(i) for i in input().split()]\n\txor = 0\n\tfor i in range(n):\n\t\tans = 2 * a[i]\n\t\txor = xor ^ ans\n\tprint(xor)\n"
    },
    {
        "task_id": 817,
        "slowest_solution_id": 9,
        "fastest_solution_id": 8,
        "slowest_time": 2.768902063369751,
        "fastest_time": 2.3087379932403564,
        "fastest_solution": "(n, m, k) = [int(x) for x in input().split()]\na = []\nfor i in range(m):\n\tv = [int(x) for x in input().split()]\n\ta.append(v)\na.sort(key=lambda x: x[0] + x[1])\n\ndef findBest(l, r):\n\tif l >= r:\n\t\treturn 0\n\tdel2 = [0] * (n + 2)\n\tfor i in range(r - l):\n\t\t[x, y] = a[l + i]\n\t\tdel2[x] += 1\n\t\tdel2[y + 1] -= 1\n\tdel1 = [0] * (n + 2)\n\tfor i in range(n):\n\t\tdel1[i + 1] = del1[i] + del2[i + 1]\n\tdel0 = [0] * (n + 2)\n\tfor i in range(n):\n\t\tdel0[i + 1] = del0[i] + del1[i + 1]\n\tans = 0\n\tfor i in range(n - k + 1):\n\t\tans = max(ans, del0[i + k] - del0[i])\n\treturn ans\nans = 0\nfor i in range(m):\n\tprefMax = findBest(0, i + 1)\n\tsuffMax = findBest(i + 1, m)\n\tans = max(ans, prefMax + suffMax)\nprint(ans)\n",
        "slowest_solution": "(n, m, k) = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(m)]\nA.sort(key=sum)\npre = [0] * (m + 1)\nfor i in range(1, n - k + 2):\n\tcur = 0\n\tfor j in range(m):\n\t\t(l, r) = A[j]\n\t\tcur += max(0, min(r, i + k - 1) - max(l, i) + 1)\n\t\tpre[j + 1] = max(pre[j + 1], cur)\nans = pre[m]\nfor i in range(1, n - k + 2):\n\tcur = 0\n\tfor j in range(m - 1, -1, -1):\n\t\t(l, r) = A[j]\n\t\tcur += max(0, min(r, i + k - 1) - max(l, i) + 1)\n\t\tans = max(ans, cur + pre[j])\nprint(ans)\n"
    },
    {
        "task_id": 841,
        "slowest_solution_id": 4,
        "fastest_solution_id": 3,
        "slowest_time": 2.6911349296569824,
        "fastest_time": 2.3806662559509277,
        "fastest_solution": "from collections import defaultdict, deque\nimport sys\nimport bisect\ninput = sys.stdin.readline\nmod = 1000000007\ngraph = defaultdict(list)\nn = int(input())\nfor i in range(n - 1):\n\t(x, y) = map(int, input().split())\n\tgraph[x].append(y)\n\tgraph[y].append(x)\nvis = set()\n(CHECK, OBSERVE) = (1, 0)\nstack = [(OBSERVE, 1, 0)]\ntree = [0] * (n + 1)\npossible = [0] * (n + 1)\nwhile stack:\n\t(state, vertex, parent) = stack.pop()\n\tif state == OBSERVE:\n\t\tstack.append((CHECK, vertex, parent))\n\t\tfor child in graph[vertex]:\n\t\t\tif child != parent:\n\t\t\t\tstack.append((OBSERVE, child, vertex))\n\telif len(graph[vertex]) == 1:\n\t\ttree[vertex] = 1\n\telse:\n\t\t(tmp, local) = ([], [0] * (n + 1))\n\t\tcount = 0\n\t\tfor child in graph[vertex]:\n\t\t\tif child != parent:\n\t\t\t\tcount += tree[child]\n\t\t\t\ttmp.append(tree[child])\n\t\ttmp.append(n - count - 1)\n\t\ttree[vertex] = count + 1\n\t\tlocal[0] = 1\n\t\tfor x in tmp:\n\t\t\tfor i in range(n - x, -1, -1):\n\t\t\t\tif local[i] == 1:\n\t\t\t\t\tlocal[x + i] = 1\n\t\t\t\t\tpossible[x + i] = 1\nans = []\nfor i in range(1, n - 1):\n\tif possible[i]:\n\t\tans.append(i)\nprint(len(ans))\nfor i in ans:\n\tsys.stdout.write(str(i) + ' ' + str(n - 1 - i) + '\\n')\n",
        "slowest_solution": "from os import path\nimport sys, time, collections as c, math as m, pprint as p\n(maxx, localsys, mod) = (float('inf'), 0, int(1000000000.0 + 7))\nif path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\ninput = sys.stdin.readline\n\ndef dfs(v, p):\n\tans = 1\n\tfor i in d[v]:\n\t\tif i != p:\n\t\t\tans += dfs(i, v)\n\treturn ans\nn = int(input())\nd = c.defaultdict(list)\nfor _ in range(1, n):\n\t(u, v) = map(int, input().split())\n\td[u].append(v)\n\td[v].append(u)\n(check, observe) = (1, 0)\n(st, tree, possible) = ([(observe, 1, 0)], [0] * n + [0], [0] * n + [0])\nwhile st:\n\t(state, vertex, parent) = st.pop()\n\tif state == observe:\n\t\tst.append((check, vertex, parent))\n\t\tfor c in d[vertex]:\n\t\t\tif c != parent:\n\t\t\t\tst.append((observe, c, vertex))\n\telse:\n\t\t(tmp, loc, cnt) = ([], [0] * (n + 1), 0)\n\t\tfor c in d[vertex]:\n\t\t\tif c != parent:\n\t\t\t\tcnt += tree[c]\n\t\t\t\ttmp.append(tree[c])\n\t\ttmp.append(n - cnt - 1)\n\t\ttree[vertex] = cnt + 1\n\t\tloc[0] = 1\n\t\tfor x in tmp:\n\t\t\tfor i in range(n - x, -1, -1):\n\t\t\t\tif loc[i] == 1:\n\t\t\t\t\tloc[x + i] = 1\n\t\t\t\t\tpossible[x + i] = 1\npossible[0] = possible[n - 1] = 0\nprint(possible.count(1))\nfor i in range(1, n - 1):\n\tif possible[i]:\n\t\tprint(i, n - 1 - i)\n"
    },
    {
        "task_id": 847,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 3.3493142127990723,
        "fastest_time": 2.9832046031951904,
        "fastest_solution": "(gg, G) = ([1, 4, 27, 256, 3125, 46656], [0] * 100005)\n\ndef mex(L):\n\tfor i in range(10):\n\t\tif i not in L:\n\t\t\treturn i\nfor i in range(100005):\n\t(temp, j) = ([], 0)\n\twhile j < len(gg) and gg[j] <= i:\n\t\ttemp.append(G[i - gg[j]])\n\t\tj += 1\n\tG[i] = mex(sorted(temp))\nfor _ in range(int(input())):\n\t(n, L, ans) = (int(input()), list(map(int, input().split(' '))), 0)\n\tfor i in L:\n\t\tans ^= G[i]\n\tprint('Head Chef') if ans == 0 else print('Little Chef')\n",
        "slowest_solution": "take = [1, 4, 27, 256, 3125, 46656]\n\ndef mex(A):\n\tA.sort()\n\tfor i in range(10):\n\t\tif i not in A:\n\t\t\treturn i\nG = [0] * 100005\nfor i in range(100005):\n\ttemp = []\n\tj = 0\n\twhile j < len(take) and take[j] <= i:\n\t\ttemp.append(G[i - take[j]])\n\t\tj += 1\n\tG[i] = mex(temp)\nT = int(input())\nfor t in range(T):\n\tn = int(input())\n\tA = [int(i) for i in input().split(' ')]\n\tans = 0\n\tfor i in A:\n\t\tans ^= G[i]\n\tif ans == 0:\n\t\tprint('Head Chef')\n\telse:\n\t\tprint('Little Chef')\n"
    },
    {
        "task_id": 829,
        "slowest_solution_id": 5,
        "fastest_solution_id": 6,
        "slowest_time": 3.667840003967285,
        "fastest_time": 2.474337577819824,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nfrom math import sqrt\nfrom collections import defaultdict, deque\n\ndef I():\n\treturn list(map(int, input().split()))\nfrom time import time\nst = time()\n\ndef bfs():\n\tmax_dep = 0\n\tstack = [(0, 0)]\n\tvis = {}\n\tans = 0\n\twhile True:\n\t\tif time() - st > 1:\n\t\t\texit()\n\t\twhile stack:\n\t\t\tif time() - st > 1:\n\t\t\t\texit()\n\t\t\t(x, y) = stack.pop()\n\t\t\tmax_dep = max(max_dep, x)\n\t\t\tif x == n - 1 and y == m - 1:\n\t\t\t\treturn ans\n\t\t\tfor (r, c) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n\t\t\t\t(X, Y) = (x + r, y + c)\n\t\t\t\tif 0 <= X < n and 0 <= Y < m and ((X, Y) not in vis) and (mat[X][Y] == '.'):\n\t\t\t\t\tstack.append((X, Y))\n\t\t\t\t\tvis[X, Y] = True\n\t\tif max_dep == n - 1:\n\t\t\tans += 1\n\t\t\treturn ans\n\t\tans += 1\n\t\tfor j in range(m):\n\t\t\tstack.append((max_dep + 1, j))\nfor _ in range(int(input())):\n\t(n, m) = I()\n\tmat = []\n\tfor i in range(n):\n\t\ttemp = input().strip()\n\t\tmat.append(temp)\n\tstack = deque([(0, 0)])\n\tprint(bfs())\n",
        "slowest_solution": "def mi():\n\treturn map(int, input().split())\n\ndef li():\n\treturn list(mi())\n\ndef si():\n\treturn str(input())\n\ndef ni():\n\treturn int(input())\nfind = lambda n, m, l, u: m * l + u + 1\nfrom heapq import heappop, heappush\n\ndef dijkstra(graph, start, n):\n\t(dist, parents) = ([float('inf')] * n, [-1] * n)\n\tdist[start] = 0\n\tqueue = [(0, start)]\n\twhile queue:\n\t\t(path_len, v) = heappop(queue)\n\t\tif path_len == dist[v]:\n\t\t\tfor (w, edge_len) in graph[v]:\n\t\t\t\tif edge_len + path_len < dist[w]:\n\t\t\t\t\t(dist[w], parents[w]) = (edge_len + path_len, v)\n\t\t\t\t\theappush(queue, (edge_len + path_len, w))\n\treturn (dist, parents)\ng = [[] for i in range(2 * 500000 + 2)]\nfor _ in range(int(input())):\n\t(n, m) = mi()\n\ttotal = n * m\n\ta = []\n\tfor i in range(n):\n\t\ta.append(input())\n\tfor i in range(2 * total + 2):\n\t\tg[i].clear()\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif a[i][j] == '.':\n\t\t\t\tif i > 0:\n\t\t\t\t\tx = find(n, m, i, j)\n\t\t\t\t\ty = find(n, m, i - 1, j)\n\t\t\t\t\tif a[i - 1][j] == '.':\n\t\t\t\t\t\tg[x].append((y, 0))\n\t\t\t\t\tg[x].append((total + y, 1))\n\t\t\t\tif j > 0:\n\t\t\t\t\tx = find(n, m, i, j)\n\t\t\t\t\ty = find(n, m, i, j - 1)\n\t\t\t\t\tif a[i][j - 1] == '.':\n\t\t\t\t\t\tg[x].append((y, 0))\n\t\t\t\t\tg[x].append((total + y, 1))\n\t\t\t\tif i < n - 1:\n\t\t\t\t\tx = find(n, m, i, j)\n\t\t\t\t\ty = find(n, m, i + 1, j)\n\t\t\t\t\tif a[i + 1][j] == '.':\n\t\t\t\t\t\tg[x].append((y, 0))\n\t\t\t\t\tg[x].append((total + y, 1))\n\t\t\t\tif j < m - 1:\n\t\t\t\t\tx = find(n, m, i, j)\n\t\t\t\t\ty = find(n, m, i, j + 1)\n\t\t\t\t\tif a[i][j + 1] == '.':\n\t\t\t\t\t\tg[x].append((y, 0))\n\t\t\t\t\tg[x].append((total + y, 1))\n\t\t\tif j > 0:\n\t\t\t\tg[total + find(n, m, i, j)].append((total + find(n, m, i, j - 1), 0))\n\t\t\t\tif a[i][j - 1] == '.':\n\t\t\t\t\tg[total + find(n, m, i, j)].append((find(n, m, i, j - 1), 0))\n\t\t\tif j < m - 1:\n\t\t\t\tg[total + find(n, m, i, j)].append((total + find(n, m, i, j + 1), 0))\n\t\t\t\tif a[i][j + 1] == '.':\n\t\t\t\t\tg[total + find(n, m, i, j)].append((find(n, m, i, j + 1), 0))\n\t\t\tif i > 0:\n\t\t\t\tg[total + find(n, m, i, j)].append((total + find(n, m, i - 1, j), 1))\n\t\t\t\tif a[i - 1][j] == '.':\n\t\t\t\t\tg[total + find(n, m, i, j)].append((find(n, m, i - 1, j), 0))\n\t\t\tif i < n - 1:\n\t\t\t\tg[total + find(n, m, i, j)].append((total + find(n, m, i + 1, j), 1))\n\t\t\t\tif a[i + 1][j] == '.':\n\t\t\t\t\tg[total + find(n, m, i, j)].append((find(n, m, i + 1, j), 0))\n\t(res, temp) = dijkstra(g, 1, 2 * total + 2)\n\tprint(min(res[total], res[2 * total]))\n"
    },
    {
        "task_id": 858,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "from bisect import bisect_right as bisect\nRES = [[] for _ in range(11)]\nfor c in range(1, 1001):\n\tc3 = c ** 3\n\tnSol = sum((((c3 - a ** 2) ** 0.5).is_integer() for a in range(1, int((c3 // 2) ** 0.5 + 1))))\n\tif 0 < nSol < 11:\n\t\tRES[nSol].append(c)\n\ndef find_abc_sumsqcube(c_max, nSol):\n\treturn RES[nSol][:bisect(RES[nSol], c_max)]\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 743,
        "slowest_solution_id": 6,
        "fastest_solution_id": 3,
        "slowest_time": 10.78519892692566,
        "fastest_time": 5.047338247299194,
        "fastest_solution": "import math\nfrom bisect import bisect_left\n\ndef sieve(n):\n\tisPrimeList = [True] * (n + 1)\n\tisPrimeList[0] = False\n\tisPrimeList[1] = False\n\tfor i in range(2, int(math.sqrt(n))):\n\t\tif isPrimeList[i]:\n\t\t\tfor j in range(i * 2, n, i):\n\t\t\t\tisPrimeList[j] = False\n\treturn isPrimeList\nprimes = sieve(3 * 10 ** 6)\np = []\nfor i in range(3 * 10 ** 6 + 1):\n\tif primes[i]:\n\t\tp.append(i)\nn = int(input())\nb = list(map(int, input().split()))\ntrihard = [0] * 3000001\nfor i in b:\n\ttrihard[i] = trihard[i] + 1\nmoveCount = 0\na = []\nfor i in range(3000000, -1, -1):\n\twhile trihard[i]:\n\t\tif primes[i]:\n\t\t\tpos = bisect_left(p, i)\n\t\t\ta.append(str(pos + 1))\n\t\t\ttrihard[i] -= 1\n\t\t\ttrihard[pos + 1] -= 1\n\t\telse:\n\t\t\tfor j in p:\n\t\t\t\tif i % j == 0:\n\t\t\t\t\ta.append(str(i))\n\t\t\t\t\ttrihard[i] -= 1\n\t\t\t\t\ttrihard[i // j] -= 1\n\t\t\t\t\tbreak\nprint(' '.join(a))\n",
        "slowest_solution": "from collections import Counter\nfrom math import sqrt\nm = 2750131 + 100\nf = list(range(m))\nfor d in range(2, int(sqrt(m)) + 10):\n\tif f[d] == d:\n\t\t(i, k) = (2, d << 1)\n\t\twhile k < m:\n\t\t\tif f[k] == k:\n\t\t\t\tf[k] = i\n\t\t\tk += d\n\t\t\ti += 1\nnp = list(range(m))\nc = 1\nfor i in range(2, m):\n\tif f[i] == i:\n\t\tnp[i] = c\n\t\tc += 1\nn = int(input())\nb = sorted(list(map(int, input().split())), reverse=True)\nd = Counter(b)\na = []\n(i, la) = (0, 0)\nwhile la < n:\n\tif d[b[i]] > 0:\n\t\tla += 1\n\t\tif f[b[i]] == b[i]:\n\t\t\ta.append(np[b[i]])\n\t\t\td[b[i]] -= 1\n\t\t\td[np[b[i]]] -= 1\n\t\telse:\n\t\t\ta.append(b[i])\n\t\t\td[b[i]] -= 1\n\t\t\td[f[b[i]]] -= 1\n\ti += 1\nprint(*a)\n"
    },
    {
        "task_id": 873,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def tops(msg):\n\t(i, d, s) = (1, 5, '')\n\twhile i < len(msg):\n\t\ts += msg[i]\n\t\ti += d\n\t\td += 4\n\treturn s[::-1]\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 821,
        "slowest_solution_id": 6,
        "fastest_solution_id": 1,
        "slowest_time": 2.9262332916259766,
        "fastest_time": 2.4467580318450928,
        "fastest_solution": "for i in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tm = set(map(int, input().split()))\n\tfor j in m:\n\t\tif j + k in m:\n\t\t\tprint('YES')\n\t\t\tbreak\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "def solve():\n\t(n, k) = map(int, input().split())\n\ta = set(map(int, input().split()))\n\tfor i in a:\n\t\tif k + i in a:\n\t\t\tprint('YES')\n\t\t\treturn\n\tprint('NO')\nfor _ in range(int(input())):\n\tsolve()\n"
    },
    {
        "task_id": 825,
        "slowest_solution_id": 9,
        "fastest_solution_id": 8,
        "slowest_time": 2.765630006790161,
        "fastest_time": 2.3709311485290527,
        "fastest_solution": "n = int(input())\na = list(map(int, input().split()))\nidx = dict()\n(length, l, idx[a[0]]) = (1, 0, 0)\nfor i in range(1, n):\n\tl = max(l, idx.get(a[i] + 2, -1) + 1, idx.get(a[i] - 2, -1) + 1)\n\tlength = max(length, i - l + 1)\n\tidx[a[i]] = i\nprint(length)\n",
        "slowest_solution": "input()\nstart = delta = j = 0\n(res, a) = ([], '-1')\nfor (i, b) in enumerate(input().split()):\n\tif a != b:\n\t\t(a, ab) = (b, int(b) - int(a))\n\t\tif delta == ab:\n\t\t\tstart = j\n\t\t(j, delta) = (i, ab)\n\tres.append(i - start)\nprint(max(res) + 1)\n"
    },
    {
        "task_id": 827,
        "slowest_solution_id": 6,
        "fastest_solution_id": 7,
        "slowest_time": 2.830012321472168,
        "fastest_time": 2.344383955001831,
        "fastest_solution": "import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n(n, m) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ndp = [0] * n\nstart = a[0]\n(k, i) = (0, 0)\nwhile i < n:\n\tif a[i] - start > 5:\n\t\tdp[k] = i - k\n\t\tk += 1\n\t\tstart = a[k]\n\telse:\n\t\ti += 1\ndp[k] = n - k\nfor i in range(k + 1, n):\n\tdp[i] = dp[i - 1] - 1\nif dp[0] == n:\n\tprint(n)\n\texit()\ndp2 = [[0 for i in range(m + 1)] for j in range(n + 1)]\nfor i in range(n - 1, -1, -1):\n\tfor j in range(1, m + 1):\n\t\tdp2[i][j] = max(dp2[i + 1][j], dp2[i + 1][j - 1] + 1, dp2[dp[i] + i][j - 1] + dp[i])\nprint(dp2[0][m])\n",
        "slowest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom array import array\n\ndef main():\n\t(n, k) = map(int, input().split())\n\ta = sorted(map(int, input().split()))\n\tdp = [array('i', [0] * (k + 1)) for _ in range(n + 1)]\n\tl = 1\n\tfor i in range(1, n + 1):\n\t\twhile l < n + 1 and a[l - 1] - a[i - 1] <= 5:\n\t\t\tfor j in range(1, k + 1):\n\t\t\t\tdp[l][j] = max(dp[l][j], dp[l - 1][j], dp[i - 1][j - 1] + l - i + 1)\n\t\t\tl += 1\n\tprint(max((max(i) for i in dp)))\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n"
    },
    {
        "task_id": 853,
        "slowest_solution_id": 6,
        "fastest_solution_id": 1,
        "slowest_time": 2.779496669769287,
        "fastest_time": 2.662522315979004,
        "fastest_solution": "class CodeforcesTask323ASolution:\n\n\tdef __init__(self):\n\t\tself.result = ''\n\t\tself.k = 0\n\n\tdef read_input(self):\n\t\tself.k = int(input())\n\n\tdef process_task(self):\n\t\tif self.k % 2:\n\t\t\tself.result = '-1'\n\t\telif self.k == 2:\n\t\t\tself.result = 'bb\\nww\\n\\nbb\\nww'\n\t\telse:\n\t\t\tlevel = 'b'\n\t\t\tcube = [[[None for y in range(self.k)] for x in range(self.k)] for z in range(self.k)]\n\t\t\tfor z in range(self.k):\n\t\t\t\tlevel = 'w' if z % 2 else 'b'\n\t\t\t\tfor k in range(self.k // 2):\n\t\t\t\t\tfor x in range(2 * (k + 1)):\n\t\t\t\t\t\tcube[z][self.k // 2 - 1 - k][self.k // 2 - 1 - k + x] = level\n\t\t\t\t\tfor x in range(2 * (k + 1)):\n\t\t\t\t\t\tcube[z][self.k // 2 + k][self.k // 2 - 1 - k + x] = level\n\t\t\t\t\tfor y in range(2 * (k + 1)):\n\t\t\t\t\t\tcube[z][self.k // 2 - 1 - k + y][self.k // 2 - 1 - k] = level\n\t\t\t\t\tfor y in range(2 * (k + 1)):\n\t\t\t\t\t\tcube[z][self.k // 2 - 1 - k + y][self.k // 2 + k] = level\n\t\t\t\t\tlevel = 'w' if level == 'b' else 'b'\n\t\t\tfor layer in cube:\n\t\t\t\tfor row in layer:\n\t\t\t\t\tprint(''.join(row))\n\t\t\t\tprint(' ')\n\n\tdef get_result(self):\n\t\treturn self.result\n\ndef __starting_point():\n\tSolution = CodeforcesTask323ASolution()\n\tSolution.read_input()\n\tSolution.process_task()\n\tprint(Solution.get_result())\n__starting_point()\n",
        "slowest_solution": "k = int(input())\nif k % 2 == 1:\n\tprint(-1)\nelse:\n\tfor i in range(k):\n\t\tfor j in range(k):\n\t\t\ta = ''\n\t\t\tfor l in range(k):\n\t\t\t\ta += 'bw'[(i // 2 + j + l // 2) % 2]\n\t\t\tprint(a)\n\t\tif i < k - 1:\n\t\t\tprint()\n"
    },
    {
        "task_id": 828,
        "slowest_solution_id": 5,
        "fastest_solution_id": 6,
        "slowest_time": 2.8179006576538086,
        "fastest_time": 2.347592353820801,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass Trie:\n\n\tclass Node:\n\n\t\tdef __init__(self, char: bool=False):\n\t\t\tself.char = char\n\t\t\tself.children = []\n\t\t\tself.words = 0\n\n\tdef __init__(self):\n\t\tself.root = Trie.Node()\n\n\tdef add(self, word):\n\t\tnode = self.root\n\t\tfor char in word:\n\t\t\tfound_in_child = False\n\t\t\tfor child in node.children:\n\t\t\t\tif child.char == char:\n\t\t\t\t\tnode = child\n\t\t\t\t\tfound_in_child = True\n\t\t\t\t\tbreak\n\t\t\tif not found_in_child:\n\t\t\t\tnew_node = Trie.Node(char)\n\t\t\t\tnode.children.append(new_node)\n\t\t\t\tnode = new_node\n\t\tnode.words += 1\n\n\tdef remove(self, word):\n\t\tnode = self.root\n\t\tnodelist = [node]\n\t\tfor char in word:\n\t\t\tfor child in node.children:\n\t\t\t\tif child.char == char:\n\t\t\t\t\tnode = child\n\t\t\t\t\tnodelist.append(node)\n\t\t\t\t\tbreak\n\t\tnode.words -= 1\n\t\tif not node.children and (not node.words):\n\t\t\tfor i in range(len(nodelist) - 2, -1, -1):\n\t\t\t\tnodelist[i].children.remove(nodelist[i + 1])\n\t\t\t\tif nodelist[i].children or nodelist[i].words:\n\t\t\t\t\tbreak\n\n\tdef query(self, prefix, root=None):\n\t\tif not root:\n\t\t\troot = self.root\n\t\tnode = root\n\t\tif not root.children:\n\t\t\treturn 0\n\t\tprefix = [prefix]\n\t\tfor char in prefix:\n\t\t\tchar_not_found = True\n\t\t\tfor child in node.children:\n\t\t\t\tif child.char == char:\n\t\t\t\t\tchar_not_found = False\n\t\t\t\t\tnode = child\n\t\t\t\t\tbreak\n\t\t\tif char_not_found:\n\t\t\t\treturn 0\n\t\treturn node\ndi = {}\ntr = Trie()\ntr.add([False] * 32)\nfor _ in range(int(input())):\n\t(a, b) = input().split()\n\tb = int(b)\n\tx = bin(b)[2:]\n\tx = '0' * (32 - len(x)) + x\n\tx = [False if k == '0' else True for k in x]\n\tif a == '+':\n\t\ttr.add(x)\n\telif a == '-':\n\t\ttr.remove(x)\n\telse:\n\t\tans = 0\n\t\tnode = tr.root\n\t\tcnt = 32\n\t\tfor i in x:\n\t\t\tcnt -= 1\n\t\t\treq = not i\n\t\t\tnext = tr.query(req, node)\n\t\t\tif not next:\n\t\t\t\tnode = tr.query(not req, node)\n\t\t\telse:\n\t\t\t\tnode = next\n\t\t\t\tans += 2 ** cnt\n\t\tprint(ans)\n",
        "slowest_solution": "from bisect import bisect_right\nfrom collections import defaultdict\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import defaultdict\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef least_significant_bit(i):\n\treturn i & -i\n\nclass FenwickTree:\n\n\tdef __init__(self, n):\n\t\tself.n = n + 1\n\t\tself.data = [0] * self.n\n\n\tdef add(self, index, value):\n\t\ti = index + 1\n\t\twhile i < self.n:\n\t\t\tself.data[i] += value\n\t\t\ti += least_significant_bit(i)\n\n\tdef prefix_sum(self, index):\n\t\ti = index + 1\n\t\tresult = 0\n\t\twhile i > 0:\n\t\t\tresult += self.data[i]\n\t\t\ti -= least_significant_bit(i)\n\t\treturn result\n\n\tdef range_sum(self, start, end):\n\t\treturn self.prefix_sum(end) - self.prefix_sum(start - 1)\n\nclass Node:\n\n\tdef __init__(self, value):\n\t\tself.parent = None\n\t\tself.val = value\n\t\tself.zero = None\n\t\tself.one = None\n\t\tself.marker = 0\n\t\tself.max_len = 0\nroot = Node(-1)\n\ndef insertnode(n):\n\tcurr_node = root\n\tbitstr = bin(n)[2:].zfill(32)\n\tfor bit in bitstr:\n\t\tif bit == '1':\n\t\t\tif curr_node.one == None:\n\t\t\t\tcurr_node.one = Node(1)\n\t\t\t\tcurr_node.one.parent = curr_node\n\t\t\tcurr_node = curr_node.one\n\t\telse:\n\t\t\tif curr_node.zero == None:\n\t\t\t\tcurr_node.zero = Node(0)\n\t\t\t\tcurr_node.zero.parent = curr_node\n\t\t\tcurr_node = curr_node.zero\n\tcurr_node.marker += 1\n\ndef delete(n):\n\tcurr_node = root\n\tbitstr = bin(n)[2:].zfill(32)\n\tfor bit in bitstr:\n\t\tif bit == '1':\n\t\t\tcurr_node = curr_node.one\n\t\telse:\n\t\t\tcurr_node = curr_node.zero\n\tcurr_node.marker -= 1\n\tif curr_node.marker == 0:\n\t\twhile curr_node.parent != None:\n\t\t\tif curr_node.one is None and curr_node.zero is None:\n\t\t\t\tif curr_node.val == 1:\n\t\t\t\t\tcurr_node.parent.one = None\n\t\t\t\telse:\n\t\t\t\t\tcurr_node.parent.zero = None\n\t\t\tcurr_node = curr_node.parent\n\ndef find(n):\n\tbitstr = bin(n)[2:].zfill(32)\n\tcurr_node = root\n\tresult = []\n\tfor bit in bitstr:\n\t\tb = int(bit)\n\t\tlooking_for = 1 - b\n\t\tzero_present = curr_node.zero != None\n\t\tone_present = curr_node.one != None\n\t\tif looking_for == 0 and zero_present:\n\t\t\tcurr_node = curr_node.zero\n\t\t\tresult.append('1')\n\t\telif looking_for == 1 and one_present:\n\t\t\tcurr_node = curr_node.one\n\t\t\tresult.append('1')\n\t\telif looking_for == 0 and one_present:\n\t\t\tcurr_node = curr_node.one\n\t\t\tresult.append('0')\n\t\telse:\n\t\t\tcurr_node = curr_node.zero\n\t\t\tresult.append('0')\n\treturn int(''.join(result), 2)\ninsertnode(0)\ny = int(input())\nfor j in range(y):\n\tb = list(map(str, input().split()))\n\tif b[0] == '+':\n\t\tinsertnode(int(b[1]))\n\telif b[0] == '-':\n\t\tdelete(int(b[1]))\n\telse:\n\t\tprint(find(int(b[1])))\n"
    },
    {
        "task_id": 830,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 2.9171791076660156,
        "fastest_time": 2.328779697418213,
        "fastest_solution": "input()\nprint(1 + max((x // -~f for (x, f) in enumerate(sorted(map(int, input().split()))))))\n",
        "slowest_solution": "n = int(input())\nx = list(map(int, input().split()))\nx.sort()\nnu = 0\nans = 0\nmark = []\nfor i in range(0, n):\n\tmark.append(0)\nfor i in range(0, n):\n\tfail = 1\n\tnu = 0\n\tfor j in range(0, n):\n\t\tif mark[j] == 0:\n\t\t\tfail = 0\n\t\t\tif x[j] >= nu:\n\t\t\t\tnu += 1\n\t\t\t\tmark[j] = 1\n\tif fail == 0:\n\t\tans += 1\n\telse:\n\t\tbreak\nprint(ans)\n"
    },
    {
        "task_id": 848,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 3.007047653198242,
        "fastest_time": 2.583061933517456,
        "fastest_solution": "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n#print 'Hello World!'\n\nimport re\n\ndef process(str, _index, _pre):\n\t_len = len(str)\n\t_ini = int(str[0])\n\tif _ini < 3:\n\t\tprint(_pre + (\"3\" * _len))\n\telif _ini == 3:\n\t\tif _len == 1:\n\t\t\tprint(_pre + \"5\")\n\t\telse:\n\t\t\t_pre += '3'\n\t\t\t#print _index\n\t\t\t#print _pre\n\t\t\t_index += 1\n\t\t\tprocess(str[1:], _index, _pre)\n\telif _ini > 3 and _ini < 5:\n\t\tprint(_pre + (\"5\" + (\"3\" * (_len-1))))\n\telif _ini == 5:\n\t\t#print _len\n\t\t#print _pre\n\t\tif _len == 1:\n\t\t\tif _pre == \"\" or _pre[-1] == \"5\":\n\t\t\t\tprint(\"3\" * (_index+2))\n\t\t\telif _pre[-1] == \"3\":    \n\t\t\t\t_pre_list = list(_pre)\n\t\t\t\t_pre_list[-1] = \"5\"\n\t\t\t\t_pre = \"\".join(_pre_list)\n\t\t\t\tprint((_pre + (\"3\" * _len)))\n\t\telif not _pre == \"\":\n\t\t\tif _pre[-1] == \"3\":\n\t\t\t\t_matches = re.findall(r'[0,1,2,3,4]', str[1:])\n\t\t\t\tif not _matches:\n\t\t\t\t\t_pre_list = list(_pre)\n\t\t\t\t\t_pre_list[-1] = \"5\"\n\t\t\t\t\t_pre = \"\".join(_pre_list)\n\t\t\t\t\tprint((_pre + (\"3\" * _len)))\n\t\t\t\telse:\n\t\t\t\t\t_pre += '5'\n\t\t\t\t\t_index += 1\n\t\t\t\t\tprocess(str[1:], _index, _pre)\n\t\t\telse:\n\t\t\t\t_pre += '5'\n\t\t\t\t_index += 1\n\t\t\t\tprocess(str[1:], _index, _pre)\n\t\telse:\n\t\t\t_pre += '5'\n\t\t\t_index += 1\n\t\t\tprocess(str[1:], _index, _pre) \n\telif _ini > 5:\n\t\tif _index == 0:\n\t\t\tprint(\"3\" * (_len+1))\n\t\telif _index > 0 and _pre[-1] == \"3\":\n\t\t\t_pre_list = list(_pre)\n\t\t\t_pre_list[-1] = \"5\"\n\t\t\t_pre = \"\".join(_pre_list)\n\t\t\tprint((_pre + (\"3\" * _len)))\n\t\telif _index > 0 and _pre[-1] == \"5\":\n\t\t\t_tmp = _pre.rfind('3')\n\t\t\t_pre_len = len(_pre)\n\t\t\tif not _tmp == -1:\n\t\t\t\t_pre_list = list(_pre)\n\t\t\t\t_pre_list[_tmp] = \"5\"\n\t\t\t\t_pre = \"\".join(_pre_list)\n\t\t\t\tprint((_pre[:_tmp+1] + (\"3\" * ((_pre_len-_tmp-1) + _len))))\n\t\t\telse:\n\t\t\t\tprint(\"3\" * (_len+_index+1))\n\t\t\t\nn = int(input())\nfor i in range(1, n+1):\n\tstr = input()\n\tprocess(str, 0, '')\n",
        "slowest_solution": "def next_lucky(digs, ind):\n\tif ind == len(digs):\n\t\treturn True\n\tif digs[ind] < 3:\n\t\tfor i in range(ind, len(digs)):\n\t\t\tdigs[i] = 3\n\t\treturn False\n\tif digs[ind] == 4:\n\t\tdigs[ind] = 5\n\t\tfor i in range(ind+1, len(digs)):\n\t\t\tdigs[i] = 3\n\t\treturn False\t\t\n\tif digs[ind] > 5:\n\t\tfor i in range(ind, len(digs)):\n\t\t\tdigs[i] = 3\n\t\treturn True\n\tif digs[ind] == 3:\n\t\tcarry = next_lucky(digs, ind+1)\n\t\tif carry:\n\t\t\tdigs[ind] = 5\n\t\treturn False\n\tif digs[ind] == 5:\n\t\tcarry = next_lucky(digs, ind+1)\n\t\tif not carry:\t\t\t\n\t\t\treturn False\n\t\tdigs[ind] = 3\n\t\treturn True\n\t\n\t\t\t\nfor lkjlkj in range(int(input())):\n\tdigs = list(int(x) for x in input())\n\tcarry = next_lucky(digs, 0)\n\tif carry:\n\t\tdigs = [3] + digs\n\tprint(''.join(map(str, digs)))\n"
    },
    {
        "task_id": 831,
        "slowest_solution_id": 7,
        "fastest_solution_id": 2,
        "slowest_time": 2.798401117324829,
        "fastest_time": 2.414238214492798,
        "fastest_solution": "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom collections import defaultdict\nfrom sys import stdin, stdout\nWHITE = 0\nGRAY = 1\nBLACK = 2\nread_numbers = lambda : list(map(int, stdin.readline().strip().split()))\noutput_line = lambda x: stdout.write(x)\n\ndef find_leaf(N, E, root=0):\n\tm = [WHITE] * N\n\tm[root] = GRAY\n\ts = [root]\n\tp = [0] * N\n\td = [0] * N\n\tmax_dist = 0\n\tmax_index = 0\n\twhile len(s):\n\t\tcur = s[-1]\n\t\tif m[cur] == BLACK:\n\t\t\ts.pop()\n\t\t\tcontinue\n\t\tfor i in E[cur]:\n\t\t\tif m[i] == WHITE:\n\t\t\t\tm[i] = GRAY\n\t\t\t\ts.append(i)\n\t\t\t\tp[i] = cur\n\t\t\tif m[i] != BLACK:\n\t\t\t\td[i] = d[p[i]] + 1\n\t\t\t\tif d[i] > max_dist:\n\t\t\t\t\tmax_dist = d[i]\n\t\t\t\t\tmax_index = i\n\t\tm[cur] = BLACK\n\treturn max_index\n\ndef search(N, E, root):\n\tm = [WHITE] * N\n\tm[root] = GRAY\n\ts = [root]\n\tp = [0] * N\n\td = [[] for _ in range(N)]\n\tc = [[] for _ in range(N)]\n\tleafs = [False] * N\n\twhile len(s):\n\t\tcur = s[-1]\n\t\tif m[cur] == BLACK:\n\t\t\ts.pop()\n\t\t\tnew_d = []\n\t\t\tfor children in c[cur]:\n\t\t\t\tif leafs[children]:\n\t\t\t\t\tnew_d += [1]\n\t\t\t\telse:\n\t\t\t\t\tif len(d[children]) > 0:\n\t\t\t\t\t\td[children][0] += 1\n\t\t\t\t\tnew_d += d[children]\n\t\t\td[cur] = new_d\n\t\t\td[cur].sort(reverse=True)\n\t\t\tcontinue\n\t\tadded = 0\n\t\tfor i in E[cur]:\n\t\t\tif m[i] == WHITE:\n\t\t\t\tm[i] = GRAY\n\t\t\t\ts.append(i)\n\t\t\t\tadded += 1\n\t\t\t\tp[i] = cur\n\t\t\tif m[i] != BLACK:\n\t\t\t\tc[cur].append(i)\n\t\tleafs[cur] = True if added == 0 else False\n\t\tm[cur] = BLACK\n\treturn d[root]\n\ndef solve(N, E, k):\n\tif k == 1:\n\t\treturn 1\n\tif k == 2:\n\t\treturn 2\n\troot = find_leaf(N, E)\n\td = search(N, E, root)\n\tmax_k = 1 + d[0]\n\tif k <= max_k:\n\t\treturn 2\n\ts = 2\n\tfor i in range(1, len(d)):\n\t\tmax_k += d[i]\n\t\ts += 1\n\t\tif k <= max_k:\n\t\t\treturn s\n\ndef main():\n\tsolutions = []\n\tfor _ in range(int(input())):\n\t\t(n, k) = read_numbers()\n\t\tE = defaultdict(list)\n\t\tfor _ in range(n - 1):\n\t\t\t(u, v) = read_numbers()\n\t\t\tu -= 1\n\t\t\tv -= 1\n\t\t\tE[u].append(v)\n\t\t\tE[v].append(u)\n\t\tsolutions.append(str(solve(n, E, k)))\n\tsolutions = '\\n'.join(solutions)\n\toutput_line(solutions)\nmain()\n",
        "slowest_solution": "import sys\ntry:\n\tsys.stdin = open('inputf.in', 'r')\n\tsys.stdout = open('outputf.in', 'w')\nexcept:\n\tpass\nfrom itertools import permutations, combinations\nimport heapq\nfrom collections import OrderedDict\nimport bisect\nfrom functools import cmp_to_key\nfrom collections import deque\nimport string\nfrom collections import Counter\nfrom collections import defaultdict\nfrom math import sqrt\nfrom queue import PriorityQueue\nimport sys\nfrom bisect import bisect_left, bisect_right\nMOD = 1000000007\nsys.setrecursionlimit(100000)\n\ndef ii():\n\treturn int(sys.stdin.readline().strip())\n\ndef si():\n\treturn sys.stdin.readline().strip()\n\ndef li():\n\treturn list(map(int, sys.stdin.readline().strip().split()))\n\ndef mi():\n\treturn map(int, sys.stdin.readline().strip().split())\n\ndef dparr(m, n):\n\treturn [[0] * n for i in range(m)]\n\ndef disdp(dp):\n\tfor i in dp:\n\t\tprint(*i)\n\ndef gai(i):\n\treturn ord(i) - ord('a')\n\ndef dij(graph, src):\n\tdis = [float('inf')] * (len(graph) + 1)\n\tdis[src] = 0\n\tq = deque()\n\tq.append(src)\n\twhile len(q) > 0:\n\t\tx = q.popleft()\n\t\tfor i in graph[x]:\n\t\t\tif dis[x] + 1 < dis[i]:\n\t\t\t\tdis[i] = min(dis[x] + 1, dis[i])\n\t\t\t\tq.append(i)\n\treturn dis\n\ndef nsel(arr):\n\tpre = []\n\tst = [-1]\n\tfor i in range(len(arr)):\n\t\twhile len(st) > 0 and arr[i] <= arr[st[-1]]:\n\t\t\tst.pop()\n\t\tif len(st) == 0:\n\t\t\tpre.append(-1)\n\t\telse:\n\t\t\tpre.append(st[-1])\n\t\tst.append(i)\n\treturn pre\n\ndef nser(arr):\n\tpre = []\n\tst = [-1]\n\tfor i in range(len(arr) - 1, -1, -1):\n\t\twhile len(st) > 0 and arr[i] <= arr[st[-1]]:\n\t\t\tst.pop()\n\t\tif len(st) == 0:\n\t\t\tpre.append(-1)\n\t\telse:\n\t\t\tpre.append(st[-1])\n\t\tst.append(i)\n\treturn pre[::-1]\n\ndef getarea(arr):\n\tleft = nsel(arr)\n\tright = nser(arr)\n\tn = len(arr)\n\tmx = 0\n\tprint(left, right)\n\tfor i in range(len(arr)):\n\t\tif left[i] == -1 and right[i] == -1:\n\t\t\tmx = max(mx, arr[i] * n)\n\t\telif left[i] == -1 and right[i] != -1:\n\t\t\tmx = max(mx, arr[i] * right[i])\n\t\telif left[i] != -1 and right[i] == -1:\n\t\t\tmx = max(mx, arr[i] * (n - left[i] - 1))\n\t\telse:\n\t\t\tmx = max(mx, arr[i] * (right[i] - left[i] - 1))\n\t\tprint(mx)\n\treturn mx\n\ndef func(nums, k):\n\tprecnt = [1 if nums[0] % 2 != 0 else 0]\n\tn = len(nums)\n\tfor i in range(1, n):\n\t\tif nums[i] % 2 != 0:\n\t\t\tprecnt.append(1 + precnt[-1])\n\t\telse:\n\t\t\tprecnt.append(precnt[-1])\n\tdp = {}\n\tdp[0] = 1\n\tans = 0\n\tfor i in range(n):\n\t\tif precnt[i] >= k:\n\t\t\ttry:\n\t\t\t\tans += dp[precnt[i] - k]\n\t\t\texcept:\n\t\t\t\tpass\n\t\ttry:\n\t\t\tdp[precnt[i]] += 1\n\t\texcept:\n\t\t\tdp[precnt[i]] = 1\n\tprint(ans)\n\ndef bfs(tree, n, node):\n\tvis = [False] * (n + 1)\n\tvis[node] = True\n\tq = deque()\n\tdist = [-1] * (n + 1)\n\tdist[node] = 0\n\tq.append(node)\n\twhile len(q) > 0:\n\t\tx = q.popleft()\n\t\tfor i in tree[x]:\n\t\t\tif vis[i] == False:\n\t\t\t\tdist[i] = dist[x] + 1\n\t\t\t\tvis[i] = True\n\t\t\t\tq.append(i)\n\tenddist = max(dist)\n\tendnode = dist.index(enddist)\n\treturn (endnode, enddist)\ndep = []\nvis = []\n\ndef depth(tree, parent, start):\n\tif vis[start]:\n\t\treturn 0\n\tvis[start] = True\n\tif tree[start] == []:\n\t\tdep[start] = 0\n\t\treturn 0\n\telif len(tree[start]) == 1 and tree[start][0] == parent:\n\t\treturn 0\n\telse:\n\t\tmd = 0\n\t\tfor i in tree[start]:\n\t\t\tif i != start:\n\t\t\t\tmd = max(md, depth(tree, start, i))\n\t\tdep[start] = md + 1\n\t\treturn md + 1\nfinal = {}\n\ndef get_path(tree, md, x, y, path):\n\tif vis[x]:\n\t\treturn\n\tvis[x] = True\n\tif len(path) + 1 == md:\n\t\tfinal['path'] = path + [x]\n\t\treturn\n\tfor i in tree[x]:\n\t\tget_path(tree, md, i, y, path + [x])\nt = ii()\nfor _ in range(t):\n\t(n, k) = mi()\n\ttree = {}\n\tfor i in range(1, n + 1):\n\t\ttree[i] = []\n\tfor i in range(n - 1):\n\t\t(u, v) = mi()\n\t\ttree[u].append(v)\n\t\ttree[v].append(u)\n\tif k == 1:\n\t\tprint(1)\n\telse:\n\t\t(start, startdist) = bfs(tree, n, 1)\n\t\t(end, enddist) = bfs(tree, n, start)\n\t\tdep = [0] * (n + 1)\n\t\tvis = [False] * (n + 1)\n\t\tdepth(tree, -1, start)\n\t\tvis = [False] * (n + 1)\n\t\tfinal = {}\n\t\tget_path(tree, max(dep) + 1, start, end, [])\n\t\tpath = final['path']\n\t\tvispath = set(path)\n\t\tif k <= len(path):\n\t\t\tprint(2)\n\t\telse:\n\t\t\tans = 2\n\t\t\tcurrnode = len(path)\n\t\t\tdpdep = Counter()\n\t\t\tx = 0\n\t\t\tfor i in range(n + 1):\n\t\t\t\tdpdep[i] = 0\n\t\t\tfor i in range(1, len(dep)):\n\t\t\t\tif i in vispath:\n\t\t\t\t\tcontinue\n\t\t\t\tdpdep[dep[i]] += 1\n\t\t\tfor i in range(n + 1, -1, -1):\n\t\t\t\ttemp = dpdep[i] - x\n\t\t\t\tb = False\n\t\t\t\tfor j in range(temp):\n\t\t\t\t\tans += 1\n\t\t\t\t\tcurrnode += i + 1\n\t\t\t\t\tif currnode >= k:\n\t\t\t\t\t\tb = True\n\t\t\t\t\t\tbreak\n\t\t\t\tif b:\n\t\t\t\t\tbreak\n\t\t\t\tx += temp\n\t\t\tprint(ans)\n"
    },
    {
        "task_id": 834,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 3.4512977600097656,
        "fastest_time": 2.4664463996887207,
        "fastest_solution": "import sys\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\ndef factors(x):\n\ts = set()\n\tfor i in range(1, int(x ** 0.5) + 1):\n\t\tif x % i == 0:\n\t\t\ts.add(i)\n\t\t\ts.add(x // i)\n\ts.remove(1)\n\treturn s\n(n, k) = input().strip().split(' ')\n(n, k) = [int(n), int(k)]\nA = [int(A_temp) for A_temp in input().strip().split(' ')]\ngcdA = A[0]\nfor a in A:\n\tgcdA = gcd(gcdA, a)\nbestL = 0\nfor f in factors(gcdA):\n\tbestL = max(bestL, k // f * f)\nprint(bestL)\n",
        "slowest_solution": "def euclidGCF(x, y):\n\twhile x:\n\t\t(x, y) = (y % x, x)\n\treturn y\n(n, k) = map(int, input().split())\nA = list(map(int, input().split()))\ngcf = A[0]\nfor x in A:\n\tgcf = euclidGCF(gcf, x)\nprimes = []\nn = 1000000\nsieve = [1] * n\nprimeset = set()\nfor i in range(2, n):\n\tif sieve[i]:\n\t\tprimeset.add(i)\n\t\tprimes.append(i)\n\t\tfor j in range(2 * i, n, i):\n\t\t\tsieve[j] = 0\n\ndef primefactors(n):\n\tfound = set()\n\twhile n > 1:\n\t\tfor p in primes:\n\t\t\tif p ** 2 > n:\n\t\t\t\tif n not in found:\n\t\t\t\t\tyield n\n\t\t\t\tn = 1\n\t\t\t\tbreak\n\t\t\tif n % p == 0:\n\t\t\t\tif p not in found:\n\t\t\t\t\tyield p\n\t\t\t\t\tfound.add(p)\n\t\t\t\tn //= p\n\t\t\t\tbreak\nfactors = list(primefactors(gcf))\nprint(max(map(lambda x: k // x * x, factors)))\n"
    },
    {
        "task_id": 874,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 3.4792003631591797,
        "fastest_time": 2.6672213077545166,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\np = 998244353\n\nclass matrix_data:\n\n\tdef __init__(self, n, m):\n\t\tself.n = n\n\t\tself.m = m\n\t\tself.filled = {}\n\t\tself.alternating = [0, 0]\n\t\tself.rows = [[0] * (n + 1), [0] * (n + 1)]\n\t\tself.cols = [[0] * (m + 1), [0] * (m + 1)]\n\t\tself.frozen_rows = 0\n\t\tself.frozen_cols = 0\n\t\tself.bad_rows = 0\n\t\tself.bad_cols = 0\n\n\tdef clear(self, x, y):\n\t\tif (x, y) not in self.filled:\n\t\t\treturn\n\t\tt = self.filled.pop((x, y))\n\t\tself.alternating[(x + y + t) % 2] -= 1\n\t\tself.rows[(y + t) % 2][x] -= 1\n\t\tif self.rows[(y + t) % 2][x] == 0:\n\t\t\tif self.rows[(y + t + 1) % 2][x] == 0:\n\t\t\t\tself.frozen_rows -= 1\n\t\t\telse:\n\t\t\t\tself.bad_rows -= 1\n\t\tself.cols[(x + t) % 2][y] -= 1\n\t\tif self.cols[(x + t) % 2][y] == 0:\n\t\t\tif self.cols[(x + t + 1) % 2][y] == 0:\n\t\t\t\tself.frozen_cols -= 1\n\t\t\telse:\n\t\t\t\tself.bad_cols -= 1\n\n\tdef write(self, x, y, t):\n\t\tself.filled[x, y] = t\n\t\tself.alternating[(x + y + t) % 2] += 1\n\t\tself.rows[(y + t) % 2][x] += 1\n\t\tif self.rows[(y + t) % 2][x] == 1:\n\t\t\tif self.rows[(y + t + 1) % 2][x] == 0:\n\t\t\t\tself.frozen_rows += 1\n\t\t\telse:\n\t\t\t\tself.bad_rows += 1\n\t\tself.cols[(x + t) % 2][y] += 1\n\t\tif self.cols[(x + t) % 2][y] == 1:\n\t\t\tif self.cols[(x + t + 1) % 2][y] == 0:\n\t\t\t\tself.frozen_cols += 1\n\t\t\telse:\n\t\t\t\tself.bad_cols += 1\n\n\tdef count(self):\n\t\ttotal = 0\n\t\tif self.bad_rows == 0:\n\t\t\ttotal += pow(2, n - self.frozen_rows, p)\n\t\tif self.bad_cols == 0:\n\t\t\ttotal += pow(2, m - self.frozen_cols, p)\n\t\tif self.alternating[0] == 0:\n\t\t\ttotal -= 1\n\t\tif self.alternating[1] == 0:\n\t\t\ttotal -= 1\n\t\tprint(total % p)\n(n, m, k) = map(int, input().split())\ndata = matrix_data(n, m)\nfor _ in range(k):\n\t(x, y, t) = map(int, input().split())\n\tif t == -1:\n\t\tdata.clear(x, y)\n\telse:\n\t\tdata.clear(x, y)\n\t\tdata.write(x, y, t)\n\tdata.count()\n",
        "slowest_solution": "import sys\ninput = sys.stdin.buffer.readline\n(n, m, q) = map(int, input().split())\nqueries = [list(map(int, input().split())) for i in range(q)]\nMOD = 998244353\npow2 = [0] * (10 ** 6 + 10 + 1)\npow2[0] = 1\nfor i in range(10 ** 6 + 10):\n\tpow2[i + 1] = pow2[i] * 2 % MOD\nans = [0] * q\ncnt0 = [0] * n\ncnt1 = [0] * n\nmass = {}\nnone = n\nzero = 0\none = 0\ninvalid = 0\nfor (idx, (i, j, flag)) in enumerate(queries):\n\ti -= 1\n\tj -= 1\n\tif (i, j) in mass:\n\t\t(c0, c1) = (cnt0[i], cnt1[i])\n\t\tif mass[i, j] == 0 and j % 2 == 0:\n\t\t\tcnt0[i] -= 1\n\t\tif mass[i, j] == 0 and j % 2 == 1:\n\t\t\tcnt1[i] -= 1\n\t\tif mass[i, j] == 1 and j % 2 == 0:\n\t\t\tcnt1[i] -= 1\n\t\tif mass[i, j] == 1 and j % 2 == 1:\n\t\t\tcnt0[i] -= 1\n\t\tdel mass[i, j]\n\t\tif c0 == 1 and cnt0[i] == 0 and (cnt1[i] == 0):\n\t\t\tzero -= 1\n\t\t\tnone += 1\n\t\tif c1 == 1 and cnt1[i] == 0 and (cnt0[i] == 0):\n\t\t\tone -= 1\n\t\t\tnone += 1\n\t\tif c0 == 1 and cnt0[i] == 0 and (cnt1[i] > 0):\n\t\t\tinvalid -= 1\n\t\t\tone += 1\n\t\tif c1 == 1 and cnt1[i] == 0 and (cnt0[i] > 0):\n\t\t\tinvalid -= 1\n\t\t\tzero += 1\n\t(c0, c1) = (cnt0[i], cnt1[i])\n\tif flag == 0 and j % 2 == 0:\n\t\tmass[i, j] = 0\n\t\tcnt0[i] += 1\n\tif flag == 0 and j % 2 == 1:\n\t\tmass[i, j] = 0\n\t\tcnt1[i] += 1\n\tif flag == 1 and j % 2 == 0:\n\t\tmass[i, j] = 1\n\t\tcnt1[i] += 1\n\tif flag == 1 and j % 2 == 1:\n\t\tmass[i, j] = 1\n\t\tcnt0[i] += 1\n\tif c0 == 0 and c1 == 0 and (cnt0[i] == 1):\n\t\tzero += 1\n\t\tnone -= 1\n\tif c0 == 0 and c1 == 0 and (cnt1[i] == 1):\n\t\tone += 1\n\t\tnone -= 1\n\tif c0 == 0 and cnt0[i] > 0 and (cnt1[i] > 0):\n\t\tinvalid += 1\n\t\tone -= 1\n\tif c1 == 0 and cnt0[i] > 0 and (cnt1[i] > 0):\n\t\tinvalid += 1\n\t\tzero -= 1\n\tif invalid > 0:\n\t\tcontinue\n\tans[idx] += pow2[none]\n\tans[idx] %= MOD\ncnt0 = [0] * m\ncnt1 = [0] * m\nmass = {}\nnone = m\nzero = 0\none = 0\ninvalid = 0\nfor (idx, (i, j, flag)) in enumerate(queries):\n\t(i, j) = (j, i)\n\ti -= 1\n\tj -= 1\n\tif (i, j) in mass:\n\t\t(c0, c1) = (cnt0[i], cnt1[i])\n\t\tif mass[i, j] == 0 and j % 2 == 0:\n\t\t\tcnt0[i] -= 1\n\t\tif mass[i, j] == 0 and j % 2 == 1:\n\t\t\tcnt1[i] -= 1\n\t\tif mass[i, j] == 1 and j % 2 == 0:\n\t\t\tcnt1[i] -= 1\n\t\tif mass[i, j] == 1 and j % 2 == 1:\n\t\t\tcnt0[i] -= 1\n\t\tdel mass[i, j]\n\t\tif c0 == 1 and cnt0[i] == 0 and (cnt1[i] == 0):\n\t\t\tzero -= 1\n\t\t\tnone += 1\n\t\tif c1 == 1 and cnt1[i] == 0 and (cnt0[i] == 0):\n\t\t\tone -= 1\n\t\t\tnone += 1\n\t\tif c0 == 1 and cnt0[i] == 0 and (cnt1[i] > 0):\n\t\t\tinvalid -= 1\n\t\t\tone += 1\n\t\tif c1 == 1 and cnt1[i] == 0 and (cnt0[i] > 0):\n\t\t\tinvalid -= 1\n\t\t\tzero += 1\n\t(c0, c1) = (cnt0[i], cnt1[i])\n\tif flag == 0 and j % 2 == 0:\n\t\tmass[i, j] = 0\n\t\tcnt0[i] += 1\n\tif flag == 0 and j % 2 == 1:\n\t\tmass[i, j] = 0\n\t\tcnt1[i] += 1\n\tif flag == 1 and j % 2 == 0:\n\t\tmass[i, j] = 1\n\t\tcnt1[i] += 1\n\tif flag == 1 and j % 2 == 1:\n\t\tmass[i, j] = 1\n\t\tcnt0[i] += 1\n\tif c0 == 0 and c1 == 0 and (cnt0[i] == 1):\n\t\tzero += 1\n\t\tnone -= 1\n\tif c0 == 0 and c1 == 0 and (cnt1[i] == 1):\n\t\tone += 1\n\t\tnone -= 1\n\tif c0 == 0 and cnt0[i] > 0 and (cnt1[i] > 0):\n\t\tinvalid += 1\n\t\tone -= 1\n\tif c1 == 0 and cnt0[i] > 0 and (cnt1[i] > 0):\n\t\tinvalid += 1\n\t\tzero -= 1\n\tif invalid > 0:\n\t\tcontinue\n\tans[idx] += pow2[none]\n\tans[idx] %= MOD\neven = [0, 0]\nodd = [0, 0]\nmass = {}\nfor (idx, (i, j, flag)) in enumerate(queries):\n\tif (i, j) in mass:\n\t\tif (i + j) % 2 == 0:\n\t\t\teven[mass[i, j]] -= 1\n\t\telse:\n\t\t\todd[mass[i, j]] -= 1\n\t\tdel mass[i, j]\n\tif flag == 0 or flag == 1:\n\t\tmass[i, j] = flag\n\t\tif (i + j) % 2 == 0:\n\t\t\teven[flag] += 1\n\t\telse:\n\t\t\todd[flag] += 1\n\tif sum(even) + sum(odd) == 0:\n\t\tans[idx] -= 2\n\t\tans[idx] %= MOD\n\telif even[0] * even[1] > 0 or odd[0] * odd[1] > 0 or even[0] * odd[0] > 0 or (even[1] * odd[1] > 0):\n\t\tpass\n\telse:\n\t\tans[idx] -= 1\n\t\tans[idx] %= MOD\nprint('\\n'.join(map(str, ans)))\n"
    },
    {
        "task_id": 843,
        "slowest_solution_id": 8,
        "fastest_solution_id": 6,
        "slowest_time": 2.8406379222869873,
        "fastest_time": 2.4821465015411377,
        "fastest_solution": "from sys import stdin, setrecursionlimit\nimport threading\nn = int(stdin.readline())\nw = [int(x) for x in stdin.readline().split()]\ngraph = [{} for x in range(n)]\nfor road in range(n - 1):\n\t(u, v, c) = [int(x) for x in stdin.readline().split()]\n\tu -= 1\n\tv -= 1\n\tif v in graph[u]:\n\t\tgraph[u][v] = min(graph[u][v], c)\n\telse:\n\t\tgraph[u][v] = c\n\tif u in graph[v]:\n\t\tgraph[v][u] = min(graph[v][u], c)\n\telse:\n\t\tgraph[v][u] = c\ngas = [{} for x in range(n)]\nhighs = [[0, 0] for x in range(n)]\npath = [(0, 0)]\nind = 0\nwhile ind < len(path):\n\t(cur, par) = path[ind]\n\tedges = graph[cur]\n\tfor x in edges:\n\t\tif x != par:\n\t\t\tpath.append((x, cur))\n\tind += 1\n\ndef mostGas(node, parent):\n\tedges = graph[node]\n\thigh = w[node]\n\thigh2 = w[node]\n\tfor x in edges:\n\t\tif x != parent:\n\t\t\tgas[node][x] = highs[x][0] + w[node] - edges[x]\n\t\t\tif gas[node][x] > high:\n\t\t\t\t(high, high2) = (gas[node][x], high)\n\t\t\telif gas[node][x] > high2:\n\t\t\t\thigh2 = gas[node][x]\n\thighs[node] = [high, high2]\n\treturn high\nfor (x, y) in path[::-1]:\n\tmostGas(x, y)\nhigh = 0\nfor x in range(n):\n\thigh = max(high, highs[x][0] + highs[x][1] - w[x])\nprint(high)\n",
        "slowest_solution": "import sys\nfrom collections import deque\nsys.setrecursionlimit(1000000)\ninput = sys.stdin.readline\nn = int(input())\nW = list(map(int, input().split()))\nEDGE = [list(map(int, input().split())) for i in range(n - 1)]\nEDGELIST = [[] for i in range(n + 1)]\nfor (i, j, c) in EDGE:\n\tEDGELIST[i].append([j, c])\n\tEDGELIST[j].append([i, c])\nQUE = deque([1])\nCOST = [[None] for i in range(n + 1)]\nCOST[1] = W[0]\nUSED = [0] * (n + 1)\nUSED[1] = 1\nHLIST = []\nEDGELIST2 = [[] for i in range(n + 1)]\nwhile QUE:\n\tx = QUE.pop()\n\tfor (to, length) in EDGELIST[x]:\n\t\tif USED[to] == 0:\n\t\t\tCOST[to] = COST[x] - length + W[to - 1]\n\t\t\tQUE.append(to)\n\t\t\tEDGELIST2[x].append(to)\n\tUSED[x] = 1\n\tHLIST.append(x)\nMAXCOST = dict()\n\ndef best(i, j):\n\tif MAXCOST.get((i, j)) != None:\n\t\treturn MAXCOST[i, j]\n\telse:\n\t\tANS = COST[j]\n\t\tfor (k, _) in EDGELIST[j]:\n\t\t\tif k == i:\n\t\t\t\tcontinue\n\t\t\tif ANS < best(j, k):\n\t\t\t\tANS = best(j, k)\n\t\tMAXCOST[i, j] = ANS\n\t\treturn ANS\nANS = max(W)\nfor i in HLIST[::-1]:\n\tfor j in EDGELIST2[i]:\n\t\tif ANS < best(i, j) - COST[i] + W[i - 1]:\n\t\t\tANS = best(i, j) - COST[i] + W[i - 1]\n\tCLIST = []\n\tfor j in EDGELIST2[i]:\n\t\tCLIST.append(best(i, j))\n\tif len(CLIST) <= 1:\n\t\tcontinue\n\telse:\n\t\tCLIST.sort(reverse=True)\n\t\tif ANS < CLIST[0] + CLIST[1] - COST[i] * 2 + W[i - 1]:\n\t\t\tANS = CLIST[0] + CLIST[1] - COST[i] * 2 + W[i - 1]\nprint(ANS)\n"
    },
    {
        "task_id": 882,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.6429240703582764,
        "fastest_time": 2.6429240703582764,
        "fastest_solution": "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\nclass fenwicktree:\n\n\tdef __init__(self, n):\n\t\tself.BITTree = [0] * (n + 1)\n\t\tself.size = n\n\n\tdef getsum(self, i):\n\t\ts = 0\n\t\ti = i + 1\n\t\twhile i > 0:\n\t\t\ts += self.BITTree[i]\n\t\t\ti -= i & -i\n\t\treturn s\n\n\tdef query(self, l, r):\n\t\treturn self.getsum(r) - self.getsum(l - 1)\n\n\tdef update(self, i, v):\n\t\ti += 1\n\t\twhile i <= self.size:\n\t\t\tself.BITTree[i] += v\n\t\t\ti += i & -i\n\ndef dfs(p, prev):\n\tv = a[p - 1]\n\tfor i in child[p]:\n\t\tv += a[i - 1]\n\tcount.update(v, 1)\n\tfor i in child[p]:\n\t\tif i == prev:\n\t\t\tcontinue\n\t\tdfs(i, p)\n\tfor i in take[p]:\n\t\t(t, k, ind) = i\n\t\t(l, h) = (0, n)\n\t\tpoint = -1\n\t\twhile l <= h:\n\t\t\tmid = (l + h) // 2\n\t\t\tif count.query(n - mid, n) < t:\n\t\t\t\tl = mid + 1\n\t\t\telse:\n\t\t\t\tpoint = n - mid\n\t\t\t\th = mid - 1\n\t\tif point == -1:\n\t\t\tcontinue\n\t\tc = point\n\t\t(l, h) = (0, k)\n\t\twhile l <= h:\n\t\t\tmid = (l + h) // 2\n\t\t\tval = c * (mid * (mid + 1) // 2)\n\t\t\tif val < k:\n\t\t\t\tl = mid + 1\n\t\t\telse:\n\t\t\t\tans[ind] = mid\n\t\t\t\th = mid - 1\n\tfor i in take[p]:\n\t\t(t, k, ind) = i\n\tcount.update(v, -1)\nfor T in range(1):\n\tn = int(input())\n\ta = inp()\n\tchild = [[] for i in range(n + 1)]\n\tfor i in range(n - 1):\n\t\t(u, v) = inp()\n\t\tchild[u].append(v)\n\t\tchild[v].append(u)\n\ttake = [[] for i in range(n + 1)]\n\tm = int(input())\n\tfor q in range(m):\n\t\t(x, t, k) = inp()\n\t\ttake[x].append([t, k, q])\n\tans = [-1 for i in range(m)]\n\tcount = fenwicktree(n + 1)\n\tdfs(1, 0)\n\tprint(*ans, sep='\\n')\n",
        "slowest_solution": "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 5)\ninp = lambda : list(map(int, input().split()))\n\nclass fenwicktree:\n\n\tdef __init__(self, n):\n\t\tself.BITTree = [0] * (n + 1)\n\t\tself.size = n\n\n\tdef getsum(self, i):\n\t\ts = 0\n\t\ti = i + 1\n\t\twhile i > 0:\n\t\t\ts += self.BITTree[i]\n\t\t\ti -= i & -i\n\t\treturn s\n\n\tdef query(self, l, r):\n\t\treturn self.getsum(r) - self.getsum(l - 1)\n\n\tdef update(self, i, v):\n\t\ti += 1\n\t\twhile i <= self.size:\n\t\t\tself.BITTree[i] += v\n\t\t\ti += i & -i\n\ndef dfs(p, prev):\n\tv = a[p - 1]\n\tfor i in child[p]:\n\t\tv += a[i - 1]\n\tcount.update(v, 1)\n\tfor i in child[p]:\n\t\tif i == prev:\n\t\t\tcontinue\n\t\tdfs(i, p)\n\tfor i in take[p]:\n\t\t(t, k, ind) = i\n\t\t(l, h) = (0, n)\n\t\tpoint = -1\n\t\twhile l <= h:\n\t\t\tmid = (l + h) // 2\n\t\t\tif count.query(n - mid, n) < t:\n\t\t\t\tl = mid + 1\n\t\t\telse:\n\t\t\t\tpoint = n - mid\n\t\t\t\th = mid - 1\n\t\tif point == -1:\n\t\t\tcontinue\n\t\tc = point\n\t\t(l, h) = (0, k)\n\t\twhile l <= h:\n\t\t\tmid = (l + h) // 2\n\t\t\tval = c * (mid * (mid + 1) // 2)\n\t\t\tif val < k:\n\t\t\t\tl = mid + 1\n\t\t\telse:\n\t\t\t\tans[ind] = mid\n\t\t\t\th = mid - 1\n\tfor i in take[p]:\n\t\t(t, k, ind) = i\n\tcount.update(v, -1)\nfor T in range(1):\n\tn = int(input())\n\ta = inp()\n\tchild = [[] for i in range(n + 1)]\n\tfor i in range(n - 1):\n\t\t(u, v) = inp()\n\t\tchild[u].append(v)\n\t\tchild[v].append(u)\n\ttake = [[] for i in range(n + 1)]\n\tm = int(input())\n\tfor q in range(m):\n\t\t(x, t, k) = inp()\n\t\ttake[x].append([t, k, q])\n\tans = [-1 for i in range(m)]\n\tcount = fenwicktree(n + 1)\n\tdfs(1, 0)\n\tprint(*ans, sep='\\n')\n"
    },
    {
        "task_id": 837,
        "slowest_solution_id": 3,
        "fastest_solution_id": 4,
        "slowest_time": 3.0182080268859863,
        "fastest_time": 2.315871238708496,
        "fastest_solution": "import sys\n\ndef binary_search(arr, col, low, high, order, min_value):\n\twhile low < high:\n\t\tmid = (low + high) // 2\n\t\tif (arr[mid][col] - arr[mid - order][col] - arr[mid][col - order] + arr[mid - order][col - order]) / (order * order) >= min_value:\n\t\t\thigh = mid - 1\n\t\telse:\n\t\t\tlow = mid + 1\n\treturn low\n\ndef binary_search2(arr, row, low, high, order, min_value):\n\twhile low < high:\n\t\tmid = (low + high) // 2\n\t\tif (arr[row][mid] - arr[row - order][mid] - arr[row][mid - order] + arr[row - order][mid - order]) / (order * order) >= min_value:\n\t\t\thigh = mid - 1\n\t\telse:\n\t\t\tlow = mid + 1\n\treturn low\n\ndef count(m, n, k, arr):\n\tmatrix_count = 0\n\tfor i in range(1, m + 1):\n\t\trow_sum = 0\n\t\tfor j in range(1, n + 1):\n\t\t\tarr[i][j] = row_sum + arr[i][j]\n\t\t\trow_sum = arr[i][j]\n\tfor i in range(1, n + 1):\n\t\tcol_sum = 0\n\t\tfor j in range(1, m + 1):\n\t\t\tarr[j][i] = col_sum + arr[j][i]\n\t\t\tcol_sum = arr[j][i]\n\tfor order in range(1, m + 1):\n\t\tfor i in range(binary_search(arr, n, order, m, order, k), m + 1):\n\t\t\tfor j in range(binary_search2(arr, i, order, n, order, k), n + 1):\n\t\t\t\tif (arr[i][j] - arr[i - order][j] - arr[i][j - order] + arr[i - order][j - order]) / (order * order) >= k:\n\t\t\t\t\tmatrix_count += n - j + 1\n\t\t\t\t\tbreak\n\treturn matrix_count\nt = int(input())\nfor _ in range(t):\n\t(n, m, k) = map(int, input().split())\n\tarr = [[0] * (m + 1)]\n\tfor row in range(n):\n\t\ttemp = list(map(int, sys.stdin.readline().split()))\n\t\ttemp.insert(0, 0)\n\t\tarr.append(temp)\n\tprint(str(count(n, m, k, arr)))\n",
        "slowest_solution": "def test_case():\n\t(n, m, k) = map(int, input().strip().split())\n\tA = [[int(x) for x in input().strip().split()] for y in range(n)]\n\tG = [[0 for x in range(m + 1)] for y in range(n + 1)]\n\tfor row in range(1, n + 1):\n\t\tfor col in range(1, m + 1):\n\t\t\tG[row][col] = A[row - 1][col - 1] + G[row - 1][col] + G[row][col - 1] - G[row - 1][col - 1]\n\tsize = min(n, m)\n\tps = 0\n\tfor sz in range(1, size + 1):\n\t\tfor row in range(sz, n + 1):\n\t\t\tlow = sz\n\t\t\thigh = m\n\t\t\twhile low <= high:\n\t\t\t\tmid = (low + high) // 2\n\t\t\t\tssum = G[row][mid] - G[row - sz][mid] - G[row][mid - sz] + G[row - sz][mid - sz]\n\t\t\t\tif ssum // (sz * sz) >= k:\n\t\t\t\t\thigh = mid - 1\n\t\t\t\t\tcurr = mid\n\t\t\t\telse:\n\t\t\t\t\tlow = mid + 1\n\t\t\tif low <= m:\n\t\t\t\tps += m - curr + 1\n\tprint(ps)\nfor _ in range(int(input().strip())):\n\ttest_case()\n"
    },
    {
        "task_id": 866,
        "slowest_solution_id": 4,
        "fastest_solution_id": 8,
        "slowest_time": 2.7898993492126465,
        "fastest_time": 2.529345750808716,
        "fastest_solution": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs2(node, tree, visited, days, solver, answer):\n\tvisited[node] = True\n\tchild = tree[node]\n\tif len(child) == 1:\n\t\tanswer.append(node)\n\t\treturn\n\ttog = 0\n\tmild = min(solver[node])\n\ttemp = len(set(solver[node]))\n\tif temp == 1 or mild > days:\n\t\tfor i in child:\n\t\t\tif visited[i] == False:\n\t\t\t\tdfs2(i, tree, visited, days, solver, answer)\n\telse:\n\t\tfor i in child:\n\t\t\tif visited[i] == False:\n\t\t\t\tif solver[node][tog] != mild:\n\t\t\t\t\tdfs2(i, tree, visited, mild, solver, answer)\n\t\t\t\ttog += 1\n\treturn\n\ndef firstnode(node, tree, visited, days, solver, answer):\n\tvisited[node] = True\n\twhile len(tree[node]) == 2:\n\t\tfor i in tree[node]:\n\t\t\tif visited[i] == False:\n\t\t\t\tnode = i\n\t\t\t\tvisited[node] = True\n\t\t\t\tdays -= 1\n\t\t\t\tbreak\n\tif len(tree[node]) == 1:\n\t\tanswer.append(node)\n\t\treturn\n\tdfs2(node, tree, visited, days - 1, solver, answer)\n\treturn\n\ndef dfs1(node, tree, visited, solver):\n\tvisited[node] = True\n\tchild = tree[node]\n\tif len(child) == 1:\n\t\treturn 1\n\ttemp = []\n\tc = 0\n\tk = 0\n\tmi = 10000000000.0\n\ttemp = []\n\tfor i in child:\n\t\tif visited[i] == False:\n\t\t\tdays = dfs1(i, tree, visited, solver)\n\t\t\ttemp.append(days)\n\t\t\tk += 1\n\t\t\tif days < mi:\n\t\t\t\tmi = days\n\t\t\t\tc = 1\n\t\t\telif days == mi:\n\t\t\t\tc += 1\n\tif c == k:\n\t\tfor i in range(k):\n\t\t\tsolver[node].append(mi)\n\t\treturn mi + 1\n\telse:\n\t\tfor i in range(k):\n\t\t\tif temp[i] == mi:\n\t\t\t\tsolver[node].append(mi)\n\t\t\telse:\n\t\t\t\tsolver[node].append(mi + 1)\n\t\treturn mi + 2\n\ndef solve(king, tree, n):\n\tass = 10000000000.0\n\tvil = tree[king]\n\tvisited = [False for x in range(n + 1)]\n\tvisited[king] = True\n\tans = -1\n\tmvil = []\n\tsolver = [[] for x in range(n + 1)]\n\tfor i in vil:\n\t\ta = dfs1(i, tree, visited, solver)\n\t\tif ans == -1 or a < ans:\n\t\t\tmvil = [i]\n\t\t\tans = a\n\t\telif a == ans:\n\t\t\tmvil.append(i)\n\tvisited = [False for x in range(n + 1)]\n\tvisited[king] = True\n\tanswer = []\n\tfor i in mvil:\n\t\tfirstnode(i, tree, visited, ans, solver, answer)\n\tanswer.sort()\n\tprint(len(answer), ans)\n\tfor i in answer:\n\t\tprint(i, end=' ')\n\tprint()\nt = int(input())\nfor test in range(t):\n\tn = int(input())\n\ttree = [[] for x in range(n + 1)]\n\tfor i in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\ttree[u].append(v)\n\t\ttree[v].append(u)\n\tsolve(1, tree, n)\n",
        "slowest_solution": "class Node:\n\n\tdef __init__(self, val, next=None) -> None:\n\t\tself.val = val\n\t\tself.next = next\nglobal d, entry, parent, killers\n\ndef calc():\n\tglobal entry, d, parent, killers\n\tStack = [[1, 0, 0]]\n\tt = 2\n\tentry[1] = 1\n\twhile Stack:\n\t\t(n, ind, cnt) = Stack[-1]\n\t\tif ind < len(d[n]):\n\t\t\tchild = d[n][ind]\n\t\t\tStack[-1][1] += 1\n\t\t\tif n > 1 and child == Stack[-2][0]:\n\t\t\t\tcontinue\n\t\t\ttop = [child, 0, 0]\n\t\t\tentry[child] = t\n\t\t\tt += 1\n\t\t\tStack[-1][-1] += 1\n\t\t\tparent[child] = n\n\t\t\tStack.append(top)\n\t\t\tcontinue\n\t\tif ind >= len(d[n]):\n\t\t\t(n, ind, cnt) = Stack.pop()\n\t\t\tif cnt == 0:\n\t\t\t\tnode = Node(n)\n\t\t\t\tkillers.append([n, node, node])\n\ndef progress():\n\tglobal entry, d, killers, parent\n\tnotvalid = dict()\n\tstatus = dict()\n\tfor (n, head, tail) in killers:\n\t\tstatus[n] = [head, tail]\n\tday = 0\n\twhile True:\n\t\tp_st = dict()\n\t\tdest = False\n\t\tfor cur in status:\n\t\t\tnotvalid[cur] = 1\n\t\t\tp = parent[cur]\n\t\t\tif p == 1:\n\t\t\t\tdest = True\n\t\t\tif p_st.get(p):\n\t\t\t\t(head, tail) = p_st[p]\n\t\t\t\t(node, ntail) = status[cur]\n\t\t\t\ttail.next = node\n\t\t\t\ttail = ntail\n\t\t\t\tp_st[p] = [head, tail]\n\t\t\telse:\n\t\t\t\tp_st[p] = status[cur]\n\t\tif dest:\n\t\t\tday += 1\n\t\t\treturn [day, p_st[1]]\n\t\tstatus = dict()\n\t\torder = list(p_st.keys())\n\t\torder.sort(key=lambda x: entry[x])\n\t\tfor cur in order:\n\t\t\tStack = [[cur, 0, 0]]\n\t\t\tif notvalid.get(cur):\n\t\t\t\tStack = []\n\t\t\twhile Stack:\n\t\t\t\t(n, ind, cnt) = Stack[-1]\n\t\t\t\tif ind < len(d[n]):\n\t\t\t\t\tchild = d[n][ind]\n\t\t\t\t\tStack[-1][1] += 1\n\t\t\t\t\tif notvalid.get(child) or parent[n] == child:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\ttop = [child, 0, 0]\n\t\t\t\t\tStack[-1][-1] += 1\n\t\t\t\t\tnotvalid[child] = 1\n\t\t\t\t\tStack.append(top)\n\t\t\t\t\tcontinue\n\t\t\t\tif ind >= len(d[n]):\n\t\t\t\t\t(n, ind, cnt) = Stack.pop()\n\t\t\t\t\tif cnt == 0:\n\t\t\t\t\t\tif n != cur:\n\t\t\t\t\t\t\tnotvalid[n] = 1\n\t\t\t\t\t\t\tparent[n] = cur\n\t\t\t\t\t\tstatus[n] = p_st[n]\n\t\tday += 1\nT = int(input().rstrip())\nfor _ in range(T):\n\tN = int(input().rstrip())\n\td = dict()\n\tentry = dict()\n\tparent = dict()\n\tkillers = []\n\tfor i in range(1, N + 1):\n\t\td[i] = []\n\tfor __ in range(N - 1):\n\t\t(u, v) = list(map(int, input().rstrip().split(' ')))\n\t\td[u].append(v)\n\t\td[v].append(u)\n\tcalc()\n\tbuff = []\n\t(cost, L) = progress()\n\tB = [0 for _ in range(N)]\n\tl = 0\n\t(Head, tail) = L\n\twhile Head:\n\t\ti = Head.val\n\t\tB[i - 1] = 1\n\t\tHead = Head.next\n\t\tl += 1\n\tprint(l, cost)\n\tfor i in range(N):\n\t\tif B[i] == 1:\n\t\t\tprint(i + 1, end=' ')\n\tprint()\n"
    },
    {
        "task_id": 862,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.953559398651123,
        "fastest_time": 2.3530161380767822,
        "fastest_solution": "from sys import stdin\nfor __ in range(int(stdin.readline())):\n\tn = int(stdin.readline())\n\tnums = list(map(int, stdin.readline().split()))\n\n\tdef solve(array, i, j):\n\t\tsmallest = array[i]\n\t\tsets = [[i, i]]\n\t\tfor k in range(i + 1, j):\n\t\t\tif array[k] == smallest:\n\t\t\t\tif sets[-1][1] + 1 == k:\n\t\t\t\t\tsets[-1][1] += 1\n\t\t\t\telse:\n\t\t\t\t\tsets.append([k, k])\n\t\t\telif array[k] < smallest:\n\t\t\t\tsmallest = array[k]\n\t\t\t\tsets = [[k, k]]\n\t\tsets = [[i - 1, i - 1]] + sets + [[j, j]]\n\t\tans = 1\n\t\tfor i in range(1, len(sets)):\n\t\t\tif sets[i - 1][1] + 1 < sets[i][0]:\n\t\t\t\tans += solve(array, sets[i - 1][1] + 1, sets[i][0])\n\t\treturn ans\n\tprint(solve(nums, 0, n) - 1)\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\tarr = list(map(int, input().split()))\n\ttop = -1\n\tst = []\n\tco = 0\n\tfor i in arr:\n\t\twhile len(st) and st[-1] > i:\n\t\t\tst.pop()\n\t\t\tco += 1\n\t\tif len(st) and st[-1] == i:\n\t\t\tst.pop()\n\t\tst.append(i)\n\tco += len(st) - 1\n\tprint(co)\n"
    },
    {
        "task_id": 849,
        "slowest_solution_id": 6,
        "fastest_solution_id": 3,
        "slowest_time": 2.7572240829467773,
        "fastest_time": 2.374849796295166,
        "fastest_solution": "import sys\nlst = []\ntime = 0\nn = 0\nfor line in sys.stdin:\n\tif time == 0:\n\t\ttime = 1\n\t\tn = int(line.split()[0])\n\t\tcontinue\n\tlst.append([int(x) for x in line.split()])\nfor i in range(n):\n\tl = lst[2 * i][0]\n\tc11 = 0\n\tc21 = 0\n\tc12 = 0\n\tc22 = 0\n\tfor j in range(l):\n\t\tb1 = lst[2 * i + 1][j] != j + 1\n\t\tb2 = lst[2 * i + 1][j] != l - j\n\t\tif b1:\n\t\t\tc11 += 1\n\t\tif b2:\n\t\t\tc21 += 1\n\t\tif b1 == True and b2 == False:\n\t\t\tc12 += 1\n\t\tif b2 == True and b1 == False:\n\t\t\tc22 += 1\n\tif c11 <= c22:\n\t\tprint('First')\n\telif c21 <= c12 - 1:\n\t\tprint('Second')\n\telse:\n\t\tprint('Tie')\n",
        "slowest_solution": "num_case = int(input())\nfor case_idx in range(num_case):\n\tn = int(input())\n\tp = list(map(int, input().split()))\n\tfirst_unique = second_unique = common = 0\n\tfor i in range(n):\n\t\tif p[i] != i + 1 and p[i] != n - i:\n\t\t\tcommon += 1\n\t\telif p[i] != i + 1:\n\t\t\tfirst_unique += 1\n\t\telif p[i] != n - i:\n\t\t\tsecond_unique += 1\n\tif first_unique + common <= second_unique:\n\t\tprint('First')\n\telif second_unique + common < first_unique:\n\t\tprint('Second')\n\telse:\n\t\tprint('Tie')\n"
    },
    {
        "task_id": 877,
        "slowest_solution_id": 1,
        "fastest_solution_id": 4,
        "slowest_time": 2.9307947158813477,
        "fastest_time": 2.5584604740142822,
        "fastest_solution": "(n, s) = map(int, input().split())\nif not 2 * n - 1 <= s <= n * (n + 1) // 2:\n\tprint('No')\n\texit()\nprint('Yes')\n\ndef ok(d):\n\t(dep, cur, sum, m) = (2, 1, 1, 0)\n\twhile cur + m < n:\n\t\tm += cur\n\t\tcur = min(n - m, cur * d)\n\t\tsum += cur * dep\n\t\tdep += 1\n\treturn sum <= s\n(l, r) = (1, n)\nwhile l < r:\n\tmid = (l + r) // 2\n\tif ok(mid):\n\t\tr = mid\n\telse:\n\t\tl = mid + 1\n(a, me) = ([l - 1] * (n + 1), [_ for _ in range(n + 1)])\n(sum, low) = (n * (n + 1) // 2, 2)\nwhile n > low and sum > s:\n\tdest = min(sum - s, n - low)\n\tsum -= dest\n\tme[n] -= dest\n\ta[me[n] + 1] += l\n\ta[me[n]] -= 1\n\tif not a[low]:\n\t\tlow += 1\n\tn -= 1\n(me, l, dg) = (sorted(me[1:]), 0, 0)\nfor i in me[1:]:\n\twhile me[l] < i - 1 or dg == r:\n\t\tdg = 0\n\t\tl += 1\n\tprint(l + 1, end=' ')\n\tdg += 1\n",
        "slowest_solution": "import math\nEPS = 1e-06\nhhh = None\n\ndef solve():\n\t(n, M) = [int(x) for x in input().split()]\n\tif out_of_solution_bounds(n, M):\n\t\tprint('No')\n\t\treturn\n\tb = find_optimal_b(n, M)\n\theights = fast_find_optimal_height_distribution(n, M, b)\n\tparents = build_tree(n, b, heights)\n\tprint('Yes')\n\tprint(*parents[1:])\n\ndef out_of_solution_bounds(n, M):\n\treturn M < 2 * n - 1 or n * (n + 1) // 2 < M\n\ndef find_optimal_b(n, M):\n\tbegin = 1\n\tend = n\n\twhile begin != end:\n\t\tmid = (begin + end) // 2\n\t\tif get_min_H_given_b(n, mid) <= M:\n\t\t\tend = mid\n\t\telse:\n\t\t\tbegin = mid + 1\n\tb = end\n\treturn b\n\ndef get_min_H_given_b(n, b):\n\tif b == 1:\n\t\treturn n * (n + 1) // 2\n\tm = math.floor(math.log((b - 1) * n + 1) / math.log(b) + EPS)\n\tnl = round((b ** m - 1) / (b - 1))\n\treturn (m * b ** (m + 1) - (m + 1) * b ** m + 1) // (b - 1) ** 2 + (m + 1) * (n - nl)\n\ndef fast_find_optimal_height_distribution(n, M, b):\n\tbegin = 0\n\tend = n + 1\n\tH_fn = lambda L: L * (L + 1) // 2 + get_min_H_given_b(n - L, b) + (L > 0) * (n - L)\n\twhile begin != end:\n\t\tmid = (begin + end) // 2\n\t\tif H_fn(mid) <= M:\n\t\t\tbegin = mid + 1\n\t\telse:\n\t\t\tend = mid\n\tL = begin - 1\n\tif L == n:\n\t\treturn [1 for _ in range(n)]\n\tunif_branch_h = uniform_height_distribution(n - L, b)\n\tif L == 0:\n\t\th = unif_branch_h\n\telse:\n\t\th = [int(i < L) for i in range(n)]\n\t\tfor (i, x) in enumerate(unif_branch_h, 1):\n\t\t\th[i] += x\n\treturn locally_increase_H(h, M, b)\n\ndef uniform_height_distribution(n, b):\n\th = [0 for _ in range(n)]\n\th[0] = 1\n\ti = 0\n\tto_fill = n - 1\n\twhile to_fill > 0:\n\t\ti += 1\n\t\th[i] = min(b * h[i - 1], to_fill)\n\t\tto_fill -= h[i]\n\treturn h\n\ndef locally_increase_H(h, M, b):\n\ti = 1\n\twhile not (b * h[i - 1] >= h[i] - 1 and b * (h[i] - 1) >= h[i + 1] + 1):\n\t\ti += 1\n\tH = sum((i * x for (i, x) in enumerate(h, 1)))\n\twhile H < M:\n\t\tif b * (h[i - 1] - 1) >= h[i] + 1:\n\t\t\ti -= 1\n\t\telse:\n\t\t\twhile not b * (h[i] - 1) >= h[i + 1] + 1:\n\t\t\t\ti += 1\n\t\th[i] -= 1\n\t\th[i + 1] += 1\n\t\tH += 1\n\treturn h\n\ndef build_tree(n, b, h):\n\tp = [None for _ in range(n)]\n\tp[0] = 1\n\ti = 1\n\tj = 0\n\tfor k in range(1, n):\n\t\tif j == h[i]:\n\t\t\ti += 1\n\t\t\tj = 0\n\t\tp[k] = k - j - h[i - 1] + j // b + 1\n\t\tj += 1\n\treturn p\nsolve()\n"
    },
    {
        "task_id": 893,
        "slowest_solution_id": 6,
        "fastest_solution_id": 0,
        "slowest_time": 0.0020415782928466797,
        "fastest_time": 0.0,
        "fastest_solution": "def simplify(poly):\n\timport re\n\tmatches = re.findall('([+\\\\-]?)(\\\\d*)([a-z]+)', poly)\n\texpanded = [[int(i[0] + (i[1] if i[1] != '' else '1')), ''.join(sorted(i[2]))] for i in matches]\n\tvariables = sorted(list(set((i[1] for i in expanded))), key=lambda x: (len(x), x))\n\tcoefficients = {v: sum((i[0] for i in expanded if i[1] == v)) for v in variables}\n\treturn '+'.join((str(coefficients[v]) + v for v in variables if coefficients[v] != 0)).replace('1', '').replace('+-', '-')\n",
        "slowest_solution": "from collections import defaultdict\nimport re\n\ndef simplify(poly):\n\tterms = defaultdict(lambda : 0)\n\tfor (a, b, c) in re.findall('([+-]?)(\\\\d*?)([a-z]+)', poly):\n\t\tterms[''.join(sorted(c))] += eval(a + (b or '1'))\n\treturn re.sub('((?<=[-+])|\\\\b)1(?=[a-z])|((?:[-+])|\\\\b)0(?:[a-z]+)|\\\\+(?=-)', '', '+'.join([f'{terms[x]}{x}' for x in sorted(list(terms.keys()), key=lambda x: (len(x), x))]))\n"
    },
    {
        "task_id": 894,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def solution(to, lst):\n\t(dolSym, eurSym, power) = ('', '\u20ac', -1) if to == 'EUR' else ('$', '', 1)\n\treturn [f'{dolSym}{v * 1.1363636 ** power:,.2f}{eurSym}' for v in lst]\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 895,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def on_line(points):\n\tpoints = list(set(points))\n\tcross_product = lambda a, b, c: a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])\n\treturn all((cross_product(p, *points[:2]) == 0 for p in points[2:]))\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 888,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.721378803253174,
        "fastest_time": 2.6268770694732666,
        "fastest_solution": "from heapq import *\nfrom bisect import bisect_left\n(n, m) = map(int, input().split())\ninf = 15 * 10 ** 8\nnorm = []\nrev = []\nslow = set()\nfor _ in range(n):\n\t(x, y) = map(int, input().split())\n\theappush(norm, (x, y))\n\theappush(rev, (y, x))\n\tslow.add((x, y))\ncx = cy = 0\nskipX = []\nskipY = []\nfor i in range(2 * n):\n\ttl = tr = inf\n\ttlp = trp = (inf, inf)\n\tif norm:\n\t\ttl = norm[0][0] - cx\n\t\ttlp = (norm[0][0] - cx, norm[0][1] - cy)\n\tif rev:\n\t\ttr = rev[0][0] - cy\n\t\ttrp = (rev[0][0] - cy, rev[0][1] - cx)\n\tif tlp < trp:\n\t\t(x, y) = heappop(norm)\n\t\tif tl < 0:\n\t\t\tcontinue\n\t\tcx += tl\n\t\tcy += tl\n\t\tassert x == cx\n\t\tif y < cy:\n\t\t\tskipX.append(x)\n\t\t\tcx += 1\n\telse:\n\t\t(y, x) = heappop(rev)\n\t\tif tr < 0:\n\t\t\tcontinue\n\t\tcx += tr\n\t\tcy += tr\n\t\tassert y == cy\n\t\tif x < cx:\n\t\t\tskipY.append(y)\n\t\t\tcy += 1\nout = []\nfor _ in range(m):\n\t(x, y) = map(int, input().split())\n\tif (x, y) in slow:\n\t\tout.append('LOSE')\n\t\tcontinue\n\tcsx = bisect_left(skipX, x)\n\tcsy = bisect_left(skipY, y)\n\tif csx < len(skipX) and skipX[csx] == x:\n\t\tout.append('WIN')\n\t\tcontinue\n\tif csy < len(skipY) and skipY[csy] == y:\n\t\tout.append('WIN')\n\t\tcontinue\n\tout.append('LOSE' if x - csx == y - csy else 'WIN')\nprint('\\n'.join(map(str, out)))\n",
        "slowest_solution": "def fun(n, m):\n\tl1 = []\n\tl2 = []\n\tset1 = set()\n\tvar = 15 * 10 ** 8\n\tfor k1 in range(n):\n\t\t(x, y) = map(int, input().split())\n\t\theappush(l1, (x, y))\n\t\theappush(l2, (y, x))\n\t\tset1.add((x, y))\n\tcx = cy = 0\n\tX2 = []\n\tY2 = []\n\tfor i in range(2 * n):\n\t\ttl = tr = var\n\t\ttlp = trp = (var, var)\n\t\tif l1:\n\t\t\ttl = l1[0][0] - cx\n\t\t\ttlp = (l1[0][0] - cx, l1[0][1] - cy)\n\t\tif l2:\n\t\t\ttr = l2[0][0] - cy\n\t\t\ttrp = (l2[0][0] - cy, l2[0][1] - cx)\n\t\tif tlp < trp:\n\t\t\t(x, y) = heappop(l1)\n\t\t\tif tl < 0:\n\t\t\t\tcontinue\n\t\t\tcx += tl\n\t\t\tcy += tl\n\t\t\tassert x == cx\n\t\t\tif y < cy:\n\t\t\t\tX2.append(x)\n\t\t\t\tcx += 1\n\t\telse:\n\t\t\t(y, x) = heappop(l2)\n\t\t\tif tr < 0:\n\t\t\t\tcontinue\n\t\t\tcx += tr\n\t\t\tcy += tr\n\t\t\tassert y == cy\n\t\t\tif x < cx:\n\t\t\t\tY2.append(y)\n\t\t\t\tcy += 1\n\tans = []\n\tfrom bisect import bisect_left\n\tfor k2 in range(m):\n\t\t(x, y) = map(int, input().split())\n\t\tif (x, y) in set1:\n\t\t\tans.append('LOSE')\n\t\t\tcontinue\n\t\tcs1 = bisect_left(X2, x)\n\t\tcs2 = bisect_left(Y2, y)\n\t\tif cs1 < len(X2) and X2[cs1] == x:\n\t\t\tans.append('WIN')\n\t\t\tcontinue\n\t\tif cs2 < len(Y2) and Y2[cs2] == y:\n\t\t\tans.append('WIN')\n\t\t\tcontinue\n\t\tif x - cs1 == y - cs2:\n\t\t\tans.append('LOSE')\n\t\telse:\n\t\t\tans.append('WIN')\n\tprint('\\n'.join(map(str, ans)))\nfrom heapq import *\n(a1, a2) = map(int, input().split())\nfun(a1, a2)\n"
    },
    {
        "task_id": 850,
        "slowest_solution_id": 9,
        "fastest_solution_id": 3,
        "slowest_time": 2.902770519256592,
        "fastest_time": 2.4866700172424316,
        "fastest_solution": "(n, k) = map(int, input().split())\nplayers = [int(c) for c in input().split()]\nlimit = 5 - k\ncoN = 0\nfor p in players:\n\tif p <= limit:\n\t\tcoN += 1\nprint(coN // 3)\n",
        "slowest_solution": "value = input()\n(n, k) = value.split()\nn = int(n)\nk = int(k)\nvalues = input()\nvalues = values.split()\nvalues = [int(i) + k <= 5 for i in values]\nprint(sum(values) // 3)\n"
    },
    {
        "task_id": 852,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 3.0967655181884766,
        "fastest_time": 2.4635422229766846,
        "fastest_solution": "for _ in range(int(input())):\n\ts = input()\n\ta = s[0]\n\tb = s[1]\n\tx = ord(a) - 97\n\ty = ord(b) - 97\n\tans = x * 26\n\tif x > y:\n\t\tans = ans + y - x + 1\n\telse:\n\t\tans = ans + y - x\n\tprint(ans)\n",
        "slowest_solution": "dic = []\nfor c1 in 'abcdefghijklmnopqrstuvwxyz':\n\tfor c2 in 'abcdefghijklmnopqrstuvwxyz':\n\t\tif c1 != c2:\n\t\t\tdic.append(c1 + c2)\nfor _ in range(int(input())):\n\tprint(dic.index(input()) + 1)\n"
    },
    {
        "task_id": 899,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "from itertools import groupby\n\ndef group_ints(lst, key=0):\n\treturn [list(g) for (_, g) in groupby(lst, lambda a: a < key)]\ngroupInts = group_ints\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 854,
        "slowest_solution_id": 9,
        "fastest_solution_id": 2,
        "slowest_time": 3.060669183731079,
        "fastest_time": 2.4363605976104736,
        "fastest_solution": "def check(A, H, W):\n\tfor h in range(H):\n\t\tfor w in range(W - 1):\n\t\t\tif A[h][w] >= A[h][w + 1]:\n\t\t\t\treturn False\n\tfor w in range(W):\n\t\tfor h in range(H - 1):\n\t\t\tif A[h][w] >= A[h + 1][w]:\n\t\t\t\treturn False\n\treturn True\n\ndef solve():\n\t(H, W) = list(map(int, input().split()))\n\tA = [list(map(int, input().split())) for i in range(H)]\n\tB = [list(map(int, input().split())) for i in range(H)]\n\tif check(A, H, W) and check(B, H, W):\n\t\treturn 'Possible'\n\tfor h in range(H):\n\t\tfor w in range(W):\n\t\t\tif A[h][w] > B[h][w]:\n\t\t\t\t(A[h][w], B[h][w]) = (B[h][w], A[h][w])\n\tif check(A, H, W) and check(B, H, W):\n\t\treturn 'Possible'\n\treturn 'Impossible'\nprint(solve())\n",
        "slowest_solution": "(n, m) = list(map(int, input().split()))\na = []\nb = []\nfor i in range(n):\n\ta.append(list(map(int, input().split())))\nfor i in range(n):\n\tb.append(list(map(int, input().split())))\nfor i in range(n):\n\tfor j in range(m):\n\t\t(a[i][j], b[i][j]) = (min(a[i][j], b[i][j]), max(a[i][j], b[i][j]))\nfor i in range(n):\n\tfor j in range(m - 1):\n\t\tif a[i][j] >= a[i][j + 1]:\n\t\t\tprint('Impossible')\n\t\t\texit()\n\t\tif b[i][j] >= b[i][j + 1]:\n\t\t\tprint('Impossible')\n\t\t\texit()\nfor j in range(m):\n\tfor i in range(n - 1):\n\t\tif a[i][j] >= a[i + 1][j]:\n\t\t\tprint('Impossible')\n\t\t\texit()\n\t\tif b[i][j] >= b[i + 1][j]:\n\t\t\tprint('Impossible')\n\t\t\texit()\nprint('Possible')\n"
    },
    {
        "task_id": 855,
        "slowest_solution_id": 9,
        "fastest_solution_id": 1,
        "slowest_time": 3.080044746398926,
        "fastest_time": 2.300783157348633,
        "fastest_solution": "def crossProd(A, B):\n\treturn A[0] * B[1] - A[1] * B[0]\nN = int(input())\n(stars, s) = ([], 0)\nfor n in range(N):\n\t(x, y, v) = [int(x) for x in input().split(' ')]\n\tstars.append(((x, y), v))\n\ts += v\ndmin = s\nfor i in range(N):\n\tfor j in range(i):\n\t\tA = (stars[j][0][0] - stars[i][0][0], stars[j][0][1] - stars[i][0][1])\n\t\td = 0\n\t\tfor k in range(N):\n\t\t\tif k != i and k != j:\n\t\t\t\tB = (stars[k][0][0] - stars[i][0][0], stars[k][0][1] - stars[i][0][1])\n\t\t\t\tif crossProd(A, B) > 0:\n\t\t\t\t\td += stars[k][1]\n\t\t\t\telse:\n\t\t\t\t\td -= stars[k][1]\n\t\tif d < 0:\n\t\t\td = -d\n\t\t(Vi, Vj) = (stars[i][1], stars[j][1])\n\t\tif Vi > Vj:\n\t\t\t(Vi, Vj) = (Vj, Vi)\n\t\tif d > Vj - Vi:\n\t\t\td -= Vj - Vi\n\t\telse:\n\t\t\td = Vj - Vi - d\n\t\tif d < dmin:\n\t\t\tdmin = d\nprint((s - dmin) // 2)\n",
        "slowest_solution": "import itertools, sys\n\nclass Point:\n\n\tdef __init__(self, x, y, v):\n\t\t(self.x, self.y, self.v) = (x, y, v)\n\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, self.__class__) and self.__dict__ == other.__dict__\n\n\tdef __ne__(self, other):\n\t\treturn not self.__eq__(other)\nN = int(sys.stdin.readline())\npoints = [Point(*list(map(int, sys.stdin.readline().split()))) for _ in range(N)]\nmax_weight = 0\nbest_weight = lambda a, b: max(max_weight, min(a, b))\ndet = lambda a, b, c: (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)\nfor (a, b) in itertools.combinations(points, 2):\n\t(above, below) = (0, 0)\n\tfor c in (p for p in points if p != a and p != b):\n\t\tif det(a, b, c) > 0:\n\t\t\tabove += c.v\n\t\telse:\n\t\t\tbelow += c.v\n\tmax_weight = best_weight(above + a.v + b.v, below)\n\tmax_weight = best_weight(above + a.v, below + b.v)\n\tmax_weight = best_weight(above + b.v, below + a.v)\n\tmax_weight = best_weight(above, below + a.v + b.v)\nprint(max_weight)\n"
    },
    {
        "task_id": 861,
        "slowest_solution_id": 9,
        "fastest_solution_id": 0,
        "slowest_time": 3.0866901874542236,
        "fastest_time": 2.511889696121216,
        "fastest_solution": "lines = int(input())\ns_dict = {}\nc = 0\n\nfor i in range(lines):\n\tl = sorted(input().split())\n\ts = '.'.join(l)\n\tif s in s_dict:\n\t\ts_dict[s] = False\n\telse:\n\t\ts_dict[s] = True\n\nfor s, flag in list(s_dict.items()):\n\tif flag:\n\t\tc += 1\n\nprint(c)\n\t\n",
        "slowest_solution": "num=int(input())\nl=[]\nfor i in range(num):\n\ts=input()\n\ts=s.split(\" \",len(s))\n\tfi=s[0]\n\tse=s[1]\n\tth=s[2]\n\tsamp=[]\n\tsamp.append(fi)\n\tsamp.append(se)\n\tsamp.append(th)\n\tsamp.sort()\n\tn=\"\"\n\tfor j in samp:\n\t\tn=n+j\n\tl.append(int(n))\nl.sort()\nunique=0\nfor i in range(1,len(l)-1):\n\tif l[i]!=l[i-1] and l[i]!=l[i+1]:\n\t\tunique=unique+1\nif l[0]!=l[1]:\n\tunique=unique+1\nif l[num-1]!=l[num-2]:\n\tunique=unique+1\nprint(unique)  \n\t\n\t\n\t\n"
    },
    {
        "task_id": 856,
        "slowest_solution_id": 9,
        "fastest_solution_id": 2,
        "slowest_time": 2.933685064315796,
        "fastest_time": 2.5130438804626465,
        "fastest_solution": "t = int(input())\n\ndef coders(a, b, c):\n\tm = min(a, b)\n\tif m >= (a + b + c) // 3:\n\t\tm = (a + b + c) // 3\n\treturn m\nfor i in range(t):\n\t(a, b, c) = map(int, input().split())\n\tprint(coders(a, b, c))\n",
        "slowest_solution": "query = []\nq = int(input())\nfor i in range(q):\n\ta = str(input())\n\ta = a.split(' ')\n\ta = [int(i) for i in a]\n\tquery.append(a)\nresults = []\nfor i in range(q):\n\tc = query[i][0]\n\tm = query[i][1]\n\tx = query[i][2]\n\tif c + m + x < 3 or c == 0 or m == 0:\n\t\tresults.append(0)\n\telif c >= m:\n\t\tif (c + m + x) // 3 < m:\n\t\t\tresults.append((c + m + x) // 3)\n\t\telse:\n\t\t\tresults.append(m)\n\telif (c + m + x) // 3 < c:\n\t\tresults.append((c + m + x) // 3)\n\telse:\n\t\tresults.append(c)\nprint(*results, sep='\\n')\n"
    },
    {
        "task_id": 864,
        "slowest_solution_id": 9,
        "fastest_solution_id": 3,
        "slowest_time": 2.979651927947998,
        "fastest_time": 2.542525291442871,
        "fastest_solution": "temp = input().split(' ')\n(maxLength, initialCount) = [int(x) for x in temp]\ndataSet = dict()\nfor i in range(initialCount):\n\ttemp = input().split(' ')\n\t(a, b) = [x for x in temp]\n\tif not b in dataSet.keys():\n\t\tdataSet[b] = set()\n\tdataSet[b].add(a)\n\ndef populate(toValue):\n\tfromValues = set()\n\tif toValue in dataSet.keys():\n\t\tfromValues = dataSet[toValue]\n\telif len(toValue) >= 2:\n\t\tprocess = toValue[:1]\n\t\ttail = toValue[1:]\n\t\tresult = populate(process)\n\t\tfor x in result:\n\t\t\tif x + tail in fromValues:\n\t\t\t\tcontinue\n\t\t\tfromValues.add(x + tail)\n\t\tdataSet[toValue] = fromValues\n\treturn fromValues\ncount = 0\ncurrents = ['a']\ncurrentCount = 1\nwhile currentCount < maxLength:\n\tbuffer = []\n\tfor current in currents:\n\t\tresult = populate(current)\n\t\tif len(result) > 0:\n\t\t\tdataSet[current] = result\n\t\t\tbuffer = buffer + list(result)\n\tif len(buffer) > 0:\n\t\tcurrentCount += 1\n\t\tcurrents = buffer\n\t\tif currentCount == maxLength:\n\t\t\tcount = len(buffer)\n\telse:\n\t\tbreak\nprint(count)\n",
        "slowest_solution": "from functools import reduce\n(n, q) = [int(x) for x in input().split()]\nsubstitutions = {}\nfor _ in range(q):\n\t(from_str, to_str) = input().split()\n\tif to_str in substitutions:\n\t\tsubstitutions[to_str].append(from_str)\n\telse:\n\t\tsubstitutions[to_str] = [from_str]\n\ndef generate_str(start_str):\n\tif len(start_str) == n:\n\t\treturn 1\n\tif start_str[0] not in substitutions:\n\t\treturn 0\n\tresult = 0\n\tfor variant in substitutions[start_str[0]]:\n\t\tresult += generate_str(variant + start_str[1:])\n\treturn result\nprint(generate_str('a'))\n"
    },
    {
        "task_id": 879,
        "slowest_solution_id": 8,
        "fastest_solution_id": 2,
        "slowest_time": 3.0136775970458984,
        "fastest_time": 2.712127685546875,
        "fastest_solution": "n = int(input())\nif n == 1:\n\tprint('Washington')\nelif n == 2:\n\tprint('Adams')\nelif n == 3:\n\tprint('Jefferson')\nelif n == 4:\n\tprint('Madison')\nelif n == 5:\n\tprint('Monroe')\nelif n == 6:\n\tprint('Adams')\nelif n == 7:\n\tprint('Jackson')\nelif n == 8:\n\tprint('Van Buren')\nelif n == 9:\n\tprint('Harrison')\nelif n == 10:\n\tprint('Tyler')\nelif n == 11:\n\tprint('Polk')\nelif n == 12:\n\tprint('Taylor')\nelif n == 13:\n\tprint('Fillmore')\nelif n == 14:\n\tprint('Pierce')\nelif n == 15:\n\tprint('Buchanan')\nelif n == 16:\n\tprint('Lincoln')\nelif n == 17:\n\tprint('Johnson')\nelif n == 18:\n\tprint('Grant')\nelif n == 19:\n\tprint('Hayes')\nelif n == 20:\n\tprint('Garfield')\nelif n == 21:\n\tprint('Arthur')\nelif n == 22:\n\tprint('Cleveland')\nelif n == 23:\n\tprint('Harrison')\nelif n == 24:\n\tprint('Cleveland')\nelif n == 25:\n\tprint('McKinley')\nelif n == 26:\n\tprint('Roosevelt')\nelif n == 27:\n\tprint('Taft')\nelif n == 28:\n\tprint('Wilson')\nelif n == 29:\n\tprint('Harding')\nelif n == 30:\n\tprint('Coolidge')\nelif n == 31:\n\tprint('Hoover')\nelif n == 32:\n\tprint('Roosevelt')\nelif n == 33:\n\tprint('Truman')\nelif n == 34:\n\tprint('Eisenhower')\nelif n == 35:\n\tprint('Kennedy')\nelif n == 36:\n\tprint('Johnson')\nelif n == 37:\n\tprint('Nixon')\nelif n == 38:\n\tprint('Ford')\nelif n == 39:\n\tprint('Carter')\nelif n == 40:\n\tprint('Reagan')\n",
        "slowest_solution": "n = int(input())\npres = [None, 'Washington', 'Adams', 'Jefferson', 'Madison', 'Monroe', 'Adams', 'Jackson', 'Van Buren', 'Harrison', 'Tyler', 'Polk', 'Taylor', 'Fillmore', 'Pierce', 'Buchanan', 'Lincoln', 'Johnson', 'Grant', 'Hayes', 'Garfield', 'Arthur', 'Cleveland', 'Harrison', 'Cleveland', 'McKinley', 'Roosevelt', 'Taft', 'Wilson', 'Harding', 'Coolidge', 'Hoover', 'Roosevelt', 'Truman', 'Eisenhower', 'Kennedy', 'Johnson', 'Nixon', 'Ford', 'Carter', 'Reagan', 'Bush', 'Clinton', 'Bush', 'Obama', 'Trump']\nresult = pres[n]\nprint(result)\n"
    },
    {
        "task_id": 900,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.9303066730499268,
        "fastest_time": 2.9303066730499268,
        "fastest_solution": "def max_clique(g):\n\tn = 0\n\tfor x in g:\n\t\tn = max(n, len(x))\n\tl = [set() for _ in range(n + 1)]\n\ts = [0] * len(g)\n\tfor (i, x) in enumerate(g):\n\t\tll = len(x)\n\t\tl[ll].add(i)\n\t\ts[i] = ll\n\tm = 0\n\tfor _ in range(len(g)):\n\t\tfor i in range(n + 1):\n\t\t\tif len(l[i]) > 0:\n\t\t\t\tx = l[i].pop()\n\t\t\t\tm = max(m, i)\n\t\t\t\ts[x] = 0\n\t\t\t\tfor k in g[x]:\n\t\t\t\t\tif s[k] > 0:\n\t\t\t\t\t\tl[s[k]].remove(k)\n\t\t\t\t\t\ts[k] -= 1\n\t\t\t\t\t\tl[s[k]].add(k)\n\t\t\t\tbreak\n\treturn m + 1\n\ndef dfs(s, b, u):\n\ts.add(u)\n\tb[u] = True\n\tfor v in g[u]:\n\t\tif b[v]:\n\t\t\tcontinue\n\t\tdfs(s, b, v)\nfor _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tg = [list() for _ in range(n)]\n\tfor _ in range(m):\n\t\t(u, v) = map(int, input().split())\n\t\tg[u - 1].append(v - 1)\n\t\tg[v - 1].append(u - 1)\n\tprint(max_clique(g))\n",
        "slowest_solution": "def max_clique(g):\n\tn = 0\n\tfor x in g:\n\t\tn = max(n, len(x))\n\tl = [set() for _ in range(n + 1)]\n\ts = [0] * len(g)\n\tfor (i, x) in enumerate(g):\n\t\tll = len(x)\n\t\tl[ll].add(i)\n\t\ts[i] = ll\n\tm = 0\n\tfor _ in range(len(g)):\n\t\tfor i in range(n + 1):\n\t\t\tif len(l[i]) > 0:\n\t\t\t\tx = l[i].pop()\n\t\t\t\tm = max(m, i)\n\t\t\t\ts[x] = 0\n\t\t\t\tfor k in g[x]:\n\t\t\t\t\tif s[k] > 0:\n\t\t\t\t\t\tl[s[k]].remove(k)\n\t\t\t\t\t\ts[k] -= 1\n\t\t\t\t\t\tl[s[k]].add(k)\n\t\t\t\tbreak\n\treturn m + 1\n\ndef dfs(s, b, u):\n\ts.add(u)\n\tb[u] = True\n\tfor v in g[u]:\n\t\tif b[v]:\n\t\t\tcontinue\n\t\tdfs(s, b, v)\nfor _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tg = [list() for _ in range(n)]\n\tfor _ in range(m):\n\t\t(u, v) = map(int, input().split())\n\t\tg[u - 1].append(v - 1)\n\t\tg[v - 1].append(u - 1)\n\tprint(max_clique(g))\n"
    },
    {
        "task_id": 859,
        "slowest_solution_id": 8,
        "fastest_solution_id": 1,
        "slowest_time": 3.0625481605529785,
        "fastest_time": 2.4667787551879883,
        "fastest_solution": "def fun(a, b):\n\tstp = 0\n\twhile a > b:\n\t\ta //= b\n\t\tstp += 1\n\tif b == a:\n\t\tstp += 2\n\telse:\n\t\tstp += 1\n\treturn stp\n\ndef solve():\n\t(a, b) = map(int, input().split())\n\tif b > a:\n\t\treturn 1\n\tif b == a:\n\t\treturn 2\n\tans = 0\n\tif b == 1:\n\t\tans += 1\n\t\tb += 1\n\tret = ans + fun(a, b)\n\ti = 1\n\twhile True:\n\t\tret2 = ans + i + fun(a, b + i)\n\t\tif ret2 > ret:\n\t\t\treturn ret\n\t\tret = ret2\n\t\ti += 1\n\treturn ret\nfor _ in range(int(input())):\n\tprint(solve())\n",
        "slowest_solution": "def log(a, b):\n\tlogVal = 0\n\twhile a >= b:\n\t\ta //= b\n\t\tlogVal += 1\n\treturn logVal\n\ndef solve(a, b):\n\tif a < b:\n\t\treturn 1\n\tif a == b:\n\t\treturn 2\n\tif b == 1:\n\t\tb += 1\n\t\tstartOpsCount = 1\n\telse:\n\t\tstartOpsCount = 0\n\topsCount = startOpsCount + log(a, b) + 1\n\tminOps = opsCount\n\twhile startOpsCount < minOps:\n\t\tb += 1\n\t\tstartOpsCount += 1\n\t\topsCount = startOpsCount + log(a, b) + 1\n\t\tminOps = min(opsCount, minOps)\n\treturn minOps\nt = int(input())\nfor tc in range(t):\n\t(a, b) = map(int, input().split())\n\tresult = solve(a, b)\n\tprint(result)\n"
    },
    {
        "task_id": 863,
        "slowest_solution_id": 8,
        "fastest_solution_id": 7,
        "slowest_time": 3.1158134937286377,
        "fastest_time": 2.547675371170044,
        "fastest_solution": "def main():\n\t(d, k, a, b, t) = map(int, input().split())\n\tres = [d * b]\n\tif d // k:\n\t\tx = d // k * (a * k + t)\n\t\tres.append(x + d % k * a)\n\t\tres.append(x - t + d % k * b)\n\t\tres.append(k * a + (d - k) * b)\n\telse:\n\t\tres.append(d * a)\n\tprint(min(res))\nmain()\n",
        "slowest_solution": "(d, k, a, b, t) = map(int, input().split())\nt1 = d * b\nt2 = d * a + (d - 1) // k * t\nt3 = max(0, d - k) * b + min(k, d) * a\ndd = d % k\nd1 = d - dd\nt4 = d1 * a + max(0, (d1 // k - 1) * t) + dd * b\nprint(min([t1, t2, t3, t4]))\n"
    },
    {
        "task_id": 871,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 2.992069959640503,
        "fastest_time": 2.6512885093688965,
        "fastest_solution": "n = int(input())\na = [0 for i in range(n)]\nfor i in range(n):\n\tinp = input().split()\n\tx = int(inp[0])\n\ty = int(inp[1])\n\ta[i] = 2 * (x % 2) + y % 2 + 1\nprint('YES')\nprint('\\n'.join((str(i) for i in a)))\n",
        "slowest_solution": "print('YES')\nfor _ in range(int(input())):\n\t(a, b, c, d) = map(int, input().split())\n\tprint(2 * (a % 2) + b % 2 + 1)\n"
    },
    {
        "task_id": 868,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 2.9799091815948486,
        "fastest_time": 2.5705244541168213,
        "fastest_solution": "def sol():\n\t(a, b) = map(int, input().split())\n\ts = input().replace('X', ' ')\n\tsmall_segs = 0\n\tcritical_region = -1\n\tfor p in map(len, s.split()):\n\t\tif p < b:\n\t\t\tcontinue\n\t\tif p < a and p >= b:\n\t\t\treturn False\n\t\tif (p - a) % 2 == 0 and p >= a + 4 * b or ((p - a) % 2 == 1 and p >= a + 4 * b - 1):\n\t\t\treturn False\n\t\tif p >= 2 * b:\n\t\t\tif critical_region != -1:\n\t\t\t\treturn False\n\t\t\tcritical_region = p\n\t\telif p >= a:\n\t\t\tsmall_segs += 1\n\tif critical_region == -1:\n\t\treturn small_segs % 2 == 1\n\tcan = [0] * 3\n\tfor l in range(critical_region + 1 - a):\n\t\tr = critical_region - l - a\n\t\tif l >= b and l < a or l >= 2 * b:\n\t\t\tcontinue\n\t\tif r >= b and r < a or r >= 2 * b:\n\t\t\tcontinue\n\t\tcanl = int(l >= a)\n\t\tcanr = int(r >= a)\n\t\tcan[canl + canr] = 1\n\tfor (choice, val) in enumerate(can):\n\t\tif val and (small_segs + choice) % 2 == 0:\n\t\t\treturn True\n\treturn False\nn = int(input())\nfor _ in range(n):\n\tprint('YES' if sol() else 'NO')\n",
        "slowest_solution": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nQ = int(input())\nfor _ in range(Q):\n\t(a, b) = list(map(int, input().split()))\n\tS = input() + 'X'\n\ts = 0\n\tx = x1 = x2 = x3 = xx = 0\n\tfor i in range(len(S)):\n\t\tif S[i] == 'X':\n\t\t\tif s < b:\n\t\t\t\tpass\n\t\t\telif a <= s < 2 * b:\n\t\t\t\tx += 1\n\t\t\telif a < 2 * b and (3 * a <= s < a + 3 * b - 1 or 2 * a <= s < a + 2 * b - 1):\n\t\t\t\txx += 1\n\t\t\telif a < 2 * b and 3 * a <= s < a + 4 * b - 1:\n\t\t\t\tx3 += 1\n\t\t\telif a < 2 * b and 2 * a <= s < a + 3 * b - 1:\n\t\t\t\tx2 += 1\n\t\t\telif a <= s < a + 2 * b - 1:\n\t\t\t\tx1 += 1\n\t\t\telse:\n\t\t\t\tprint('NO')\n\t\t\t\tbreak\n\t\t\ts = 0\n\t\telse:\n\t\t\ts += 1\n\telse:\n\t\tif xx + x1 + x2 + x3 >= 2:\n\t\t\tprint('NO')\n\t\telif xx:\n\t\t\tprint('YES')\n\t\telif (x + x1 + x2 * 2 + x3 * 3) % 2 == 0:\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint('YES')\n"
    },
    {
        "task_id": 860,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 3.006969928741455,
        "fastest_time": 2.316610813140869,
        "fastest_solution": "from math import log\n(n, q) = [int(i) for i in input().split()]\nmaxlvl = int(log(n + 1, 2)) + 1\nsteps = [2 ** i for i in range(maxlvl)]\n\ndef calc_lvl(m):\n\tfor lvl in range(1, maxlvl):\n\t\tif (m - steps[lvl - 1]) % steps[lvl] == 0:\n\t\t\treturn (lvl, (m - steps[lvl - 1]) % (2 * steps[lvl]) == 0)\nfor i in range(q):\n\tstrt = int(input())\n\tqwery = input()\n\t(lvl, ind) = calc_lvl(strt)\n\tfor c in qwery:\n\t\tif c == 'U':\n\t\t\tif strt == steps[-2]:\n\t\t\t\tcontinue\n\t\t\tif not ind:\n\t\t\t\tstrt -= steps[lvl - 1]\n\t\t\t\t(lvl, ind) = calc_lvl(strt)\n\t\t\telse:\n\t\t\t\tstrt += steps[lvl - 1]\n\t\t\t\t(lvl, ind) = calc_lvl(strt)\n\t\telif c == 'L':\n\t\t\tif strt % 2 != 0:\n\t\t\t\tcontinue\n\t\t\tstrt -= steps[lvl - 2]\n\t\t\t(lvl, ind) = (lvl - 1, 1)\n\t\telse:\n\t\t\tif strt % 2 != 0:\n\t\t\t\tcontinue\n\t\t\tstrt += steps[lvl - 2]\n\t\t\t(lvl, ind) = (lvl - 1, 0)\n\tprint(strt)\n",
        "slowest_solution": "from math import log\n(n, q) = [int(i) for i in input().split()]\nmaxlvl = int(log(n + 1, 2)) + 1\npows = [2 ** i for i in range(maxlvl)]\ndone = dict()\n\ndef calc_lvl(m):\n\tfor lvl in range(1, maxlvl):\n\t\tif (m - pows[lvl - 1]) % pows[lvl] == 0:\n\t\t\treturn (lvl, (m - pows[lvl - 1]) % (2 * pows[lvl]) == 0)\nfor i in range(q):\n\tstart = int(input())\n\tquery = input()\n\t(lvl, ind) = calc_lvl(start)\n\tfor c in query:\n\t\tif c == 'U':\n\t\t\tif start == pows[-2]:\n\t\t\t\tcontinue\n\t\t\tstart += (1 if ind else -1) * pows[lvl - 1]\n\t\t\tif start not in list(done.keys()):\n\t\t\t\t(lvl, ind) = calc_lvl(start)\n\t\t\t\tdone[start] = (lvl, ind)\n\t\t\telse:\n\t\t\t\t(lvl, ind) = done[start]\n\t\telse:\n\t\t\tif start % 2 != 0:\n\t\t\t\tcontinue\n\t\t\tstart += (1 if c == 'R' else -1) * pows[lvl - 2]\n\t\t\t(lvl, ind) = (lvl - 1, int(c == 'L'))\n\tprint(start)\n"
    },
    {
        "task_id": 898,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.955004930496216,
        "fastest_time": 2.851297378540039,
        "fastest_solution": "def add(a, b):\n\tif a + b >= mod:\n\t\treturn (a + b) % mod\n\treturn a + b\nn = int(input()) * 2\ns = input()\nd = [[0, 0] for i in range(len(s) + 1)]\naux = ''\nfor i in range(len(s)):\n\tif s[i] == '(':\n\t\td[i][1] = i + 1\n\t\tx = aux + ')'\n\t\tfor j in range(1, i + 2):\n\t\t\tif x[j:] == s[0:len(x) - j]:\n\t\t\t\td[i][0] = len(x[j:])\n\t\t\t\tbreak\n\telse:\n\t\td[i][0] = i + 1\n\t\tx = aux + '('\n\t\tfor j in range(1, i + 2):\n\t\t\tif x[j:] == s[0:len(x) - j]:\n\t\t\t\td[i][1] = len(x[j:])\n\t\t\t\tbreak\n\taux += s[i]\nd[len(s)][1] = len(s)\nd[len(s)][0] = len(s)\ndp = [[[0 for i in range(len(s) + 1)] for j in range(n // 2 + 1)] for k in range(n + 1)]\ndp[0][0][0] = 1\nmod = 10 ** 9 + 7\nfor i in range(n):\n\tfor j in range(1, n // 2 + 1):\n\t\tfor k in range(len(s) + 1):\n\t\t\tdp[i + 1][j - 1][d[k][0]] = (dp[i][j][k] + dp[i + 1][j - 1][d[k][0]]) % mod\n\tfor j in range(n // 2):\n\t\tfor k in range(len(s) + 1):\n\t\t\tdp[i + 1][j + 1][d[k][1]] = (dp[i][j][k] + dp[i + 1][j + 1][d[k][1]]) % mod\nprint(dp[n][0][len(s)] % mod)\n",
        "slowest_solution": "M = 10 ** 9 + 7\nn = int(input())\ns = [c == '(' for c in input()]\nm = len(s)\nz = [[0, 0]]\nfor v in s:\n\ta = z[-1][v]\n\tz[-1][v] = len(z)\n\tz += [z[a][:]]\nz[m] = [m, m]\ndp = [[0] * (m + 1) for _ in range(n + 1)]\ndp[0][0] = 1\nfor _ in range(2 * n):\n\tndp = [[0] * (m + 1) for _ in range(n + 1)]\n\tfor i in range(n + 1):\n\t\tfor j in range(m + 1):\n\t\t\tif i > 0:\n\t\t\t\tndp[i - 1][z[j][0]] = (ndp[i - 1][z[j][0]] + dp[i][j]) % M\n\t\t\tif i < n:\n\t\t\t\tndp[i + 1][z[j][1]] = (ndp[i + 1][z[j][1]] + dp[i][j]) % M\n\tdp = ndp\nprint(dp[0][m])\n"
    },
    {
        "task_id": 865,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 3.0909130573272705,
        "fastest_time": 2.541747570037842,
        "fastest_solution": "for _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\ta = [int(x) for x in input().split()]\n\ta.sort()\n\tif a[0] + a[-1] > k and len(a) > 1:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n",
        "slowest_solution": "for i in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tx = list(map(int, input().split()))\n\tt = min(x)\n\tmax1 = max(x)\n\tif max1 + t <= b or a == 1:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 867,
        "slowest_solution_id": 9,
        "fastest_solution_id": 0,
        "slowest_time": 4.550405740737915,
        "fastest_time": 2.498183488845825,
        "fastest_solution": "import math\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nmod = 10 ** 9 + 7\nmod1 = 998244353\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass TreeNode:\n\n\tdef __init__(self, k, v):\n\t\tself.key = k\n\t\tself.value = v\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.parent = None\n\t\tself.height = 1\n\t\tself.num_left = 1\n\t\tself.num_total = 1\n\nclass AvlTree:\n\n\tdef __init__(self):\n\t\tself._tree = None\n\n\tdef add(self, k, v):\n\t\tif not self._tree:\n\t\t\tself._tree = TreeNode(k, v)\n\t\t\treturn\n\t\tnode = self._add(k, v)\n\t\tif node:\n\t\t\tself._rebalance(node)\n\n\tdef _add(self, k, v):\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tif node.left:\n\t\t\t\t\tnode = node.left\n\t\t\t\telse:\n\t\t\t\t\tnode.left = TreeNode(k, v)\n\t\t\t\t\tnode.left.parent = node\n\t\t\t\t\treturn node.left\n\t\t\telif node.key < k:\n\t\t\t\tif node.right:\n\t\t\t\t\tnode = node.right\n\t\t\t\telse:\n\t\t\t\t\tnode.right = TreeNode(k, v)\n\t\t\t\t\tnode.right.parent = node\n\t\t\t\t\treturn node.right\n\t\t\telse:\n\t\t\t\tnode.value = v\n\t\t\t\treturn\n\n\t@staticmethod\n\tdef get_height(x):\n\t\treturn x.height if x else 0\n\n\t@staticmethod\n\tdef get_num_total(x):\n\t\treturn x.num_total if x else 0\n\n\tdef _rebalance(self, node):\n\t\tn = node\n\t\twhile n:\n\t\t\tlh = self.get_height(n.left)\n\t\t\trh = self.get_height(n.right)\n\t\t\tn.height = max(lh, rh) + 1\n\t\t\tbalance_factor = lh - rh\n\t\t\tn.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n\t\t\tn.num_left = 1 + self.get_num_total(n.left)\n\t\t\tif balance_factor > 1:\n\t\t\t\tif self.get_height(n.left.left) < self.get_height(n.left.right):\n\t\t\t\t\tself._rotate_left(n.left)\n\t\t\t\tself._rotate_right(n)\n\t\t\telif balance_factor < -1:\n\t\t\t\tif self.get_height(n.right.right) < self.get_height(n.right.left):\n\t\t\t\t\tself._rotate_right(n.right)\n\t\t\t\tself._rotate_left(n)\n\t\t\telse:\n\t\t\t\tn = n.parent\n\n\tdef _remove_one(self, node):\n\t\treplacement = node.left or node.right\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = replacement\n\t\t\telse:\n\t\t\t\tnode.parent.right = replacement\n\t\t\treplacement.parent = node.parent\n\t\t\tnode.parent = None\n\t\telse:\n\t\t\tself._tree = replacement\n\t\t\treplacement.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\t\tnode.parent = None\n\t\tself._rebalance(replacement)\n\n\tdef _remove_leaf(self, node):\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = None\n\t\t\telse:\n\t\t\t\tnode.parent.right = None\n\t\t\tself._rebalance(node.parent)\n\t\telse:\n\t\t\tself._tree = None\n\t\tnode.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\n\tdef remove(self, k):\n\t\tnode = self._get_node(k)\n\t\tif not node:\n\t\t\treturn\n\t\tif AvlTree._is_leaf(node):\n\t\t\tself._remove_leaf(node)\n\t\t\treturn\n\t\tif node.left and node.right:\n\t\t\tnxt = AvlTree._get_next(node)\n\t\t\tnode.key = nxt.key\n\t\t\tnode.value = nxt.value\n\t\t\tif self._is_leaf(nxt):\n\t\t\t\tself._remove_leaf(nxt)\n\t\t\telse:\n\t\t\t\tself._remove_one(nxt)\n\t\t\tself._rebalance(node)\n\t\telse:\n\t\t\tself._remove_one(node)\n\n\tdef get(self, k):\n\t\tnode = self._get_node(k)\n\t\treturn node.value if node else -1\n\n\tdef _get_node(self, k):\n\t\tif not self._tree:\n\t\t\treturn None\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tnode = node.left\n\t\t\telif node.key < k:\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn node\n\t\treturn None\n\n\tdef get_at(self, pos):\n\t\tx = pos + 1\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif x < node.num_left:\n\t\t\t\tnode = node.left\n\t\t\telif node.num_left < x:\n\t\t\t\tx -= node.num_left\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn (node.key, node.value)\n\t\traise IndexError('Out of ranges')\n\n\t@staticmethod\n\tdef _is_left(node):\n\t\treturn node.parent.left and node.parent.left == node\n\n\t@staticmethod\n\tdef _is_leaf(node):\n\t\treturn node.left is None and node.right is None\n\n\tdef _rotate_right(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.left\n\t\t\tnode.left.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.left\n\t\t\tnode.left.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.left\n\t\t\tnode.left.parent = node.parent\n\t\tbk = node.left.right\n\t\tnode.left.right = node\n\t\tnode.parent = node.left\n\t\tnode.left = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\tdef _rotate_left(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.right\n\t\t\tnode.right.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.right\n\t\t\tnode.right.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.right\n\t\t\tnode.right.parent = node.parent\n\t\tbk = node.right.left\n\t\tnode.right.left = node\n\t\tnode.parent = node.right\n\t\tnode.right = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\t@staticmethod\n\tdef _get_next(node):\n\t\tif not node.right:\n\t\t\treturn node.parent\n\t\tn = node.right\n\t\twhile n.left:\n\t\t\tn = n.left\n\t\treturn n\n\nclass SegmentTree1:\n\n\tdef __init__(self, data, default=0, func=lambda a, b: max(a, b)):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass SegmentTree:\n\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass Factorial:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorials = [1, 1]\n\t\tself.invModulos = [0, 1]\n\t\tself.invFactorial_ = [1, 1]\n\n\tdef calc(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.factorials):\n\t\t\treturn self.factorials[n]\n\t\tnextArr = [0] * (n + 1 - len(self.factorials))\n\t\tinitialI = len(self.factorials)\n\t\tprev = self.factorials[-1]\n\t\tm = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * i % m\n\t\tself.factorials += nextArr\n\t\treturn self.factorials[n]\n\n\tdef inv(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n^(-1)')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tp = self.MOD\n\t\tpi = n % p\n\t\tif pi < len(self.invModulos):\n\t\t\treturn self.invModulos[pi]\n\t\tnextArr = [0] * (n + 1 - len(self.invModulos))\n\t\tinitialI = len(self.invModulos)\n\t\tfor i in range(initialI, min(p, n + 1)):\n\t\t\tnext = -self.invModulos[p % i] * (p // i) % p\n\t\t\tself.invModulos.append(next)\n\t\treturn self.invModulos[pi]\n\n\tdef invFactorial(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate (n^(-1))!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.invFactorial_):\n\t\t\treturn self.invFactorial_[n]\n\t\tself.inv(n)\n\t\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\n\t\tinitialI = len(self.invFactorial_)\n\t\tprev = self.invFactorial_[-1]\n\t\tp = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\n\t\tself.invFactorial_ += nextArr\n\t\treturn self.invFactorial_[n]\n\nclass Combination:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorial = Factorial(MOD)\n\n\tdef ncr(self, n, k):\n\t\tif k < 0 or n < k:\n\t\t\treturn 0\n\t\tk = min(k, n - k)\n\t\tf = self.factorial\n\t\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n\tif a == 1 or n == 0:\n\t\treturn 1\n\tif n % 2 == 0:\n\t\ts = powm(a, n // 2, m)\n\t\treturn s * s % m\n\telse:\n\t\treturn a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n\tzipped_pairs = zip(list2, list1)\n\tz = [x for (_, x) in sorted(zipped_pairs)]\n\treturn z\n\ndef product(l):\n\tpor = 1\n\tfor i in range(len(l)):\n\t\tpor *= l[i]\n\treturn por\n\ndef binarySearchCount(arr, n, key):\n\tleft = 0\n\tright = n - 1\n\tcount = 0\n\twhile left <= right:\n\t\tmid = int((right + left) / 2)\n\t\tif arr[mid] < key:\n\t\t\tcount = mid + 1\n\t\t\tleft = mid + 1\n\t\telse:\n\t\t\tright = mid - 1\n\treturn count\n\ndef countdig(n):\n\tc = 0\n\twhile n > 0:\n\t\tn //= 10\n\t\tc += 1\n\treturn c\n\ndef binary(x, length):\n\ty = bin(x)[2:]\n\treturn y if len(y) >= length else '0' * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n\tl = 0\n\tr = n - 1\n\tleftGreater = n\n\twhile l <= r:\n\t\tm = int(l + (r - l) / 2)\n\t\tif arr[m] >= k:\n\t\t\tleftGreater = m\n\t\t\tr = m - 1\n\t\telse:\n\t\t\tl = m + 1\n\treturn n - leftGreater\nn = int(input())\nl = list(map(int, input().split()))\nf = [i for i in range(1, n + 1)]\ns = SegmentTree(f)\nans = [0] * n\nfor i in range(n - 1, -1, -1):\n\tst = 1\n\tend = n\n\twhile st <= end:\n\t\tmid = (st + end) // 2\n\t\tsu = s.query(0, mid - 2)\n\t\tif su == l[i]:\n\t\t\tan = mid\n\t\t\tst = mid + 1\n\t\telif su < l[i]:\n\t\t\tst = mid + 1\n\t\telse:\n\t\t\tend = mid - 1\n\tans[i] = an\n\ts.__setitem__(an - 1, 0)\nprint(*ans, sep=' ')\n",
        "slowest_solution": "n = int(input())\nP = [int(i) for i in input().split()]\nimport math\nimport bisect\nn_max = 2 * 10 ** 5\nnn = int(math.log2(n_max)) + 1\nBIT = [0] * (2 ** nn + 1)\n\ndef bitsum(BIT, i):\n\ts = 0\n\twhile i > 0:\n\t\ts += BIT[i]\n\t\ti -= i & -i\n\treturn s\n\ndef bitadd(BIT, i, x):\n\tif i <= 0:\n\t\treturn True\n\telse:\n\t\twhile i <= 2 ** nn:\n\t\t\tBIT[i] += x\n\t\t\ti += i & -i\n\t\treturn BIT\n\ndef bitlowerbound(BIT, s):\n\tif s <= 0:\n\t\treturn 0\n\telse:\n\t\tret = 0\n\t\tk = 2 ** nn\n\t\twhile k > 0:\n\t\t\tif k + ret <= 2 ** nn and BIT[k + ret] < s:\n\t\t\t\ts -= BIT[k + ret]\n\t\t\t\tret += k\n\t\t\tk //= 2\n\t\treturn ret + 1\nfor i in range(n_max):\n\tbitadd(BIT, i + 1, i + 1)\nAns = []\nfor i in reversed(range(n)):\n\tp = P[i]\n\tans = bitlowerbound(BIT, p + 1)\n\tAns.append(ans)\n\tbitadd(BIT, ans, -ans)\nAns = Ans[::-1]\nprint(*Ans)\n"
    },
    {
        "task_id": 881,
        "slowest_solution_id": 3,
        "fastest_solution_id": 1,
        "slowest_time": 3.059419870376587,
        "fastest_time": 2.6939892768859863,
        "fastest_solution": "def xnor(a, b):\n\tif a == b:\n\t\treturn 1\n\treturn 0\n\ndef matrix_parity(r):\n\tp = 1\n\tfor i in range(1, N + 1):\n\t\tp = xnor(row_parity(i), p)\n\treturn p\n\ndef row_parity(x):\n\tx = x - 1\n\tif (r[x][1] - r[x][0] + 1) % 2 == 0:\n\t\treturn 1\n\telse:\n\t\treturn 0\n\ndef intersect_parity(x, y):\n\tx -= 1\n\tif r[x][0] <= y and r[x][1] >= y:\n\t\treturn 0\n\telse:\n\t\treturn 1\n\ndef column_parity(y):\n\ty -= 1\n\tif c[y] % 2 == 0:\n\t\treturn 1\n\telse:\n\t\treturn 0\nN = int(input())\nr = []\nfor n in range(N):\n\tr.append([int(x) for x in input().split()])\nc = [0 for i in range(N)]\nfor i in range(N):\n\tc[r[i][0] - 1] += 1\n\ttry:\n\t\tc[r[i][1]] -= 1\n\texcept IndexError:\n\t\tpass\nfor i in range(1, N):\n\tc[i] = c[i] + c[i - 1]\npmatrix = matrix_parity(r)\nQ = int(input())\nfor q in range(Q):\n\t(X, Y) = [int(x) for x in input().split()]\n\tprow = row_parity(X)\n\tpcolumn = column_parity(Y)\n\tpintersection = intersect_parity(X, Y)\n\tif xnor(xnor(xnor(prow, pcolumn), pintersection), pmatrix) == 1:\n\t\tprint('E')\n\telse:\n\t\tprint('O')\n",
        "slowest_solution": "N = int(input())\nL = [0] * N\nR = [0] * N\nLeft = [0] * N\nRight = [0] * N\nrowpairity = [0] * N\ncolumnpairity = [0] * N\npairity = 0\nfor i in range(N):\n\t(a, b) = input().split(' ')\n\t(c, d) = (int(a) - 1, int(b) - 1)\n\tLeft[i] = c\n\tRight[i] = d\n\tL[c] += 1\n\tR[d] += 1\n\trowpairity[i] = (d - c + 1) % 2\n\tpairity = (pairity + d - c + 1) % 2\ncolumnpairity[0] = L[0] % 2\nfor i in range(1, N):\n\tcolumnpairity[i] = (columnpairity[i - 1] + L[i] - R[i - 1]) % 2\nQ = int(input())\nfor i in range(Q):\n\t(a, b) = input().split(' ')\n\t(r, c) = (int(a) - 1, int(b) - 1)\n\tif Left[r] <= c and c <= Right[r]:\n\t\tif (pairity - columnpairity[c] - rowpairity[r] + 1) % 2 == 0:\n\t\t\tprint('E')\n\t\telse:\n\t\t\tprint('O')\n\telif (pairity - columnpairity[c] - rowpairity[r]) % 2 == 0:\n\t\tprint('E')\n\telse:\n\t\tprint('O')\n"
    },
    {
        "task_id": 872,
        "slowest_solution_id": 6,
        "fastest_solution_id": 4,
        "slowest_time": 2.9996039867401123,
        "fastest_time": 2.610745429992676,
        "fastest_solution": "mod = 10 ** 9 + 7\nN = int(input())\nA = [int(x) for x in input().split()]\nM = int(input())\nC = []\nfor i in range(20):\n\tR = [0]\n\tt = 0\n\tfor x in A:\n\t\tt += x >> i & 1\n\t\tR.append(t)\n\tC.append(R)\nfor m in range(M):\n\t(K, P, R) = map(int, input().split())\n\td = R - P + 1\n\tt = 0\n\tfor i in range(20):\n\t\tn1 = C[i][R] - C[i][P - 1]\n\t\tn0 = d - n1\n\t\tif K >> i & 1:\n\t\t\tx = n1 * (n1 - 1) + n0 * (n0 - 1) >> 1\n\t\telse:\n\t\t\tx = n1 * n0\n\t\tt = (t + (x << i)) % mod\n\tprint(t)\n",
        "slowest_solution": "MOD = 10 ** 9 + 7\n\ndef mod(x):\n\treturn x % MOD\n\ndef prepare(A):\n\tlimit = 20\n\tmask = [1] * limit\n\tfor i in range(limit):\n\t\tmask[i] = mask[i] << i\n\tcs = tuple(([] for _ in range(limit)))\n\t(a, m) = (A[0], mask[0])\n\tfor (m, c) in zip(mask, cs):\n\t\tc.append((m & a) // m)\n\tfor a in A[1:]:\n\t\tfor (m, c) in zip(mask, cs):\n\t\t\tc.append((m & a) // m + c[-1])\n\treturn (mask, cs)\n\ndef solve(K, P, R, env):\n\tif P == R:\n\t\treturn 0\n\t(P, R, L) = (P - 1, R - 1, R - P)\n\tD = L * (L + 1) // 2\n\tS = 0\n\tfor (m, c) in zip(*env):\n\t\tk = (K & m) // m\n\t\tn1 = c[R] - (c[P - 1] if P > 0 else 0)\n\t\tn1 = n1 * (L + 1 - n1)\n\t\tif k == 0:\n\t\t\tS = mod(S + n1 * m)\n\t\telse:\n\t\t\tS = mod(S + (D - n1) * m)\n\treturn S\n_ = input()\nA = input().strip()\nA = tuple((int(x) for x in A.split()))\nE = prepare(A)\nnt = int(input())\nfor _ in range(nt):\n\tline = input().strip().split(' ')\n\t(K, P, R) = map(int, line)\n\tprint(solve(K, P, R, E))\n"
    },
    {
        "task_id": 905,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 3.123047113418579,
        "fastest_time": 2.889770269393921,
        "fastest_solution": "for _ in range(int(input())):\n\tn, k = map(int, input().split())\n\ta = [int(input(), 2) for __ in range(n)]\n\tans = []\n\tfor i in range(2**k):\n\t\tc = 0\n\t\tfor j in a:\n\t\t\tif j & i == 0:\n\t\t\t\tbreak\n\t\t\tc += 1\n\t\tif c == len(a):\n\t\t\tans.append(bin(i).count(\"1\"))\n\tprint(min(ans))\n",
        "slowest_solution": "import sys\nt = int(input())\ndef findDishes(index, mask, k, f, dp):\n\tif index == n:\n\t\treturn 0\n\tif dp[index][mask] != -1:\n\t\treturn dp[index][mask]\n\tans = sys.maxsize\n\tfor i in range(k):\n\t\tif f[index][i] == '0':\n\t\t\tcontinue\n\t\tif mask & (1 << (k - 1 - i)):\n\t\t\tans = min(ans, findDishes(index + 1, mask, k, f, dp))\n\t\telse:\n\t\t\tans = min(ans, 1 + findDishes(index + 1, mask | (1 << (k - 1 - i)), k, f, dp))\n\tdp[index][mask] = ans\n\treturn ans\nfor i in range(t):\n\tdp = [[-1] * ((1 << 10) + 10)] * (500 + 10)\n\t(n, k) = map(int, input().strip().split(' '))\n\tf = [None] * n\n\tfor j in range(n):\n\t\tf[j] = input()\n\tans = findDishes(0, 0, k, f, dp)\n\tprint(ans)\n"
    },
    {
        "task_id": 916,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.025700807571411,
        "fastest_time": 3.025700807571411,
        "fastest_solution": "from itertools import groupby\nfrom operator import itemgetter\nM = 2 ** 17\nB = [0] * (M + 1)\n\ndef reset():\n\tglobal B\n\tB = [0] * (M + 1)\n\ndef update(idx, val):\n\tidx += 1\n\twhile idx <= M:\n\t\tB[idx] += val\n\t\tidx += idx & -idx\n\ndef read(idx):\n\tr = 0\n\tidx += 1\n\twhile idx > 0:\n\t\tr += B[idx]\n\t\tidx -= idx & -idx\n\treturn r\nfor _ in range(int(input())):\n\t(N, Q) = [int(x) for x in input().split()]\n\ta = [int(x) for x in input().split()]\n\tq = [[0, i] + [int(x) for x in input().split()] for i in range(Q)]\n\tgroups = []\n\ti = 0\n\tfor (g, (_, l)) in enumerate(groupby(a)):\n\t\tj = i\n\t\tgc = len(groups)\n\t\tfor _ in l:\n\t\t\ta[j] = gc\n\t\t\tj += 1\n\t\tgroups.append([1, gc, i, j - 1, j - i])\n\t\ti = j\n\treset()\n\tq.extend(groups)\n\tq.sort(key=itemgetter(4, 0), reverse=True)\n\tfor x in q:\n\t\tif x[0]:\n\t\t\tupdate(x[1], 1)\n\t\telse:\n\t\t\t(y, z) = (a[x[2] - 1] + 1, a[x[3] - 1] - 1)\n\t\t\tr = read(z) - read(y - 1) if z >= y else 0\n\t\t\tif z + 1 == y - 1:\n\t\t\t\tif x[3] - x[2] + 1 >= x[4]:\n\t\t\t\t\tr += 1\n\t\t\telse:\n\t\t\t\tif groups[y - 1][3] - x[2] + 1 + 1 >= x[4]:\n\t\t\t\t\tr += 1\n\t\t\t\tif x[3] - 1 - groups[z + 1][2] + 1 >= x[4]:\n\t\t\t\t\tr += 1\n\t\t\tx[-1] = r\n\tfor x in sorted((x for x in q if x[0] == 0)):\n\t\tprint(x[-1])\n",
        "slowest_solution": "from itertools import groupby\nfrom operator import itemgetter\nM = 2 ** 17\nB = [0] * (M + 1)\n\ndef reset():\n\tglobal B\n\tB = [0] * (M + 1)\n\ndef update(idx, val):\n\tidx += 1\n\twhile idx <= M:\n\t\tB[idx] += val\n\t\tidx += idx & -idx\n\ndef read(idx):\n\tr = 0\n\tidx += 1\n\twhile idx > 0:\n\t\tr += B[idx]\n\t\tidx -= idx & -idx\n\treturn r\nfor _ in range(int(input())):\n\t(N, Q) = [int(x) for x in input().split()]\n\ta = [int(x) for x in input().split()]\n\tq = [[0, i] + [int(x) for x in input().split()] for i in range(Q)]\n\tgroups = []\n\ti = 0\n\tfor (g, (_, l)) in enumerate(groupby(a)):\n\t\tj = i\n\t\tgc = len(groups)\n\t\tfor _ in l:\n\t\t\ta[j] = gc\n\t\t\tj += 1\n\t\tgroups.append([1, gc, i, j - 1, j - i])\n\t\ti = j\n\treset()\n\tq.extend(groups)\n\tq.sort(key=itemgetter(4, 0), reverse=True)\n\tfor x in q:\n\t\tif x[0]:\n\t\t\tupdate(x[1], 1)\n\t\telse:\n\t\t\t(y, z) = (a[x[2] - 1] + 1, a[x[3] - 1] - 1)\n\t\t\tr = read(z) - read(y - 1) if z >= y else 0\n\t\t\tif z + 1 == y - 1:\n\t\t\t\tif x[3] - x[2] + 1 >= x[4]:\n\t\t\t\t\tr += 1\n\t\t\telse:\n\t\t\t\tif groups[y - 1][3] - x[2] + 1 + 1 >= x[4]:\n\t\t\t\t\tr += 1\n\t\t\t\tif x[3] - 1 - groups[z + 1][2] + 1 >= x[4]:\n\t\t\t\t\tr += 1\n\t\t\tx[-1] = r\n\tfor x in sorted((x for x in q if x[0] == 0)):\n\t\tprint(x[-1])\n"
    },
    {
        "task_id": 886,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 3.021049737930298,
        "fastest_time": 2.65800404548645,
        "fastest_solution": "def solve(l, c):\n\tcc = chr(c)\n\tif len(l) == 1:\n\t\treturn 1 if l[0] != cc else 0\n\tk = len(l) // 2\n\tl1 = k - l[:k].count(cc) + solve(l[k:], c + 1)\n\tl2 = k - l[k:].count(cc) + solve(l[:k], c + 1)\n\treturn min(l1, l2)\nfor _ in range(int(input())):\n\tn = int(input())\n\ts = input()\n\tprint(solve(s, ord('a')))\n",
        "slowest_solution": "from sys import stdin\n\ndef calc(s, c):\n\tif len(s) == 1:\n\t\treturn int(s[0] != c)\n\tm = len(s) // 2\n\tcntl = calc(s[m:], chr(ord(c) + 1))\n\tcntl += len(s) / 2 - s[0:m].count(c)\n\tcntr = calc(s[0:m], chr(ord(c) + 1))\n\tcntr += len(s) / 2 - s[m:].count(c)\n\treturn int(min(cntl, cntr))\nlines = stdin.readlines()\nt = int(lines[0])\nfor i in range(2, len(lines), 2):\n\ts = lines[i].rstrip('\\r\\n')\n\tprint(calc(s, 'a'))\n"
    },
    {
        "task_id": 918,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.014580249786377,
        "fastest_time": 3.014580249786377,
        "fastest_solution": "(n, b) = [int(x) for x in input().split()]\nni = [0 for _ in range(n + 1)]\nfor i in range(1, n + 1):\n\tni[i] = int(input())\ndp = [0 for _ in range(b + 1)]\ncum = [0 for _ in range(n + 2)]\ndp[b - 1] = 1\ndp[b] = 0\ncum[b] = 1\ncum[b - 1] = 2\nmd = int(1000000000.0 + 7)\nfor i in range(b - 2, 0, -1):\n\tdp[i] = (cum[i + 1] - cum[i + ni[i] + 1] + md) % md\n\tcum[i] = (dp[i] + cum[i + 1]) % md\nq = int(input())\nfor i in range(q):\n\tqu = int(input())\n\tprint(dp[qu])\n",
        "slowest_solution": "(n, b) = [int(x) for x in input().split()]\nni = [0 for _ in range(n + 1)]\nfor i in range(1, n + 1):\n\tni[i] = int(input())\ndp = [0 for _ in range(b + 1)]\ncum = [0 for _ in range(n + 2)]\ndp[b - 1] = 1\ndp[b] = 0\ncum[b] = 1\ncum[b - 1] = 2\nmd = int(1000000000.0 + 7)\nfor i in range(b - 2, 0, -1):\n\tdp[i] = (cum[i + 1] - cum[i + ni[i] + 1] + md) % md\n\tcum[i] = (dp[i] + cum[i + 1]) % md\nq = int(input())\nfor i in range(q):\n\tqu = int(input())\n\tprint(dp[qu])\n"
    },
    {
        "task_id": 875,
        "slowest_solution_id": 9,
        "fastest_solution_id": 2,
        "slowest_time": 3.011791944503784,
        "fastest_time": 2.6486637592315674,
        "fastest_solution": "def f(x, y, a, b, n):\n\treturn (a + (x - a) * cos[n] - (y - b) * sin[n], b + (x - a) * sin[n] + (y - b) * cos[n])\n\ndef check(p):\n\td = {}\n\tfor i in range(len(p) - 1):\n\t\tfor j in range(i + 1, len(p)):\n\t\t\tdist = (p[i][0] - p[j][0]) ** 2 + (p[i][1] - p[j][1]) ** 2\n\t\t\td[dist] = d.get(dist, 0) + 1\n\tif len(d) != 2:\n\t\treturn 0\n\t(a, b) = sorted(d)\n\treturn 2 * a == b and d[a] == 4 and (d[b] == 2)\n(cos, sin, variants) = ([1, 0, -1, 0], [0, 1, 0, -1], [[x, y, z, a] for x in range(4) for y in range(4) for z in range(4) for a in range(4)])\nfor t in range(int(input())):\n\t(moles, ans) = ([list(map(int, input().split())) for x in range(4)], 13)\n\tfor a in variants:\n\t\tif check([f(moles[i][0], moles[i][1], moles[i][2], moles[i][3], a[i]) for i in range(4)]):\n\t\t\tans = min(ans, sum(a))\n\tprint(ans if ans != 13 else -1)\n",
        "slowest_solution": "def siblings(initial, root):\n\tth = (initial[0] - root[0], initial[1] - root[1])\n\treturn [(root[0] + th[0], root[1] + th[1]), (root[0] - th[1], root[1] + th[0]), (root[0] - th[0], root[1] - th[1]), (root[0] + th[1], root[1] - th[0])]\n\ndef dist(x, y):\n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\ndef isSquare(p1, p2, p3, p4):\n\td2 = dist(p1, p2)\n\td3 = dist(p1, p3)\n\td4 = dist(p1, p4)\n\tu = {p1, p2, p3, p4}\n\tif len(u) != 4:\n\t\treturn 0\n\tif d2 == d3 and 2 * d2 == d4:\n\t\td = dist(p2, p4)\n\t\treturn d == dist(p3, p4) and d == d2\n\tif d3 == d4 and 2 * d3 == d2:\n\t\td = dist(p2, p3)\n\t\treturn d == dist(p2, p4) and d == d3\n\tif d2 == d4 and 2 * d2 == d3:\n\t\td = dist(p2, p3)\n\t\treturn d == dist(p3, p4) and d == d2\n\treturn False\n\ndef distOri(x, y, root):\n\tth1 = (y[0] - root[0], y[1] - root[1])\n\tth2 = (x[0] - root[0], x[1] - root[1])\n\tif th1[0] == th2[0] and th1[1] == th2[1]:\n\t\treturn 0\n\tif th2[0] == -th1[1] and th2[1] == th1[0]:\n\t\treturn 1\n\tif th2[0] == -th1[0] and th2[1] == -th1[1]:\n\t\treturn 2\n\tif th2[0] == th1[1] and th2[1] == -th1[0]:\n\t\treturn 3\nn = int(input())\nfor i in range(n):\n\tinitial = []\n\troot = []\n\t_min = 1000\n\tfor j in range(4):\n\t\t(x, y, a, b) = [int(k) for k in input().split()]\n\t\tinitial.append((x, y))\n\t\troot.append((a, b))\n\tfor x1 in siblings(initial[0], root[0]):\n\t\tfor x2 in siblings(initial[1], root[1]):\n\t\t\tfor x3 in siblings(initial[2], root[2]):\n\t\t\t\tfor x4 in siblings(initial[3], root[3]):\n\t\t\t\t\tif isSquare(x1, x2, x3, x4):\n\t\t\t\t\t\t_min = min(_min, distOri(x1, initial[0], root[0]) + distOri(x2, initial[1], root[1]) + distOri(x3, initial[2], root[2]) + distOri(x4, initial[3], root[3]))\n\tif _min == 1000:\n\t\tprint(-1)\n\telse:\n\t\tprint(_min)\n"
    },
    {
        "task_id": 876,
        "slowest_solution_id": 9,
        "fastest_solution_id": 3,
        "slowest_time": 2.9645464420318604,
        "fastest_time": 2.6757965087890625,
        "fastest_solution": "n = int(input())\na = []\nfor i in range(n):\n\ta.append(int(input()) - 1)\nans = 0\nfor i in range(len(a)):\n\tL = 0\n\twhile i > -2:\n\t\ti = a[i]\n\t\tL += 1\n\tans = max(ans, L)\nprint(ans)\n",
        "slowest_solution": "n = int(input())\nl = [int(input()) - 1 for i in range(n)]\ncc = 0\nfor i in range(n):\n\tc = 0\n\twhile i != -2:\n\t\ti = l[i]\n\t\tc += 1\n\tcc = max(c, cc)\nprint(cc)\n"
    },
    {
        "task_id": 897,
        "slowest_solution_id": 0,
        "fastest_solution_id": 5,
        "slowest_time": 3.106606960296631,
        "fastest_time": 2.841614007949829,
        "fastest_solution": "R = lambda : map(int, input().split())\n(n, m, k) = R()\n(F, T) = ([], [])\nans = int(1000000000000.0)\nfor i in range(m):\n\t(d, f, t, c) = R()\n\tif f:\n\t\tF.append((d, f, c))\n\telse:\n\t\tT.append((-d, t, c))\nfor p in [F, T]:\n\tcost = [ans] * (n + 1)\n\ts = n * ans\n\tq = []\n\tp.sort()\n\tfor (d, t, c) in p:\n\t\tif c < cost[t]:\n\t\t\ts += c - cost[t]\n\t\t\tcost[t] = c\n\t\t\tif s < ans:\n\t\t\t\tq.append((s, d))\n\tp.clear()\n\tp += q\n(s, t) = (ans, (0, 0))\nfor f in F:\n\twhile f:\n\t\tif f[1] + t[1] + k < 0:\n\t\t\ts = min(s, f[0] + t[0])\n\t\telif T:\n\t\t\tt = T.pop()\n\t\t\tcontinue\n\t\tf = 0\nprint(s if s < ans else -1)\n",
        "slowest_solution": "def main():\n\t(n, m, k) = list(map(int, input().split()))\n\t(ff, tt) = ([], [])\n\tfor _ in range(m):\n\t\t(d, f, t, c) = list(map(int, input().split()))\n\t\tif f:\n\t\t\tff.append((d, f, c))\n\t\telse:\n\t\t\ttt.append((-d, t, c))\n\tfor ft in (ff, tt):\n\t\t(cnt, costs) = (n, [1000001] * (n + 1))\n\t\tft.sort(reverse=True)\n\t\twhile ft:\n\t\t\t(day, city, cost) = ft.pop()\n\t\t\toldcost = costs[city]\n\t\t\tif oldcost > cost:\n\t\t\t\tcosts[city] = cost\n\t\t\t\tif oldcost == 1000001:\n\t\t\t\t\tcnt -= 1\n\t\t\t\t\tif not cnt:\n\t\t\t\t\t\tbreak\n\t\telse:\n\t\t\tprint(-1)\n\t\t\treturn\n\t\ttotal = sum(costs) - 1000001\n\t\tl = [(day, total)]\n\t\twhile ft:\n\t\t\t(day, city, cost) = ft.pop()\n\t\t\toldcost = costs[city]\n\t\t\tif oldcost > cost:\n\t\t\t\ttotal -= oldcost - cost\n\t\t\t\tcosts[city] = cost\n\t\t\t\tif l[-1][0] == day:\n\t\t\t\t\tl[-1] = (day, total)\n\t\t\t\telse:\n\t\t\t\t\tl.append((day, total))\n\t\tif ft is ff:\n\t\t\tff = l\n\t\telse:\n\t\t\ttt = l\n\t(l, k) = ([], -k)\n\t(d, c) = tt.pop()\n\ttry:\n\t\tfor (day, cost) in ff:\n\t\t\twhile d + day >= k:\n\t\t\t\t(d, c) = tt.pop()\n\t\t\tif d + day < k:\n\t\t\t\tl.append(c + cost)\n\texcept IndexError:\n\t\tpass\n\tprint(min(l, default=-1))\n\ndef __starting_point():\n\tmain()\n__starting_point()\n"
    },
    {
        "task_id": 878,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 3.1136815547943115,
        "fastest_time": 2.5789542198181152,
        "fastest_solution": "def f(n, k, l, r):\n\tif n & 1:\n\t\tif k == n:\n\t\t\treturn bool(l & 1)\n\t\telif k & 1:\n\t\t\treturn n + k <= 2 * l\n\t\telse:\n\t\t\treturn 2 * l < n + k and 2 * l > n - k - 1\n\telif k == n:\n\t\treturn bool(l & 1)\n\telif k & 1:\n\t\treturn n - k + 1 <= 2 * l\n\telse:\n\t\treturn False\n(n, k) = list(map(int, input().split(' ')))\na = list(map(int, input().split(' ')))\nl = list([i & 1 for i in a]).count(1)\nr = n - l\nprint('Stannis' if f(n, k, l, r) else 'Daenerys')\n",
        "slowest_solution": "def main():\n\t(n, k) = map(int, input().split())\n\teven = 0\n\todd = 0\n\tfor elem in input().split():\n\t\tif int(elem) % 2 == 0:\n\t\t\teven += 1\n\t\telse:\n\t\t\todd += 1\n\tturns = n - k\n\tif turns == 0:\n\t\tif odd % 2 == 1:\n\t\t\treturn 'Stannis'\n\t\telse:\n\t\t\treturn 'Daenerys'\n\tif turns % 2 == 0:\n\t\tif k % 2 == 1 and even <= turns // 2:\n\t\t\treturn 'Stannis'\n\t\telse:\n\t\t\treturn 'Daenerys'\n\telif k % 2 == 0 and even <= turns // 2 or odd <= turns // 2:\n\t\treturn 'Daenerys'\n\telse:\n\t\treturn 'Stannis'\nprint(main())\n"
    },
    {
        "task_id": 914,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.8118934631347656,
        "fastest_time": 2.8118934631347656,
        "fastest_solution": "print('red')\n",
        "slowest_solution": "print('red')\n"
    },
    {
        "task_id": 880,
        "slowest_solution_id": 3,
        "fastest_solution_id": 2,
        "slowest_time": 3.0841355323791504,
        "fastest_time": 2.558896064758301,
        "fastest_solution": "(x0, y0, ax, ay, bx, by) = map(int, input().split())\n(xs, ys, t) = map(int, input().split())\nn = 100\nx = [x0]\ny = [y0]\nfor _ in range(n - 1):\n\tx.append(ax * x[-1] + bx)\n\ty.append(ay * y[-1] + by)\nanswer = 0\nfor i in range(n):\n\tfor j in range(i, n):\n\t\tto_i = abs(xs - x[i]) + abs(ys - y[i])\n\t\tto_j = abs(xs - x[j]) + abs(ys - y[j])\n\t\tdist = min(to_i, to_j) + (x[j] - x[i]) + (y[j] - y[i])\n\t\tif dist <= t:\n\t\t\tanswer = max(answer, j - i + 1)\nprint(answer)\n",
        "slowest_solution": "INF = 10 ** 10\n\ndef main():\n\t(x, y, ax, ay, bx, by) = get_list()\n\t(xs, ys, t) = get_list()\n\tpoints = [[x, y]]\n\twhile points[-1][0] < 10 ** 18 and points[-1][1] < 10 ** 18:\n\t\tpoints.append([ax * points[-1][0] + bx, ay * points[-1][1] + by])\n\tmanhattan = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n\tdef calc(curr_pnt, t, res=0):\n\t\torg_point = curr_pnt\n\t\tt -= manhattan(points[curr_pnt], [xs, ys])\n\t\tif t < 0:\n\t\t\treturn 0\n\t\tres += 1\n\t\twhile curr_pnt > 0:\n\t\t\tt -= manhattan(points[curr_pnt], points[curr_pnt - 1])\n\t\t\tif t < 0:\n\t\t\t\tbreak\n\t\t\tres += 1\n\t\t\tcurr_pnt -= 1\n\t\tt -= manhattan(points[curr_pnt], points[org_point])\n\t\tcurr_pnt = org_point\n\t\twhile True:\n\t\t\tt -= manhattan(points[curr_pnt], points[curr_pnt + 1])\n\t\t\tif t < 0:\n\t\t\t\tbreak\n\t\t\tres += 1\n\t\t\tcurr_pnt += 1\n\t\treturn res\n\tres = 0\n\tfor i in range(len(points) - 1):\n\t\tres = max(res, calc(i, t))\n\tprint(res)\nimport sys\nfrom collections import defaultdict, Counter\nfrom bisect import bisect_left, bisect_right\nimport math\nout = []\nget_int = lambda : int(input())\nget_list = lambda : list(map(int, input().split()))\nmain()\nprint(*out, sep='\\n')\n"
    },
    {
        "task_id": 926,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 4.350947380065918,
        "fastest_time": 4.350947380065918,
        "fastest_solution": "import sys\nfrom array import array\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\n(n, m, k) = map(int, input().split())\nadj = [[] for _ in range(n)]\ndp = [[0] * (1 << n) for _ in range(1 << n)]\nfor (u, v) in (map(int, input().split()) for _ in range(m)):\n\t(u, v) = (u - 1, v - 1)\n\tadj[u].append(v)\n\tadj[v].append(u)\n\tdp[1 << u | 1 << v][1 << u | 1 << v] = 1\nfor v_set in range(1, 1 << n):\n\tleaf_set = v_set\n\twhile leaf_set:\n\t\tfor new_v in range(n):\n\t\t\tif 1 << new_v & v_set:\n\t\t\t\tcontinue\n\t\t\tfor bridge in adj[new_v]:\n\t\t\t\tif 1 << bridge & v_set == 0:\n\t\t\t\t\tcontinue\n\t\t\t\tnew_leaf_set = (leaf_set | 1 << new_v) & ~(1 << bridge)\n\t\t\t\tif (1 << new_v) - 1 & new_leaf_set == 0:\n\t\t\t\t\tdp[v_set | 1 << new_v][new_leaf_set] += dp[v_set][leaf_set]\n\t\tleaf_set = leaf_set - 1 & v_set\nans = 0\nbit = (1 << k) - 1\nwhile bit < 1 << n:\n\tans += dp[-1][bit]\n\tx = bit & -bit\n\ty = bit + x\n\tbit = (bit & ~y) // x >> 1 | y\nprint(ans)\n",
        "slowest_solution": "import sys\nfrom array import array\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\n(n, m, k) = map(int, input().split())\nadj = [[] for _ in range(n)]\ndp = [[0] * (1 << n) for _ in range(1 << n)]\nfor (u, v) in (map(int, input().split()) for _ in range(m)):\n\t(u, v) = (u - 1, v - 1)\n\tadj[u].append(v)\n\tadj[v].append(u)\n\tdp[1 << u | 1 << v][1 << u | 1 << v] = 1\nfor v_set in range(1, 1 << n):\n\tleaf_set = v_set\n\twhile leaf_set:\n\t\tfor new_v in range(n):\n\t\t\tif 1 << new_v & v_set:\n\t\t\t\tcontinue\n\t\t\tfor bridge in adj[new_v]:\n\t\t\t\tif 1 << bridge & v_set == 0:\n\t\t\t\t\tcontinue\n\t\t\t\tnew_leaf_set = (leaf_set | 1 << new_v) & ~(1 << bridge)\n\t\t\t\tif (1 << new_v) - 1 & new_leaf_set == 0:\n\t\t\t\t\tdp[v_set | 1 << new_v][new_leaf_set] += dp[v_set][leaf_set]\n\t\tleaf_set = leaf_set - 1 & v_set\nans = 0\nbit = (1 << k) - 1\nwhile bit < 1 << n:\n\tans += dp[-1][bit]\n\tx = bit & -bit\n\ty = bit + x\n\tbit = (bit & ~y) // x >> 1 | y\nprint(ans)\n"
    },
    {
        "task_id": 922,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.985654354095459,
        "fastest_time": 2.9432640075683594,
        "fastest_solution": "mod = 998244353\n\ndef invfac(x):\n\treturn pow(x, mod - 2, mod)\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = sorted(list(map(int, input().split())))\n\tx = len(set(a))\n\tden = invfac(n)\n\tdp = [0] * n\n\tdp[-1] = 1\n\tnum = 1\n\tfor i in reversed(range(n - 1)):\n\t\tdp[i] = dp[i + 1] if a[i] == a[i + 1] else (1 + num * invfac(n - i - 1)) % mod\n\t\tnum = (num % mod + dp[i] % mod) % mod\n\tprint(num * den % mod)\n",
        "slowest_solution": "modulo = 998244353\n\ndef shuffle(x):\n\treturn pow(x, modulo - 2, modulo)\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = sorted(list(map(int, input().split())))\n\tz = len(set(a))\n\tsort = shuffle(n)\n\tarr = [0] * n\n\tarr[-1] = 1\n\tnum = 1\n\tfor i in reversed(range(n - 1)):\n\t\tarr[i] = arr[i + 1] if a[i] == a[i + 1] else (1 + num * shuffle(n - i - 1)) % modulo\n\t\tnum = (num % modulo + arr[i] % modulo) % modulo\n\tprint(num * sort % modulo)\n"
    },
    {
        "task_id": 932,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def bowling_score(frames):\n\trolls = list(frames.replace(' ', ''))\n\tfor (i, hit) in enumerate(rolls):\n\t\tif hit == 'X':\n\t\t\trolls[i] = 10\n\t\telif hit == '/':\n\t\t\trolls[i] = 10 - rolls[i - 1]\n\t\telse:\n\t\t\trolls[i] = int(hit)\n\tscore = 0\n\tfor i in range(10):\n\t\tframe = rolls.pop(0)\n\t\tif frame == 10:\n\t\t\tscore += frame + rolls[0] + rolls[1]\n\t\telse:\n\t\t\tframe += rolls.pop(0)\n\t\t\tscore += frame\n\t\t\tif frame == 10:\n\t\t\t\tscore += rolls[0]\n\treturn score\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 883,
        "slowest_solution_id": 3,
        "fastest_solution_id": 1,
        "slowest_time": 3.114501476287842,
        "fastest_time": 2.6241912841796875,
        "fastest_solution": "def multiply(a, m, mod):\n\tfst = a[0][0] * m[0][0] + a[0][1] * m[1][0]\n\tsec = a[0][0] * m[0][1] + a[0][1] * m[1][1]\n\ttrd = a[1][0] * m[0][0] + a[1][1] * m[1][0]\n\tfur = a[1][0] * m[0][1] + a[1][1] * m[1][1]\n\t(a[0][0], a[0][1]) = (fst % mod, sec % mod)\n\t(a[1][0], a[1][1]) = (trd % mod, fur % mod)\n\ndef power(a, n, mod):\n\tif n == 0 or n == 1:\n\t\treturn\n\tpower(a, n // 2, mod)\n\tmultiply(a, a, mod)\n\tif n % 2 != 0:\n\t\tm = [[1, 1], [1, 0]]\n\t\tmultiply(a, m, mod)\n\ndef fib(n, mod):\n\tif n == 0:\n\t\treturn 0\n\ta = [[1, 1], [1, 0]]\n\tpower(a, n - 1, mod)\n\treturn a\nt = int(input())\nmod = 10 ** 9 + 7\nwhile t:\n\tt -= 1\n\t(m, n) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\tsuma = sum(a) * m % mod\n\tsumb = sum(b) * m % mod\n\tif n == 1:\n\t\tprint(suma % mod)\n\telif n == 2:\n\t\tprint(sumb % mod)\n\telse:\n\t\tmatrix = fib(n - 1, mod)\n\t\tans = (matrix[0][0] * sumb + matrix[0][1] * suma) % mod\n\t\tprint(ans)\n",
        "slowest_solution": "mod = 1000000007\n\ndef multiply(mat1, mat2):\n\tmat3 = [[0, 0], [0, 0]]\n\tmat3[0][0] = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0]\n\tmat3[0][1] = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1]\n\tmat3[1][0] = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0]\n\tmat3[1][1] = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1]\n\treturn mat3\n\ndef power(mat, n):\n\tif n == 0:\n\t\ta = [[1, 0], [0, 1]]\n\t\treturn a\n\tif n == 1:\n\t\treturn mat\n\ty = power(mat, int(n // 2))\n\tif n & 1:\n\t\treturn multiply(mat, multiply(y, y))\n\telse:\n\t\treturn multiply(y, y)\nt = int(input())\nfor i in range(t):\n\t(m, n) = map(int, input().split())\n\tl1 = list([int(x) for x in input().split()])\n\tl2 = list([int(x) for x in input().split()])\n\td1 = dict()\n\td2 = dict()\n\tf1 = 0\n\tf2 = 0\n\tfor j in range(0, m):\n\t\tf1 += l1[j]\n\t\tf2 += l2[j]\n\tf1 = m * f1 % mod\n\tf2 = m * f2 % mod\n\tans = 0\n\tmat = [[1, 1], [1, 0]]\n\tif n == 1:\n\t\tprint(f1 % mod)\n\telif n == 2:\n\t\tprint(f2 % mod)\n\telif n > 2:\n\t\tmat = power(mat, n - 2)\n\t\tans = mat[0][0] * f2 + mat[0][1] * f1\n\t\tprint(ans % mod)\n"
    },
    {
        "task_id": 904,
        "slowest_solution_id": 4,
        "fastest_solution_id": 1,
        "slowest_time": 5.511855840682983,
        "fastest_time": 2.9059641361236572,
        "fastest_solution": "from collections import defaultdict\nfrom math import *\n\ndef getReducedGraph(G, N, XTable):\n\tvisited = [0 for i in range(N)]\n\tLevels = [0 for i in range(N)]\n\tmaxLevel = 0\n\tqueue = [0]\n\twhile queue:\n\t\tu = queue[0]\n\t\tvisited[u] = 1\n\t\tqueue.pop(0)\n\t\tif maxLevel < Levels[u]:\n\t\t\tmaxLevel = Levels[u]\n\t\tfor v in G[u]:\n\t\t\tif not visited[v]:\n\t\t\t\tLevels[v] = Levels[u] + 1\n\t\t\t\tqueue.append(v)\n\tMaxPower = int(ceil(log(maxLevel + 1, 2)))\n\tUpto = 2 ** MaxPower\n\tnewXTable = [0 for y in range(Upto)]\n\tfor i in range(N):\n\t\tnewXTable[Levels[i]] ^= XTable[i]\n\tfor i in range(MaxPower):\n\t\tSkipAndDo = 2 ** i\n\t\tflag = 0\n\t\tfor q in range(0, Upto, SkipAndDo):\n\t\t\tif flag == 0:\n\t\t\t\tflag = 1\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tflag = 0\n\t\t\t\tfor z in range(q, q + SkipAndDo):\n\t\t\t\t\tnewXTable[z] ^= newXTable[z - SkipAndDo]\n\trevList = newXTable[1:]\n\trevList.reverse()\n\treturn (newXTable[0:1] + revList, Upto)\n(N, Q) = map(int, input().split())\nG = defaultdict(list)\nfor i in range(N - 1):\n\t(u, v) = map(int, input().split())\n\tassert u < v\n\tG[u].append(v)\n\tG[v].append(u)\nXTable = list(map(int, input().split()))\n(newXTable, Upto) = getReducedGraph(G, N, XTable)\nfor i in range(Q):\n\tq = int(input())\n\tprint(newXTable[q % Upto])\n",
        "slowest_solution": "import math\nimport sys\nfrom sys import stdin\nfrom collections import deque\nBIG = 2 ** 18\nANS = []\n(N, Q) = list(map(int, sys.stdin.readline().strip().split(' ')))\ngraph = [[] for i in range(N)]\nfor _ in range(N - 1):\n\t(a, b) = list(map(int, sys.stdin.readline().strip().split(' ')))\n\tgraph[a] += [b]\n\tgraph[b] += [a]\nvalue = list(map(int, sys.stdin.readline().strip().split(' ')))\nquery = []\nfor _ in range(Q):\n\tquery += [int(input())]\nparent = [-1] * N\nlevel = [0] * N\nq = deque([0])\nwhile q:\n\tu = q.popleft()\n\tfor v in graph[u]:\n\t\tif v != parent[u]:\n\t\t\tq.append(v)\n\t\t\tlevel[v] = level[u] + 1\n\t\t\tparent[v] = u\nmaxlevel = max(level)\nLL = [[] for i in range(maxlevel + 1)]\nfor i in range(N):\n\tLL[level[i]] += [value[i]]\nnewvalue = [0] * (maxlevel + 1)\n\ndef find(C):\n\ttemp = 0\n\tfor i in range(len(C)):\n\t\ttemp ^= C[i]\n\treturn temp\nfor i in range(maxlevel + 1):\n\tnewvalue[i] = find(LL[i])\nnewvalue = newvalue + [0] * (BIG - len(newvalue))\n\ndef findout(array):\n\tif len(array) == 2:\n\t\treturn [array[0], array[1] ^ array[0]]\n\tif len(array) == 1:\n\t\treturn [array[0]]\n\tleft = array[:len(array) // 2]\n\tright = array[len(array) // 2:]\n\tans1 = findout(left)\n\tans2 = findout(right)\n\tans = [0] * len(array)\n\tfor i in range(len(array) // 2):\n\t\tif i == 0:\n\t\t\tans[i] = ans1[i]\n\t\telse:\n\t\t\tans[i] = ans1[i] ^ ans2[i]\n\tfor i in range(len(array) // 2, len(array)):\n\t\tif i == len(array) // 2:\n\t\t\tans[i] = ans1[0] ^ ans2[0]\n\t\telse:\n\t\t\tans[i] = ans1[i - len(array) // 2]\n\treturn ans\nanswers = findout(newvalue)\nANS = []\nfor i in range(len(query)):\n\tneed = query[i] % BIG\n\tANS += [answers[need]]\nprint('\\n'.join(list(map(str, ANS))))\n"
    },
    {
        "task_id": 935,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 0.002000570297241211,
        "fastest_time": 0.0,
        "fastest_solution": "def shortest_time(speed):\n\t(a, b, c, d) = sorted(speed)\n\treturn a + b + d + min(2 * b, a + c)\n",
        "slowest_solution": "def shortest_time(speed):\n\timport itertools\n\tfrom collections import Counter\n\ttimes = []\n\tfor elem in itertools.combinations(speed, 2):\n\t\tend1 = [x for x in elem]\n\t\tbase1 = list((Counter(speed) - Counter(end1)).elements())\n\t\tfor i in itertools.combinations(end1, 1):\n\t\t\tbase2 = [x for x in base1 + [i[0]]]\n\t\t\tif sum(end1) != 2 * end1[0]:\n\t\t\t\tend2 = [x for x in end1 if x != i[0]]\n\t\t\telse:\n\t\t\t\tend2 = [end1[0]]\n\t\t\tfor j in itertools.combinations(base2, 2):\n\t\t\t\tend3 = [x for x in end2 + [j[0], j[1]]]\n\t\t\t\tbase3 = list((Counter(base2) - Counter(j)).elements())\n\t\t\t\tfor k in itertools.combinations(end3, 1):\n\t\t\t\t\tbase4 = [x for x in base3 + [k[0]]]\n\t\t\t\t\ttimes += [max(elem) + i[0] + max(j) + k[0] + max(base4)]\n\treturn min(times)\n"
    },
    {
        "task_id": 884,
        "slowest_solution_id": 8,
        "fastest_solution_id": 1,
        "slowest_time": 3.0182323455810547,
        "fastest_time": 2.5995118618011475,
        "fastest_solution": "for a in range(int(input())):\n\t(N, M) = map(int, input().split())\n\tif min(N, M) >= 2:\n\t\tif M % 2 == 0 or N % 2 == 0:\n\t\t\tprint('Yes')\n\t\telse:\n\t\t\tprint('No')\n\telif min(M, N) == 1 and max(M, N) == 2:\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')\n",
        "slowest_solution": "def testcase(N: int, M: int) -> bool:\n\treturn N == 1 and M == 2 or (N == 2 and M == 1) or (N != 1 and M != 1 and (N % 2 == 0 or M % 2 == 0))\n\ndef main() -> None:\n\tT = int(input())\n\tfor _ in range(T):\n\t\t(N, M) = map(int, input().split())\n\t\tprint('Yes' if testcase(N, M) else 'No')\nmain()\n"
    },
    {
        "task_id": 885,
        "slowest_solution_id": 5,
        "fastest_solution_id": 1,
        "slowest_time": 3.0220861434936523,
        "fastest_time": 2.6445603370666504,
        "fastest_solution": "from collections import deque\nfor tt in range(int(input())):\n\t(n, s) = map(int, input().split())\n\tadj = [[] for i in range(n)]\n\ts -= 1\n\tq = deque([s])\n\tfor i in range(n - 1):\n\t\t(a, b) = map(int, input().split())\n\t\tadj[a - 1].append(b - 1)\n\t\tadj[b - 1].append(a - 1)\n\tif len(adj[s]) <= 1:\n\t\tprint('Ayush')\n\t\tcontinue\n\tif n % 2 == 1:\n\t\tprint('Ashish')\n\telse:\n\t\tprint('Ayush')\n",
        "slowest_solution": "def leaves(m, n):\n\tcount = 0\n\tfor i in m:\n\t\tif count >= 2:\n\t\t\tbreak\n\t\tif i[0] == n or i[1] == n:\n\t\t\tcount += 1\n\tif len(m) <= 1 or count == 1:\n\t\treturn 'Ayush'\n\telif (len(m) - 2) % 2 == 0:\n\t\treturn 'Ashish'\n\telse:\n\t\treturn 'Ayush'\nfor i in range(int(input().strip())):\n\tmass = []\n\tt = [int(d) for d in input().strip().split()]\n\tfor j in range(t[0] - 1):\n\t\tg = [int(d) for d in input().strip().split()]\n\t\tmass.append(g)\n\tprint(leaves(mass, t[1]))\n"
    },
    {
        "task_id": 913,
        "slowest_solution_id": 3,
        "fastest_solution_id": 4,
        "slowest_time": 3.0627288818359375,
        "fastest_time": 2.7566165924072266,
        "fastest_solution": "from collections import defaultdict, Counter\nfrom sys import stdin\ninput = stdin.readline\n\nclass BIT:\n\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.tree = [0] * (n + 1)\n\n\tdef sum(self, i):\n\t\tans = 0\n\t\ti += 1\n\t\twhile i > 0:\n\t\t\tans += self.tree[i]\n\t\t\ti -= i & -i\n\t\treturn ans\n\n\tdef update(self, i, value):\n\t\ti += 1\n\t\twhile i <= self.n:\n\t\t\tself.tree[i] += value\n\t\t\ti += i & -i\n\ndef score(t):\n\tcnt = Counter(t)\n\treturn list(cnt.values()).count(2)\n\ndef year():\n\tdct = defaultdict(list)\n\tn = int(input())\n\tleft = [0] * n\n\tright = [0] * n\n\tfor i in range(n):\n\t\t(a, b) = map(int, input().strip().split())\n\t\tleft[i] = a\n\t\tright[i] = b\n\torder = list(range(n))\n\torder = sorted(order, key=lambda s: left[s])\n\tfor i in range(n):\n\t\tleft[order[i]] = i\n\torder = list(range(n))\n\torder = sorted(order, key=lambda s: right[s])\n\tft = BIT(n)\n\tres = [0] * n\n\tfor (i, k) in enumerate(order):\n\t\ta = left[k]\n\t\tres[k] = i - ft.sum(a - 1)\n\t\tft.update(a, 1)\n\tprint(*res, sep='\\n')\nyear()\n",
        "slowest_solution": "import sys\n\nclass BIT_RSQ(object):\n\t__slots__ = ['nodes', 'size']\n\n\tdef __init__(self, size: int):\n\t\tself.nodes = [0] * (size + 1)\n\t\tself.size = size + 1\n\n\tdef add(self, index: int, value: int):\n\t\twhile index < self.size:\n\t\t\tself.nodes[index] += value\n\t\t\tindex += index & -index\n\n\tdef sum(self, right: int):\n\t\tresult = 0\n\t\twhile right:\n\t\t\tresult += self.nodes[right]\n\t\t\tright -= right & -right\n\t\treturn result\nn = int(sys.stdin.buffer.readline().decode('utf-8'))\nsegment = []\ncset = set()\nfor (i, (li, ri)) in enumerate((map(int, line.decode('utf-8').split()) for line in sys.stdin.buffer)):\n\tcset.add(li)\n\tcset.add(ri)\n\tsegment.append((li, ri, i))\nm = len(cset) + 5\nrsq = BIT_RSQ(m)\ncomp_dict = {x: i for (i, x) in enumerate(sorted(cset), start=2)}\nfor (_, ri, _) in segment:\n\trsq.add(comp_dict[ri], 1)\nsegment.sort()\nans = [0] * n\nsi = 0\nfor i in range(2, m):\n\twhile si < n and comp_dict[segment[si][0]] <= i:\n\t\tif comp_dict[segment[si][0]] == i:\n\t\t\trsq.add(comp_dict[segment[si][1]], -1)\n\t\t\tans[segment[si][2]] = rsq.sum(comp_dict[segment[si][1]]) - rsq.sum(comp_dict[segment[si][0]])\n\t\t\tsi += 1\nsys.stdout.buffer.write('\\n'.join(map(str, ans)).encode('utf-8'))\n"
    },
    {
        "task_id": 887,
        "slowest_solution_id": 2,
        "fastest_solution_id": 1,
        "slowest_time": 3.072741985321045,
        "fastest_time": 2.5114731788635254,
        "fastest_solution": "import sys\n\ndef main():\n\t(n, m) = tuple([int(x) for x in input().split()])\n\tw = [int(x) for x in input().split()]\n\tb = [int(x) - 1 for x in input().split()]\n\to = []\n\tfor i in range(m):\n\t\tif len(o) == n:\n\t\t\tbreak\n\t\tif b[i] not in [x[0] for x in o]:\n\t\t\to.append((b[i], w[b[i]]))\n\ts = 0\n\tfor i in range(m):\n\t\tind = [o[i][0] for i in range(len(o))].index(b[i])\n\t\ts += sum([o[i][1] for i in range(ind)])\n\t\tel = o.pop(ind)\n\t\to.insert(0, el)\n\tprint(s)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n",
        "slowest_solution": "(n, m) = list(map(int, input().split()))\nw = list(map(int, input().split()))\nl = list(map(int, input().split()))\nk = 0\nf = []\nfor x in l:\n\tx -= 1\n\tif x not in f:\n\t\tfor y in f:\n\t\t\tk += w[y]\n\t\tf = [x] + f\n\telse:\n\t\tfor i in range(len(f)):\n\t\t\tif f[i] != x:\n\t\t\t\tk += w[f[i]]\n\t\t\telse:\n\t\t\t\tbreak\n\t\tdel f[i]\n\t\tf = [x] + f\nprint(k)\n"
    },
    {
        "task_id": 890,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 3.0318429470062256,
        "fastest_time": 2.566648244857788,
        "fastest_solution": "import sys\nsys.setrecursionlimit(1000000)\ninput = sys.stdin.buffer.readline\nt = int(input())\nfor zzz in range(t):\n\t(n, m) = [int(x) for x in input().split()]\n\tp = [int(x) for x in input().split()]\n\th = [int(x) for x in input().split()]\n\tp.insert(0, 0)\n\th.insert(0, 0)\n\tedges = [[] for _ in range(n + 1)]\n\tfor zz in range(n - 1):\n\t\t(u, v) = [int(x) for x in input().split()]\n\t\tedges[u].append(v)\n\t\tedges[v].append(u)\n\tok = [True]\n\n\tdef dfs(node, parent):\n\t\tT = p[node]\n\t\tminH = 0\n\t\tfor nextt in edges[node]:\n\t\t\tif nextt != parent:\n\t\t\t\t(a, b) = dfs(nextt, node)\n\t\t\t\tT += a\n\t\t\t\tminH += b\n\t\ttemp = h[node] + T\n\t\tif temp % 2 == 1:\n\t\t\tok[0] = False\n\t\tactualH = temp // 2\n\t\tactualS = T - actualH\n\t\tif actualH < 0 or actualS < 0:\n\t\t\tok[0] = False\n\t\tif actualH < minH:\n\t\t\tok[0] = False\n\t\treturn (T, actualH)\n\tdfs(1, 0)\n\tif ok[0]:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "import sys\nsys.setrecursionlimit(10 ** 7)\n\ndef solve():\n\t(N, M) = map(int, input().split())\n\tperson = list(map(int, input().split()))\n\thappy = list(map(int, input().split()))\n\tG = [[] for i in range(N + 1)]\n\tfor i in range(N - 1):\n\t\t(x, y) = map(int, input().split())\n\t\tG[x].append(y)\n\t\tG[y].append(x)\n\tvisited = [False for i in range(N + 1)]\n\tdepth = [0 for i in range(N + 1)]\n\tchild_cnt = [person[i - 1] for i in range(N + 1)]\n\n\tdef dfs(s_node):\n\t\tvisited[s_node] = True\n\t\tfor child in G[s_node]:\n\t\t\tif visited[child] == False:\n\t\t\t\tdepth[child] = depth[s_node] + 1\n\t\t\t\tdfs(child)\n\t\tfor child in G[s_node]:\n\t\t\tif depth[child] > depth[s_node]:\n\t\t\t\tchild_cnt[s_node] += child_cnt[child]\n\tdfs(1)\n\tgood_count = [0 for i in range(N + 1)]\n\tflag = True\n\tfor i in range(N):\n\t\tif (child_cnt[i + 1] + happy[i]) % 2 != 0:\n\t\t\tflag = False\n\t\t\tbreak\n\t\telse:\n\t\t\tgood_count[i + 1] = (child_cnt[i + 1] + happy[i]) // 2\n\tif flag == False:\n\t\tprint('NO')\n\t\treturn\n\tfor i in range(1, N + 1):\n\t\tleft = good_count[i]\n\t\tif not 0 <= left <= child_cnt[i]:\n\t\t\tflag = False\n\t\t\tbreak\n\t\tright = 0\n\t\tfor child in G[i]:\n\t\t\tif depth[i] < depth[child]:\n\t\t\t\tright += good_count[child]\n\t\tif left < right:\n\t\t\tflag = False\n\t\t\tbreak\n\tif flag:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n\treturn\n\ndef main():\n\tt = int(input())\n\tfor i in range(t):\n\t\tsolve()\nmain()\n"
    },
    {
        "task_id": 928,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.9757556915283203,
        "fastest_time": 2.872394323348999,
        "fastest_solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h\nfrom bisect import bisect_left, bisect_right\nfrom types import GeneratorType\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\timport os\n\t\tself.os = os\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tself.os.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string\n\ndef getInts():\n\treturn [int(s) for s in input().split()]\n\ndef getInt():\n\treturn int(input())\n\ndef getStrs():\n\treturn [s for s in input().split()]\n\ndef getStr():\n\treturn input()\n\ndef listStr():\n\treturn list(input())\n\ndef getMat(n):\n\treturn [getInts() for _ in range(n)]\nMOD = 10 ** 9 + 7\n\ndef bootstrap(f, stack=[]):\n\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\n\ndef solve():\n\t(N, K) = getInts()\n\tgraph = dd(set)\n\tfor i in range(N - 1):\n\t\t(A, B) = getInts()\n\t\tgraph[A].add(B)\n\t\tgraph[B].add(A)\n\tdp_count = [[0 for j in range(5)] for i in range(N + 1)]\n\tdp_total = [0 for j in range(N + 1)]\n\tglobal ans\n\tans = 0\n\n\t@bootstrap\n\tdef dfs(node, parent, depth):\n\t\tglobal ans\n\t\tdp_count[node][depth % K] = 1\n\t\tdp_total[node] = 1\n\t\tfor neigh in graph[node]:\n\t\t\tif neigh != parent:\n\t\t\t\tyield dfs(neigh, node, depth + 1)\n\t\t\t\tfor i in range(K):\n\t\t\t\t\tfor j in range(K):\n\t\t\t\t\t\tdiff = (i + j - 2 * depth) % K\n\t\t\t\t\t\treq = -diff % K\n\t\t\t\t\t\tans += req * dp_count[node][i] * dp_count[neigh][j]\n\t\t\t\tfor i in range(K):\n\t\t\t\t\tdp_count[node][i] += dp_count[neigh][i]\n\t\t\t\tdp_total[node] += dp_total[neigh]\n\t\tans += dp_total[node] * (N - dp_total[node])\n\t\tyield\n\tdfs(1, -1, 0)\n\treturn ans // K\nprint(solve())\n",
        "slowest_solution": "import sys\ninput = sys.stdin.buffer.readline\nfrom collections import deque\n(n, k) = map(int, input().split())\ntot_dist = 0\nvis = [0] * (n + 1)\ndist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\nadj = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n\t(u, v) = map(int, input().split())\n\tadj[u].append(v)\n\tadj[v].append(u)\ns = deque([1])\nwhile s:\n\tc = s[-1]\n\tif not vis[c]:\n\t\tvis[c] = 1\n\t\tfor ne in adj[c]:\n\t\t\tif not vis[ne]:\n\t\t\t\ts.append(ne)\n\telse:\n\t\ttot = [0] * k\n\t\tsum_dist = 0\n\t\tpairable = 0\n\t\tfor ne in adj[c]:\n\t\t\ttot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n\t\t\tfor i in range(k):\n\t\t\t\tfor j in range(k):\n\t\t\t\t\ttot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n\t\t\tfor i in range(k):\n\t\t\t\ttot[i] += dist[ne][i][1]\n\t\t\t\tpairable += dist[ne][i][1]\n\t\t\t\tsum_dist += dist[ne][i][0]\n\t\tfor ne in adj[c]:\n\t\t\tfor i in range(k):\n\t\t\t\tfor j in range(2):\n\t\t\t\t\tdist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n\t\t\tdist[c][0][0] += dist[ne][k - 1][1]\n\t\tdist[c][0][1] += 1\n\t\tfor i in range(k):\n\t\t\ttot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n\t\ts.pop()\nprint(tot_dist)\n"
    },
    {
        "task_id": 889,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 3.0579335689544678,
        "fastest_time": 2.613781452178955,
        "fastest_solution": "for _ in range(int(input())):\n\t(a, b) = map(str, input().split())\n\tlst = {}\n\tflag = 0\n\tfor i in range(len(a)):\n\t\tif a[i] in lst:\n\t\t\tlst[a[i]] += 1\n\t\telse:\n\t\t\tlst[a[i]] = 1\n\tfor i in range(len(b)):\n\t\tif b[i] in lst:\n\t\t\tlst[b[i]] += 1\n\t\telse:\n\t\t\tlst[b[i]] = 1\n\tfor j in range(int(input())):\n\t\tson = input()\n\t\tfor k in range(len(son)):\n\t\t\tif son[k] in lst and lst[son[k]] >= 1:\n\t\t\t\tlst[son[k]] -= 1\n\t\t\telse:\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\tif flag == 0:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "for _ in range(int(input())):\n\t(a, b) = input().split()\n\ts = ''\n\tfor i in range(int(input())):\n\t\ts += input()\n\t(d1, d2, f) = ({}, {}, 0)\n\ta += b\n\tfor i in a:\n\t\tif i not in d1:\n\t\t\td1[i] = 1\n\t\telse:\n\t\t\td1[i] += 1\n\tfor i in s:\n\t\tif i not in d1:\n\t\t\td1[i] = 0\n\t\tif i not in d2:\n\t\t\td2[i] = 1\n\t\telse:\n\t\t\td2[i] += 1\n\tfor i in d2:\n\t\tif d1[i] < d2[i] or i not in d2:\n\t\t\tf = 1\n\t\t\tbreak\n\tif f:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n"
    },
    {
        "task_id": 945,
        "slowest_solution_id": 8,
        "fastest_solution_id": 0,
        "slowest_time": 0.0010116100311279297,
        "fastest_time": 0.0,
        "fastest_solution": "from collections import defaultdict\nimport re\nP = re.compile('\\\\+?(-?\\\\d*)(x\\\\^?)?(\\\\d*)')\n\ndef differentiate(eq, x):\n\tderivate = defaultdict(int)\n\tfor (coef, var, exp) in P.findall(eq):\n\t\texp = int(exp or (var and '1') or '0')\n\t\tcoef = int(coef != '-' and coef or (coef and '-1') or '1')\n\t\tif exp:\n\t\t\tderivate[exp - 1] += exp * coef\n\treturn sum((coef * x ** exp for (exp, coef) in derivate.items()))\n",
        "slowest_solution": "from re import findall\n\ndef val(s):\n\tif not s:\n\t\treturn 1\n\tif s[0] == '+':\n\t\treturn int(s[1:] or '1')\n\tif s[0] == '-':\n\t\treturn -int(s[1:] or '1')\n\treturn int(s)\n\ndef differentiate(equation, point):\n\tres = 0\n\tfor x in findall('[+-]?\\\\d*x(?:\\\\^\\\\d+)?', equation):\n\t\ti = x.find('x')\n\t\t(v, p) = (val(x[:i]), int(x[i + 2:] or '1'))\n\t\tres += v * p * point ** (p - 1)\n\treturn res\n"
    },
    {
        "task_id": 933,
        "slowest_solution_id": 1,
        "fastest_solution_id": 0,
        "slowest_time": 2.9793150424957275,
        "fastest_time": 2.7440617084503174,
        "fastest_solution": "import time\n\ndef find_max_clique(remain, size, max_, index, maxs):\n\tresult = max_\n\tif size + len(remain) <= result:\n\t\treturn result\n\tif not remain:\n\t\treturn size\n\twhile remain:\n\t\tcandidate = max(remain)\n\t\tif maxs[candidate] + size <= result:\n\t\t\treturn result\n\t\tif size + len(remain) <= result:\n\t\t\treturn result\n\t\tremain.remove(candidate)\n\t\tsub_result = find_max_clique(remain & index[candidate], size + 1, result, index, maxs)\n\t\tif sub_result > result:\n\t\t\tresult = sub_result\n\t\t\treturn result\n\treturn result\n\ndef test_find():\n\tindex = [{2, 4, 5, 7}, {4, 5, 6}, {0, 5, 6, 7}, {5, 6, 7}, {0, 1, 6, 7}, {0, 1, 2, 3}, {1, 2, 3, 4}, {0, 2, 3, 4}]\n\tm = 8\n\tmaxs = [0] * m\n\twhole = set()\n\tfor i in range(m):\n\t\twhole.add(i)\n\t\tmaxs[i] = max(maxs[i - 1], find_max_clique(whole & index[i], 1, maxs[i - 1], index, maxs))\n\ndef solve(events, m):\n\tindex = [set() for _ in range(m)]\n\tr = []\n\twhile events:\n\t\tele = events.pop()\n\t\tif ele is None:\n\t\t\tr.clear()\n\t\telse:\n\t\t\tfor n in r:\n\t\t\t\tindex[n].add(ele)\n\t\t\tindex[ele].update(r)\n\t\t\tr.append(ele)\n\twhole = set(range(m))\n\tfor i in range(m):\n\t\tindex[i] = whole - index[i] - {i}\n\tmaxs = [0] * m\n\twhole = set()\n\tfor i in range(m):\n\t\twhole.add(i)\n\t\tmaxs[i] = max(maxs[i - 1], find_max_clique(whole & index[i], 1, maxs[i - 1], index, maxs))\n\treturn maxs[-1]\n\ndef test():\n\tevents = []\n\tm = 700\n\tfor i in range(m):\n\t\tevents.extend([None, i])\n\ttick = time.time()\n\tprint(solve(events, m))\n\ttock = time.time()\n\tprint('T:', round(tock - tick, 5))\n\ndef main():\n\t(n, m) = list(map(int, input().split()))\n\tevents = []\n\td = {}\n\tid_ = 0\n\tfor i in range(n):\n\t\tline = input()\n\t\tif line.startswith('1'):\n\t\t\tevents.append(None)\n\t\telse:\n\t\t\tif line not in d:\n\t\t\t\td[line] = id_\n\t\t\t\tid_ += 1\n\t\t\tevents.append(d[line])\n\tprint(solve(events, m))\n\ndef __starting_point():\n\tmain()\n__starting_point()\n",
        "slowest_solution": "import time\n(n, m) = map(int, input().split())\nnames = {None: 0}\ncount = {i: 0 for i in range(1, m + 1)}\na = [0] * (n + 1)\nfor i in range(n):\n\tl = list(input().split())\n\tif l[0] == '2':\n\t\tif l[1] not in names:\n\t\t\tnames[l[1]] = len(names)\n\t\ta[i] = names[l[1]]\n\t\tcount[a[i]] = count[a[i]] + 1\ndense = [set() for _ in range(m + 1)]\nbulk = set()\nfor i in range(n):\n\tif a[i] == 0:\n\t\tbulk.clear()\n\t\tcontinue\n\tif a[i] in bulk:\n\t\tcontinue\n\tfor j in bulk:\n\t\tdense[j].add(a[i])\n\t\tdense[a[i]].add(j)\n\tbulk.add(a[i])\nres = 0\nhappy = set()\nunhappy = set()\nmindep = 99\nindependent = set()\ndependent = set()\nfor i in range(1, m + 1):\n\tif len(dense[i]) == 0:\n\t\tindependent.add(i)\n\telse:\n\t\tdependent.add(i)\n\t\tif len(dense[i]) < mindep:\n\t\t\tmindep = len(dense[i])\nfor k in list(dependent):\n\thappy.clear()\n\tunhappy.clear()\n\tbulk.clear()\n\tbulk.update(dependent)\n\thappy.add(k)\n\tbulk.remove(k)\n\tfor j in dense[k]:\n\t\tif j in bulk:\n\t\t\tunhappy.add(j)\n\t\t\tbulk.remove(j)\n\twhile bulk:\n\t\tmini = min([len(dense[i]) for i in bulk])\n\t\tfor i in list(bulk):\n\t\t\tif len(dense[i]) == mini and i in bulk:\n\t\t\t\thappy.add(i)\n\t\t\t\tbulk.remove(i)\n\t\t\t\tfor j in dense[i]:\n\t\t\t\t\tif j in bulk:\n\t\t\t\t\t\tunhappy.add(j)\n\t\t\t\t\t\tbulk.remove(j)\n\t\t\t\tcontinue\n\tres = max(res, len(happy))\nprint(res + len(independent))\n"
    },
    {
        "task_id": 892,
        "slowest_solution_id": 0,
        "fastest_solution_id": 6,
        "slowest_time": 3.072228193283081,
        "fastest_time": 2.78935170173645,
        "fastest_solution": "import sys\n\ndef read_ints():\n\treturn map(int, input().split())\n(s, x) = read_ints()\nif s < x or s - x & 1:\n\tprint(0)\nelse:\n\tans = 1\n\tab = (s - x) // 2\n\txb = bin(x)[2:][::-1]\n\tabb = bin(ab)[2:][::-1]\n\tabb = abb + '0' * max(0, len(xb) - len(abb))\n\txb = xb + '0' * max(0, len(abb) - len(xb))\n\tfor (abi, xbi) in zip(abb, xb):\n\t\tif xbi == '1':\n\t\t\tif abi == '0':\n\t\t\t\tans = ans << 1\n\t\t\telse:\n\t\t\t\tprint(0)\n\t\t\t\tsys.exit(0)\n\tif s == x:\n\t\tans -= 2\n\tprint(ans)\n",
        "slowest_solution": "(s, x) = map(int, input().split())\nif x > s or (s - x) % 2 != 0:\n\tprint(0)\nelse:\n\tmask = 1\n\tres = 1\n\tbit = 0\n\tND = (s - x) // 2\n\tflag = False\n\twhile bit < 50:\n\t\tif mask & x > 0:\n\t\t\tres *= 2\n\t\tif mask & x > 0 and ND & mask > 0:\n\t\t\tflag = True\n\t\t\tbreak\n\t\tmask *= 2\n\t\tbit += 1\n\tif s == x:\n\t\tres -= 2\n\tif flag:\n\t\tres = 0\n\tprint(res)\n"
    },
    {
        "task_id": 948,
        "slowest_solution_id": -1,
        "fastest_solution_id": 0,
        "slowest_time": 0,
        "fastest_time": 0.0,
        "fastest_solution": "def split_odd_and_even(n):\n\timport re\n\treturn [int(i) for i in re.findall('[2468]+|[13579]+', str(n))]\n",
        "slowest_solution": "The running time of all solutions to this problem is 0s, and the time dif between them is hard to estimate."
    },
    {
        "task_id": 923,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.9805407524108887,
        "fastest_time": 2.7937824726104736,
        "fastest_solution": "import sys\n\ndef numGood(P, a, b):\n\tcount = 0\n\taCount = 0\n\tfor letter in P:\n\t\tif letter == a:\n\t\t\taCount += 1\n\t\t\tcontinue\n\t\tif letter == b:\n\t\t\tcount += aCount\n\treturn count\n\ndef main():\n\targs = []\n\tfor line in sys.stdin:\n\t\targs.append(line)\n\tP = args[0]\n\tQ = args[1]\n\toffset = 2\n\tletters = ['c', 'h', 'e', 'f']\n\tletterCount = {'c': [0], 'h': [0], 'e': [0], 'f': [0]}\n\tpairCount = {'c': {'h': [0], 'e': [0], 'f': [0]}, 'h': {'c': [0], 'e': [0], 'f': [0]}, 'e': {'c': [0], 'h': [0], 'f': [0]}, 'f': {'c': [0], 'h': [0], 'e': [0]}}\n\tfor n in P[:-1]:\n\t\tletterCount[n].append(letterCount[n][-1] + 1)\n\t\tfor letter in letters:\n\t\t\tif letter != n:\n\t\t\t\tletterCount[letter].append(letterCount[letter][-1])\n\t\t\tfor letter2 in letters:\n\t\t\t\tif letter2 == n and letter != n:\n\t\t\t\t\tpairCount[letter][n].append(pairCount[letter][n][-1] + letterCount[letter][-1])\n\t\t\t\telif letter != letter2:\n\t\t\t\t\tpairCount[letter][letter2].append(pairCount[letter][letter2][-1])\n\tfor query in args[offset:]:\n\t\t(a, b, L, R) = query.split()\n\t\tL = int(L)\n\t\tR = int(R)\n\t\tcntA = letterCount[a][L - 1]\n\t\tcntB = letterCount[b][R] - letterCount[b][L - 1]\n\t\tprint(pairCount[a][b][R] - pairCount[a][b][L - 1] - cntA * cntB)\nmain()\n",
        "slowest_solution": "def main():\n\tP = input()\n\tQ = int(input())\n\tLetterCount = {'c': 0, 'h': 0, 'e': 0, 'f': 0}\n\tLetterCountList = {'c': list(), 'h': list(), 'e': list(), 'f': list()}\n\tways = {'ch': list(), 'ce': list(), 'cf': list(), 'hc': list(), 'he': list(), 'hf': list(), 'eh': list(), 'ec': list(), 'ef': list(), 'fe': list(), 'fc': list(), 'fh': list()}\n\tfor x in ways:\n\t\tways[x].append(0)\n\tLetterCount[P[0]] = 1\n\tLetterCountList['c'].append(LetterCount['c'])\n\tLetterCountList['h'].append(LetterCount['h'])\n\tLetterCountList['e'].append(LetterCount['e'])\n\tLetterCountList['f'].append(LetterCount['f'])\n\tfor i in range(1, len(P)):\n\t\tLetterCount[P[i]] = LetterCount[P[i]] + 1\n\t\tLetterCountList['c'].append(LetterCount['c'])\n\t\tLetterCountList['h'].append(LetterCount['h'])\n\t\tLetterCountList['e'].append(LetterCount['e'])\n\t\tLetterCountList['f'].append(LetterCount['f'])\n\t\tif P[i] == 'f':\n\t\t\tways['cf'].append(ways['cf'][i - 1] + LetterCount['c'])\n\t\t\tways['hf'].append(ways['hf'][i - 1] + LetterCount['h'])\n\t\t\tways['ef'].append(ways['ef'][i - 1] + LetterCount['e'])\n\t\t\tways['ch'].append(ways['ch'][i - 1])\n\t\t\tways['fh'].append(ways['fh'][i - 1])\n\t\t\tways['eh'].append(ways['eh'][i - 1])\n\t\t\tways['ce'].append(ways['ce'][i - 1])\n\t\t\tways['he'].append(ways['he'][i - 1])\n\t\t\tways['fe'].append(ways['fe'][i - 1])\n\t\t\tways['fc'].append(ways['fc'][i - 1])\n\t\t\tways['hc'].append(ways['hc'][i - 1])\n\t\t\tways['ec'].append(ways['ec'][i - 1])\n\t\telif P[i] == 'h':\n\t\t\tways['ch'].append(ways['ch'][i - 1] + LetterCount['c'])\n\t\t\tways['fh'].append(ways['fh'][i - 1] + LetterCount['f'])\n\t\t\tways['eh'].append(ways['eh'][i - 1] + LetterCount['e'])\n\t\t\tways['cf'].append(ways['cf'][i - 1])\n\t\t\tways['hf'].append(ways['hf'][i - 1])\n\t\t\tways['ef'].append(ways['ef'][i - 1])\n\t\t\tways['ce'].append(ways['ce'][i - 1])\n\t\t\tways['he'].append(ways['he'][i - 1])\n\t\t\tways['fe'].append(ways['fe'][i - 1])\n\t\t\tways['fc'].append(ways['fc'][i - 1])\n\t\t\tways['hc'].append(ways['hc'][i - 1])\n\t\t\tways['ec'].append(ways['ec'][i - 1])\n\t\telif P[i] == 'e':\n\t\t\tways['ce'].append(ways['ce'][i - 1] + LetterCount['c'])\n\t\t\tways['he'].append(ways['he'][i - 1] + LetterCount['h'])\n\t\t\tways['fe'].append(ways['fe'][i - 1] + LetterCount['f'])\n\t\t\tways['cf'].append(ways['cf'][i - 1])\n\t\t\tways['hf'].append(ways['hf'][i - 1])\n\t\t\tways['ef'].append(ways['ef'][i - 1])\n\t\t\tways['ch'].append(ways['ch'][i - 1])\n\t\t\tways['fh'].append(ways['fh'][i - 1])\n\t\t\tways['eh'].append(ways['eh'][i - 1])\n\t\t\tways['fc'].append(ways['fc'][i - 1])\n\t\t\tways['hc'].append(ways['hc'][i - 1])\n\t\t\tways['ec'].append(ways['ec'][i - 1])\n\t\telse:\n\t\t\tways['fc'].append(ways['fc'][i - 1] + LetterCount['f'])\n\t\t\tways['hc'].append(ways['hc'][i - 1] + LetterCount['h'])\n\t\t\tways['ec'].append(ways['ec'][i - 1] + LetterCount['e'])\n\t\t\tways['cf'].append(ways['cf'][i - 1])\n\t\t\tways['hf'].append(ways['hf'][i - 1])\n\t\t\tways['ef'].append(ways['ef'][i - 1])\n\t\t\tways['ch'].append(ways['ch'][i - 1])\n\t\t\tways['fh'].append(ways['fh'][i - 1])\n\t\t\tways['eh'].append(ways['eh'][i - 1])\n\t\t\tways['ce'].append(ways['ce'][i - 1])\n\t\t\tways['he'].append(ways['he'][i - 1])\n\t\t\tways['fe'].append(ways['fe'][i - 1])\n\toutput = list()\n\tfor x in range(0, Q):\n\t\tquery = input()\n\t\ta = query.split()[0]\n\t\tb = query.split()[1]\n\t\tL = int(query.split()[2])\n\t\tR = int(query.split()[3])\n\t\tif L == R:\n\t\t\toutput.append(0)\n\t\telse:\n\t\t\tkey = str(a + b)\n\t\t\tif L != 1:\n\t\t\t\tcnta = LetterCountList[a][L - 1 - 1]\n\t\t\t\tcntb = LetterCountList[b][R - 1] - LetterCountList[b][L - 1]\n\t\t\t\toutput.append(ways[key][R - 1] - cnta * cntb - ways[key][L - 1])\n\t\t\telse:\n\t\t\t\toutput.append(ways[key][R - 1])\n\tfor x in output:\n\t\tprint(x)\nmain()\n"
    },
    {
        "task_id": 896,
        "slowest_solution_id": 0,
        "fastest_solution_id": 7,
        "slowest_time": 3.0280511379241943,
        "fastest_time": 2.741285562515259,
        "fastest_solution": "t = int(input())\nwhile t != 0:\n\tn = int(input())\n\ts1 = input()\n\ts2 = input()\n\tflag = 0\n\tfor i in range(n):\n\t\tif s1[i] == '1' and s2[i] == '1':\n\t\t\tflag = 1\n\tif flag == 1:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n\tt -= 1\n",
        "slowest_solution": "t = int(input())\nn = []\nstr1 = []\nstr2 = []\nfor i in range(t):\n\tn.append(int(input()))\n\tstr1.append(list(input()))\n\tstr2.append(list(input()))\nfor i in range(t):\n\tpossibility = 'NO'\n\tfor j in range(n[i] - 2):\n\t\tif str2[i][j + 1] == '1' and str1[i][j + 1] == '1':\n\t\t\tpossibility = 'NO'\n\t\t\tbreak\n\t\telse:\n\t\t\tpossibility = 'YES'\n\tprint(possibility)\n"
    },
    {
        "task_id": 891,
        "slowest_solution_id": 8,
        "fastest_solution_id": 7,
        "slowest_time": 2.9830915927886963,
        "fastest_time": 2.709907293319702,
        "fastest_solution": "from collections import defaultdict\nfrom sys import exit\n\nclass Graph:\n\n\tdef __init__(self, n):\n\t\tself.adj = defaultdict(list)\n\t\tself.V = n\n\t\tself.visited = list()\n\t\tself.va = [0]\n\n\tdef add_edge(self, x, y):\n\t\tself.adj[x].append(y)\n\t\tself.adj[y].append(x)\n\n\tdef dfs(self, i):\n\t\tif i in self.visited:\n\t\t\treturn 0\n\t\tif len(self.adj[i]) < 2:\n\t\t\tself.va[0] = 0\n\t\tcomp = 0\n\t\tself.visited.append(i)\n\t\tfor i in self.adj[i]:\n\t\t\tcomp += self.dfs(i)\n\t\treturn comp + 1\n\n\tdef dfs_main(self):\n\t\tans = 0\n\t\tfor i in range(1, self.V + 1):\n\t\t\tif i not in self.visited:\n\t\t\t\tself.va[0] = 1\n\t\t\t\tcomponents = self.dfs(i)\n\t\t\t\tif components != 1 and components % 2 == 1 and (self.va[0] == 1):\n\t\t\t\t\tans += 1\n\t\tif self.V % 2 != ans % 2:\n\t\t\tans += 1\n\t\tprint(ans)\n(n, m) = map(int, input().split())\ng = Graph(n)\nfor i in range(m):\n\t(x, y) = map(int, input().split())\n\tg.add_edge(x, y)\ng.dfs_main()\n",
        "slowest_solution": "import sys\n\ndef explore(i, p):\n\tglobal seen\n\tglobal sum\n\tseen[i] = 1\n\tfor k in adj[i]:\n\t\tif not seen[k]:\n\t\t\texplore(k, i)\n\t\t\tif sum != 0:\n\t\t\t\tsum = sum + 1\n\t\telif p != k:\n\t\t\tsum = sum + 1\ninput = sys.stdin.read()\ndata = list(map(int, input.split()))\n(n, m) = data[:2]\ndata = data[2:]\nedges = list(zip(data[0:2 * m:2], data[1:2 * m:2]))\nadj = [[] for _ in range(n)]\nfor (a, b) in edges:\n\tadj[a - 1].append(b - 1)\n\tadj[b - 1].append(a - 1)\nseen = []\nbench = 0\nfor i in range(n):\n\tseen.append(0)\ncc = 0\ncarr = []\nfor i in range(n):\n\tsum = 0\n\tif not seen[i]:\n\t\texplore(i, -1)\n\t\tcc = cc + 1\n\t\tif sum != 0:\n\t\t\tcarr.append(sum - 1)\n\t\telse:\n\t\t\tcarr.append(sum)\nfor elt in carr:\n\tif elt % 2 != 0:\n\t\tbench += 1\nif (n - bench) % 2 != 0:\n\tbench += 1\nprint(bench)\n"
    },
    {
        "task_id": 925,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 4.037091016769409,
        "fastest_time": 4.022555828094482,
        "fastest_solution": "import sys\nimport numpy as np\n\ndef memo(f):\n\tD = dict()\n\n\tdef g(*a):\n\t\ttry:\n\t\t\treturn D[a]\n\t\texcept:\n\t\t\tx = f(*a)\n\t\t\tD[a] = x\n\t\t\treturn x\n\treturn g\nNMAX = 100\nMMAX = 10 ** 5\nmod = 10 ** 9 + 7\n\ndef gcd2(a, b):\n\tif a == 0:\n\t\treturn (b, 0, 1)\n\telse:\n\t\t(g, y, x) = gcd2(b % a, a)\n\t\treturn (g, x - b // a * y, y)\n\ndef inv(a):\n\treturn gcd2(a, mod)[1] % mod\nprimeB = np.ones(NMAX + 1, dtype=bool)\nprimeB[0] = primeB[1] = False\nfor q in range(2, NMAX + 1):\n\tif primeB[q]:\n\t\tprimeB[q * 2::q] = False\nP = np.where(primeB)[0]\nsfree = np.ones(NMAX + 1, dtype=np.int64)\nsfree[0] = 0\nfor p in P:\n\tsfree[p::p] *= p\nsbits = np.zeros(NMAX + 1, dtype=np.int64)\nfor (i, p) in enumerate(P):\n\tsbits[p::p] |= 1 << i\nF = np.ones(MMAX + 1, dtype=np.int64)\nG = np.ones(MMAX + 1, dtype=np.int64)\nfor x in range(1, MMAX + 1):\n\tF[x] = F[x - 1] * x % mod\n\tG[x] = G[x - 1] * inv(x) % mod\n\ndef choose(n, k):\n\treturn F[n] * G[n - k] % mod * G[k] % mod\n\ndef solve(n, m):\n\tQ = P[P <= m]\n\tQ0 = Q[Q * 2 > m]\n\tQ = Q[Q * 2 <= m]\n\tlq = len(Q)\n\tD = np.zeros((2 ** lq, lq + 1), dtype=np.int64, order='F')\n\talq = np.arange(2 ** lq)\n\tD[0, 0] = 1\n\tfor i in range(2, m + 1):\n\t\tif i * 2 > m and primeB[i]:\n\t\t\tcontinue\n\t\tsi = sbits[i]\n\t\tfor x in range(min(lq - 1, i), -1, -1):\n\t\t\tg0 = np.where(alq & si == 0)[0]\n\t\t\tg0 = g0[D[g0, x] > 0]\n\t\t\tD[g0 + si, x + 1] += D[g0, x]\n\t\t\tD[g0 + si, x + 1] %= mod\n\tret = 0\n\tnbig = len(Q0)\n\tfor i in range(0, lq + 1):\n\t\tif i <= n:\n\t\t\tss = np.sum(D[:, i]) % mod\n\t\t\tfor j in range(nbig + 1):\n\t\t\t\tij = i + j\n\t\t\t\tif ij <= n:\n\t\t\t\t\ts = ss * choose(nbig, j) % mod\n\t\t\t\t\tmult = choose(n, ij) * F[ij] % mod\n\t\t\t\t\tret += mult * s\n\t\t\t\t\tret %= mod\n\treturn ret\nf = sys.stdin\nq = int(f.readline())\nfor i in range(q):\n\tprint(solve(*map(int, f.readline().split())))\n",
        "slowest_solution": "factors = [set(), set(), {2}, {3}, {2}, {5}, {2, 3}, {7}, {2}, {3}, {2, 5}, {11}, {2, 3}, {13}, {2, 7}, {3, 5}, {2}, {17}, {2, 3}, {19}, {2, 5}, {3, 7}, {2, 11}, {23}, {2, 3}, {5}, {2, 13}, {3}, {2, 7}, {29}, {2, 3, 5}, {31}, {2}, {11, 3}, {17, 2}, {5, 7}, {2, 3}, {37}, {2, 19}, {3, 13}, {2, 5}, {41}, {2, 3, 7}, {43}, {2, 11}, {3, 5}, {2, 23}, {47}, {2, 3}, {7}, {2, 5}, {17, 3}, {2, 13}, {53}, {2, 3}, {11, 5}, {2, 7}, {19, 3}, {2, 29}, {59}, {2, 3, 5}, {61}, {2, 31}, {3, 7}, {2}, {13, 5}, {11, 2, 3}, {67}, {17, 2}, {3, 23}, {2, 5, 7}, {71}, {2, 3}, {73}, {2, 37}, {3, 5}, {2, 19}, {11, 7}, {2, 3, 13}, {79}, {2, 5}, {3}, {41, 2}, {83}, {2, 3, 7}, {17, 5}, {2, 43}, {3, 29}, {2, 11}, {89}, {2, 3, 5}, {13, 7}, {2, 23}, {3, 31}, {2, 47}, {19, 5}, {2, 3}, {97}, {2, 7}, {11, 3}, {2, 5}]\nmod = 10 ** 9 + 7\nmemo = {}\n\ndef half(m, banned=set()):\n\tbanned = {x for x in banned if x <= m}\n\tif m == 1:\n\t\treturn [1]\n\tkey = (m, tuple(sorted(banned)))\n\tif key not in memo:\n\t\tsize = [0] * (m + 1)\n\t\tfor (i, j) in enumerate(half(m - 1, banned)):\n\t\t\tsize[i] += j\n\t\tf = factors[m]\n\t\tif max(f) <= 50 and (not f & banned):\n\t\t\tfor (i, j) in enumerate(half(m - 1, banned | f)):\n\t\t\t\tsize[i + 1] += j\n\t\tmemo[key] = size\n\treturn memo[key]\nq = [1]\nfor i in range(1, 100001):\n\tq.append(q[-1] * i % mod)\ninv = [pow(i, mod - 2, mod) for i in q]\nA = lambda k, n: q[n] * inv[n - k] % mod\nC = lambda k, n: q[n] * inv[n - k] * inv[k] % mod\n\ndef bigger(m):\n\tbig = sum((i <= m for i in [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]))\n\tans = [0] * (m + 1)\n\tv = half(m)\n\tfor i in range(m + 1):\n\t\tfor j in range(big + 1):\n\t\t\tif i + j <= m:\n\t\t\t\tans[i + j] += v[i] * C(j, big)\n\t\t\t\tans[i + j] %= mod\n\treturn ans\n\ndef solve(n, m):\n\tans = bigger(m) if m > 50 else half(m)\n\tr = 0\n\tfor (i, j) in enumerate(ans):\n\t\tif i <= n and j:\n\t\t\tr += A(i, n) * j % mod\n\t\t\tr %= mod\n\treturn r\nfor _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tprint(solve(n, m))\n"
    },
    {
        "task_id": 953,
        "slowest_solution_id": 2,
        "fastest_solution_id": 0,
        "slowest_time": 0.0010006427764892578,
        "fastest_time": 0.0,
        "fastest_solution": "import heapq\nfrom collections import defaultdict\n\ndef shortest(N, edge):\n\t(ver, inf) = (defaultdict(list), 10 ** 10)\n\tfor e in edge:\n\t\tver[e[0]].append(e[1:])\n\tdist = {i: inf for i in range(N)}\n\t(dist[0], pq) = (0, [])\n\theapq.heappush(pq, [dist[0], 0])\n\twhile pq:\n\t\t(u_dis, u_node) = heapq.heappop(pq)\n\t\tif u_dis == dist[u_node]:\n\t\t\tfor v in ver[u_node]:\n\t\t\t\tv_node = v[0]\n\t\t\t\tv_wei = v[1]\n\t\t\t\tif dist[u_node] + v_wei < dist[v_node]:\n\t\t\t\t\tdist[v_node] = dist[u_node] + v_wei\n\t\t\t\t\theapq.heappush(pq, [dist[v_node], v_node])\n\treturn -1 if dist[N - 1] == inf else dist[N - 1]\n",
        "slowest_solution": "def shortest(N, edgeList):\n\tedgeList.sort(key=lambda x: x[0])\n\tpath_values = [None for _ in range(N)]\n\tpath_values[0] = 0\n\tfor edge in edgeList:\n\t\tif path_values[edge[0]] != None:\n\t\t\tnew_val = edge[2] + path_values[edge[0]]\n\t\t\tif path_values[edge[1]] == None:\n\t\t\t\tpath_values[edge[1]] = new_val\n\t\t\telse:\n\t\t\t\tpath_values[edge[1]] = min(path_values[edge[1]], new_val)\n\tif path_values[-1] == None:\n\t\treturn -1\n\telse:\n\t\treturn path_values[-1]\n"
    },
    {
        "task_id": 906,
        "slowest_solution_id": 3,
        "fastest_solution_id": 9,
        "slowest_time": 3.023956775665283,
        "fastest_time": 2.7407138347625732,
        "fastest_solution": "import sys\nimport queue\nsys.setrecursionlimit(100000)\nINF = int(10000000.0 + 1)\nMAX = 100005\nparents = []\nranks = []\nsize = []\nn = 0\n\nclass Pair:\n\n\tdef __init__(self, a, b):\n\t\tself.first = a\n\t\tself.second = b\n\ndef init():\n\tglobal parents, ranks, size\n\tparents = [i for i in range(n + 2)]\n\tranks = [0 for i in range(n + 2)]\n\tsize = [1 for i in range(n + 2)]\n\ndef findSet(u):\n\tif parents[u] != u:\n\t\tparents[u] = findSet(parents[u])\n\treturn parents[u]\n\ndef unionSet(u, v):\n\tup = findSet(u)\n\tvp = findSet(v)\n\tif up == vp:\n\t\treturn\n\tif ranks[up] < ranks[vp]:\n\t\tparents[up] = vp\n\telif ranks[vp] < ranks[up]:\n\t\tparents[vp] = up\n\telse:\n\t\tranks[vp] += 1\n\t\tparents[up] = vp\n\ndef main():\n\tglobal n\n\t(n, a, b) = map(int, input().split())\n\tinit()\n\tM = {}\n\tl = list(map(int, input().split()))\n\tMax = -1\n\tl.insert(0, -1)\n\tl.append(-1)\n\tfor i in range(1, n + 1):\n\t\tM[l[i]] = i\n\t\tparents[i] = i\n\t\tMax = max(Max, l[i])\n\tif Max >= a and Max >= b:\n\t\tprint('NO')\n\t\treturn\n\tfor i in range(1, n + 1):\n\t\tif a - l[i] in M:\n\t\t\tunionSet(M[a - l[i]], i)\n\t\telse:\n\t\t\tunionSet(i, n + 1)\n\t\tif b - l[i] in M:\n\t\t\tunionSet(M[b - l[i]], i)\n\t\telse:\n\t\t\tunionSet(i, 0)\n\tA = findSet(0)\n\tB = findSet(n + 1)\n\tif A == B:\n\t\tprint('NO')\n\t\treturn\n\tprint('YES')\n\tfor i in range(1, n + 1):\n\t\tif findSet(i) == A:\n\t\t\tprint('%d' % 0, end=' ')\n\t\telse:\n\t\t\tprint('%d' % 1, end=' ')\nmain()\n",
        "slowest_solution": "class DisjointSet:\n\n\tdef __init__(self, n):\n\t\tself._fa = list(range(n))\n\n\tdef union(self, x, y):\n\t\tx = self.get_father(x)\n\t\ty = self.get_father(y)\n\t\tself._fa[x] = y\n\t\treturn y\n\n\tdef get_father(self, x):\n\t\ty = self._fa[x]\n\t\tif self._fa[y] == y:\n\t\t\treturn y\n\t\telse:\n\t\t\tz = self._fa[y] = self.get_father(y)\n\t\t\treturn z\n\n\tdef __repr__(self):\n\t\treturn repr([self.get_father(i) for i in range(len(self._fa))])\n\ndef solve(n, a, b, xs):\n\th = {x: i for (i, x) in enumerate(xs)}\n\tif a == b:\n\t\tif all((a - x in h for x in xs)):\n\t\t\treturn [0] * n\n\t\treturn False\n\tg1 = n\n\tg2 = n + 1\n\tds = DisjointSet(n + 2)\n\tfor (i, x) in enumerate(xs):\n\t\tfor t in (a, b):\n\t\t\tif t - x in h:\n\t\t\t\tds.union(i, h[t - x])\n\tfor (i, x) in enumerate(xs):\n\t\tb1 = a - x in h\n\t\tb2 = b - x in h\n\t\tif b1 + b2 == 0:\n\t\t\treturn False\n\t\tif b1 + b2 == 1:\n\t\t\tif b1:\n\t\t\t\tds.union(i, g1)\n\t\t\telse:\n\t\t\t\tds.union(i, g2)\n\t\t\tif ds.get_father(g1) == ds.get_father(g2):\n\t\t\t\treturn False\n\tgroup = [None] * n\n\tfor (i, x) in enumerate(xs):\n\t\tf = ds.get_father(i)\n\t\tif f < n:\n\t\t\treturn False\n\t\tgroup[i] = f - n\n\treturn group\n(n, a, b) = list(map(int, input().split()))\nxs = list(map(int, input().split()))\ngroup = solve(n, a, b, xs)\nif isinstance(group, list):\n\tprint('YES')\n\tprint(' '.join(map(str, group)))\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 902,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 2.9713165760040283,
        "fastest_time": 2.755060911178589,
        "fastest_solution": "s = input()\nn = len(s)\narr = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\nfor i in range(4):\n\tj = i\n\tcount = 0\n\twhile j < n:\n\t\tif s[j] == '!':\n\t\t\tcount += 1\n\t\telse:\n\t\t\tchr = s[j]\n\t\tj += 4\n\tarr[chr] = count\nfor j in list(arr.values()):\n\tprint(j, end=' ')\n",
        "slowest_solution": "s = input()\nk = {'R': 0, 'Y': 0, 'B': 0, 'G': 0}\na = [''] * 4\nfor i in range(len(s)):\n\tif s[i] != '!' and a[i % 4] == '':\n\t\ta[i % 4] = s[i]\nfor i in range(len(s)):\n\tif s[i] == '!':\n\t\tk[a[i % 4]] += 1\nprint(k['R'], k['B'], k['Y'], k['G'])\n"
    },
    {
        "task_id": 901,
        "slowest_solution_id": 3,
        "fastest_solution_id": 5,
        "slowest_time": 3.051578998565674,
        "fastest_time": 2.751307725906372,
        "fastest_solution": "t = int(input())\nwhile t:\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tq = int(input())\n\tres = list()\n\tfor i in range(n):\n\t\tif a[i] % 2 == 0:\n\t\t\tres.append(i)\n\tfor i in range(q):\n\t\tflag = 1\n\t\t(l, r) = list(map(int, input().split()))\n\t\tl = l - 1\n\t\tr = r - 1\n\t\tfor j in res:\n\t\t\tif j >= l and j <= r:\n\t\t\t\tflag = 0\n\t\tif flag != 0:\n\t\t\tprint('ODD')\n\t\telse:\n\t\t\tprint('EVEN')\n\tt -= 1\n",
        "slowest_solution": "T = int(input())\nfor i in range(T):\n\tN = int(input())\n\tarr = list(map(int, input().split()))\n\tQ = int(input())\n\tlis = []\n\tfor (x, y) in enumerate(arr):\n\t\tif y % 2 == 0:\n\t\t\tlis.append(x + 1)\n\tfor j in range(Q):\n\t\t(L, R) = map(int, input().split())\n\t\tdone = False\n\t\tfor k in lis:\n\t\t\tif k >= L and k <= R:\n\t\t\t\tprint('EVEN')\n\t\t\t\tdone = True\n\t\t\t\tbreak\n\t\tif not done:\n\t\t\tprint('ODD')\n"
    },
    {
        "task_id": 903,
        "slowest_solution_id": 6,
        "fastest_solution_id": 7,
        "slowest_time": 3.0947024822235107,
        "fastest_time": 2.7189836502075195,
        "fastest_solution": "(n, p) = map(int, input().split())\nfor m in range(1, 10000):\n\tx = n - m * p\n\tb = bin(x)\n\tif b.count('1') <= m <= x:\n\t\tprint(m)\n\t\texit()\nprint(-1)\n",
        "slowest_solution": "(n, p) = map(int, input().split())\nif n <= p:\n\tprint(-1)\n\texit()\nfor ans in range(1, 10 ** 6):\n\tx = n - p * ans\n\tif x >= ans and bin(x).count('1') <= ans:\n\t\tprint(ans)\n\t\tbreak\nelse:\n\tprint(-1)\n"
    },
    {
        "task_id": 908,
        "slowest_solution_id": 3,
        "fastest_solution_id": 7,
        "slowest_time": 3.020315408706665,
        "fastest_time": 2.747013807296753,
        "fastest_solution": "from collections import defaultdict\ng = defaultdict(set)\n(n, m) = map(int, input().split())\nfor j in range(m):\n\t(u, v) = map(int, input().split())\n\tg[u].add(v)\n\tg[v].add(u)\nvisited = [0] * (n + 1)\nf = 0\nfor j in range(1, n + 1):\n\tif visited[j] != 1:\n\t\tg[j].add(j)\n\t\tvisited[j] = 1\n\t\tfor v in g[j]:\n\t\t\tif visited[v] == 0:\n\t\t\t\tvisited[v] = 1\n\t\t\t\tg[v].add(v)\n\t\t\t\tif g[v] != g[j]:\n\t\t\t\t\tf = 1\n\t\t\t\t\tbreak\nif f == 0:\n\tprint('YES')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "(n, m) = map(int, input().split())\nmarked = [0] * n\nadjlist = [set([i]) for i in range(n)]\nfor i in range(m):\n\t(v1, v2) = map(int, input().split())\n\tv1 -= 1\n\tv2 -= 1\n\tadjlist[v1].add(v2)\n\tadjlist[v2].add(v1)\nfor i in range(n):\n\tif not marked[i]:\n\t\tfor j in adjlist[i]:\n\t\t\tmarked[j] = 1\n\t\t\tif adjlist[i] != adjlist[j]:\n\t\t\t\tprint('NO')\n\t\t\t\texit(0)\nprint('YES')\n"
    },
    {
        "task_id": 907,
        "slowest_solution_id": 5,
        "fastest_solution_id": 9,
        "slowest_time": 3.050265312194824,
        "fastest_time": 2.7797181606292725,
        "fastest_solution": "(n, t) = list(map(int, input().split()))\nans = 2\ncont = list()\nfor i in range(n):\n\ttemp = [int(item) for item in input().split()]\n\t(center, length) = temp\n\tcont.append([center - length / 2, center + length / 2])\ncont = sorted(cont, key=lambda item: item[0])\nfor i in range(n - 1):\n\tgap = cont[i + 1][0] - cont[i][1]\n\tif gap > t:\n\t\tans += 2\n\telif gap == t:\n\t\tans += 1\nprint(ans)\n",
        "slowest_solution": "import math\nimport queue\nfrom itertools import permutations\n(n, t) = map(int, input().split())\nb = []\nfor i in range(0, n):\n\t(x, a) = map(int, input().split())\n\tb.append(x * 1000 + a - 1)\nb.sort()\nanswer = 2\nfor i in range(0, n - 1):\n\ta1 = b[i] % 1000 + 1\n\ta2 = b[i + 1] % 1000 + 1\n\tx1 = b[i] // 1000\n\tx2 = b[i + 1] // 1000\n\tdist = 2 * x2 - a2 - (2 * x1 + a1)\n\tif dist == 2 * t:\n\t\tanswer += 1\n\telif dist > 2 * t:\n\t\tanswer += 2\nprint(answer)\n"
    },
    {
        "task_id": 910,
        "slowest_solution_id": 7,
        "fastest_solution_id": 5,
        "slowest_time": 3.0087289810180664,
        "fastest_time": 2.7743546962738037,
        "fastest_solution": "import sys\nimport heapq\n\ndef solve(pr, mm):\n\tomm = []\n\tn = len(mm)\n\tfor i in range(n + 1):\n\t\tomm.append([])\n\tfor i in range(n):\n\t\tomm[mm[i]].append(pr[i])\n\theap = []\n\tc = 0\n\tt = n\n\tp = 0\n\tfor i in range(n, -1, -1):\n\t\tfor h in omm[i]:\n\t\t\theapq.heappush(heap, h)\n\t\tt -= len(omm[i])\n\t\tmn = max(i - c - t, 0)\n\t\tc += mn\n\t\tfor j in range(mn):\n\t\t\tp += heapq.heappop(heap)\n\treturn p\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nt = int(input().strip())\nfor i in range(t):\n\tn = int(input().strip())\n\tms = []\n\tps = []\n\tfor j in range(n):\n\t\tarr = [int(v) for v in input().strip().split(' ')]\n\t\tms.append(arr[0])\n\t\tps.append(arr[1])\n\tprint(solve(ps, ms))\n",
        "slowest_solution": "import sys\nimport heapq as hp\nt = int(sys.stdin.readline())\nfor ti in range(t):\n\tn = int(sys.stdin.readline())\n\ta = [tuple(map(int, sys.stdin.readline().split())) for i in range(n)]\n\ta.sort(key=lambda x: (x[0], -x[1]))\n\tc = 0\n\th = []\n\tres = 0\n\tfor i in range(n - 1, -1, -1):\n\t\thp.heappush(h, a[i][1])\n\t\twhile c + i < a[i][0]:\n\t\t\tres += hp.heappop(h)\n\t\t\tc += 1\n\tprint(res)\n"
    },
    {
        "task_id": 944,
        "slowest_solution_id": 1,
        "fastest_solution_id": 3,
        "slowest_time": 3.120605707168579,
        "fastest_time": 2.929898738861084,
        "fastest_solution": "import sys\nimport threading\nfrom bisect import *\n\ndef ri():\n\treturn map(int, input().split())\n\ndef dfs(v, d, c, w):\n\td += 1\n\tdist[d] = w[v] + dist[d - 1]\n\tadd[d] = 0\n\tfor i in c[v]:\n\t\tdfs(i, d, c, w)\n\tx = bisect_left(dist, dist[d] - a[v], 0, d)\n\tadd[x - 1] -= 1\n\tadd[d - 1] += 1 + add[d]\n\tans[v] = str(add[d])\n\td -= 1\nn = int(input())\ndist = [0] * (2 * 10 ** 5 + 3)\nadd = [0] * (2 * 10 ** 5 + 3)\nans = [''] * (n + 1)\na = [0] * (n + 1)\n\ndef solve():\n\tc = [[] for i in range(n + 1)]\n\tw = [0] * (n + 1)\n\tfor (i, j) in enumerate(ri()):\n\t\ta[i + 1] = j\n\tfor i in range(2, n + 1):\n\t\t(t1, t2) = ri()\n\t\tc[t1].append(i)\n\t\tw[i] = t2\n\tdfs(1, 0, c, w)\n\tprint(' '.join(ans))\nsys.setrecursionlimit(10 ** 5 * 3 + 100)\nthreading.stack_size(10 ** 8 + 10 ** 7)\nthread = threading.Thread(target=solve)\nthread.start()\n",
        "slowest_solution": "import sys\nimport threading\nfrom bisect import *\n\ndef dfs(v):\n\tglobal d\n\td += 1\n\tdist[d] = w[v] + dist[d - 1]\n\tadd[d] = 0\n\tfor i in c[v]:\n\t\tdfs(i)\n\tx = bisect_left(dist, dist[d] - a[v], 0, d)\n\tadd[x - 1] -= 1\n\tadd[d - 1] += 1\n\tadd[d - 1] += add[d]\n\tans[v] = add[d]\n\td -= 1\nd = 0\ndist = [0 for i in range(2 * 10 ** 5 + 3)]\nadd = [0 for i in range(2 * 10 ** 5 + 3)]\nn = int(input())\na = [0 for i in range(n + 1)]\nc = [[] for i in range(n + 1)]\nw = [0 for i in range(n + 1)]\nans = [0 for i in range(n + 1)]\nfor (i, j) in enumerate(map(int, input().split())):\n\ta[i + 1] = j\nfor i in range(2, n + 1):\n\t(t1, t2) = map(int, input().split())\n\tc[t1].append(i)\n\tw[i] = t2\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 7 * 8)\nthread = threading.Thread(target=dfs, args=(1,))\nthread.start()\nif thread.is_alive():\n\tthread.join()\nprint(' '.join((str(ans[i]) for i in range(1, n + 1))))\n"
    },
    {
        "task_id": 911,
        "slowest_solution_id": 4,
        "fastest_solution_id": 9,
        "slowest_time": 3.390251636505127,
        "fastest_time": 2.7350850105285645,
        "fastest_solution": "from collections import defaultdict\n(n, m) = list(map(int, input().split()))\ns = defaultdict(set)\nvisited = [False] * (n + 1)\nfor i in range(m):\n\t(u, v) = list(map(int, input().split()))\n\ts[u].add(v)\n\ts[v].add(u)\n\ts[u].add(u)\n\ts[v].add(v)\nfor i in range(1, n + 1):\n\tif not visited[i]:\n\t\tfor j in s[i]:\n\t\t\tvisited[j] = True\n\t\t\tif s[i] != s[j]:\n\t\t\t\tprint('NO')\n\t\t\t\texit()\nprint('YES')\n",
        "slowest_solution": "(n, m) = map(int, input().split())\nv = [0] * 150005\ns = [set([i]) for i in range(150005)]\nfor _ in ' ' * m:\n\t(a, b) = map(int, input().split())\n\ts[a].add(b)\n\ts[b].add(a)\nfor i in range(n):\n\tif not v[i]:\n\t\tfor j in s[i]:\n\t\t\tv[j] = 1\n\t\t\tif s[j] != s[i]:\n\t\t\t\tprint('NO')\n\t\t\t\texit(0)\nprint('YES')\n"
    },
    {
        "task_id": 912,
        "slowest_solution_id": 7,
        "fastest_solution_id": 9,
        "slowest_time": 3.0731594562530518,
        "fastest_time": 2.7529091835021973,
        "fastest_solution": "input()\nt = input()\nkeys = t[0::2]\nrooms = t[1::2].lower()\nkeyDict = dict()\ncount = 0\nfor (k, r) in zip(keys, rooms):\n\tkeyDict[k] = keyDict.get(k, 0) + 1\n\tif r in keyDict and keyDict[r] >= 1:\n\t\tkeyDict[r] -= 1\n\telse:\n\t\tcount += 1\nprint(count)\n",
        "slowest_solution": "import sys\nimport os\nimport math\nimport copy\nfrom math import gcd\nfrom bisect import bisect\nfrom io import BytesIO, IOBase\nfrom math import sqrt, floor, factorial, gcd, log, ceil\nfrom collections import deque, Counter, defaultdict\nfrom itertools import permutations, combinations\nimport itertools\n\ndef Int():\n\treturn int(sys.stdin.readline())\n\ndef Mint():\n\treturn map(int, sys.stdin.readline().split())\n\ndef Lstr():\n\treturn list(sys.stdin.readline().strip())\n\ndef Str():\n\treturn sys.stdin.readline().strip()\n\ndef Mstr():\n\treturn map(str, sys.stdin.readline().strip().split())\n\ndef List():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef Hash():\n\treturn dict()\n\ndef Mod():\n\treturn 1000000007\n\ndef Ncr(n, r, p):\n\treturn fact[n] * (ifact[r] * ifact[n - r] % p) % p\n\ndef Most_frequent(list):\n\treturn max(set(list), key=list.count)\n\ndef Mat2x2(n):\n\treturn [List() for _ in range(n)]\n\ndef Lcm(x, y):\n\treturn x * y // gcd(x, y)\n\ndef dtob(n):\n\treturn bin(n).replace('0b', '')\n\ndef btod(n):\n\treturn int(n, 2)\n\ndef solution():\n\tn = Int()\n\ta = Str()\n\tm = len(a)\n\tk = Hash()\n\ti = 0\n\tcount = 0\n\twhile i < m:\n\t\tx = a[i].lower()\n\t\tif i % 2 == 0:\n\t\t\tif x in k:\n\t\t\t\tk[x] += 1\n\t\t\telse:\n\t\t\t\tk[x] = 1\n\t\telif x in k:\n\t\t\tif k[x] > 0:\n\t\t\t\tk[x] = k[x] - 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\t\telse:\n\t\t\tcount += 1\n\t\ti += 1\n\tprint(count)\nsolution()\n"
    },
    {
        "task_id": 955,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.986088991165161,
        "fastest_time": 2.872011661529541,
        "fastest_solution": "import sys\n\ndef read():\n\treturn int(input())\n\ndef reads():\n\treturn [int(x) for x in input().split()]\n(N, M) = reads()\ntable = [reads() for i in range(N)]\nA = [[0] * N for i in range(N)]\nB = [[0] * N for i in range(N)]\nfor i in range(N):\n\tfor j in range(N):\n\t\tres = 10 ** 9 + 7\n\t\tfor k in range(M):\n\t\t\tres = min(res, abs(table[i][k] - table[j][k]))\n\t\tA[i][j] = res\n\t\tA[j][i] = res\n\t\tres = 10 ** 9 + 7\n\t\tfor k in range(M - 1):\n\t\t\tres = min(res, abs(table[i][k] - table[j][k + 1]))\n\t\tB[i][j] = res\ndp = [[-1] * N for i in range(1 << N)]\n\ndef calc(mask, v):\n\tif dp[mask][v] != -1:\n\t\treturn dp[mask][v]\n\tres = 0\n\tfor u in range(N):\n\t\tif mask & 1 << u and u != v:\n\t\t\tres = max(res, min(calc(mask ^ 1 << v, u), A[u][v]))\n\tdp[mask][v] = res\n\treturn dp[mask][v]\nans = 0\nfor i in range(N):\n\tdp = [[-1] * N for i in range(1 << N)]\n\tfor k in range(N):\n\t\tif k == i:\n\t\t\tdp[1 << k][k] = 10 ** 9 + 7\n\t\telse:\n\t\t\tdp[1 << k][k] = 0\n\tfor j in range(N):\n\t\tans = max(ans, min(B[j][i], calc((1 << N) - 1, j)))\nprint(ans)\n",
        "slowest_solution": "import sys\nfrom array import array\nfrom typing import List, Tuple, TypeVar, Generic, Sequence, Union\n\ndef input():\n\treturn sys.stdin.buffer.readline().decode('utf-8')\n\ndef solve(i, n, delta, delta2):\n\tinf = 2 * 10 ** 9\n\tdp = [[-1] * n for _ in range(1 << n)]\n\tdp[1 << i][i] = inf\n\tstack = [(1 << i, i)]\n\tfor t in range(1, n + 1):\n\t\tnext_s = []\n\t\tfor (bit, v) in stack:\n\t\t\tfor dest in range(n):\n\t\t\t\tif 1 << dest & bit:\n\t\t\t\t\tcontinue\n\t\t\t\tif dp[bit | 1 << dest][dest] == -1:\n\t\t\t\t\tnext_s.append((bit | 1 << dest, dest))\n\t\t\t\tdp[bit | 1 << dest][dest] = max(dp[bit | 1 << dest][dest], min(dp[bit][v], delta[v][dest]))\n\t\tstack = next_s\n\treturn max((min(delta2[j][i], dp[-1][j]) for j in range(n) if i != j))\n\ndef main():\n\t(n, m) = map(int, input().split())\n\tmatrix = [tuple(map(int, input().split())) for _ in range(n)]\n\tif n == 1:\n\t\tprint(min((abs(x - y) for (x, y) in zip(matrix[0], matrix[0][1:]))))\n\t\texit()\n\tdelta = [[0] * n for _ in range(n)]\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\tdelta[i][j] = delta[j][i] = min((abs(x - y) for (x, y) in zip(matrix[i], matrix[j])))\n\tdelta2 = [[0] * n for _ in range(n)]\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tdelta2[i][j] = min((abs(x - y) for (x, y) in zip(matrix[i], matrix[j][1:])), default=2 * 10 ** 9)\n\tprint(max((solve(i, n, delta, delta2) for i in range(n))))\nmain()\n"
    },
    {
        "task_id": 915,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 3.0107545852661133,
        "fastest_time": 2.70998215675354,
        "fastest_solution": "import sys\nimport collections\nfrom math import ceil, gcd, sqrt, log\nimport bisect\nINF = float('inf')\nmod = 1000000007\n\ndef solve():\n\tn = int(input())\n\tA = list(map(int, input().split()))\n\tif n == 1:\n\t\tprint(1)\n\t\treturn\n\tnet = collections.Counter(A)\n\t(one, two) = (0, 0)\n\tfor i in net.values():\n\t\tif i > 1:\n\t\t\ttwo += 1\n\t\telse:\n\t\t\tone += 1\n\tans = two + ceil(one / 2)\n\tprint(ans)\nt = int(input())\nwhile t != 0:\n\tsolve()\n\tt -= 1\n",
        "slowest_solution": "from collections import *\nfor s in [*open(0)][2::2]:\n\tc = Counter(s.split())\n\tprint(sum((min(2, c[x]) for x in c)) + 1 >> 1)\n"
    },
    {
        "task_id": 934,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.9859778881073,
        "fastest_time": 2.742985486984253,
        "fastest_solution": "s = input()\nn = int(input())\ntests = []\nfor _ in range(n):\n\t(a, b) = map(int, input().split())\n\ta -= 1\n\tb -= 1\n\ttests.append((a, b))\ncount_left = {}\ncount_left[-1] = (0, 0, 0)\n(x, y, z) = (0, 0, 0)\nfor (i, c) in enumerate(s):\n\tif c == 'x':\n\t\tx += 1\n\telif c == 'y':\n\t\ty += 1\n\telif c == 'z':\n\t\tz += 1\n\tcount_left[i] = (x, y, z)\n\ndef count(a, b):\n\t(x2, y2, z2) = count_left[b]\n\t(x1, y1, z1) = count_left[a - 1]\n\tx = x2 - x1\n\ty = y2 - y1\n\tz = z2 - z1\n\treturn (x, y, z)\n\ndef is_valid(s, a, b):\n\tif b - a < 2:\n\t\treturn True\n\t(x, y, z) = count(a, b)\n\tdiffs = map(abs, [x - y, x - z, y - z])\n\treturn not any((d > 1 for d in diffs))\nresult = []\nfor (a, b) in tests:\n\tresult.append('YES' if is_valid(s, a, b) else 'NO')\nprint('\\n'.join(result))\n",
        "slowest_solution": "def f(t):\n\treturn t[2] - t[0] > 1\nt = input()\n(n, m, p) = (len(t), int(input()), {'x': 0, 'y': 1, 'z': 2})\ns = [[0] * (n + 1) for i in range(3)]\nfor (i, c) in enumerate(t, 1):\n\ts[p[c]][i] = 1\nfor i in range(3):\n\tfor j in range(1, n):\n\t\ts[i][j + 1] += s[i][j]\n(a, b, c) = s\n(q, d) = ([map(int, input().split()) for i in range(m)], ['YES'] * m)\nfor (i, (l, r)) in enumerate(q):\n\tif r - l > 1 and f(sorted([a[r] - a[l - 1], b[r] - b[l - 1], c[r] - c[l - 1]])):\n\t\td[i] = 'NO'\nprint('\\n'.join(d))\n"
    },
    {
        "task_id": 930,
        "slowest_solution_id": 4,
        "fastest_solution_id": 3,
        "slowest_time": 4.658341646194458,
        "fastest_time": 2.9129090309143066,
        "fastest_solution": "import itertools\nfrom sys import stdin\n\ndef input():\n\treturn next(stdin)[:-1]\n\ndef readline():\n\treturn map(int, input().split())\nprimes = [2]\nprimes.extend((q for q in range(3, 10 ** 3, 2) if all((q % p for p in primes))))\n\ndef prime_divisors(n):\n\tfor p in primes:\n\t\tif p * p > n:\n\t\t\tbreak\n\t\tif n % p == 0:\n\t\t\tyield p\n\t\t\twhile n % p == 0:\n\t\t\t\tn //= p\n\tif n > 1:\n\t\tyield n\n\nclass DSU:\n\n\tdef __init__(self):\n\t\tself.p = dict()\n\n\tdef _get_root(self, a):\n\t\twhile a in self.p:\n\t\t\ta = self.p[a]\n\t\treturn a\n\n\tdef __setitem__(self, a, b):\n\t\tr = self._get_root(b)\n\t\twhile a != r:\n\t\t\t(self.p[a], a) = (r, self.p.get(a, a))\n\n\tdef __getitem__(self, a):\n\t\tself[a] = a\n\t\treturn self.p.get(a, a)\n\ndef main():\n\t(n, q) = readline()\n\ta = list(readline())\n\tqueries = (readline() for __ in range(q))\n\tmin_divisor = list()\n\tdsu = DSU()\n\tfor ai in a:\n\t\t(p, *rest) = prime_divisors(ai)\n\t\tmin_divisor.append(p)\n\t\tfor q in rest:\n\t\t\tdsu[q] = p\n\n\tdef sorted_tuple(t):\n\t\treturn tuple(sorted(t))\n\tone = set()\n\tfor (ai, p) in zip(a, min_divisor):\n\t\tnew_node = {dsu[p], *(dsu[q] for q in prime_divisors(ai + 1))}\n\t\tone.update(map(sorted_tuple, itertools.combinations(new_node, 2)))\n\tfor (s, t) in queries:\n\t\tp = dsu[min_divisor[s - 1]]\n\t\tq = dsu[min_divisor[t - 1]]\n\t\tif p == q:\n\t\t\tprint(0)\n\t\telif sorted_tuple((p, q)) in one:\n\t\t\tprint(1)\n\t\telse:\n\t\t\tprint(2)\nmain()\n",
        "slowest_solution": "from collections import defaultdict\nfrom sys import stdin, gettrace\nif gettrace():\n\n\tdef inputi():\n\t\treturn input()\nelse:\n\n\tdef input():\n\t\treturn next(stdin)[:-1]\n\n\tdef inputi():\n\t\treturn stdin.buffer.readline()\n\nclass DisjointUnionSet:\n\n\tdef __init__(self, size):\n\t\tself.parent = list(range(size))\n\t\tself.rank = [0] * size\n\n\tdef find_set(self, v):\n\t\tif v == self.parent[v]:\n\t\t\treturn v\n\t\tself.parent[v] = self.find_set(self.parent[v])\n\t\treturn self.parent[v]\n\n\tdef union_sets(self, a, b):\n\t\ta = self.find_set(a)\n\t\tb = self.find_set(b)\n\t\tif a != b:\n\t\t\tif self.rank[a] < self.rank[b]:\n\t\t\t\t(a, b) = (b, a)\n\t\t\tself.parent[b] = a\n\t\t\tif self.rank[a] == self.rank[b]:\n\t\t\t\tself.rank[a] += 1\n\ndef main():\n\t(n, q) = map(int, input().split())\n\taa = [int(a) for a in input().split()]\n\tmxaa = max(aa)\n\tpf = [set() for _ in range(mxaa + 2)]\n\tfor i in range(2, mxaa + 2):\n\t\tif not pf[i]:\n\t\t\tfor j in range(i, mxaa + 2, i):\n\t\t\t\tpf[j].add(i)\n\tdus = DisjointUnionSet(mxaa + 2)\n\tfor a in aa:\n\t\tfor p in pf[a]:\n\t\t\tdus.union_sets(a, p)\n\ta1p = defaultdict(set)\n\tfor a in aa:\n\t\ts1 = {dus.find_set(p) for p in pf[a + 1]}\n\t\ta1p[dus.find_set(a)] |= s1\n\t\tfor s in s1:\n\t\t\tfor t in s1:\n\t\t\t\tif s != t:\n\t\t\t\t\ta1p[s].add(t)\n\tfor _ in range(q):\n\t\t(s, t) = map(int, input().split())\n\t\tss = dus.find_set(aa[s - 1])\n\t\tts = dus.find_set(aa[t - 1])\n\t\tif ss == ts:\n\t\t\tprint(0)\n\t\telif ss in a1p[ts] or ts in a1p[ss]:\n\t\t\tprint(1)\n\t\telse:\n\t\t\tprint(2)\nmain()\n"
    },
    {
        "task_id": 917,
        "slowest_solution_id": 7,
        "fastest_solution_id": 1,
        "slowest_time": 2.946930170059204,
        "fastest_time": 2.7512950897216797,
        "fastest_solution": "def get(x, y):\n\tif x <= 0 or y <= 0:\n\t\treturn 0\n\treturn x * (x + 1) * y * (y + 1) // 4\nt = int(input())\nwhile t > 0:\n\tt -= 1\n\t(n, m, k) = map(int, input().split())\n\tans = 0\n\tL = list(map(int, input().split()))\n\tfor v in L:\n\t\tv -= 1\n\t\tx = v // m + 1\n\t\ty = v % m + 1\n\t\ttmp = get(x - 1, m) + get(n - x, m) + get(n, y - 1) + get(n, m - y)\n\t\ttmp -= get(x - 1, y - 1) + get(x - 1, m - y) + get(n - x, y - 1) + get(n - x, m - y)\n\t\tans += (get(n, m) - tmp) * 1.0 / get(n, m)\n\tprint('%.13f' % ans)\n",
        "slowest_solution": "t = int(input())\nwhile t > 0:\n\t(n, m, k) = map(int, input().split())\n\ttot = 0\n\tl = list(map(int, input().split()))\n\tfor i in range(0, k):\n\t\ta = l[i]\n\t\tx = (a - 1) // m + 1\n\t\ty = (a - 1) % m + 1\n\t\ttot = tot + x * y * (n - x + 1) * (m - y + 1)\n\tprint('{0:.10f}'.format(tot / (m * (m + 1) * n * (n + 1) // 4)))\n\tt = t - 1\n"
    },
    {
        "task_id": 921,
        "slowest_solution_id": 4,
        "fastest_solution_id": 2,
        "slowest_time": 3.009263277053833,
        "fastest_time": 2.697870969772339,
        "fastest_solution": "import sys\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n\treturn int(sys.stdin.buffer.readline())\n\ndef MI():\n\treturn map(int, sys.stdin.buffer.readline().split())\n\ndef LI():\n\treturn list(map(int, sys.stdin.buffer.readline().split()))\n\ndef LLI(rows_number):\n\treturn [LI() for _ in range(rows_number)]\n\ndef BI():\n\treturn sys.stdin.buffer.readline().rstrip()\n\ndef SI():\n\treturn sys.stdin.buffer.readline().rstrip().decode()\ninf = 10 ** 16\nmd = 10 ** 9 + 7\nfor _ in range(II()):\n\t(n, k) = MI()\n\ts = SI()\n\tc0 = [0]\n\tfor c in s:\n\t\tc0.append(c0[-1] + (c == '0'))\n\td = min(30, k)\n\tng = set()\n\tnow = int(s[n - d:], 2)\n\tnow ^= (1 << d) - 1\n\tif c0[n - d] - c0[n - k] == 0:\n\t\tng.add(now)\n\tfor i in range(n - d - 1, k - d - 1, -1):\n\t\tnow >>= 1\n\t\tif s[i] == '0':\n\t\t\tnow |= 1 << d - 1\n\t\tif c0[i] - c0[i + d - k]:\n\t\t\tcontinue\n\t\tng.add(now)\n\tfor a in range(1 << d):\n\t\tif a not in ng:\n\t\t\tprint('YES')\n\t\t\tprint(f'{a:b}'.zfill(k))\n\t\t\tbreak\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n(T,) = map(int, input().split())\nfor _ in range(T):\n\t(N, K) = map(int, input().split())\n\ts = input().strip()\n\thr = min(N - K + 2, 2 ** K)\n\tm = (1 << min(K, 20)) - 1\n\tx = 0\n\tover = 0\n\tfor i in range(K):\n\t\tx <<= 1\n\t\tx += 1 - int(s[i])\n\t\tif m + 1 & x:\n\t\t\tover += 1\n\t\tx &= m\n\tvs = set()\n\tif not over:\n\t\tvs.add(x)\n\tfor i in range(N - K):\n\t\tx <<= 1\n\t\tif m + 1 & x:\n\t\t\tover += 1\n\t\tx = x & m\n\t\tif 1 - int(s[i + K]):\n\t\t\tx += 1\n\t\tif 1 - int(s[i]):\n\t\t\tover -= 1\n\t\tif not over:\n\t\t\tvs.add(x)\n\tfor i in range(hr):\n\t\tif i not in vs:\n\t\t\tprint('YES')\n\t\t\tprint(bin(i)[2:].zfill(K))\n\t\t\tbreak\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 919,
        "slowest_solution_id": 5,
        "fastest_solution_id": 2,
        "slowest_time": 3.620711088180542,
        "fastest_time": 2.705929756164551,
        "fastest_solution": "import math, sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ncompute_lcm = lambda x, y: x * y // math.gcd(x, y)\nfor t_itr in range(int(input())):\n\tn = int(input())\n\tp = 1\n\tcurrent_min = 10 ** 20\n\tout = (n, n + 1)\n\twhile p * p <= n:\n\t\tif n % p == 0:\n\t\t\tflag1 = abs(compute_lcm(n, n + p) - math.gcd(n, n + p))\n\t\t\tflag2 = flag1 + 1\n\t\t\tif n + n // p != 2 * n:\n\t\t\t\tflag2 = abs(compute_lcm(n, n + n // p) - math.gcd(n, n + n // p))\n\t\t\tcpl = (n, n + p)\n\t\t\tif flag2 <= flag1:\n\t\t\t\tcpl = (n, n + n // p)\n\t\t\tflag = min(flag1, flag2)\n\t\t\tif flag <= current_min:\n\t\t\t\tout = cpl\n\t\t\t\tcurrent_min = min(current_min, flag)\n\t\tp += 1\n\tprint(out[1])\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\n\ndef GetPrimes(max_prime=10 ** 6):\n\tprimes = []\n\tis_prime = [True for n in range(max_prime + 1)]\n\tfor n in range(2, max_prime + 1):\n\t\tif is_prime[n]:\n\t\t\tprimes += [n]\n\t\t\tfor m in range(2 * n, max_prime + 1, n):\n\t\t\t\tis_prime[m] = False\n\treturn primes\n\ndef GetSmallestPrimeFactor(x):\n\tif x in primes_set:\n\t\treturn x\n\tfor prime in primes:\n\t\tif x % prime == 0:\n\t\t\treturn prime\n\treturn x\nprimes = GetPrimes()\nprimes_set = set(primes)\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n\tn = int(input())\n\tsmallest_prime_factor = GetSmallestPrimeFactor(n)\n\tbiggest_factor = n // smallest_prime_factor\n\tprint(n + biggest_factor)\n"
    },
    {
        "task_id": 927,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.9894471168518066,
        "fastest_time": 2.7304844856262207,
        "fastest_solution": "for i in range(int(input())):\n\t(n, y) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\torp = a[0]\n\tfound = 0\n\tfor i in range(n - 1):\n\t\torp = orp | a[i + 1]\n\treq = orp ^ y\n\tif req | orp == y:\n\t\tprint(req)\n\telse:\n\t\tprint(-1)\n",
        "slowest_solution": "def valadd(l, s):\n\ts = int(s)\n\tr = 0\n\tfor i in l:\n\t\tr = r | i\n\t\tif r > s:\n\t\t\treturn -1\n\tval = r ^ s\n\tif r | val == s:\n\t\treturn val\n\treturn -1\nans = []\nn = int(input())\nfor i in range(n):\n\ta = input()\n\ta = a.split(' ')\n\tres = input()\n\tres = list(map(int, res.split(' ')))\n\tans.append(valadd(res, a[1]))\nfor x in ans:\n\tprint(x)\n"
    },
    {
        "task_id": 954,
        "slowest_solution_id": 0,
        "fastest_solution_id": 4,
        "slowest_time": 2.9397494792938232,
        "fastest_time": 2.806942939758301,
        "fastest_solution": "def count(a):\n\tn = len(a)\n\tcnt = 0\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\tif a[i] > a[j]:\n\t\t\t\tcnt += 1\n\treturn cnt\nn = int(input())\np = list(map(int, input().split()))\nnum = count(p)\nprint(num * 2 - num % 2)\n",
        "slowest_solution": "n = int(input().strip())\np = [0] + list(map(int, input().split()))\nc = [0] * (n + 1)\n\ndef lowbit(x):\n\treturn x & -x\n\ndef add(x, v):\n\twhile x <= n:\n\t\tc[x] += v\n\t\tx += lowbit(x)\n\ndef get(x):\n\tans = 0\n\twhile x:\n\t\tans += c[x]\n\t\tx -= lowbit(x)\n\treturn ans\nans = 0\nfor i in range(n, 0, -1):\n\tans += get(p[i])\n\tadd(p[i], 1)\nif ans % 2:\n\tprint(2 * ans - 1)\nelse:\n\tprint(2 * ans)\n"
    },
    {
        "task_id": 937,
        "slowest_solution_id": 7,
        "fastest_solution_id": 6,
        "slowest_time": 3.2318122386932373,
        "fastest_time": 2.7821152210235596,
        "fastest_solution": "from collections import defaultdict\nimport sys, os, math\n(a00, a01, a10, a11) = map(int, input().split())\n(x, y) = (int((1 + math.sqrt(1 + 8 * a11)) // 2), int((1 + math.sqrt(1 + 8 * a00)) // 2))\nif a11 + a10 + a01 + a00 == 0:\n\tprint(1)\n\tsys.exit(0)\nelif a11 + a10 + a01 == 0 and y * (y - 1) // 2 == a00:\n\tprint('0' * y)\n\tsys.exit(0)\nelif a00 + a10 + a01 == 0 and x * (x - 1) // 2 == a11:\n\tprint('1' * x)\n\tsys.exit(0)\nif y * (y - 1) // 2 != a00 or x * (x - 1) // 2 != a11 or x * y != a10 + a01:\n\tprint('Impossible')\n\tsys.exit(0)\nl = x - math.ceil((x * y - a10) / y)\nr = (x * y - a10) // y\ndiff = a10 - l * y\nif diff == 0:\n\tprint('1' * l + '0' * y + '1' * r)\nelse:\n\tprint('1' * l + '0' * (y - diff) + '1' + '0' * diff + '1' * r)\n",
        "slowest_solution": "from math import *\nfrom sys import *\n\ndef calc(f):\n\treturn int((1 + sqrt(8 * f + 1)) // 2)\n(a, b, c, d) = (int(z) for z in input().split())\nif a == d == 0 and b == 1 and (c == 0):\n\tprint('01')\n\texit(0)\nif a == d == 0 and b == 0 and (c == 1):\n\tprint('10')\n\texit(0)\nif a == d == 0:\n\tif b + c != 0:\n\t\tprint('Impossible')\n\t\texit(0)\n\tprint(0)\n\texit(0)\nif a == 0:\n\tif sqrt(8 * d + 1) != int(sqrt(8 * d + 1)):\n\t\tprint('Impossible')\n\t\texit(0)\n\tif b == c == 0:\n\t\tans = '1' * calc(d)\n\t\tprint(ans)\n\telse:\n\t\tif b + c != calc(d):\n\t\t\tprint('Impossible')\n\t\t\texit(0)\n\t\tans = c * '1' + '0' + b * '1'\n\t\tprint(ans)\n\texit(0)\nif d == 0:\n\tif sqrt(8 * a + 1) != int(sqrt(8 * a + 1)):\n\t\tprint('Impossible')\n\t\texit(0)\n\tif b == c == 0:\n\t\tans = '0' * calc(a)\n\t\tprint(ans)\n\telse:\n\t\tif b + c != calc(a):\n\t\t\tprint('Impossible')\n\t\t\texit(0)\n\t\tans = b * '0' + '1' + c * '0'\n\t\tprint(ans)\n\texit(0)\nif sqrt(8 * d + 1) != int(sqrt(8 * d + 1)):\n\tprint('Impossible')\n\texit(0)\nif sqrt(8 * a + 1) != int(sqrt(8 * a + 1)):\n\tprint('Impossible')\n\texit(0)\nx = calc(a)\ny = calc(d)\nif x * y != b + c:\n\tprint('Impossible')\n\texit(0)\nans = ''\nres = 0\nwhile res + x <= c:\n\tans += '1'\n\ty -= 1\n\tres += x\nwhile res + x != c:\n\tans += '0'\n\tx -= 1\nif res != c:\n\tans += '1'\n\ty -= 1\nwhile x:\n\tx -= 1\n\tans += '0'\nwhile y:\n\ty -= 1\n\tans += '1'\nprint(ans)\n"
    },
    {
        "task_id": 939,
        "slowest_solution_id": 1,
        "fastest_solution_id": 4,
        "slowest_time": 3.0290472507476807,
        "fastest_time": 2.740415573120117,
        "fastest_solution": "n = int(input())\nd = {}\n\ndef count(x):\n\tif x == 0:\n\t\treturn 0\n\telif x in d:\n\t\treturn d[x]\n\tx_s = str(x)\n\tlow = int('1' * len(x_s)) if int('1' * len(x_s)) <= x else int('1' * (len(x_s) - 1))\n\thigh = int('1' * len(x_s)) if int('1' * len(x_s)) >= x else int('1' * (len(x_s) + 1))\n\t(l_val, h_val) = (-1, -1)\n\tif abs(x - low) < x:\n\t\tl_val = len(str(low)) + count(abs(x - low))\n\tif abs(x - high) < x:\n\t\th_val = len(str(high)) + count(abs(x - high))\n\tret = min(l_val, h_val) if min(l_val, h_val) >= 0 else max(l_val, h_val)\n\td[x] = ret\n\treturn ret\nprint(count(n))\n",
        "slowest_solution": "import math\nacc = []\nn = int(input())\n\ndef OneNum(num, One):\n\tonetrans = num // acc[One]\n\tnum = num % acc[One]\n\tif num == 0:\n\t\treturn onetrans * One\n\telse:\n\t\treturn onetrans * One + min(OneNum(num, One - 1), One + OneNum(acc[One] - num, One - 1))\nacc.append(0)\nfor i in range(1, 17):\n\tacc.append(acc[i - 1] * 10 + 1)\nprint(OneNum(n, 16))\n"
    },
    {
        "task_id": 931,
        "slowest_solution_id": 2,
        "fastest_solution_id": 7,
        "slowest_time": 2.994560718536377,
        "fastest_time": 2.710975408554077,
        "fastest_solution": "for i in range(int(input())):\n\t(a, b, c) = map(int, input().split())\n\tprint(2 * (a + 180) - (b + c))\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\t(N, A, B) = map(int, input().split())\n\tprint(2 * (180 + N) - (A + B))\n"
    },
    {
        "task_id": 973,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.8822596073150635,
        "fastest_time": 2.8822596073150635,
        "fastest_solution": "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n\treturn list(sys.stdin.readline().strip())\n\ndef li():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n\treturn map(int, sys.stdin.readline().split())\n\ndef inp():\n\treturn int(sys.stdin.readline())\n\ndef pr(n):\n\treturn sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n\treturn sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\ndef solve():\n\t(n, m) = mp()\n\tk = inp()\n\tl = li()\n\tq = deque()\n\tv = [[0] * (m + 1) for i in range(n + 1)]\n\tfor i in range(0, 2 * k - 1, 2):\n\t\tq.append((l[i], l[i + 1]))\n\t\tv[l[i]][l[i + 1]] = 1\n\twhile q:\n\t\t(a, b) = q.popleft()\n\t\tfor i in range(4):\n\t\t\t(A, B) = (a + dx[i], b + dy[i])\n\t\t\tif A > 0 and A <= n and (B > 0) and (B <= m):\n\t\t\t\tif not v[A][B]:\n\t\t\t\t\tq.append((A, B))\n\t\t\t\t\tv[A][B] = 1\n\tprint(a, b)\nfor _ in range(1):\n\tsolve()\n",
        "slowest_solution": "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n\treturn list(sys.stdin.readline().strip())\n\ndef li():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n\treturn map(int, sys.stdin.readline().split())\n\ndef inp():\n\treturn int(sys.stdin.readline())\n\ndef pr(n):\n\treturn sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n\treturn sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\ndef solve():\n\t(n, m) = mp()\n\tk = inp()\n\tl = li()\n\tq = deque()\n\tv = [[0] * (m + 1) for i in range(n + 1)]\n\tfor i in range(0, 2 * k - 1, 2):\n\t\tq.append((l[i], l[i + 1]))\n\t\tv[l[i]][l[i + 1]] = 1\n\twhile q:\n\t\t(a, b) = q.popleft()\n\t\tfor i in range(4):\n\t\t\t(A, B) = (a + dx[i], b + dy[i])\n\t\t\tif A > 0 and A <= n and (B > 0) and (B <= m):\n\t\t\t\tif not v[A][B]:\n\t\t\t\t\tq.append((A, B))\n\t\t\t\t\tv[A][B] = 1\n\tprint(a, b)\nfor _ in range(1):\n\tsolve()\n"
    },
    {
        "task_id": 936,
        "slowest_solution_id": 2,
        "fastest_solution_id": 8,
        "slowest_time": 3.0648415088653564,
        "fastest_time": 2.7245852947235107,
        "fastest_solution": "good = set('AHIMOTUVWXY')\nin_str = input('')\nstr_len = len(in_str)\nresult = ''\ni = 0\nwhile i < str_len / 2:\n\tif in_str[i] in good and in_str[i] == in_str[-1 - i]:\n\t\ti += 1\n\telse:\n\t\tresult = 'NO'\n\t\tbreak\nif result != 'NO':\n\tresult = 'YES'\nprint(result)\n",
        "slowest_solution": "syms = {'A': True, 'H': True, 'I': True, 'M': True, 'O': True, 'T': True, 'U': True, 'V': True, 'W': True, 'X': True, 'Y': True}\nname = input()\nmatch = True\nend = len(name) - 1\nstart = 0\nwhile start <= end:\n\tif name[start] is name[end] and name[start] in syms.keys():\n\t\tstart += 1\n\t\tend -= 1\n\telse:\n\t\tmatch = False\n\t\tbreak\nif match:\n\tprint('YES')\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 938,
        "slowest_solution_id": 9,
        "fastest_solution_id": 6,
        "slowest_time": 2.936436414718628,
        "fastest_time": 2.7804293632507324,
        "fastest_solution": "t = int(input())\ni = 0\nwhile i < t:\n\t(n, k) = map(int, input().split())\n\tprint(k // n)\n\ti += 1\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\t(n, k) = tuple(map(int, input().split()))\n\tprint(k // n)\n"
    },
    {
        "task_id": 972,
        "slowest_solution_id": 1,
        "fastest_solution_id": 2,
        "slowest_time": 2.8246874809265137,
        "fastest_time": 2.756359815597534,
        "fastest_solution": "import sys\nsys.setrecursionlimit(100000)\n\ndef integer_list():\n\treturn list(map(int, input().split()))\n\ndef string_list():\n\treturn list(map(str, input().split()))\n\ndef hetro_list():\n\treturn list(input().split())\nimport math\nfrom collections import Counter\n\ndef dfs(node):\n\tif node in visited:\n\t\tchilds_dct[node] = []\n\t\treturn 0\n\tchilds = dct[node]\n\tcount = []\n\ts = 0\n\tfor child in childs:\n\t\tif child not in visited:\n\t\t\tvisited.add(node)\n\t\t\ta = 0\n\t\t\ta += dfs(child) + 1\n\t\t\ts += a\n\t\t\tcount.append(a)\n\tchilds_dct[node] = count\n\treturn s\n\ndef main():\n\ttry:\n\t\tif dct == {}:\n\t\t\tprint(1)\n\t\t\treturn\n\t\tmod = 1000000007\n\t\tdfs(1)\n\t\tans = [0]\n\t\tfor i in range(1, n + 1):\n\t\t\tchild_list = childs_dct[i]\n\t\t\tcount = 0\n\t\t\tfor j in range(len(child_list)):\n\t\t\t\ta = child_list[j]\n\t\t\t\tcount += a * 2\n\t\t\t\tfor k in range(j + 1, len(child_list)):\n\t\t\t\t\tb = child_list[k]\n\t\t\t\t\tcount += a * b * 2\n\t\t\t\t\tcount %= mod\n\t\t\t\tcount %= mod\n\t\t\tans.append(count + 1)\n\t\ta = 0\n\t\tfor i in range(n + 1):\n\t\t\ta += i * ans[i]\n\t\t\ta %= mod\n\t\tprint(a)\n\texcept Exception as e:\n\t\tprint(e)\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tdct = {}\n\tchilds_dct = {i: [] for i in range(1, n + 1)}\n\tvisited = set()\n\tfor i in range(n - 1):\n\t\t(a, b) = integer_list()\n\t\t(a, b) = (min(a, b), max(a, b))\n\t\tif a not in dct:\n\t\t\tdct[a] = [b]\n\t\telse:\n\t\t\tdct[a].append(b)\n\t\tif b not in dct:\n\t\t\tdct[b] = [a]\n\t\telse:\n\t\t\tdct[b].append(a)\n\tmain()\n",
        "slowest_solution": "import sys\nsys.setrecursionlimit(100000)\n\ndef dfs(node):\n\tif node in visited:\n\t\tchilds_dct[node] = []\n\t\treturn 0\n\tchilds = dct[node]\n\tcount = []\n\ts = 0\n\tvisited.add(node)\n\tfor child in childs:\n\t\tif child not in visited:\n\t\t\ta = dfs(child) + 1\n\t\t\ts += a\n\t\t\tcount.append(a)\n\tchilds_dct[node] = count\n\treturn s\n\ndef solve():\n\ttry:\n\t\tif dct == {}:\n\t\t\tprint(1)\n\t\t\treturn\n\t\tmod = 1000000007\n\t\tdfs(1)\n\t\tans = [0]\n\t\tfor i in range(1, n + 1):\n\t\t\tchild_list = childs_dct[i]\n\t\t\tcount = 0\n\t\t\tfor j in range(len(child_list)):\n\t\t\t\ta = child_list[j]\n\t\t\t\tcount += a * 2\n\t\t\t\tfor k in range(j + 1, len(child_list)):\n\t\t\t\t\tb = child_list[k]\n\t\t\t\t\tcount += a * b * 2\n\t\t\t\t\tcount %= mod\n\t\t\tans.append(count + 1)\n\t\ta = 0\n\t\tfor i in range(n + 1):\n\t\t\ta += i * ans[i]\n\t\t\ta %= mod\n\t\tprint(a)\n\texcept Exception as e:\n\t\tprint(e)\nfor _ in range(int(input())):\n\tn = int(input())\n\tdct = {}\n\tchilds_dct = {i: [] for i in range(1, n + 1)}\n\tvisited = set()\n\tfor i in range(n - 1):\n\t\t(a, b) = list(map(int, input().split()))\n\t\t(a, b) = (min(a, b), max(a, b))\n\t\tif a not in dct:\n\t\t\tdct[a] = [b]\n\t\telse:\n\t\t\tdct[a].append(b)\n\t\tif b not in dct:\n\t\t\tdct[b] = [a]\n\t\telse:\n\t\t\tdct[b].append(a)\n\tsolve()\n"
    },
    {
        "task_id": 940,
        "slowest_solution_id": 1,
        "fastest_solution_id": 3,
        "slowest_time": 3.0218913555145264,
        "fastest_time": 2.7261860370635986,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ta.sort()\n\tflag = False\n\tsum = 0\n\tfor i in a[::-1]:\n\t\tt = n - i\n\t\tif t < 0:\n\t\t\tflag = True\n\t\t\tbreak\n\t\telse:\n\t\t\tsum += t\n\t\tn -= 1\n\tif flag:\n\t\tprint('Second')\n\telif sum % 2 == 0:\n\t\tprint('Second')\n\telse:\n\t\tprint('First')\n",
        "slowest_solution": "t = int(input())\nfor kkk in range(t):\n\tn = int(input())\n\ta = [int(x) for x in input().split()]\n\ta.sort()\n\tfirst = 1\n\tsecond = 0\n\twin = 'Second'\n\tif a[0] > 1:\n\t\tif first == 1:\n\t\t\twin = 'Second'\n\t\telse:\n\t\t\twin = 'First'\n\t\tprint(win)\n\t\tcontinue\n\tfor i in range(1, n):\n\t\tif a[i] > i + 1:\n\t\t\twin = 'Second'\n\t\t\tbreak\n\t\tif a[i - 1] >= a[i]:\n\t\t\tif second == 1:\n\t\t\t\tif (a[i - 1] + 1 - a[i]) % 2 == 1:\n\t\t\t\t\twin = 'Second'\n\t\t\t\t\tsecond = 0\n\t\t\t\t\tfirst = 1\n\t\t\t\telse:\n\t\t\t\t\twin = 'First'\n\t\t\t\t\tsecond = 1\n\t\t\t\t\tfirst = 0\n\t\t\telif (a[i - 1] + 1 - a[i]) % 2 == 1:\n\t\t\t\twin = 'First'\n\t\t\t\tsecond = 1\n\t\t\t\tfirst = 0\n\t\t\telse:\n\t\t\t\twin = 'Second'\n\t\t\t\tsecond = 0\n\t\t\t\tfirst = 1\n\t\t\ta[i] = a[i - 1] + 1\n\tprint(win)\n"
    },
    {
        "task_id": 977,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.9501450061798096,
        "fastest_time": 2.9501450061798096,
        "fastest_solution": "import math\nteststring = '4\\n0 3 4 6\\n3 0 2 1\\n4 2 0 5\\n6 1 5 0\\n\\n'\nonline = __file__ != '/home/jhli/py/Grakn/Problem_G2.py'\n(true, false) = (True, False)\nif True:\n\n\tdef spitout():\n\t\tfor c in teststring.splitlines():\n\t\t\tyield c\n\t_ito = spitout()\n\tif not online:\n\n\t\tdef input():\n\t\t\treturn next(_ito)\n\n\tdef build_enum(*a):\n\t\tbuilt = dict()\n\t\tfor (i, c) in enumerate(a):\n\t\t\tbuilt[c] = i\n\t\treturn lambda x: built[x]\nn = int(input())\nE = [(0, 0)] * int(n * (n - 1) / 2)\nP = 998244353\nfor i in range(n):\n\tL = list(map(int, input().split(' ')))\n\tfor j in range(i + 1, n):\n\t\tE[L[j] - 1] = (i, j)\nR = list(range(n))\nC = [[0, 1] for _ in range(n)]\nNv = [1] * n\nNe = [0] * n\n\ndef root(x):\n\tif x == R[x]:\n\t\treturn x\n\telse:\n\t\tR[x] = y = root(R[x])\n\t\treturn y\n\ndef prod(A, B, da, db):\n\tC = [0] * (min(da + db, n) + 1)\n\tfor i in range(da + 1):\n\t\tfor j in range(db + 1):\n\t\t\tif i + j <= n:\n\t\t\t\tC[i + j] += A[i] * B[j]\n\t\t\t\tC[i + j] %= P\n\treturn C\nfor (x, y) in E:\n\tr = rx = root(x)\n\try = root(y)\n\tif rx != ry:\n\t\tif r > ry:\n\t\t\tr = ry\n\t\tR[rx] = R[ry] = r\n\t\tC[r] = prod(C[rx], C[ry], Nv[rx], Nv[ry])\n\t\tNv[r] = Nv[rx] + Nv[ry]\n\t\tNe[r] = Ne[rx] + Ne[ry] + 1\n\telse:\n\t\tNe[r] += 1\n\tif Ne[r] * 2 == Nv[r] * (Nv[r] - 1):\n\t\tC[r][1] = 1\nprint(' '.join(map(str, C[0][1:n + 1])))\n",
        "slowest_solution": "import math\nteststring = '4\\n0 3 4 6\\n3 0 2 1\\n4 2 0 5\\n6 1 5 0\\n\\n'\nonline = __file__ != '/home/jhli/py/Grakn/Problem_G2.py'\n(true, false) = (True, False)\nif True:\n\n\tdef spitout():\n\t\tfor c in teststring.splitlines():\n\t\t\tyield c\n\t_ito = spitout()\n\tif not online:\n\n\t\tdef input():\n\t\t\treturn next(_ito)\n\n\tdef build_enum(*a):\n\t\tbuilt = dict()\n\t\tfor (i, c) in enumerate(a):\n\t\t\tbuilt[c] = i\n\t\treturn lambda x: built[x]\nn = int(input())\nE = [(0, 0)] * int(n * (n - 1) / 2)\nP = 998244353\nfor i in range(n):\n\tL = list(map(int, input().split(' ')))\n\tfor j in range(i + 1, n):\n\t\tE[L[j] - 1] = (i, j)\nR = list(range(n))\nC = [[0, 1] for _ in range(n)]\nNv = [1] * n\nNe = [0] * n\n\ndef root(x):\n\tif x == R[x]:\n\t\treturn x\n\telse:\n\t\tR[x] = y = root(R[x])\n\t\treturn y\n\ndef prod(A, B, da, db):\n\tC = [0] * (min(da + db, n) + 1)\n\tfor i in range(da + 1):\n\t\tfor j in range(db + 1):\n\t\t\tif i + j <= n:\n\t\t\t\tC[i + j] += A[i] * B[j]\n\t\t\t\tC[i + j] %= P\n\treturn C\nfor (x, y) in E:\n\tr = rx = root(x)\n\try = root(y)\n\tif rx != ry:\n\t\tif r > ry:\n\t\t\tr = ry\n\t\tR[rx] = R[ry] = r\n\t\tC[r] = prod(C[rx], C[ry], Nv[rx], Nv[ry])\n\t\tNv[r] = Nv[rx] + Nv[ry]\n\t\tNe[r] = Ne[rx] + Ne[ry] + 1\n\telse:\n\t\tNe[r] += 1\n\tif Ne[r] * 2 == Nv[r] * (Nv[r] - 1):\n\t\tC[r][1] = 1\nprint(' '.join(map(str, C[0][1:n + 1])))\n"
    },
    {
        "task_id": 978,
        "slowest_solution_id": 0,
        "fastest_solution_id": 1,
        "slowest_time": 2.970796823501587,
        "fastest_time": 2.752365827560425,
        "fastest_solution": "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(2 * 10 ** 5)\n\nclass SortedList:\n\n\tdef __init__(self, iterable=[], _load=200):\n\t\tvalues = sorted(iterable)\n\t\tself._len = _len = len(values)\n\t\tself._load = _load\n\t\tself._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n\t\tself._list_lens = [len(_list) for _list in _lists]\n\t\tself._mins = [_list[0] for _list in _lists]\n\t\tself._fen_tree = []\n\t\tself._rebuild = True\n\n\tdef _fen_build(self):\n\t\tself._fen_tree[:] = self._list_lens\n\t\t_fen_tree = self._fen_tree\n\t\tfor i in range(len(_fen_tree)):\n\t\t\tif i | i + 1 < len(_fen_tree):\n\t\t\t\t_fen_tree[i | i + 1] += _fen_tree[i]\n\t\tself._rebuild = False\n\n\tdef _fen_update(self, index, value):\n\t\tif not self._rebuild:\n\t\t\t_fen_tree = self._fen_tree\n\t\t\twhile index < len(_fen_tree):\n\t\t\t\t_fen_tree[index] += value\n\t\t\t\tindex |= index + 1\n\n\tdef _fen_query(self, end):\n\t\tif self._rebuild:\n\t\t\tself._fen_build()\n\t\t_fen_tree = self._fen_tree\n\t\tx = 0\n\t\twhile end:\n\t\t\tx += _fen_tree[end - 1]\n\t\t\tend &= end - 1\n\t\treturn x\n\n\tdef _fen_findkth(self, k):\n\t\t_list_lens = self._list_lens\n\t\tif k < _list_lens[0]:\n\t\t\treturn (0, k)\n\t\tif k >= self._len - _list_lens[-1]:\n\t\t\treturn (len(_list_lens) - 1, k + _list_lens[-1] - self._len)\n\t\tif self._rebuild:\n\t\t\tself._fen_build()\n\t\t_fen_tree = self._fen_tree\n\t\tidx = -1\n\t\tfor d in reversed(range(len(_fen_tree).bit_length())):\n\t\t\tright_idx = idx + (1 << d)\n\t\t\tif right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n\t\t\t\tidx = right_idx\n\t\t\t\tk -= _fen_tree[idx]\n\t\treturn (idx + 1, k)\n\n\tdef _delete(self, pos, idx):\n\t\t_lists = self._lists\n\t\t_mins = self._mins\n\t\t_list_lens = self._list_lens\n\t\tself._len -= 1\n\t\tself._fen_update(pos, -1)\n\t\tdel _lists[pos][idx]\n\t\t_list_lens[pos] -= 1\n\t\tif _list_lens[pos]:\n\t\t\t_mins[pos] = _lists[pos][0]\n\t\telse:\n\t\t\tdel _lists[pos]\n\t\t\tdel _list_lens[pos]\n\t\t\tdel _mins[pos]\n\t\t\tself._rebuild = True\n\n\tdef _loc_left(self, value):\n\t\tif not self._len:\n\t\t\treturn (0, 0)\n\t\t_lists = self._lists\n\t\t_mins = self._mins\n\t\t(lo, pos) = (-1, len(_lists) - 1)\n\t\twhile lo + 1 < pos:\n\t\t\tmi = lo + pos >> 1\n\t\t\tif value <= _mins[mi]:\n\t\t\t\tpos = mi\n\t\t\telse:\n\t\t\t\tlo = mi\n\t\tif pos and value <= _lists[pos - 1][-1]:\n\t\t\tpos -= 1\n\t\t_list = _lists[pos]\n\t\t(lo, idx) = (-1, len(_list))\n\t\twhile lo + 1 < idx:\n\t\t\tmi = lo + idx >> 1\n\t\t\tif value <= _list[mi]:\n\t\t\t\tidx = mi\n\t\t\telse:\n\t\t\t\tlo = mi\n\t\treturn (pos, idx)\n\n\tdef _loc_right(self, value):\n\t\tif not self._len:\n\t\t\treturn (0, 0)\n\t\t_lists = self._lists\n\t\t_mins = self._mins\n\t\t(pos, hi) = (0, len(_lists))\n\t\twhile pos + 1 < hi:\n\t\t\tmi = pos + hi >> 1\n\t\t\tif value < _mins[mi]:\n\t\t\t\thi = mi\n\t\t\telse:\n\t\t\t\tpos = mi\n\t\t_list = _lists[pos]\n\t\t(lo, idx) = (-1, len(_list))\n\t\twhile lo + 1 < idx:\n\t\t\tmi = lo + idx >> 1\n\t\t\tif value < _list[mi]:\n\t\t\t\tidx = mi\n\t\t\telse:\n\t\t\t\tlo = mi\n\t\treturn (pos, idx)\n\n\tdef add(self, value):\n\t\t_load = self._load\n\t\t_lists = self._lists\n\t\t_mins = self._mins\n\t\t_list_lens = self._list_lens\n\t\tself._len += 1\n\t\tif _lists:\n\t\t\t(pos, idx) = self._loc_right(value)\n\t\t\tself._fen_update(pos, 1)\n\t\t\t_list = _lists[pos]\n\t\t\t_list.insert(idx, value)\n\t\t\t_list_lens[pos] += 1\n\t\t\t_mins[pos] = _list[0]\n\t\t\tif _load + _load < len(_list):\n\t\t\t\t_lists.insert(pos + 1, _list[_load:])\n\t\t\t\t_list_lens.insert(pos + 1, len(_list) - _load)\n\t\t\t\t_mins.insert(pos + 1, _list[_load])\n\t\t\t\t_list_lens[pos] = _load\n\t\t\t\tdel _list[_load:]\n\t\t\t\tself._rebuild = True\n\t\telse:\n\t\t\t_lists.append([value])\n\t\t\t_mins.append(value)\n\t\t\t_list_lens.append(1)\n\t\t\tself._rebuild = True\n\n\tdef discard(self, value):\n\t\t_lists = self._lists\n\t\tif _lists:\n\t\t\t(pos, idx) = self._loc_right(value)\n\t\t\tif idx and _lists[pos][idx - 1] == value:\n\t\t\t\tself._delete(pos, idx - 1)\n\n\tdef remove(self, value):\n\t\t_len = self._len\n\t\tself.discard(value)\n\t\tif _len == self._len:\n\t\t\traise ValueError('{0!r} not in list'.format(value))\n\n\tdef pop(self, index=-1):\n\t\t(pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n\t\tvalue = self._lists[pos][idx]\n\t\tself._delete(pos, idx)\n\t\treturn value\n\n\tdef bisect_left(self, value):\n\t\t(pos, idx) = self._loc_left(value)\n\t\treturn self._fen_query(pos) + idx\n\n\tdef bisect_right(self, value):\n\t\t(pos, idx) = self._loc_right(value)\n\t\treturn self._fen_query(pos) + idx\n\n\tdef count(self, value):\n\t\treturn self.bisect_right(value) - self.bisect_left(value)\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef __getitem__(self, index):\n\t\t(pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n\t\treturn self._lists[pos][idx]\n\n\tdef __delitem__(self, index):\n\t\t(pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n\t\tself._delete(pos, idx)\n\n\tdef __contains__(self, value):\n\t\t_lists = self._lists\n\t\tif _lists:\n\t\t\t(pos, idx) = self._loc_left(value)\n\t\t\treturn idx < len(_lists[pos]) and _lists[pos][idx] == value\n\t\treturn False\n\n\tdef __iter__(self):\n\t\treturn (value for _list in self._lists for value in _list)\n\n\tdef __reversed__(self):\n\t\treturn (value for _list in reversed(self._lists) for value in reversed(_list))\n\n\tdef __repr__(self):\n\t\treturn 'SortedList({0})'.format(list(self))\n\nclass OrderedList(SortedList):\n\n\tdef __init__(self, arg):\n\t\tsuper().__init__(arg)\n\n\tdef rangeCountByValue(self, leftVal, rightVal):\n\t\tleftCummulative = self.bisect_left(leftVal)\n\t\trightCummulative = self.bisect_left(rightVal + 1)\n\t\treturn rightCummulative - leftCummulative\n\ndef dfs(p, prev):\n\ttotal = SortedList([])\n\ttotal.add(a[p - 1])\n\tvalue = float('inf')\n\tfor i in child[p]:\n\t\tif i == prev:\n\t\t\tcontinue\n\t\t(take, val) = dfs(i, p)\n\t\tif len(take) > len(total):\n\t\t\t(total, take) = (take, total)\n\t\tvalue = min(value, val)\n\t\tfor x in take:\n\t\t\tind = total.bisect_left(x)\n\t\t\tif ind < len(total):\n\t\t\t\tvalue = min(value, total[ind] ^ x)\n\t\t\tif ind > 0:\n\t\t\t\tvalue = min(value, total[ind - 1] ^ x)\n\t\t\ttotal.add(x)\n\tif value == float('inf'):\n\t\tans[p - 1] = -1\n\telse:\n\t\tans[p - 1] = value\n\treturn [total, value]\nfor T in range(int(input())):\n\tn = int(input())\n\tchild = [[] for i in range(n + 1)]\n\tfor i in range(n - 1):\n\t\t(u, v) = map(int, input().split())\n\t\tchild[u].append(v)\n\t\tchild[v].append(u)\n\ta = list(map(int, input().split()))\n\tans = [-1 for i in range(n)]\n\tdfs(1, -1)\n\tprint(*ans)\n",
        "slowest_solution": "from collections import deque\nfrom enum import Enum, auto\n\nclass RedBlackTree:\n\n\tclass Colour(Enum):\n\t\tRED = auto()\n\t\tBLACK = auto()\n\n\tclass Node:\n\n\t\tdef __init__(self, key):\n\t\t\tself.parent = None\n\t\t\tself.left = None\n\t\t\tself.right = None\n\t\t\tself.colour = RedBlackTree.Colour.RED\n\t\t\tself.key = key\n\n\t\t@property\n\t\tdef grandparent(self):\n\t\t\treturn self.parent and self.parent.parent\n\n\t\t@property\n\t\tdef sibling(self):\n\t\t\tp = self.parent\n\t\t\treturn p and (p.right if p.left == self else p.left)\n\n\t\t@property\n\t\tdef uncle(self):\n\t\t\tp = self.parent\n\t\t\treturn p and p.sibling\n\n\t\tdef has_red_child(self):\n\t\t\treturn self.left and self.left.colour == RedBlackTree.Colour.RED or (self.right and self.right.colour == RedBlackTree.Colour.RED)\n\n\t\tdef is_on_left(self):\n\t\t\treturn self.parent.left == self\n\n\t\tdef find(self, v):\n\t\t\tif self.key == v:\n\t\t\t\treturn self\n\t\t\tchild = self.left if self.key > v else self.right\n\t\t\treturn child and child.find(v)\n\n\t\tdef far_left(self):\n\t\t\tif self.left:\n\t\t\t\treturn self.left.far_left()\n\t\t\telse:\n\t\t\t\treturn self\n\n\t\tdef far_right(self):\n\t\t\tif self.right:\n\t\t\t\treturn self.right.far_right()\n\t\t\telse:\n\t\t\t\treturn self\n\n\t\tdef next(self):\n\t\t\tif self.right:\n\t\t\t\treturn self.right.far_left()\n\t\t\tn = self\n\t\t\tp = n.parent\n\t\t\twhile p:\n\t\t\t\tif n == p.left:\n\t\t\t\t\treturn p\n\t\t\t\tn = p\n\t\t\t\tp = n.parent\n\t\t\treturn None\n\n\t\tdef prev(self):\n\t\t\tif self.left:\n\t\t\t\treturn self.left.far_right()\n\t\t\tn = self\n\t\t\tp = n.parent\n\t\t\twhile p:\n\t\t\t\tif n == p.right:\n\t\t\t\t\treturn p\n\t\t\t\tn = p\n\t\t\t\tp = n.parent\n\t\t\treturn None\n\n\t\tdef __str__(self):\n\t\t\treturn str(self.key) + ' ' + str(self.colour)\n\n\tdef __init__(self):\n\t\tself.root = None\n\t\tself.len = 0\n\n\t@staticmethod\n\tdef is_red(node):\n\t\treturn node and node.colour == RedBlackTree.Colour.RED\n\n\tdef rotate_left(self, n):\n\t\tnnew = n.right\n\t\tp = n.parent\n\t\tn.right = nnew.left\n\t\tnnew.left = n\n\t\tn.parent = nnew\n\t\tif n.right:\n\t\t\tn.right.parent = n\n\t\tif p:\n\t\t\tif n == p.left:\n\t\t\t\tp.left = nnew\n\t\t\telif n == p.right:\n\t\t\t\tp.right = nnew\n\t\telse:\n\t\t\tself.root = nnew\n\t\tnnew.parent = p\n\n\tdef rotate_right(self, n):\n\t\tnnew = n.left\n\t\tp = n.parent\n\t\tn.left = nnew.right\n\t\tnnew.right = n\n\t\tn.parent = nnew\n\t\tif n.left:\n\t\t\tn.left.parent = n\n\t\tif p:\n\t\t\tif n == p.left:\n\t\t\t\tp.left = nnew\n\t\t\telif n == p.right:\n\t\t\t\tp.right = nnew\n\t\telse:\n\t\t\tself.root = nnew\n\t\tnnew.parent = p\n\n\tdef insert(self, k):\n\t\tn = self.Node(k)\n\n\t\tdef insert_recurse(root):\n\t\t\tif root and n.key < root.key:\n\t\t\t\tif root.left:\n\t\t\t\t\tinsert_recurse(root.left)\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\troot.left = n\n\t\t\telif root:\n\t\t\t\tif root.right:\n\t\t\t\t\tinsert_recurse(root.right)\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\troot.right = n\n\t\t\tn.parent = root\n\n\t\tdef repair_insert(n):\n\t\t\tif not n.parent:\n\t\t\t\tn.colour = RedBlackTree.Colour.BLACK\n\t\t\telif n.parent.colour == RedBlackTree.Colour.BLACK:\n\t\t\t\treturn\n\t\t\telif n.uncle and n.uncle.colour == RedBlackTree.Colour.RED:\n\t\t\t\tn.parent.colour = RedBlackTree.Colour.BLACK\n\t\t\t\tn.uncle.colour = RedBlackTree.Colour.BLACK\n\t\t\t\tn.grandparent.colour = RedBlackTree.Colour.RED\n\t\t\t\trepair_insert(n.grandparent)\n\t\t\telse:\n\t\t\t\tp = n.parent\n\t\t\t\tg = n.grandparent\n\t\t\t\tif n == p.right and p == g.left:\n\t\t\t\t\tself.rotate_left(p)\n\t\t\t\t\tn = n.left\n\t\t\t\telif n == p.left and p == g.right:\n\t\t\t\t\tself.rotate_right(p)\n\t\t\t\t\tn = n.right\n\t\t\t\tp = n.parent\n\t\t\t\tg = n.grandparent\n\t\t\t\tif n == p.left:\n\t\t\t\t\tself.rotate_right(g)\n\t\t\t\telse:\n\t\t\t\t\tself.rotate_left(g)\n\t\t\t\tp.colour = RedBlackTree.Colour.BLACK\n\t\t\t\tg.colour = RedBlackTree.Colour.RED\n\t\tinsert_recurse(self.root)\n\t\trepair_insert(n)\n\t\tself.root = n\n\t\twhile self.root.parent:\n\t\t\tself.root = self.root.parent\n\t\tself.len += 1\n\n\tdef remove(self, v):\n\n\t\tdef fix_double_black(n):\n\t\t\tif n == self.root:\n\t\t\t\treturn\n\t\t\tp = n.parent\n\t\t\ts = n.sibling\n\t\t\tif not s:\n\t\t\t\tfix_double_black(n.parent)\n\t\t\t\treturn\n\t\t\tif s.colour == RedBlackTree.Colour.RED:\n\t\t\t\tp.colour = RedBlackTree.Colour.RED\n\t\t\t\ts.colour = RedBlackTree.Colour.BLACK\n\t\t\t\tif p.left == n:\n\t\t\t\t\tself.rotate_left(p)\n\t\t\t\telse:\n\t\t\t\t\tself.rotate_right(p)\n\t\t\t\tfix_double_black(n)\n\t\t\telif s.has_red_child():\n\t\t\t\tif self.is_red(s.left):\n\t\t\t\t\tif s.is_on_left():\n\t\t\t\t\t\ts.left.colour = s.colour\n\t\t\t\t\t\ts.colour = p.colour\n\t\t\t\t\t\tself.rotate_right(p)\n\t\t\t\t\telse:\n\t\t\t\t\t\ts.left.colour = p.colour\n\t\t\t\t\t\tself.rotate_right(s)\n\t\t\t\t\t\tself.rotate_left(p)\n\t\t\t\telif s.is_on_left():\n\t\t\t\t\ts.right.colour = p.colour\n\t\t\t\t\tself.rotate_left(s)\n\t\t\t\t\tself.rotate_right(p)\n\t\t\t\telse:\n\t\t\t\t\ts.right.colour = s.colour\n\t\t\t\t\ts.colour = p.colour\n\t\t\t\t\tself.rotate_left(p)\n\t\t\t\tp.colour = RedBlackTree.Colour.BLACK\n\t\t\telse:\n\t\t\t\ts.colour = RedBlackTree.Colour.RED\n\t\t\t\tif p.colour == RedBlackTree.Colour.BLACK:\n\t\t\t\t\tfix_double_black(p)\n\t\t\t\telse:\n\t\t\t\t\tp.colour = RedBlackTree.Colour.BLACK\n\n\t\tdef delete(n):\n\t\t\tchild = n.left or n.right\n\t\t\tif not (self.is_red(n) or self.is_red(child)):\n\t\t\t\tfix_double_black(n)\n\t\t\tif child:\n\t\t\t\tchild.parent = n.parent\n\t\t\t\tchild.colour = RedBlackTree.Colour.BLACK\n\t\t\tif not n.parent:\n\t\t\t\tself.root = child\n\t\t\telif n.is_on_left():\n\t\t\t\tn.parent.left = child\n\t\t\telse:\n\t\t\t\tn.parent.right = child\n\t\tn = self.root.find(v)\n\t\tif n.right and n.left:\n\t\t\tm = n.right.far_left()\n\t\t\tn.key = m.key\n\t\t\tn = m\n\t\tdelete(n)\n\t\tself.len -= 1\n\n\tdef find(self, v):\n\t\treturn self.root and self.root.find(v)\n\n\tdef __iter__(self):\n\t\tif not self.root:\n\t\t\treturn None\n\t\tn = self.root.far_left()\n\t\twhile n:\n\t\t\tyield n.key\n\t\t\tn = n.next()\n\n\tdef __len__(self):\n\t\treturn self.len\n\ndef main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn = int(input())\n\t\tedges = [[int(a) for a in input().split()] for _ in range(n - 1)]\n\t\taa = [0] + [int(a) for a in input().split()]\n\t\tres = solve(n, edges, aa)\n\t\tprint(' '.join(map(str, res)))\nINF = 10000000000000000\n\ndef solve(n, edges, aa):\n\tadj = [[] for _ in range(n + 1)]\n\tfor (u, v) in edges:\n\t\tadj[u].append(v)\n\t\tadj[v].append(u)\n\tparent = [0] * (n + 1)\n\tdl = []\n\tq = deque([1])\n\twhile q:\n\t\tv = q.popleft()\n\t\tfor w in adj[v]:\n\t\t\tif w != parent[v]:\n\t\t\t\tdl.append(w)\n\t\t\t\tparent[w] = v\n\t\t\t\tq.append(w)\n\tdl.reverse()\n\tres = [INF] * (n + 1)\n\tvalues = [RedBlackTree() for _ in range(n + 1)]\n\tfor (i, a) in enumerate(aa):\n\t\tvalues[i].insert(a)\n\tfor u in dl:\n\t\tres[parent[u]] = min(res[parent[u]], res[u])\n\t\tif len(values[u]) > len(values[parent[u]]):\n\t\t\t(values[u], values[parent[u]]) = (values[parent[u]], values[u])\n\t\tfor v in values[u]:\n\t\t\tvalues[parent[u]].insert(v)\n\t\t\tvn = values[parent[u]].find(v)\n\t\t\tpn = vn.prev()\n\t\t\tif pn:\n\t\t\t\tres[parent[u]] = min(res[parent[u]], pn.key ^ v)\n\t\t\tnn = vn.next()\n\t\t\tif nn:\n\t\t\t\tres[parent[u]] = min(res[parent[u]], nn.key ^ v)\n\treturn [-1 if r == INF else r for r in res[1:]]\nmain()\n"
    },
    {
        "task_id": 947,
        "slowest_solution_id": 3,
        "fastest_solution_id": 3,
        "slowest_time": 2.8473880290985107,
        "fastest_time": 2.8473880290985107,
        "fastest_solution": "def gcd(a, b):\n\treturn a if b == 0 else gcd(b, a % b)\n(L, R) = map(int, input().split())\nR += 1\n\ndef solve():\n\tfor a in range(L, R):\n\t\tfor b in range(a + 1, R):\n\t\t\tfor c in range(b + 1, R):\n\t\t\t\tif gcd(a, b) == 1 and gcd(b, c) == 1 and (gcd(a, c) != 1):\n\t\t\t\t\treturn str(a) + ' ' + str(b) + ' ' + str(c)\n\treturn -1\nprint(solve())\n",
        "slowest_solution": "def gcd(a, b):\n\treturn a if b == 0 else gcd(b, a % b)\n(L, R) = map(int, input().split())\nR += 1\n\ndef solve():\n\tfor a in range(L, R):\n\t\tfor b in range(a + 1, R):\n\t\t\tfor c in range(b + 1, R):\n\t\t\t\tif gcd(a, b) == 1 and gcd(b, c) == 1 and (gcd(a, c) != 1):\n\t\t\t\t\treturn str(a) + ' ' + str(b) + ' ' + str(c)\n\treturn -1\nprint(solve())\n"
    },
    {
        "task_id": 946,
        "slowest_solution_id": 0,
        "fastest_solution_id": 5,
        "slowest_time": 3.004289388656616,
        "fastest_time": 2.720791816711426,
        "fastest_solution": "def answer(a):\n\tn = len(ath_sc)\n\tif n == 1:\n\t\treturn 1\n\tanswer = -1\n\tgold = 0\n\tfor i in range(1, n):\n\t\tnum = 0\n\t\tfor j in range(5):\n\t\t\tif a[i][j] < a[gold][j]:\n\t\t\t\tnum += 1\n\t\tif num >= 3:\n\t\t\tgold = i\n\ti = 0\n\tfor i in range(n):\n\t\tnum = 0\n\t\tif i != gold:\n\t\t\tfor j in range(5):\n\t\t\t\tif a[i][j] < a[gold][j]:\n\t\t\t\t\tnum += 1\n\t\t\tif num >= 3:\n\t\t\t\tres = -1\n\t\t\t\tbreak\n\tif i == n - 1:\n\t\tres = gold + 1\n\treturn res\ntc = int(input())\nfor i in range(tc):\n\tath_sc = []\n\tno_ath = int(input())\n\tfor j in range(no_ath):\n\t\tath_sc.append(list(map(int, input().split())))\n\tath_ans = answer(ath_sc)\n\tprint(ath_ans)\n",
        "slowest_solution": "import os, sys\ninput = lambda : sys.stdin.buffer.readline().rstrip(b'\\r\\n')\n\ndef dbp(*args, **kwargs):\n\tprint(*args, file=sys.stderr, **kwargs)\na_str = lambda : input().decode('ascii')\nget_int_list = lambda : [int(x) for x in input().split()]\njoin_str = lambda l, ch=' ': ch.join((str(x) for x in l))\n\ndef sup(a, b):\n\tcount = 0\n\tfor i in range(5):\n\t\tif a[i] < b[i]:\n\t\t\tcount += 1\n\t\tif count >= 3:\n\t\t\treturn True\n\treturn False\n\ndef do_thing():\n\tn = int(input())\n\tg = [get_int_list() for i in range(n)]\n\tcand = 0\n\tfor i in range(1, n):\n\t\tif sup(g[i], g[cand]):\n\t\t\tcand = i\n\tif all((sup(g[cand], g[i]) for i in range(n) if i != cand)):\n\t\treturn cand + 1\n\treturn -1\n\ndef multicase():\n\tmaxcc = int(input().strip())\n\tfor cc in range(maxcc):\n\t\tprint(do_thing())\nmulticase()\n"
    },
    {
        "task_id": 949,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 2.9712462425231934,
        "fastest_time": 2.756699323654175,
        "fastest_solution": "T = 998244353\nfor j in range(int(input())):\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tans = pref = 0\n\tsum1 = sum2 = sum3 = 0\n\tfor i in range(N):\n\t\tpref += A[i]\n\t\tans += (i + 1) * pref ** 3\n\t\tans -= sum3\n\t\tans -= 3 * pref ** 2 * sum1\n\t\tans += 3 * pref * sum2\n\t\tsum1 += pref\n\t\tsum2 += pref ** 2\n\t\tsum3 += pref ** 3\n\tprint(ans % T)\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = list()\n\tv = 0\n\tfor i in range(n):\n\t\tv += a[i]\n\t\tb.append(v)\n\tans = 0\n\tst = n\n\tfor i in range(n):\n\t\tans = (ans + st * b[-1 - i] ** 3) % 998244353\n\t\tst -= 2\n\tv = 0\n\tw = 0\n\tb_sq = list()\n\tb_back = list()\n\tfor i in range(n):\n\t\tv += b[i]\n\t\tb_sq.append(v)\n\t\tw += b[-1 - i]\n\t\tb_back.append(w)\n\tfor i in range(n - 1):\n\t\tans = (ans + 3 * (b_back[-i - 2] * b[i] * b[i] - b[i + 1] * b[i + 1] * b_sq[i])) % 998244353\n\tprint(ans)\n"
    },
    {
        "task_id": 929,
        "slowest_solution_id": 0,
        "fastest_solution_id": 3,
        "slowest_time": 4.410343885421753,
        "fastest_time": 2.787637948989868,
        "fastest_solution": "from itertools import accumulate\n\ndef val_at(x, y, trs):\n\treturn trs[y + x - 2] + x\ntri = list(accumulate(range(2 * 1000 + 1)))\nactri = [0] + list(accumulate(tri))\nT = int(input())\nfor tx in range(T):\n\t(x1, y1, x2, y2) = map(int, input().split())\n\tif x2 < x1:\n\t\t(x1, y1, x2, y2) = (x2, y2, x1, y1)\n\tres = tri[x2 - 1] - tri[x1 - 1] + actri[y1 + x2 - 2] - actri[y1 + x1 - 2]\n\tif y2 < y1:\n\t\t(y1, y2) = (y2, y1)\n\tres += x2 * (y2 + 1 - y1) + actri[y2 + 1 + x2 - 2] - actri[y1 + x2 - 2]\n\tprint(res)\n",
        "slowest_solution": "t = int(input())\nn = 1001\nl = [[0 for i in range(n)] for i in range(n)]\nfor i in range(1, n):\n\tl[i][1] = i * (i + 1) // 2\nfor j in range(1, n):\n\tfor k in range(2, n):\n\t\tl[j][k] = l[j][k - 1] + (k - 1) + (j - 1)\nfor z in range(t):\n\t(r1, c1, r2, c2) = list(map(int, input().split()))\n\ts = 0\n\tfor a in range(r1, r2 + 1):\n\t\ts += l[a][c1]\n\tfor b in range(c1 + 1, c2 + 1):\n\t\ts += l[r2][b]\n\tprint(s)\n"
    },
    {
        "task_id": 951,
        "slowest_solution_id": 0,
        "fastest_solution_id": 2,
        "slowest_time": 2.9791629314422607,
        "fastest_time": 2.7438530921936035,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\ts = input()\n\tif s.count('1') % 2 == 1:\n\t\tprint('WIN')\n\telse:\n\t\tprint('LOSE')\n",
        "slowest_solution": "o = 20\nk = 30\nkk = -1\nn = int(input())\nfor _ in range(n):\n\tstr = input()\n\tcol = 0\n\tfor i in str:\n\t\tif i == '1':\n\t\t\tcol += 1\n\tif col % 2 == 1:\n\t\tprint('WIN')\n\telse:\n\t\tprint('LOSE')\n"
    },
    {
        "task_id": 952,
        "slowest_solution_id": 7,
        "fastest_solution_id": 4,
        "slowest_time": 3.001460075378418,
        "fastest_time": 2.749060869216919,
        "fastest_solution": "for _ in range(int(input())):\n\ta = input()\n\tb = input()\n\tp = ''\n\tfor i in range(len(a)):\n\t\tif a[i] == b[i]:\n\t\t\tif a[i] == 'B':\n\t\t\t\tp += 'W'\n\t\t\telse:\n\t\t\t\tp += 'B'\n\t\telse:\n\t\t\tp += 'B'\n\tprint(p)\n",
        "slowest_solution": "t = int(input())\nwhile t:\n\tx = input()\n\ty = input()\n\tstri = ''\n\tfor i in range(len(x)):\n\t\tif x[i] == y[i]:\n\t\t\tif x[i] == 'W':\n\t\t\t\tstri += 'B'\n\t\t\telse:\n\t\t\t\tstri += 'W'\n\t\telse:\n\t\t\tstri += min(x[i], y[i])\n\tprint(stri)\n\tt -= 1\n"
    },
    {
        "task_id": 966,
        "slowest_solution_id": 4,
        "fastest_solution_id": 1,
        "slowest_time": 2.9877965450286865,
        "fastest_time": 2.682573080062866,
        "fastest_solution": "n = int(input())\nt = input()\nl = len(t)\nm = int(input())\nq = {c: [] for c in 'abcdefghijklmnopqrstuvwxyz'}\nfor (j, c) in enumerate(t):\n\tq[c].append(j)\nq = {c: [i + j for i in range(0, n * l, l) for j in q[c]] for c in q}\nt = n * list(t)\nfor i in range(m):\n\t(j, c) = input().split()\n\tt[q[c].pop(int(j) - 1)] = ''\nprint(''.join(t))\n",
        "slowest_solution": "k = int(input())\ne = {}\ns = input()\nt = list(s * k)\nfor i in range(len(t)):\n\tif t[i] in e:\n\t\te[t[i]] += [i]\n\telse:\n\t\te[t[i]] = [i]\nfor i in range(int(input())):\n\t(q, w) = input().split()\n\tq = int(q) - 1\n\tt[e[w][q]] = ''\n\te[w].pop(q)\nprint(''.join(t))\n"
    },
    {
        "task_id": 988,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.9643301963806152,
        "fastest_time": 2.9643301963806152,
        "fastest_solution": "def naiveSolve():\n\treturn\n\ndef solve():\n\treturn\n\nclass SegmentTree:\n\n\tdef __init__(self, arr, combinerFunction, isCommutative=True):\n\t\tself.n = len(arr)\n\n\t\tdef cmb(a, b):\n\t\t\tif a == None:\n\t\t\t\treturn b\n\t\t\tif b == None:\n\t\t\t\treturn a\n\t\t\treturn combinerFunction(a, b)\n\t\tself.cmb = cmb\n\t\tself.sz = self.n if isCommutative else pow(2, (self.n - 1).bit_length())\n\t\tself.t = [None] * (2 * self.sz)\n\t\tfor i in range(self.n):\n\t\t\tself.t[i + self.sz] = arr[i]\n\t\tfor i in range(self.sz - 1, 0, -1):\n\t\t\tself.pull(i)\n\n\tdef pull(self, p):\n\t\tself.t[p] = self.cmb(self.t[2 * p], self.t[2 * p + 1])\n\n\tdef update(self, idx, val):\n\t\tidx += self.sz\n\t\tself.t[idx] = val\n\t\tidx //= 2\n\t\twhile idx > 0:\n\t\t\tself.pull(idx)\n\t\t\tidx //= 2\n\n\tdef query(self, l, r):\n\t\tl += self.sz\n\t\tr += self.sz + 1\n\t\ta = b = None\n\t\twhile l < r:\n\t\t\tif l % 2 == 1:\n\t\t\t\ta = self.cmb(a, self.t[l])\n\t\t\t\tl += 1\n\t\t\tif r % 2 == 1:\n\t\t\t\tr -= 1\n\t\t\t\tb = self.cmb(self.t[r], b)\n\t\t\tl //= 2\n\t\t\tr //= 2\n\t\treturn self.cmb(a, b)\n\ndef add(length):\n\treturn length * (length + 1) // 2\n\ndef combiner(a, b):\n\t(alv, arv, all, arl, ac, ab) = a\n\t(blv, brv, bll, brl, bc, bb) = b\n\t(clv, crv, cll, crl, cc, cb) = (alv, brv, all, brl, ac + bc, ab or bb)\n\tif ab and bb:\n\t\tif arv <= blv:\n\t\t\tcc += add(arl + bll)\n\t\telse:\n\t\t\tcc += add(arl) + add(bll)\n\telif ab and (not bb):\n\t\tif arv <= blv:\n\t\t\tcrl += arl\n\t\telse:\n\t\t\tcc += add(arl)\n\telif not ab and bb:\n\t\tif arv <= blv:\n\t\t\tcll += bll\n\t\telse:\n\t\t\tcc += add(bll)\n\telif arv <= blv:\n\t\tcll = crl = all + bll\n\telse:\n\t\tcb = True\n\treturn (clv, crv, cll, crl, cc, cb)\n\ndef main():\n\t(n, q) = readIntArr()\n\tarr2 = readIntArr()\n\tarr = [(x, x, 1, 1, 0, False) for x in arr2]\n\tst = SegmentTree(arr, combiner, False)\n\tallans = []\n\tfor _ in range(q):\n\t\t(t, u, v) = readIntArr()\n\t\tif t == 1:\n\t\t\tu -= 1\n\t\t\tst.update(u, (v, v, 1, 1, 0, False))\n\t\telse:\n\t\t\t(lv, rv, ll, rl, c, b) = st.query(u - 1, v - 1)\n\t\t\tif b:\n\t\t\t\tans = c + add(ll) + add(rl)\n\t\t\telse:\n\t\t\t\tans = add(ll)\n\t\t\tallans.append(ans)\n\tmultiLineArrayPrint(allans)\n\treturn\nimport sys\ninput = sys.stdin.buffer.readline\n\ndef oneLineArrayPrint(arr):\n\tprint(' '.join([str(x) for x in arr]))\n\ndef multiLineArrayPrint(arr):\n\tprint('\\n'.join([str(x) for x in arr]))\n\ndef multiLineArrayOfArraysPrint(arr):\n\tprint('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n\ndef readIntArr():\n\treturn [int(x) for x in input().split()]\n\ndef makeArr(defaultValFactory, dimensionArr):\n\tdv = defaultValFactory\n\tda = dimensionArr\n\tif len(da) == 1:\n\t\treturn [dv() for _ in range(da[0])]\n\telse:\n\t\treturn [makeArr(dv, da[1:]) for _ in range(da[0])]\n\ndef queryInteractive(x):\n\tprint('{}'.format(x))\n\tsys.stdout.flush()\n\treturn int(input())\n\ndef answerInteractive(ans):\n\tprint('! {}'.format(ans))\n\tsys.stdout.flush()\ninf = float('inf')\nfrom math import gcd, floor, ceil\nfor _abc in range(1):\n\tmain()\n",
        "slowest_solution": "def naiveSolve():\n\treturn\n\ndef solve():\n\treturn\n\nclass SegmentTree:\n\n\tdef __init__(self, arr, combinerFunction, isCommutative=True):\n\t\tself.n = len(arr)\n\n\t\tdef cmb(a, b):\n\t\t\tif a == None:\n\t\t\t\treturn b\n\t\t\tif b == None:\n\t\t\t\treturn a\n\t\t\treturn combinerFunction(a, b)\n\t\tself.cmb = cmb\n\t\tself.sz = self.n if isCommutative else pow(2, (self.n - 1).bit_length())\n\t\tself.t = [None] * (2 * self.sz)\n\t\tfor i in range(self.n):\n\t\t\tself.t[i + self.sz] = arr[i]\n\t\tfor i in range(self.sz - 1, 0, -1):\n\t\t\tself.pull(i)\n\n\tdef pull(self, p):\n\t\tself.t[p] = self.cmb(self.t[2 * p], self.t[2 * p + 1])\n\n\tdef update(self, idx, val):\n\t\tidx += self.sz\n\t\tself.t[idx] = val\n\t\tidx //= 2\n\t\twhile idx > 0:\n\t\t\tself.pull(idx)\n\t\t\tidx //= 2\n\n\tdef query(self, l, r):\n\t\tl += self.sz\n\t\tr += self.sz + 1\n\t\ta = b = None\n\t\twhile l < r:\n\t\t\tif l % 2 == 1:\n\t\t\t\ta = self.cmb(a, self.t[l])\n\t\t\t\tl += 1\n\t\t\tif r % 2 == 1:\n\t\t\t\tr -= 1\n\t\t\t\tb = self.cmb(self.t[r], b)\n\t\t\tl //= 2\n\t\t\tr //= 2\n\t\treturn self.cmb(a, b)\n\ndef add(length):\n\treturn length * (length + 1) // 2\n\ndef combiner(a, b):\n\t(alv, arv, all, arl, ac, ab) = a\n\t(blv, brv, bll, brl, bc, bb) = b\n\t(clv, crv, cll, crl, cc, cb) = (alv, brv, all, brl, ac + bc, ab or bb)\n\tif ab and bb:\n\t\tif arv <= blv:\n\t\t\tcc += add(arl + bll)\n\t\telse:\n\t\t\tcc += add(arl) + add(bll)\n\telif ab and (not bb):\n\t\tif arv <= blv:\n\t\t\tcrl += arl\n\t\telse:\n\t\t\tcc += add(arl)\n\telif not ab and bb:\n\t\tif arv <= blv:\n\t\t\tcll += bll\n\t\telse:\n\t\t\tcc += add(bll)\n\telif arv <= blv:\n\t\tcll = crl = all + bll\n\telse:\n\t\tcb = True\n\treturn (clv, crv, cll, crl, cc, cb)\n\ndef main():\n\t(n, q) = readIntArr()\n\tarr2 = readIntArr()\n\tarr = [(x, x, 1, 1, 0, False) for x in arr2]\n\tst = SegmentTree(arr, combiner, False)\n\tallans = []\n\tfor _ in range(q):\n\t\t(t, u, v) = readIntArr()\n\t\tif t == 1:\n\t\t\tu -= 1\n\t\t\tst.update(u, (v, v, 1, 1, 0, False))\n\t\telse:\n\t\t\t(lv, rv, ll, rl, c, b) = st.query(u - 1, v - 1)\n\t\t\tif b:\n\t\t\t\tans = c + add(ll) + add(rl)\n\t\t\telse:\n\t\t\t\tans = add(ll)\n\t\t\tallans.append(ans)\n\tmultiLineArrayPrint(allans)\n\treturn\nimport sys\ninput = sys.stdin.buffer.readline\n\ndef oneLineArrayPrint(arr):\n\tprint(' '.join([str(x) for x in arr]))\n\ndef multiLineArrayPrint(arr):\n\tprint('\\n'.join([str(x) for x in arr]))\n\ndef multiLineArrayOfArraysPrint(arr):\n\tprint('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n\ndef readIntArr():\n\treturn [int(x) for x in input().split()]\n\ndef makeArr(defaultValFactory, dimensionArr):\n\tdv = defaultValFactory\n\tda = dimensionArr\n\tif len(da) == 1:\n\t\treturn [dv() for _ in range(da[0])]\n\telse:\n\t\treturn [makeArr(dv, da[1:]) for _ in range(da[0])]\n\ndef queryInteractive(x):\n\tprint('{}'.format(x))\n\tsys.stdout.flush()\n\treturn int(input())\n\ndef answerInteractive(ans):\n\tprint('! {}'.format(ans))\n\tsys.stdout.flush()\ninf = float('inf')\nfrom math import gcd, floor, ceil\nfor _abc in range(1):\n\tmain()\n"
    },
    {
        "task_id": 990,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.8722193241119385,
        "fastest_time": 2.8722193241119385,
        "fastest_solution": "class Node(object):\n\n\tdef __init__(self):\n\t\tsuper(Node, self).__init__()\n\t\tself.next = [-1] * 26\n\t\tself.trans = []\n\t\tself.matches = 0\n\t\tself.leaf = 0\n\t\tself.link = 0\n\nclass AhoCorasick(object):\n\n\tdef __init__(self):\n\t\tsuper(AhoCorasick, self).__init__()\n\t\tself.T = [Node()]\n\t\tself.T[0].link = 0\n\n\tdef insert_trie(self, s):\n\t\tv = 0\n\t\tfor i in range(len(s)):\n\t\t\tc = ord(s[i]) - ord('a')\n\t\t\tif self.T[v].next[c] == -1:\n\t\t\t\tself.T[v].trans.append(c)\n\t\t\t\tself.T[v].next[c] = len(self.T)\n\t\t\t\tself.T.append(Node())\n\t\t\tv = self.T[v].next[c]\n\t\tself.T[v].leaf += 1\n\t\tself.T[v].matches += 1\n\n\tdef set_suffix_link(self, S):\n\t\tQ = []\n\t\tfor j in range(len(S)):\n\t\t\tQ.append((j, 0, 0, 0))\n\t\ti = 0\n\t\twhile i < len(Q):\n\t\t\t(j, ind, v, suff) = Q[i]\n\t\t\ti += 1\n\t\t\tc = ord(S[j][ind]) - ord('a')\n\t\t\tif ind > 0:\n\t\t\t\twhile suff > 0 and self.T[suff].next[c] == -1:\n\t\t\t\t\tsuff = self.T[suff].link\n\t\t\t\tif self.T[suff].next[c] != -1:\n\t\t\t\t\tsuff = self.T[suff].next[c]\n\t\t\tv = self.T[v].next[c]\n\t\t\tself.T[v].link = suff\n\t\t\tif ind + 1 < len(S[j]):\n\t\t\t\tQ.append((j, ind + 1, v, suff))\n\n\tdef set_matches(self):\n\t\ti = 0\n\t\tQ = [0]\n\t\twhile i < len(Q):\n\t\t\tv = Q[i]\n\t\t\tself.T[v].matches = self.T[v].leaf + self.T[self.T[v].link].matches\n\t\t\tfor c in self.T[v].trans:\n\t\t\t\tQ.append(self.T[v].next[c])\n\t\t\ti += 1\n\n\tdef build(self, S):\n\t\tfor i in range(len(S)):\n\t\t\tself.insert_trie(S[i])\n\t\tself.set_suffix_link(S)\n\t\tself.set_matches()\n\n\tdef get(self, s):\n\t\tv = 0\n\t\tmatches = []\n\t\tfor i in range(len(s)):\n\t\t\tc = ord(s[i]) - ord('a')\n\t\t\twhile v > 0 and self.T[v].next[c] == -1:\n\t\t\t\tv = self.T[v].link\n\t\t\tif self.T[v].next[c] != -1:\n\t\t\t\tv = self.T[v].next[c]\n\t\t\tmatches.append(self.T[v].matches)\n\t\treturn matches\n\n\tdef printTree(self):\n\t\tfor i in range(len(self.T)):\n\t\t\tprint(str(i) + ' leaf:' + str(self.T[i].leaf) + ' link:' + str(self.T[i].link) + ' matches:' + str(self.T[i].matches) + ' : ', end='')\n\t\t\tfor j in range(26):\n\t\t\t\tprint(' ' + str(chr(j + ord('a'))) + '-' + (str(self.T[i].next[j]) if self.T[i].next[j] != -1 else '_') + ' ', end='')\n\t\t\tprint()\nt = input()\nn = int(input())\npatterns = []\npatterns_rev = []\nfor i in range(n):\n\ts = input()\n\tpatterns.append(s)\n\tpatterns_rev.append(s[::-1])\nt1 = AhoCorasick()\nt2 = AhoCorasick()\nt1.build(patterns)\nt2.build(patterns_rev)\nx1 = t1.get(t)\nx2 = t2.get(t[::-1])[::-1]\nans = 0\nfor i in range(len(x1) - 1):\n\tans += x1[i] * x2[i + 1]\nprint(ans)\n",
        "slowest_solution": "class Node(object):\n\n\tdef __init__(self):\n\t\tsuper(Node, self).__init__()\n\t\tself.next = [-1] * 26\n\t\tself.trans = []\n\t\tself.matches = 0\n\t\tself.leaf = 0\n\t\tself.link = 0\n\nclass AhoCorasick(object):\n\n\tdef __init__(self):\n\t\tsuper(AhoCorasick, self).__init__()\n\t\tself.T = [Node()]\n\t\tself.T[0].link = 0\n\n\tdef insert_trie(self, s):\n\t\tv = 0\n\t\tfor i in range(len(s)):\n\t\t\tc = ord(s[i]) - ord('a')\n\t\t\tif self.T[v].next[c] == -1:\n\t\t\t\tself.T[v].trans.append(c)\n\t\t\t\tself.T[v].next[c] = len(self.T)\n\t\t\t\tself.T.append(Node())\n\t\t\tv = self.T[v].next[c]\n\t\tself.T[v].leaf += 1\n\t\tself.T[v].matches += 1\n\n\tdef set_suffix_link(self, S):\n\t\tQ = []\n\t\tfor j in range(len(S)):\n\t\t\tQ.append((j, 0, 0, 0))\n\t\ti = 0\n\t\twhile i < len(Q):\n\t\t\t(j, ind, v, suff) = Q[i]\n\t\t\ti += 1\n\t\t\tc = ord(S[j][ind]) - ord('a')\n\t\t\tif ind > 0:\n\t\t\t\twhile suff > 0 and self.T[suff].next[c] == -1:\n\t\t\t\t\tsuff = self.T[suff].link\n\t\t\t\tif self.T[suff].next[c] != -1:\n\t\t\t\t\tsuff = self.T[suff].next[c]\n\t\t\tv = self.T[v].next[c]\n\t\t\tself.T[v].link = suff\n\t\t\tif ind + 1 < len(S[j]):\n\t\t\t\tQ.append((j, ind + 1, v, suff))\n\n\tdef set_matches(self):\n\t\ti = 0\n\t\tQ = [0]\n\t\twhile i < len(Q):\n\t\t\tv = Q[i]\n\t\t\tself.T[v].matches = self.T[v].leaf + self.T[self.T[v].link].matches\n\t\t\tfor c in self.T[v].trans:\n\t\t\t\tQ.append(self.T[v].next[c])\n\t\t\ti += 1\n\n\tdef build(self, S):\n\t\tfor i in range(len(S)):\n\t\t\tself.insert_trie(S[i])\n\t\tself.set_suffix_link(S)\n\t\tself.set_matches()\n\n\tdef get(self, s):\n\t\tv = 0\n\t\tmatches = []\n\t\tfor i in range(len(s)):\n\t\t\tc = ord(s[i]) - ord('a')\n\t\t\twhile v > 0 and self.T[v].next[c] == -1:\n\t\t\t\tv = self.T[v].link\n\t\t\tif self.T[v].next[c] != -1:\n\t\t\t\tv = self.T[v].next[c]\n\t\t\tmatches.append(self.T[v].matches)\n\t\treturn matches\n\n\tdef printTree(self):\n\t\tfor i in range(len(self.T)):\n\t\t\tprint(str(i) + ' leaf:' + str(self.T[i].leaf) + ' link:' + str(self.T[i].link) + ' matches:' + str(self.T[i].matches) + ' : ', end='')\n\t\t\tfor j in range(26):\n\t\t\t\tprint(' ' + str(chr(j + ord('a'))) + '-' + (str(self.T[i].next[j]) if self.T[i].next[j] != -1 else '_') + ' ', end='')\n\t\t\tprint()\nt = input()\nn = int(input())\npatterns = []\npatterns_rev = []\nfor i in range(n):\n\ts = input()\n\tpatterns.append(s)\n\tpatterns_rev.append(s[::-1])\nt1 = AhoCorasick()\nt2 = AhoCorasick()\nt1.build(patterns)\nt2.build(patterns_rev)\nx1 = t1.get(t)\nx2 = t2.get(t[::-1])[::-1]\nans = 0\nfor i in range(len(x1) - 1):\n\tans += x1[i] * x2[i + 1]\nprint(ans)\n"
    },
    {
        "task_id": 957,
        "slowest_solution_id": 3,
        "fastest_solution_id": 0,
        "slowest_time": 2.927985191345215,
        "fastest_time": 2.7183170318603516,
        "fastest_solution": "from collections import defaultdict\n\ndef change(u, j):\n\twhile j in u:\n\t\tj = u[j]\n\treturn j\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = input().strip()\n\tb = input().strip()\n\tc = defaultdict(dict)\n\tfor i in range(n):\n\t\tif a[i] > b[i]:\n\t\t\tprint(-1)\n\t\t\tbreak\n\t\tif a[i] != b[i]:\n\t\t\tc[b[i]][a[i]] = 1\n\telse:\n\t\tu = defaultdict(str)\n\t\tans = 0\n\t\tfor i in sorted(c):\n\t\t\tfor j in list(c[i]):\n\t\t\t\tcj = change(u, j)\n\t\t\t\tc[i][cj] = 1\n\t\t\t\tif cj != j:\n\t\t\t\t\tc[i][j] = 0\n\t\t\tfor j in c[i]:\n\t\t\t\tans += 1 if c[i][j] else 0\n\t\t\t\tu[j] = i\n\t\tprint(ans)\n",
        "slowest_solution": "import sys\nfrom collections import defaultdict as dd\nfrom collections import deque\nfrom functools import *\nfrom fractions import Fraction as f\nfrom copy import *\nfrom bisect import *\nfrom heapq import *\nfrom math import *\nfrom itertools import permutations\n\ndef eprint(*args):\n\tprint(*args, file=sys.stderr)\nzz = 1\nif zz:\n\tinput = sys.stdin.readline\nelse:\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('all.txt', 'w')\n\ndef inc(d, c):\n\td[c] = d[c] + 1 if c in d else 1\n\ndef li():\n\treturn [int(xx) for xx in input().split()]\n\ndef fli():\n\treturn [float(x) for x in input().split()]\n\ndef comp(a, b):\n\tif a > b:\n\t\treturn 2\n\treturn 2 if a == b else 0\n\ndef gi():\n\treturn [xx for x in input().split()]\n\ndef fi():\n\treturn int(input())\n\ndef pro(a):\n\treturn reduce(lambda a, b: a * b, a)\n\ndef swap(a, i, j):\n\t(a[i], a[j]) = (a[j], a[i])\n\ndef si():\n\treturn list(input().rstrip())\n\ndef mi():\n\treturn map(int, input().split())\n\ndef gh():\n\tsys.stdout.flush()\n\ndef graph(n, m):\n\tfor i in range(m):\n\t\t(x, y) = mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\n\ndef bo(i):\n\treturn ord(i) - ord('a')\nt = fi()\n\ndef find(a, i):\n\tif a[i] == i:\n\t\treturn i\n\ta[i] = find(a, a[i])\n\treturn a[i]\n\ndef union(a, x, y):\n\txs = find(a, x)\n\tys = find(a, y)\n\tif xs == ys:\n\t\treturn True\n\ta[ys] = xs\n\treturn False\nwhile t > 0:\n\tt -= 1\n\tn = fi()\n\ts = si()\n\tp = si()\n\tl = []\n\ta = [i for i in range(21)]\n\tflag = ans = 0\n\tr = set()\n\tss = set()\n\tfor i in range(n):\n\t\tif s[i] == p[i]:\n\t\t\tcontinue\n\t\tif s[i] > p[i]:\n\t\t\tans = -1\n\t\t\tbreak\n\t\tif union(a, bo(s[i]), bo(p[i])):\n\t\t\tcontinue\n\t\tans += 1\n\tprint(ans)\n"
    },
    {
        "task_id": 994,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 3.7725112438201904,
        "fastest_time": 3.7725112438201904,
        "fastest_solution": "import sys\nimport math\nfrom heapq import *\ninput = sys.stdin.readline\nfrom functools import cmp_to_key\n\ndef pi():\n\treturn int(input())\n\ndef pl():\n\treturn int(input(), 16)\n\ndef ti():\n\treturn list(map(int, input().split()))\n\ndef ts():\n\ts = input()\n\treturn list(s[:len(s) - 1])\n\ndef invr():\n\treturn map(int, input().split())\nmod = 1000000007\nf = []\n\ndef fact(n, m):\n\tglobal f\n\tf = [1 for i in range(n + 1)]\n\tf[0] = 1\n\tfor i in range(1, n + 1):\n\t\tf[i] = f[i - 1] * i % m\n\ndef fast_mod_exp(a, b, m):\n\tres = 1\n\twhile b > 0:\n\t\tif b & 1:\n\t\t\tres = res * a % m\n\t\ta = a * a % m\n\t\tb = b >> 1\n\treturn res\n\ndef inverseMod(n, m):\n\treturn fast_mod_exp(n, m - 2, m)\n\ndef ncr(n, r, m):\n\tif n < 0 or r < 0 or r > n:\n\t\treturn 0\n\tif r == 0:\n\t\treturn 1\n\treturn f[n] * inverseMod(f[n - r], m) % m * inverseMod(f[r], m) % m\n\ndef main():\n\tE()\nmp = [{''} for i in range(300005)]\n\ndef canConnect(a, b):\n\treturn b not in mp[a]\nremaining = {''}\n\ndef dfs(a):\n\ttemp = []\n\tfor b in remaining:\n\t\tif canConnect(a, b):\n\t\t\ttemp.append(b)\n\tfor b in temp:\n\t\tremaining.remove(b)\n\tfor b in temp:\n\t\tdfs(b)\n\ndef E():\n\t[n, m, k] = ti()\n\tmxDegreePossible = n - 1\n\tfor i in range(m):\n\t\t[a, b] = ti()\n\t\tmp[a].add(b)\n\t\tmp[b].add(a)\n\t\tif a == 1 or b == 1:\n\t\t\tmxDegreePossible -= 1\n\tif mxDegreePossible < k:\n\t\tprint('impossible')\n\t\treturn\n\tfor i in range(2, n + 1):\n\t\tremaining.add(i)\n\tcomponents = 0\n\tfor i in range(2, n + 1):\n\t\tif i in remaining and canConnect(1, i):\n\t\t\tremaining.remove(i)\n\t\t\tdfs(i)\n\t\t\tcomponents += 1\n\tremaining.remove('')\n\tif components > k or len(remaining) > 0:\n\t\tprint('impossible')\n\t\treturn\n\tprint('possible')\nmain()\n",
        "slowest_solution": "import sys\nimport math\nfrom heapq import *\ninput = sys.stdin.readline\nfrom functools import cmp_to_key\n\ndef pi():\n\treturn int(input())\n\ndef pl():\n\treturn int(input(), 16)\n\ndef ti():\n\treturn list(map(int, input().split()))\n\ndef ts():\n\ts = input()\n\treturn list(s[:len(s) - 1])\n\ndef invr():\n\treturn map(int, input().split())\nmod = 1000000007\nf = []\n\ndef fact(n, m):\n\tglobal f\n\tf = [1 for i in range(n + 1)]\n\tf[0] = 1\n\tfor i in range(1, n + 1):\n\t\tf[i] = f[i - 1] * i % m\n\ndef fast_mod_exp(a, b, m):\n\tres = 1\n\twhile b > 0:\n\t\tif b & 1:\n\t\t\tres = res * a % m\n\t\ta = a * a % m\n\t\tb = b >> 1\n\treturn res\n\ndef inverseMod(n, m):\n\treturn fast_mod_exp(n, m - 2, m)\n\ndef ncr(n, r, m):\n\tif n < 0 or r < 0 or r > n:\n\t\treturn 0\n\tif r == 0:\n\t\treturn 1\n\treturn f[n] * inverseMod(f[n - r], m) % m * inverseMod(f[r], m) % m\n\ndef main():\n\tE()\nmp = [{''} for i in range(300005)]\n\ndef canConnect(a, b):\n\treturn b not in mp[a]\nremaining = {''}\n\ndef dfs(a):\n\ttemp = []\n\tfor b in remaining:\n\t\tif canConnect(a, b):\n\t\t\ttemp.append(b)\n\tfor b in temp:\n\t\tremaining.remove(b)\n\tfor b in temp:\n\t\tdfs(b)\n\ndef E():\n\t[n, m, k] = ti()\n\tmxDegreePossible = n - 1\n\tfor i in range(m):\n\t\t[a, b] = ti()\n\t\tmp[a].add(b)\n\t\tmp[b].add(a)\n\t\tif a == 1 or b == 1:\n\t\t\tmxDegreePossible -= 1\n\tif mxDegreePossible < k:\n\t\tprint('impossible')\n\t\treturn\n\tfor i in range(2, n + 1):\n\t\tremaining.add(i)\n\tcomponents = 0\n\tfor i in range(2, n + 1):\n\t\tif i in remaining and canConnect(1, i):\n\t\t\tremaining.remove(i)\n\t\t\tdfs(i)\n\t\t\tcomponents += 1\n\tremaining.remove('')\n\tif components > k or len(remaining) > 0:\n\t\tprint('impossible')\n\t\treturn\n\tprint('possible')\nmain()\n"
    },
    {
        "task_id": 956,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 3.874800682067871,
        "fastest_time": 2.6110222339630127,
        "fastest_solution": "from math import ceil\n\ndef gcd(a, b):\n\tif a > b:\n\t\treturn gcd(b, a)\n\twhile a != 0:\n\t\t(a, b) = (b % a, a)\n\treturn b\n\ndef product(lst):\n\tprod = 1\n\tfor n in lst:\n\t\tprod = prod * n % (10 ** 9 + 7)\n\treturn prod\nbounds = None\ncache = None\n\ndef coprime_count(divisor):\n\tif divisor > bounds[-1] // 2:\n\t\treturn 1\n\tif divisor in cache:\n\t\treturn cache[divisor]\n\tscaled_bounds = [n // divisor for n in bounds]\n\ttotal = product(scaled_bounds)\n\tcap = scaled_bounds[0]\n\trest = sum((coprime_count(divisor * d) for d in range(2, cap + 1)))\n\tcache[divisor] = (total - rest) % (10 ** 9 + 7)\n\treturn cache[divisor]\nt = int(input())\nfor _ in range(t):\n\tk = int(input())\n\tbounds = list(map(int, input().split()))\n\tbounds.sort()\n\tcache = dict()\n\ttotal = 0\n\tfor i in range(1, bounds[0] + 1):\n\t\ttotal = (total + i * coprime_count(i)) % (10 ** 9 + 7)\n\tprint(total)\n",
        "slowest_solution": "M = 100010\nP = 1000000007\ndelta = [0] * M\nfor i in range(1, M):\n\tdelta[i] += i\n\tfor j in range(i + i, M, i):\n\t\tdelta[j] -= delta[i]\nt = int(input())\nfor ca in range(t):\n\tk = int(input())\n\tnList = [int(tok) for tok in input().split()]\n\tm = max(nList)\n\tres = 0\n\tfor i in range(1, m + 1):\n\t\tprod = 1\n\t\tfor n in nList:\n\t\t\tprod *= n // i\n\t\tif prod == 0:\n\t\t\tbreak\n\t\tres = (res + prod * delta[i]) % P\n\tprint((res + P) % P)\n"
    },
    {
        "task_id": 981,
        "slowest_solution_id": 2,
        "fastest_solution_id": 3,
        "slowest_time": 2.9269518852233887,
        "fastest_time": 2.7151055335998535,
        "fastest_solution": "import sys\nfrom itertools import *\nfrom math import *\n\ndef solve():\n\t(n, m) = map(int, input().split())\n\th = list(map(int, input().split()))\n\tp = list(map(int, input().split()))\n\t(ss, ll) = (0, int(22000000000.0))\n\twhile ss < ll:\n\t\tavg = (ss + ll) // 2\n\t\tworks = True\n\t\thidx = 0\n\t\tpidx = 0\n\t\twhile hidx < len(h) and pidx < len(p):\n\t\t\tleftget = p[pidx]\n\t\t\tcurpos = h[hidx]\n\t\t\tif curpos - leftget > avg:\n\t\t\t\tworks = False\n\t\t\t\tbreak\n\t\t\tgetbacktime = max(0, 2 * (curpos - leftget))\n\t\t\talsotoright = max(0, avg - getbacktime)\n\t\t\tleftime = max(0, curpos - leftget)\n\t\t\tremtime = max(0, (avg - leftime) // 2)\n\t\t\tfurthestright = curpos + max(alsotoright, remtime)\n\t\t\twhile pidx < len(p) and p[pidx] <= furthestright:\n\t\t\t\tpidx += 1\n\t\t\thidx += 1\n\t\tif pidx != len(p):\n\t\t\tworks = False\n\t\tif works:\n\t\t\tll = avg\n\t\telse:\n\t\t\tss = avg + 1\n\tprint(ss)\nif sys.hexversion == 50594544:\n\tsys.stdin = open('test.txt')\nsolve()\n",
        "slowest_solution": "import sys\n\ndef input():\n\treturn sys.stdin.buffer.readline()[:-1]\nfor T in range(1):\n\t(n, m) = map(int, input().split())\n\tp = list(map(int, input().split()))\n\tq = list(map(int, input().split()))\n\t(ok, ng) = (10 ** 11, -1)\n\twhile ok - ng > 1:\n\t\tx = (ok + ng) // 2\n\t\tflg = True\n\t\tj = 0\n\t\tfor i in range(n):\n\t\t\tl = max(p[i] - q[j], 0)\n\t\t\tif l > x:\n\t\t\t\tflg = False\n\t\t\t\tbreak\n\t\t\twhile j < m and q[j] < p[i]:\n\t\t\t\tj += 1\n\t\t\tif j == m:\n\t\t\t\tbreak\n\t\t\twhile j < m:\n\t\t\t\tr = q[j] - p[i]\n\t\t\t\tif min(l, r) * 2 + max(l, r) <= x:\n\t\t\t\t\tj += 1\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tif j == m:\n\t\t\t\tbreak\n\t\tif flg == False or j < m:\n\t\t\tng = x\n\t\telse:\n\t\t\tok = x\n\tprint(ok)\n"
    },
    {
        "task_id": 961,
        "slowest_solution_id": 4,
        "fastest_solution_id": 9,
        "slowest_time": 2.931675434112549,
        "fastest_time": 2.6377828121185303,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor tc in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = [0] * (n + 1)\n\tfor i in range(n):\n\t\tb[a[i]] = i\n\tlr = (n + 1) // 2\n\thr = (n + 2) // 2\n\tl = (n - 1) // 2\n\th = (n + 4) // 2\n\tans = 0\n\tif b[lr] > b[hr]:\n\t\tans = 1\n\twhile l >= 1 and h <= n:\n\t\tif b[l] < b[l + 1] <= b[h - 1] < b[h]:\n\t\t\tpass\n\t\telse:\n\t\t\tans += 1\n\t\t\tb[l] = 0\n\t\t\tb[h] = n - 1\n\t\tl -= 1\n\t\th += 1\n\tprint(ans)\n",
        "slowest_solution": "def solve():\n\tn = int(input())\n\tv1 = list(map(int, input().split()))\n\tv2 = [0] * (n + 1)\n\tfor x in v1:\n\t\tv2[x] = v2[x - 1] + 1\n\tfor i in range(1, (n + 1) // 2 + 1):\n\t\tok = n - 2 * (i - 1)\n\t\tif v2[n - i + 1] >= ok:\n\t\t\tprint(i - 1)\n\t\t\treturn\n\tprint((n + 1) // 2)\nt = int(input())\nfor _ in range(t):\n\tsolve()\n"
    },
    {
        "task_id": 963,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.9315507411956787,
        "fastest_time": 2.3715262413024902,
        "fastest_solution": "try:\n\tt = int(input())\n\ti = 1\n\twhile i <= t:\n\t\ti = i + 1\n\t\ts = input()\n\t\tuniq = []\n\t\tuniq_frq = []\n\t\tdick = {}\n\t\tfor x in s:\n\t\t\tif x not in dick.keys():\n\t\t\t\tdick[x] = 1\n\t\t\telse:\n\t\t\t\tdick[x] = dick[x] + 1\n\t\tuniq_frq = list(dick.values())\n\t\tcount1 = 0\n\t\tcount2 = 0\n\t\to = 0\n\t\tfor p in range(0, len(uniq_frq)):\n\t\t\tif int(uniq_frq[p]) % 2 == 0:\n\t\t\t\tcount2 = count2 + int(uniq_frq[p]) // 2\n\t\t\telif int(uniq_frq[p]) % 2 != 0:\n\t\t\t\to = int(uniq_frq[p] // 2) - 1\n\t\t\t\tif o < 0:\n\t\t\t\t\to = 0\n\t\t\t\tcount2 = count2 + o\n\t\tfor u in range(0, len(uniq_frq)):\n\t\t\tif uniq_frq[u] == 1:\n\t\t\t\tcount1 = count1 + 1\n\t\tif count2 >= count1:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\nexcept:\n\tpass\n",
        "slowest_solution": "n = int(input())\nfor i in range(n):\n\tval = input()\n\tcount = {}\n\tfor i in val:\n\t\tif i not in count:\n\t\t\tcount[i] = 1\n\t\telse:\n\t\t\tcount[i] += 1\n\todds = 0\n\tfor i in count:\n\t\tif count[i] % 2 == 1:\n\t\t\todds += 1\n\tif (len(val) - odds) // 2 >= odds and len(val) != odds:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 964,
        "slowest_solution_id": 4,
        "fastest_solution_id": 9,
        "slowest_time": 2.9792497158050537,
        "fastest_time": 2.540820360183716,
        "fastest_solution": "(n, x, y) = map(int, input().split())\nA = input()\ncnt = 0\nk = A.find('0')\nwhile k < n and k != -1:\n\twhile A[k] != '1':\n\t\tk += 1\n\t\tif k >= n:\n\t\t\tbreak\n\tcnt += 1\n\tk = A.find('0', k)\nif cnt == 0:\n\tprint(0)\nelse:\n\tprint((cnt - 1) * min(x, y) + y)\n",
        "slowest_solution": "(n, x, y) = list(map(int, input().split()))\na = input()\n(n0, n1) = (len(list(filter(lambda x: x != '', a.split('1')))), len(list(filter(lambda x: x != '', a.split('0')))))\nprint(min(max(n0 * x - x + y, 0), max(n0 * y, 0)))\n"
    },
    {
        "task_id": 965,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.903371810913086,
        "fastest_time": 2.5045032501220703,
        "fastest_solution": "from sys import stdin, stdout\nx = stdin.readline().replace('\\n', '')\nlst = x.split(' ')\ngenderLst = []\ntypeLst = []\nvalid = 1\nfor x in lst:\n\tif x.endswith('lios') or x.endswith('etr') or x.endswith('initis'):\n\t\tgenderLst.append(1)\n\telif x.endswith('liala') or x.endswith('etra') or x.endswith('inites'):\n\t\tgenderLst.append(0)\n\telse:\n\t\tvalid = 0\nif valid == 0:\n\tprint('NO')\n\texit()\nfor x in lst:\n\tif x.endswith('lios') or x.endswith('liala'):\n\t\ttypeLst.append(1)\n\tif x.endswith('etr') or x.endswith('etra'):\n\t\ttypeLst.append(2)\n\tif x.endswith('initis') or x.endswith('inites'):\n\t\ttypeLst.append(3)\nif genderLst[0] == 1 and 0 in genderLst:\n\tvalid = 0\nif genderLst[0] == 0 and 1 in genderLst:\n\tvalid = 0\nif len(typeLst) != 1:\n\tif typeLst.count(2) != 1:\n\t\tvalid = 0\ni = 0\nwhile i < len(typeLst) and typeLst[i] == 1:\n\ti += 1\nwhile i < len(typeLst) and typeLst[i] == 2:\n\ti += 1\nwhile i < len(typeLst) and typeLst[i] == 3:\n\ti += 1\nif i != len(typeLst):\n\tvalid = 0\nif valid:\n\tprint('YES')\nelse:\n\tprint('NO')\n",
        "slowest_solution": "(s, n, m, f) = (input().split(), False, False, False)\n\ndef cc(w, me, fe):\n\tglobal m, f\n\tif w.endswith(me):\n\t\tm = True\n\t\treturn True\n\telif w.endswith(fe):\n\t\tf = True\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef ad(w):\n\treturn cc(w, 'lios', 'liala')\n\ndef nn(w):\n\treturn cc(w, 'etr', 'etra')\n\ndef vb(w):\n\treturn cc(w, 'initis', 'inites')\nfor w in s:\n\tif not n:\n\t\tif ad(w) or (vb(w) and len(s) == 1):\n\t\t\tpass\n\t\telif nn(w):\n\t\t\tn = True\n\t\telse:\n\t\t\tprint('NO')\n\t\t\texit()\n\telif not vb(w):\n\t\tprint('NO')\n\t\texit()\nprint('YES' if len(s) == 1 or (n and m ^ f) else 'NO')\n"
    },
    {
        "task_id": 967,
        "slowest_solution_id": 7,
        "fastest_solution_id": 9,
        "slowest_time": 2.957563638687134,
        "fastest_time": 1.9306385517120361,
        "fastest_solution": "for _ in range(int(input())):\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tX = int(input())\n\tcnt = 0\n\td = {}\n\tfor i in range(N):\n\t\tA[i] = A[i] & X\n\t\tif A[i] in d:\n\t\t\td.update({A[i]: d[A[i]] + 1})\n\t\telse:\n\t\t\td.update({A[i]: 1})\n\tfor i in d.values():\n\t\tcnt += i * i\n\tprint(cnt)\n",
        "slowest_solution": "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tx = int(input())\n\td = {}\n\tfor e in l:\n\t\tandd = e & x\n\t\tif andd in d.keys():\n\t\t\td[andd] += 1\n\t\telse:\n\t\t\td[andd] = 1\n\tcount = 0\n\tfor k in d.keys():\n\t\tcount += d[k] * d[k]\n\tprint(count)\n"
    },
    {
        "task_id": 991,
        "slowest_solution_id": 1,
        "fastest_solution_id": 1,
        "slowest_time": 2.978537082672119,
        "fastest_time": 2.978537082672119,
        "fastest_solution": "s = input()\na = s.split(':')\na = [int(a[0]), int(a[1])]\nif a[0] >= 12:\n\ta[0] -= 12\nm = a[1] * 6\nh = a[0] * 30 + a[1] / 2\nif h % 1 == 0:\n\th = int(h)\nprint(h, m)\n",
        "slowest_solution": "s = input()\na = s.split(':')\na = [int(a[0]), int(a[1])]\nif a[0] >= 12:\n\ta[0] -= 12\nm = a[1] * 6\nh = a[0] * 30 + a[1] / 2\nif h % 1 == 0:\n\th = int(h)\nprint(h, m)\n"
    },
    {
        "task_id": 971,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.9522616863250732,
        "fastest_time": 1.6701648235321045,
        "fastest_solution": "n = int(input())\nfreq = list(map(int, input().split()))\nk = int(input())\nkeys = list(map(int, input().split()))\n\nfreq = sorted(freq, reverse=True)\npos = {}\n\nfor key in keys:\n\tfor i in range(key):\n\t\tif i+1 not in pos:\n\t\t\tpos[i+1]=0\n\t\tpos[i+1]+=1\n\ncur = 0\ns = 0\n\nfor key in sorted(pos.keys()):\n\tval = pos[key]\n\ts += key*sum(freq[cur:cur+val])\n\tcur += val\n\nif sum(keys)>=n:\n\tprint(s)\nelse:\n\tprint((-1))\n",
        "slowest_solution": "def main():\n\n\tn = input()\n\tfreq = input()\n\tk = input()\n\tkeys = input()\n\n\tn = int(n)\n\tfreq = [int(f) for f in freq.split()]\n\t\n\tkeys = [int(k) for k in keys.split()]\n\tkeys_max = sum(keys)\n\n\tif keys_max < n:\n\t\tprint(-1)\n\t\treturn\n\n\tfreq.sort(reverse=True)\n\tkeys_stack = []\n\n\tfor k in keys:\n\t\tfor i in range(1, k + 1):\n\t\t\tkeys_stack.append(i)\n\tkeys_stack.sort()\n\n\ttotal = 0\n\tfor f in freq:\n\t\tk = keys_stack.pop(0)\n\t\ttotal += f * k\n\n\tprint(total)\n\treturn\n\n\nif '__main__' == __name__:\n\tmain()\n"
    },
    {
        "task_id": 974,
        "slowest_solution_id": 4,
        "fastest_solution_id": 9,
        "slowest_time": 2.956686019897461,
        "fastest_time": 1.6929173469543457,
        "fastest_solution": "import sys\ninput = sys.stdin.readline\nfrom collections import *\n\nclass Unionfind:\n\n\tdef __init__(self, n):\n\t\tself.par = [-1] * n\n\t\tself.rank = [1] * n\n\n\tdef root(self, x):\n\t\tr = x\n\t\twhile not self.par[r] < 0:\n\t\t\tr = self.par[r]\n\t\tt = x\n\t\twhile t != r:\n\t\t\ttmp = t\n\t\t\tt = self.par[t]\n\t\t\tself.par[tmp] = r\n\t\treturn r\n\n\tdef unite(self, x, y):\n\t\trx = self.root(x)\n\t\try = self.root(y)\n\t\tif rx == ry:\n\t\t\treturn\n\t\tif self.rank[rx] <= self.rank[ry]:\n\t\t\tself.par[ry] += self.par[rx]\n\t\t\tself.par[rx] = ry\n\t\t\tif self.rank[rx] == self.rank[ry]:\n\t\t\t\tself.rank[ry] += 1\n\t\telse:\n\t\t\tself.par[rx] += self.par[ry]\n\t\t\tself.par[ry] = rx\n(n, m, k) = map(int, input().split())\ns = [input()[:-1] for _ in range(n)]\nuf = Unionfind(n * m)\nfor i in range(n):\n\tfor j in range(m):\n\t\tif s[i][j] == '.':\n\t\t\tif i + 1 < n and s[i + 1][j] == '.':\n\t\t\t\tuf.unite(m * i + j, m * (i + 1) + j)\n\t\t\tif j + 1 < m and s[i][j + 1] == '.':\n\t\t\t\tuf.unite(m * i + j, m * i + j + 1)\nd = defaultdict(int)\nfor i in range(n):\n\tfor j in range(m):\n\t\tif s[i][j] == '.':\n\t\t\tfor (ni, nj) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n\t\t\t\tif 0 <= ni < n and 0 <= nj < m and (s[ni][nj] == '*'):\n\t\t\t\t\td[uf.root(m * i + j)] += 1\nfor _ in range(k):\n\t(x, y) = map(int, input().split())\n\tprint(d[uf.root(m * (x - 1) + y - 1)])\n",
        "slowest_solution": "import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass Factorial:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorials = [1, 1]\n\t\tself.invModulos = [0, 1]\n\t\tself.invFactorial_ = [1, 1]\n\n\tdef calc(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.factorials):\n\t\t\treturn self.factorials[n]\n\t\tnextArr = [0] * (n + 1 - len(self.factorials))\n\t\tinitialI = len(self.factorials)\n\t\tprev = self.factorials[-1]\n\t\tm = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * i % m\n\t\tself.factorials += nextArr\n\t\treturn self.factorials[n]\n\n\tdef inv(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n^(-1)')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tp = self.MOD\n\t\tpi = n % p\n\t\tif pi < len(self.invModulos):\n\t\t\treturn self.invModulos[pi]\n\t\tnextArr = [0] * (n + 1 - len(self.invModulos))\n\t\tinitialI = len(self.invModulos)\n\t\tfor i in range(initialI, min(p, n + 1)):\n\t\t\tnext = -self.invModulos[p % i] * (p // i) % p\n\t\t\tself.invModulos.append(next)\n\t\treturn self.invModulos[pi]\n\n\tdef invFactorial(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate (n^(-1))!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.invFactorial_):\n\t\t\treturn self.invFactorial_[n]\n\t\tself.inv(n)\n\t\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\n\t\tinitialI = len(self.invFactorial_)\n\t\tprev = self.invFactorial_[-1]\n\t\tp = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\n\t\tself.invFactorial_ += nextArr\n\t\treturn self.invFactorial_[n]\n\nclass Combination:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorial = Factorial(MOD)\n\n\tdef ncr(self, n, k):\n\t\tif k < 0 or n < k:\n\t\t\treturn 0\n\t\tk = min(k, n - k)\n\t\tf = self.factorial\n\t\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef dfs(start_n, start_m, cnt):\n\tans = 0\n\tq = deque([(start_n, start_m)])\n\tvisited[start_n][start_m] = cnt\n\twhile q:\n\t\t(pos_n, pos_m) = q.pop()\n\t\tfor (i, j) in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n\t\t\tnext_pos_n = pos_n + i\n\t\t\tnext_pos_m = pos_m + j\n\t\t\tif 0 <= next_pos_n < n and 0 <= next_pos_m < m:\n\t\t\t\tif s[next_pos_n][next_pos_m] == '*':\n\t\t\t\t\tans += 1\n\t\t\t\t\tcontinue\n\t\t\t\tif visited[next_pos_n][next_pos_m] == -1:\n\t\t\t\t\tvisited[next_pos_n][next_pos_m] = cnt\n\t\t\t\t\tq.append((next_pos_n, next_pos_m))\n\tans_memo[cnt] = ans\n(n, m, k) = map(int, input().split())\ns = [input() for i in range(n)]\ninfo = [list(map(int, input().split())) for i in range(k)]\nans_memo = {}\nnext_pos = [0, 1]\nvisited = [[-1] * m for i in range(n)]\ncnt = 0\nfor i in range(n):\n\tfor j in range(m):\n\t\tif s[i][j] == '*' or visited[i][j] >= 0:\n\t\t\tcontinue\n\t\tdfs(i, j, cnt)\n\t\tcnt += 1\nfor i in range(k):\n\t(tmp_n, tmp_m) = info[i]\n\ttmp = visited[tmp_n - 1][tmp_m - 1]\n\tprint(ans_memo[tmp])\n"
    },
    {
        "task_id": 987,
        "slowest_solution_id": 0,
        "fastest_solution_id": 0,
        "slowest_time": 2.936540126800537,
        "fastest_time": 2.936540126800537,
        "fastest_solution": "t = int(input())\nfor _ in range(t):\n\t(x, n) = map(int, input().split())\n\tif n < 4 or (n ^ n >> 1 ^ x) & 1:\n\t\tprint('impossible')\n\telif x == n == 5:\n\t\tprint('01102')\n\telse:\n\t\tr = ['0'] * n\n\t\tr[x - 1] = '2'\n\t\ts = (n * (n + 1) // 2 - x) // 2\n\t\twhile s > n:\n\t\t\tif x != n != s - x:\n\t\t\t\tr[n - 1] = '1'\n\t\t\t\ts -= n\n\t\t\tn -= 1\n\t\tr[s - 1] = '1'\n\t\tprint(''.join(r))\n",
        "slowest_solution": "t = int(input())\nfor _ in range(t):\n\t(x, n) = map(int, input().split())\n\tif n < 4 or (n ^ n >> 1 ^ x) & 1:\n\t\tprint('impossible')\n\telif x == n == 5:\n\t\tprint('01102')\n\telse:\n\t\tr = ['0'] * n\n\t\tr[x - 1] = '2'\n\t\ts = (n * (n + 1) // 2 - x) // 2\n\t\twhile s > n:\n\t\t\tif x != n != s - x:\n\t\t\t\tr[n - 1] = '1'\n\t\t\t\ts -= n\n\t\t\tn -= 1\n\t\tr[s - 1] = '1'\n\t\tprint(''.join(r))\n"
    },
    {
        "task_id": 960,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 4.079080820083618,
        "fastest_time": 1.8187634944915771,
        "fastest_solution": "n,m=list(map(int,input().split()))\ncities=input().split()\nINF=10000000\nd={}\nadj=[[INF for i in range(n)] for j in range(n)]\nfor i in range(n):\n\td[cities[i]]=i\nfor j in range(m):\n\ta,b,c=input().split()\n\tadj[d[a]][d[b]]=int(c)\n\tadj[d[b]][d[a]]=int(c)\ndef f_w(n):\n\tfor k in range(n):\n\t\tfor i in range(n):\n\t\t\tfor j in range(n):\n\t\t\t\tadj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j])\nf_w(n)\nq=int(input())\nwhile q!=0:\n\ta,b=input().split()\n\tprint(adj[d[a]][d[b]])\n\tq-=1\n\t\t\t\t\t  \n\t\t\n",
        "slowest_solution": "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\nfrom heapq import heappush, heappop\nfrom datetime import datetime\nfrom copy import deepcopy\ngraph = { \n\t'a' : {'b':-2},\n\t'b' : {'c':-1},\n\t'c' : {'x':2, 'a':4, 'y':-3},\n\t'z' : {'x':1, 'y':-4},\n\t'x' : {},\n\t'y' : {},\n}\n\ninf = float('inf')\ndist = {}\n\ndef read_graph(n, m):\n\tinp = input()\n\tvertices = inp.split(' ')\n\t\n\tgraph = dict()\n\tfor loop in range(m):\n\t\tinp = input()\n\t\tinpa = inp.split(' ')\n\t\tif inpa[0] not in graph:\n\t\t\tgraph[inpa[0]] = dict()\n\t\tgraph[inpa[0]][inpa[1]] = int(inpa[2])\n\t\tif inpa[1] not in graph:\n\t\t\tgraph[inpa[1]] = dict()\n\t\tgraph[inpa[1]][inpa[0]] = int(inpa[2])\n\t\t\n\tfor v in vertices:\n\t\tif v not in graph:\n\t\t\tgraph[v] = dict()\n\t\n\treturn graph\n\ndef dijkstra(graph, s):\n\tn = len(list(graph.keys()))\n\tdist = dict()\n\tQ = list()\n\t\n\tfor v in graph:\n\t\tdist[v] = inf\n\tdist[s] = 0\n\t\n\theappush(Q, (dist[s], s))\n\n\twhile Q:\n\t\td, u = heappop(Q)\n\t\tif d < dist[u]:\n\t\t\tdist[u] = d\n\t\tfor v in graph[u]:\n\t\t\tif dist[v] > dist[u] + graph[u][v]:\n\t\t\t\tdist[v] = dist[u] + graph[u][v]\n\t\t\t\theappush(Q, (dist[v], v))\n\treturn dist\n\ndef initialize_single_source(graph, s):\n\tfor v in graph:\n\t\tdist[v] = inf\n\tdist[s] = 0\n\t\ndef relax(graph, u, v):\n\tif dist[v] > dist[u] + graph[u][v]:\n\t\tdist[v] = dist[u] + graph[u][v]\n\ndef bellman_ford(graph, s):\n\tinitialize_single_source(graph, s)\n\tedges = [(u, v) for u in graph for v in list(graph[u].keys())]\n\tnumber_vertices = len(graph)\n\tfor i in range(number_vertices-1):\n\t\tfor (u, v) in edges:\n\t\t\trelax(graph, u, v)\n\tfor (u, v) in edges:\n\t\tif dist[v] > dist[u] + graph[u][v]:\n\t\t\treturn False # there exists a negative cycle\n\treturn True\n\ndef add_extra_node(graph):\n\tgraph[0] = dict()\n\tfor v in list(graph.keys()):\n\t\tif v != 0:\n\t\t\tgraph[0][v] = 0\n\ndef reweighting(graph_new):\n\tadd_extra_node(graph_new)\n\tif not bellman_ford(graph_new, 0):\n\t\t# graph contains negative cycles\n\t\treturn False\n\tfor u in graph_new:\n\t\tfor v in graph_new[u]:\n\t\t\tif u != 0:\n\t\t\t\tgraph_new[u][v] += dist[u] - dist[v]\n\tdel graph_new[0]\n\treturn graph_new\n\ndef johnsons(graph_new):\n\tgraph = reweighting(graph_new)\n\tif not graph:\n\t\treturn False\n\tfinal_distances = {}\n\tfor u in graph:\n\t\tfinal_distances[u] = dijkstra(graph, u)\n\n\tfor u in final_distances:\n\t\tfor v in final_distances[u]:\n\t\t\tfinal_distances[u][v] += dist[v] - dist[u]\n\treturn final_distances\n\t\t\t\ndef compute_min(final_distances):\n\treturn min(final_distances[u][v] for u in final_distances for v in final_distances[u])\n\nif __name__ == \"__main__\":\n\t# graph = read_graph(\"graph.txt\", 1000)\n\tinp = input()\n\tinpa = inp.split(' ')\n\tgraph = read_graph(int(inpa[0]), int(inpa[1]))\n\tgraph_new = deepcopy(graph)\n\tt1 = datetime.utcnow()\n\tfinal_distances =  johnsons(graph_new)\n\t# if not final_distances:\n\t\t# print \"Negative cycle\"\n\t# else:\n\t\t# print compute_min(final_distances)\n\t# print datetime.utcnow() - t1\n\t# print final_distances\n\tn = eval(input())\n\tfor loop in range(n):\n\t\tinp = input()\n\t\tinpa = inp.split(' ')\n\t\tprint(final_distances[inpa[0]][inpa[1]])\n"
    },
    {
        "task_id": 976,
        "slowest_solution_id": 1,
        "fastest_solution_id": 6,
        "slowest_time": 2.9047274589538574,
        "fastest_time": 1.6657512187957764,
        "fastest_solution": "n = int(input())\n(x1, y1) = map(lambda x: int(x) - 1, input().split())\n(x2, y2) = map(lambda x: int(x) - 1, input().split())\nmatrix = []\nfor _ in range(n):\n\tmatrix.append(list(input()))\naux = [[] for _ in range(2)]\nindex = 0\nnext = [[0, -1], [0, 1], [-1, 0], [1, 0]]\n\ndef bfs(x, y):\n\tq = [[x, y]]\n\twhile len(q):\n\t\t(i, j) = q.pop()\n\t\tmatrix[i][j] = '1'\n\t\taux[index].append([i, j])\n\t\tfor (a, b) in next:\n\t\t\tif i + a >= 0 and j + b >= 0 and (i + a < n) and (j + b < n):\n\t\t\t\tif matrix[i + a][j + b] == '0':\n\t\t\t\t\tq.append([i + a, j + b])\nbfs(x1, y1)\nif matrix[x2][y2] == 1:\n\tprint(0)\nelse:\n\tindex += 1\n\tbfs(x2, y2)\n\tans = 5000\n\tfor (x1, y1) in aux[0]:\n\t\tfor (x2, y2) in aux[1]:\n\t\t\tans = min(ans, (x1 - x2) ** 2 + (y1 - y2) ** 2)\n\tprint(ans)\n",
        "slowest_solution": "import itertools\nn = int(input())\n(x1, y1) = [int(a) - 1 for a in input().split()]\n(x2, y2) = [int(a) - 1 for a in input().split()]\nboard = [list(input()) for i in range(n)]\n\ndef ma_sens(x, y):\n\tglobal board\n\treturn not (x < 0 or x >= n or y < 0 or (y >= n) or (board[x][y] != '0'))\n\ndef bfs(x, y, c):\n\tglobal board\n\ttab = [(x, y)]\n\tpocz = 0\n\tboard[x][y] = c\n\twhile pocz < len(tab):\n\t\t(x, y) = tab[pocz]\n\t\tpocz += 1\n\t\tfor (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n\t\t\tif ma_sens(x + dx, y + dy):\n\t\t\t\tboard[x + dx][y + dy] = c\n\t\t\t\ttab.append((x + dx, y + dy))\n\treturn tab\nres = 13337\nfor (a, b) in itertools.product(bfs(x1, y1, 's'), bfs(x2, y2, 'e')):\n\tres = min(res, (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)\nprint(res)\n"
    },
    {
        "task_id": 975,
        "slowest_solution_id": 3,
        "fastest_solution_id": 9,
        "slowest_time": 2.94667911529541,
        "fastest_time": 1.3845486640930176,
        "fastest_solution": "from math import gcd\nfor i in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tg = a[0]\n\tfor i in range(1, n):\n\t\tg = gcd(g, a[i])\n\tprint(n - a.count(g))\n",
        "slowest_solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = min(a)\n\tc = 0\n\tfor i in range(n):\n\t\tif a[i] % b == 0:\n\t\t\tc += 1\n\tif c == n:\n\t\tprint(n - a.count(b))\n\telse:\n\t\tprint(n)\n"
    },
    {
        "task_id": 980,
        "slowest_solution_id": 3,
        "fastest_solution_id": 9,
        "slowest_time": 2.907419443130493,
        "fastest_time": 1.485222578048706,
        "fastest_solution": "def check_cond(mid, H, K, tot_1, tot_0):\n\tif mid != 0 and tot_0[H] - tot_0[mid - 1] <= K and (tot_1[H] - tot_1[mid - 1] <= K):\n\t\treturn True\n\tif mid == 0 and tot_0[H] <= K and (tot_1[H] <= K):\n\t\treturn True\n\treturn False\n\ndef find_index(tot_0, tot_1, L, H, K):\n\t(l, h) = (L, H)\n\tans = H\n\twhile l <= h:\n\t\tmid = (l + h) // 2\n\t\tif check_cond(mid, H, K, tot_1, tot_0):\n\t\t\tans = mid\n\t\t\th = mid - 1\n\t\telse:\n\t\t\tl = mid + 1\n\treturn ans\n\ndef find_ind(res, L, R):\n\t(l, h) = (L, R)\n\tans = L\n\twhile l <= h:\n\t\tmid = (l + h) // 2\n\t\tif max(L, mid - res[mid] + 1) == L:\n\t\t\tans = mid\n\t\t\tl = mid + 1\n\t\telse:\n\t\t\th = mid - 1\n\treturn ans\nfor _ in range(int(input())):\n\t(N, K, Q) = map(int, input().split())\n\tS = input()\n\ttot_0 = [0 for _ in range(N)]\n\ttot_1 = [0 for _ in range(N)]\n\tfor i in range(N):\n\t\tif i == 0:\n\t\t\tif S[i] == '0':\n\t\t\t\ttot_0[i] += 1\n\t\t\telse:\n\t\t\t\ttot_1[i] += 1\n\t\telif S[i] == '0':\n\t\t\ttot_0[i] = tot_0[i - 1] + 1\n\t\t\ttot_1[i] = tot_1[i - 1]\n\t\telse:\n\t\t\ttot_1[i] = tot_1[i - 1] + 1\n\t\t\ttot_0[i] = tot_0[i - 1]\n\tres = [0 for _ in range(N)]\n\tres[0] = 1\n\tfor j in range(1, N):\n\t\tind = find_index(tot_0, tot_1, 0, j, K)\n\t\tans = j - ind + 1\n\t\tres[j] = ans\n\tre = [res[0]]\n\ttot = res[0]\n\tfor i in range(1, N):\n\t\ttot += res[i]\n\t\tre.append(tot)\n\tfor j in range(Q):\n\t\t(L, R) = map(int, input().split())\n\t\t(L, R) = (L - 1, R - 1)\n\t\tind = find_ind(res, L, R)\n\t\tcount = (ind - L + 1) * (L + ind) // 2 - (L - 1) * (ind - L + 1)\n\t\tcount += re[R] - re[ind]\n\t\tprint(count)\n",
        "slowest_solution": "def precompute(s, n, k, far, sumfar):\n\t(j, count0, count1) = (1, 0, 0)\n\tif s[0] == '0':\n\t\tcount0 += 1\n\telse:\n\t\tcount1 += 1\n\tfor i in range(1, n + 1):\n\t\twhile j <= n and count0 <= k and (count1 <= k):\n\t\t\tj += 1\n\t\t\tif j > n:\n\t\t\t\tbreak\n\t\t\tif s[j - 1] == '1':\n\t\t\t\tcount1 += 1\n\t\t\telse:\n\t\t\t\tcount0 += 1\n\t\tfar[i] = j\n\t\tif s[i - 1] == '0':\n\t\t\tcount0 -= 1\n\t\telse:\n\t\t\tcount1 -= 1\n\tfor i in range(1, n + 1):\n\t\tsumfar[i] = sumfar[i - 1] + far[i]\n\ndef answer_query(l, r):\n\tk1 = l - 1\n\tk2 = r + 1\n\twhile k2 - k1 > 1:\n\t\tkm = (k1 + k2) // 2\n\t\tif far[km] <= r:\n\t\t\tk1 = km\n\t\telse:\n\t\t\tk2 = km\n\tk = k1\n\tanswer = sumfar[k] - sumfar[l - 1] + (r - k) * (r + 1) - (r * (r + 1) // 2 - l * (l - 1) // 2)\n\treturn answer\nfor _ in range(int(input().strip())):\n\t(n, k, q) = map(int, input().strip().split())\n\tstring = input().strip()\n\tfar = [0 for i in range(n + 1)]\n\tsumfar = [0 for i in range(n + 1)]\n\tprecompute(string, n, k, far, sumfar)\n\tfor idx in range(q):\n\t\t(l, r) = map(int, input().strip().split())\n\t\tans = answer_query(l, r)\n\t\tprint(ans)\n"
    },
    {
        "task_id": 979,
        "slowest_solution_id": 3,
        "fastest_solution_id": 9,
        "slowest_time": 2.8893954753875732,
        "fastest_time": 1.3167588710784912,
        "fastest_solution": "import sys, os, io\nimport math, bisect, operator\n(inf, mod) = (float('inf'), 10 ** 9 + 7)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nNeo = lambda : list(map(int, input().split()))\n\ndef dijakstra(weight, k):\n\theap = [(0, k)]\n\theapify(heap)\n\tdist = defaultdict(tuple)\n\twhile heap:\n\t\t(cost, u) = heappop(heap)\n\t\tif u not in dist:\n\t\t\tdist[u] = cost\n\t\t\tfor v in weight[u]:\n\t\t\t\theappush(heap, (dist[u] + weight[u][v], v))\n\treturn dist\n(n, m) = Neo()\n(G1, G2) = (defaultdict(dict), defaultdict(dict))\ns = set()\nfor i in range(m):\n\t(u, v) = Neo()\n\tG1[u][v] = 1\n\tG1[v][u] = 1\n\ts.add((u, v))\n\ts.add((v, u))\nfor i in range(1, n + 1):\n\tfor j in range(i + 1, n + 1):\n\t\tif (i, j) not in s:\n\t\t\tG2[i][j] = 1\n\t\t\tG2[j][i] = 1\nif (1, n) in s:\n\tdist = dijakstra(G2, 1)\n\tif n not in dist:\n\t\tprint(-1)\n\telse:\n\t\tprint(dist[n])\nelse:\n\tdist = dijakstra(G1, 1)\n\tif n not in dist:\n\t\tprint(-1)\n\telse:\n\t\tprint(dist[n])\n",
        "slowest_solution": "def routes(n, m):\n\tdistance = [0] * (n + 1)\n\tfor i in range(n + 1):\n\t\tdistance[i] = [1] * (n + 1)\n\tfor x in range(m):\n\t\t(a, b) = map(int, input().split())\n\t\tdistance[a][b] = distance[b][a] = 2\n\tx = 3 - distance[1][n]\n\ty = [0] * (n + 1)\n\ti = 1\n\td = [n + 1] * (n + 1)\n\tresult = d[1] = 0\n\twhile i != n:\n\t\ty[i] = 1\n\t\tfor j in range(1, n + 1):\n\t\t\tif y[j] == 0 and distance[i][j] == x and (d[j] > d[i] + 1):\n\t\t\t\td[j] = d[i] + 1\n\t\tend = n + 1\n\t\tfor j in range(1, n + 1):\n\t\t\tif y[j] == 0 and d[j] < end:\n\t\t\t\tend = d[j]\n\t\t\t\ti = j\n\t\tif end == n + 1:\n\t\t\tresult = -1\n\t\t\tbreak\n\t\telif i == n:\n\t\t\tresult = d[n]\n\t\t\tbreak\n\treturn result\n(n, m) = map(int, input().split())\nprint(routes(n, m))\n"
    },
    {
        "task_id": 983,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.8923001289367676,
        "fastest_time": 1.2247867584228516,
        "fastest_solution": "(ip, rd) = (lambda : input().split(), lambda : map(int, ip()))\n(n, k, m) = rd()\na = ip()\nd = dict(zip(a, rd()))\nfor _ in range(k):\n\tx = list(rd())[1:]\n\tm = min((d[a[i - 1]] for i in x))\n\tfor i in x:\n\t\td[a[i - 1]] = m\nprint(sum((d[x] for x in ip())))\n",
        "slowest_solution": "(n, k, m) = map(int, input().split())\nL = input().split()\nA = list(map(int, input().split()))\nfor i in range(k):\n\tinp = list(map(int, input().split()))\n\tX = []\n\tind = 1\n\tfor i in range(2, inp[0] + 1):\n\t\tif A[inp[i] - 1] < A[inp[ind] - 1]:\n\t\t\tind = i\n\tfor i in range(1, inp[0] + 1):\n\t\tA[inp[i] - 1] = A[inp[ind] - 1]\ndic = dict()\nfor i in range(n):\n\tdic[L[i]] = A[i]\nmes = input().split()\nout = 0\nfor i in mes:\n\tout += dic[i]\nprint(out)\n"
    },
    {
        "task_id": 989,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.9620449542999268,
        "fastest_time": 1.1990885734558105,
        "fastest_solution": "I = lambda : tuple(map(int, input().split()))\ninput()\n(a, b, c) = (I(), I(), I())\nprint('YES' if all(((i - j) / (i - k) > 0 for (i, j, k) in zip(a, b, c))) else 'NO')\n",
        "slowest_solution": "n = int(input())\n(bx, by) = map(int, input().split())\n(ax, ay) = map(int, input().split())\n(cx, cy) = map(int, input().split())\nif ax < bx and cx < bx and (ay < by) and (cy < by):\n\tprint('YES')\nelif ax < bx and cx < bx and (ay > by) and (cy > by):\n\tprint('YES')\nelif ax > bx and cx > bx and (ay > by) and (cy > by):\n\tprint('YES')\nelif ax > bx and cx > bx and (ay < by) and (cy < by):\n\tprint('YES')\nelse:\n\tprint('NO')\n"
    },
    {
        "task_id": 984,
        "slowest_solution_id": 2,
        "fastest_solution_id": 9,
        "slowest_time": 2.84002947807312,
        "fastest_time": 1.281977653503418,
        "fastest_solution": "import itertools\n\ndef validate_prefix(s, prefix):\n\tn = len(s)\n\tsource = 0\n\tfor i in range(prefix, n):\n\t\tif s[i] > s[source]:\n\t\t\treturn prefix\n\t\telif s[i] == s[source]:\n\t\t\tsource += 1\n\t\t\tif source == prefix:\n\t\t\t\tsource = 0\n\t\t\tcontinue\n\t\tassert s[i] < s[source]\n\t\tprefix = i + 1\n\t\tsource = 0\n\treturn prefix\n\ndef determine_initial_prefix(s):\n\tprefix = 1\n\twhile True:\n\t\tnew_prefix = validate_prefix(s, prefix)\n\t\tif new_prefix == prefix:\n\t\t\tbreak\n\t\tprefix = new_prefix\n\treturn prefix\n\ndef solve():\n\t(n, k) = [int(x) for x in input().split()]\n\ts = list(input())\n\tpref = determine_initial_prefix(s)\n\treturn ''.join(itertools.islice(itertools.cycle(s[:pref]), k))\nprint(solve())\n",
        "slowest_solution": "from math import ceil\n(n, k) = [int(s) for s in input().split(' ')]\ns = input()\nprefix_idx = 0\nidx = n - 1\nfor i in range(1, n):\n\tif s[i] == s[prefix_idx]:\n\t\tif idx == n - 1:\n\t\t\tidx = i - 1\n\t\tprefix_idx += 1\n\telif s[i] < s[prefix_idx]:\n\t\tprefix_idx = 0\n\t\tidx = n - 1\n\telse:\n\t\tif idx == n - 1:\n\t\t\tidx = i - 1\n\t\tbreak\nmultiply = ceil(k / (idx + 1))\nprint((s[:idx + 1] * multiply)[:k])\n"
    },
    {
        "task_id": 941,
        "slowest_solution_id": 1,
        "fastest_solution_id": 5,
        "slowest_time": 7.675257682800293,
        "fastest_time": 3.4691150188446045,
        "fastest_solution": "a = 123 ** 511211\nprint(*sorted(list(map(int, input().split()))[1:]))\n",
        "slowest_solution": "arr = input().split()[1:]\nimport time\ncurrent_milli_time = lambda : int(round(time.time() * 1000))\ns = current_milli_time()\nfor i in range(len(arr)):\n\tfor j in range(len(arr) - i - 1):\n\t\tif int(arr[j]) > int(arr[j + 1]):\n\t\t\t(arr[j], arr[j + 1]) = (arr[j + 1], arr[j])\nwhile current_milli_time() - s <= 1.5 * 1000:\n\tpass\nprint(' '.join(arr))\n"
    },
    {
        "task_id": 986,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.9461138248443604,
        "fastest_time": 1.2133395671844482,
        "fastest_solution": "(n, m) = map(int, input().split())\nlis = []\nfor i in range(n):\n\tss = list(input())\n\ttmp = [10000] * 3\n\tfor i in range(m):\n\t\ta = min(i, m - i)\n\t\tif ss[i] >= '0' and ss[i] <= '9':\n\t\t\ttmp[0] = min(tmp[0], a)\n\t\telif ss[i] >= 'a' and ss[i] <= 'z':\n\t\t\ttmp[1] = min(tmp[1], a)\n\t\telif ss[i] == '#' or ss[i] == '*' or ss[i] == '&':\n\t\t\ttmp[2] = min(tmp[2], a)\n\tlis.append(tmp)\nans = 10000000000\nfor i in range(n):\n\tfor j in range(n):\n\t\tfor k in range(n):\n\t\t\tif i != j and j != k and (i != k):\n\t\t\t\tans = min(lis[i][0] + lis[j][1] + lis[k][2], ans)\nprint(ans)\n",
        "slowest_solution": "(n, m) = map(int, input().split())\nl = [input() for _ in range(n)]\nans = n * m * n\ndig = [ans for _ in range(n)]\nla = [ans for _ in range(n)]\nsp = [ans for _ in range(n)]\nd = {}\nfor i in '#*&':\n\td[i] = sp\nfor i in '0123456789':\n\td[i] = dig\nfor i in 'abcdefghijklmnopqrstuvwxyz':\n\td[i] = la\nfor i in range(n):\n\tfor j in range(m):\n\t\td[l[i][j]][i] = min(d[l[i][j]][i], min(j, m - j))\nfor i in range(n):\n\tfor j in range(n):\n\t\tfor k in range(n):\n\t\t\tif i != k and i != j and (j != k):\n\t\t\t\tans = min(ans, dig[i] + la[j] + sp[k])\nprint(ans)\n"
    },
    {
        "task_id": 993,
        "slowest_solution_id": 0,
        "fastest_solution_id": 8,
        "slowest_time": 2.912717819213867,
        "fastest_time": 1.2110679149627686,
        "fastest_solution": "import sys\nfrom math import gcd\nt = int(input())\nfor _ in range(t):\n\tv = []\n\t(n, k) = map(int, input().split())\n\tv = list(map(int, input().split()))\n\tv.sort()\n\tg = 0\n\tF = False\n\tfor i in range(1, n):\n\t\tg = gcd(g, v[i] - v[0])\n\tif (k - v[0]) % g == 0:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
        "slowest_solution": "import math\n\ndef gcd(a, b):\n\treturn math.gcd(a, b)\nfor _ in range(int(input())):\n\t(n, k) = map(int, input().split())\n\tl = list(map(int, input().split()))\n\tg = 0\n\tl.sort()\n\tfor i in range(1, n):\n\t\tg = gcd(g, l[i] - l[0])\n\tif (k - l[0]) % g == 0:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    },
    {
        "task_id": 1000,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.5969738960266113,
        "fastest_time": 1.1416049003601074,
        "fastest_solution": "from sys import stdin\nfrom math import ceil, floor\nn = int(input())\ns = stdin.readline()\nt = stdin.readline()\nfirst = 0\nsecond = 0\ndraw = 0\nfor i in range(2 * n):\n\tif s[i] == '1' and t[i] == '1':\n\t\tdraw += 1\n\telif s[i] == '1':\n\t\tfirst += 1\n\telif t[i] == '1':\n\t\tsecond += 1\nif first > second:\n\tif draw % 2 == 1:\n\t\tfirst -= ceil((first - second) / 2)\n\telse:\n\t\tfirst -= first - second - ceil((first - second) / 2)\nelif second > first:\n\tif draw % 2 == 1:\n\t\tsecond -= second - first - ceil((second - first) / 2)\n\telse:\n\t\tsecond -= ceil((second - first) / 2)\nfirst += ceil(draw / 2.0)\nsecond += draw - ceil(draw / 2.0)\nif first > second:\n\tprint('First')\nelif second > first:\n\tprint('Second')\nelse:\n\tprint('Draw')\n",
        "slowest_solution": "n = input()\ns = input()\nt = input()\nfir = 0\nsec = 0\nsame = 0\nfor (l, r) in zip(s, t):\n\tif l == '1':\n\t\tfir += 1\n\t\tif r == '1':\n\t\t\tsame += 1\n\t\t\tsec += 1\n\telif r == '1':\n\t\tsec += 1\nif same % 2 != 0:\n\tfir += 1\nif fir > sec:\n\tprint('First')\nelif sec > fir + 1:\n\tprint('Second')\nelse:\n\tprint('Draw')\n"
    },
    {
        "task_id": 996,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.751854181289673,
        "fastest_time": 1.019806146621704,
        "fastest_solution": "from sys import stdin\ninput = stdin.readline\nn = int(input())\nmatrix = []\ndiagOnes = 0\nfor i in range(n):\n\trow = input().split()\n\tif row[i] == '1':\n\t\tdiagOnes += 1\n\tmatrix.append(row)\ndiagOnes %= 2\nans = []\nq = int(input())\nfor _ in range(q):\n\tx = input().split()\n\tif x[0] == '1' or x[0] == '2':\n\t\tdiagOnes = 1 - diagOnes\n\telse:\n\t\tans.append(str(diagOnes))\nprint(''.join(ans))\n",
        "slowest_solution": "from sys import stdin\nn = int(stdin.readline())\ndot = 0\nj = 0\nfor i in range(n):\n\tline = stdin.readline()\n\tif line[j] == '1':\n\t\tdot ^= 1\n\tj += 2\nout = []\nstdin.readline()\nfor query in stdin:\n\tif len(query) < 3:\n\t\tout.append('1' if dot else '0')\n\telse:\n\t\tdot ^= 1\nprint(''.join(out))\n"
    },
    {
        "task_id": 997,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.8205933570861816,
        "fastest_time": 1.118776798248291,
        "fastest_solution": "import sys\n(X, Y) = ([], [])\nn = int(input())\nfor _ in range(n):\n\t(x, y) = input().split()\n\t(x, y) = (int(x), int(y))\n\tX.append(x)\n\tY.append(y)\n(pl, pr) = ([None] * (n + 1), [None] * (n + 1))\n(sl, sr) = ([None] * (n + 1), [None] * (n + 1))\npl[0] = sl[-1] = 0\npr[0] = sr[-1] = sys.maxsize\nfor i in range(n - 1):\n\tpl[i + 1] = max(pl[i], X[i])\n\tpr[i + 1] = min(pr[i], Y[i])\nfor i in range(n - 1, 0, -1):\n\tsl[i] = max(sl[i + 1], X[i])\n\tsr[i] = min(sr[i + 1], Y[i])\nans = 0\nfor i in range(n):\n\tans = max(ans, min(sr[i + 1], pr[i]) - max(sl[i + 1], pl[i]))\nprint(ans)\n",
        "slowest_solution": "n = int(input())\nl1 = -1\nl2 = l1\nr1 = 10 ** 10\nr2 = r1\nsame = False\nfor _ in range(n):\n\t(a, b) = map(int, input().split())\n\t(ls, rs) = (False, False)\n\tif a > l1:\n\t\tl2 = l1\n\t\tl1 = a\n\t\tls = True\n\telif a > l2:\n\t\tl2 = a\n\tif b < r1:\n\t\tr2 = r1\n\t\tr1 = b\n\t\trs = True\n\telif b < r2:\n\t\tr2 = b\n\tif ls or rs:\n\t\tsame = ls and rs\nif same:\n\tans = r2 - l2\nelse:\n\tans = max(r1 - l2, r2 - l1)\nprint(max(0, ans))\n"
    },
    {
        "task_id": 998,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.7814083099365234,
        "fastest_time": 1.0492608547210693,
        "fastest_solution": "def gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\ndef gcd_of_list(lst):\n\ta = lst[0]\n\tfor item in lst:\n\t\ta = gcd(item, a)\n\t\tif a == 1:\n\t\t\treturn 1\n\treturn a\n\ndef __starting_point():\n\tcases = int(input())\n\tfor _ in range(cases):\n\t\tcuts = int(input())\n\t\tangles = list(map(int, input().split()))\n\t\tmin_angle = angles[0]\n\t\tsize = []\n\t\tfor i in range(cuts):\n\t\t\tif i != cuts - 1:\n\t\t\t\tsize.append(angles[i + 1] - angles[i])\n\t\tsize.append(360 - angles[-1] + angles[0])\n\t\tdiff = gcd_of_list(size)\n\t\tprint(360 // diff - len(size))\n__starting_point()\n",
        "slowest_solution": "from functools import reduce\nfrom math import gcd\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = [int(i) for i in input().split()]\n\tarr = []\n\tval = 0\n\tfor i in a:\n\t\tarr.append(i - val)\n\t\tval = i\n\tarr[0] = 360 - (val - arr[0])\n\tarr.append(360)\n\tq = reduce(gcd, arr)\n\tneeded = 360 / q\n\tprint(int(needed - n))\n"
    },
    {
        "task_id": 995,
        "slowest_solution_id": 1,
        "fastest_solution_id": 9,
        "slowest_time": 2.938384532928467,
        "fastest_time": 1.0395324230194092,
        "fastest_solution": "mod = 10 ** 9 + 7\nf = [1] * 100001\nfor i in range(2, 100001):\n\tf[i] = (f[i - 1] + f[i - 2]) % mod\n(n, m) = map(int, input().split())\nprint(2 * (f[n] + f[m] - 1) % mod)\n",
        "slowest_solution": "import sys\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 7)\nMOD = 10 ** 9 + 7\n(n, m) = [int(item) for item in input().split()]\nif n > m:\n\t(n, m) = (m, n)\nif n == 1 and m == 1:\n\tprint(2)\n\texit()\ndp = [[0] * m for _ in range(4)]\ndp[0][1] = 1\ndp[1][1] = 1\ndp[2][1] = 1\ndp[3][1] = 1\nfor i in range(2, m):\n\tdp[0][i] += dp[2][i - 1]\n\tdp[1][i] += dp[0][i - 1]\n\tdp[1][i] += dp[2][i - 1]\n\tdp[2][i] += dp[1][i - 1]\n\tdp[2][i] += dp[3][i - 1]\n\tdp[3][i] += dp[1][i - 1]\n\tdp[0][i] %= MOD\n\tdp[1][i] %= MOD\n\tdp[2][i] %= MOD\n\tdp[3][i] %= MOD\nlr = 0\nud = 0\nfor i in range(4):\n\tlr += dp[i][m - 1]\n\tud += dp[i][n - 1]\nif n == 1:\n\tprint(lr % MOD)\n\texit()\nelse:\n\tprint((lr + ud - 2) % MOD)\n"
    },
    {
        "task_id": 999,
        "slowest_solution_id": 0,
        "fastest_solution_id": 9,
        "slowest_time": 2.760007858276367,
        "fastest_time": 1.0140981674194336,
        "fastest_solution": "import sys\n\ndef is_changeable(l, r, x, a, b):\n\tif a == b:\n\t\treturn 0\n\tif abs(b - a) >= x:\n\t\treturn 1\n\tif a - l >= x and b - l >= x or (r - a >= x and r - b >= x):\n\t\treturn 2\n\tif a - l >= x and r - l >= x and (r - b >= x):\n\t\treturn 3\n\tif r - a >= x and r - l >= x and (b - l >= x):\n\t\treturn 3\n\telse:\n\t\treturn -1\nj = -1\nfor line in sys.stdin:\n\tline = line.rstrip()\n\tif j == -1:\n\t\tj = 0\n\telif j == 0:\n\t\ty = line.split(' ')\n\t\t(l, r, x) = (int(y[0]), int(y[1]), int(y[2]))\n\t\tj = 1\n\telif j == 1:\n\t\tz = line.split(' ')\n\t\t(a, b) = (int(z[0]), int(z[1]))\n\t\tprint(is_changeable(l, r, x, a, b))\n\t\tj = 0\n",
        "slowest_solution": "import sys\ninput = sys.stdin.readline\nfor t in range(int(input())):\n\t(l, r, x) = map(int, input().split())\n\t(a, b) = map(int, input().split())\n\tif a == b:\n\t\tprint(0)\n\t\tcontinue\n\tif abs(a - b) >= x:\n\t\tprint(1)\n\t\tcontinue\n\tif a < b:\n\t\tif a - l >= x:\n\t\t\tprint(2)\n\t\t\tcontinue\n\t\tif r - a >= x:\n\t\t\tif r - b >= x:\n\t\t\t\tprint(2)\n\t\t\t\tcontinue\n\t\t\tif r - l >= x:\n\t\t\t\tif b - l >= x:\n\t\t\t\t\tprint(3)\n\t\t\t\t\tcontinue\n\t\t\t\tprint(-1)\n\t\t\t\tcontinue\n\t\t\tprint(-1)\n\t\t\tcontinue\n\t\tprint(-1)\n\t\tcontinue\n\telse:\n\t\tif r - a >= x:\n\t\t\tprint(2)\n\t\t\tcontinue\n\t\tif a - l >= x:\n\t\t\tif b - l >= x:\n\t\t\t\tprint(2)\n\t\t\t\tcontinue\n\t\t\tif r - l >= x:\n\t\t\t\tif r - b >= x:\n\t\t\t\t\tprint(3)\n\t\t\t\t\tcontinue\n\t\t\t\tprint(-1)\n\t\t\t\tcontinue\n\t\t\tprint(-1)\n\t\t\tcontinue\n\t\tprint(-1)\n\t\tcontinue\n"
    },
    {
        "task_id": 982,
        "slowest_solution_id": 1,
        "fastest_solution_id": 8,
        "slowest_time": 5.509698390960693,
        "fastest_time": 0.8952865600585938,
        "fastest_solution": "n = int(input())\nx = list(map(int, input().split()))\n\nclass fenwick:\n\n\tdef __init__(self, n):\n\t\tself.tree = [0] * (n + 1)\n\n\tdef update(self, i):\n\t\ti += 1\n\t\twhile i < len(self.tree):\n\t\t\tself.tree[i] += 1\n\t\t\ti += i & -i\n\n\tdef query(self, i):\n\t\tsum = 0\n\t\ti += 1\n\t\twhile i > 0:\n\t\t\tsum += self.tree[i]\n\t\t\ti -= i & -i\n\t\treturn sum\n\ndef solve(x):\n\tn = len(x)\n\tmod = 1000000007\n\tmissing = [True] * n\n\tbit1 = fenwick(n)\n\tbit2 = fenwick(n)\n\tfor i in range(n):\n\t\tx[i] -= 1\n\t\tif x[i] != -1:\n\t\t\tmissing[x[i]] = False\n\tmissisng_elems = []\n\tfor i in range(n):\n\t\tif missing[i]:\n\t\t\tmissisng_elems.append(i)\n\tmissing_sum = 0\n\tm = len(missisng_elems)\n\tfor i in missisng_elems:\n\t\tmissing_sum += i\n\t\tif i < n - 1:\n\t\t\tbit2.update(i + 1)\n\tfact = [1] * 500010\n\tfor i in range(1, 500010):\n\t\tfact[i] = i * fact[i - 1] % mod\n\ttotal_cost = 0\n\tp = 0\n\ty = 0\n\tfor i in range(n - 1):\n\t\tif x[i] != -1:\n\t\t\tif m == 0:\n\t\t\t\tD1 = bit1.query(x[i])\n\t\t\t\tbit1.update(x[i] + 1)\n\t\t\t\tcost = (x[i] - D1) * fact[n - i - 1]\n\t\t\telse:\n\t\t\t\tD1 = bit1.query(x[i]) * m\n\t\t\t\tno_of_smaller_missing_elems = bit2.query(x[i])\n\t\t\t\tD2 = no_of_smaller_missing_elems * p\n\t\t\t\tbit1.update(x[i] + 1)\n\t\t\t\tcost = (x[i] * m - (D1 + D2)) * fact[m - 1] * fact[n - i - 1]\n\t\t\t\ty += m - no_of_smaller_missing_elems\n\t\telse:\n\t\t\tif p == 0:\n\t\t\t\tcost = (missing_sum - y) * fact[m - 1] * fact[n - i - 1]\n\t\t\telse:\n\t\t\t\tD1 = p * m * (m - 1) // 2\n\t\t\t\tD2 = y * (m - 1)\n\t\t\t\tcost = (missing_sum * (m - 1) - (D1 + D2)) * fact[m - 2] * fact[n - i - 1]\n\t\t\tp += 1\n\t\ttotal_cost += cost % mod\n\treturn (total_cost + fact[m]) % mod\nprint(solve(x))\n",
        "slowest_solution": "from bisect import bisect_right, bisect_left\nMOD = 10 ** 9 + 7\nN = 3 * 10 ** 5\n\nclass SegmentTree:\n\n\tdef __init__(self, arr):\n\t\tself.size = len(arr)\n\t\tself.tree = [0] * (2 * self.size)\n\t\tself.build(arr)\n\n\tdef build(self, arr):\n\t\tfor i in range(n):\n\t\t\tself.tree[i + n] = arr[i]\n\t\tfor i in range(self.size - 1, 0, -1):\n\t\t\tself.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]\n\n\tdef query(self, l, r):\n\t\tif l > r:\n\t\t\treturn 0\n\t\tl += self.size\n\t\tr += self.size\n\t\ts = 0\n\t\twhile l <= r:\n\t\t\tif l % 2 == 1:\n\t\t\t\ts += self.tree[l]\n\t\t\t\tl += 1\n\t\t\tif r % 2 == 0:\n\t\t\t\ts += self.tree[r]\n\t\t\t\tr -= 1\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\treturn s\n\n\tdef update(self, i, x):\n\t\ti += n\n\t\tself.tree[i] = x\n\t\twhile i > 1:\n\t\t\tself.tree[i >> 1] = self.tree[i] + self.tree[i ^ 1]\n\t\t\ti >>= 1\n\ndef binomial(n, k):\n\tif n < k or k < 0:\n\t\treturn 0\n\treturn fac[n] * inv_fac[k] * inv_fac[n - k] % MOD\n\ndef factorial(n):\n\tif n < 0:\n\t\treturn 0\n\treturn fac[n]\n\ndef my_bisect(a, x):\n\treturn bisect_left(a, x)\nfac = [1] * (N + 1)\ninv_fac = [1] * (N + 1)\nfor i in range(1, N + 1):\n\tfac[i] = fac[i - 1] * i % MOD\n\tinv_fac[i] = inv_fac[i - 1] * pow(i, MOD - 2, MOD) % MOD\nn = int(input().strip())\np = list(map(int, input().strip().split()))\nS = set(range(n))\nfor i in range(n):\n\tp[i] -= 1\n\tif p[i] != -1:\n\t\tS.remove(p[i])\nsum_S = sum(S)\nm = len(S)\nS = sorted(S)\nans = fac[m]\nc = 0\nT = 0\nH = SegmentTree([0] * n)\nfor k in range(n):\n\tif p[k] == -1:\n\t\tA = factorial(n - 1 - k) * factorial(c) * factorial(m - 1 - c) % MOD\n\t\tB = (binomial(m - 1, c) * (sum_S - T) - binomial(m - 2, c - 1) * m * (m - 1) // 2) % MOD\n\t\tans = (ans + A * B) % MOD\n\t\tc += 1\n\telse:\n\t\tA = fac[n - 1 - k] * factorial(c) * factorial(m - c) % MOD\n\t\tB = ((p[k] - H.query(0, p[k] - 1)) * binomial(m, c) - my_bisect(S, p[k]) * binomial(m - 1, c - 1)) % MOD\n\t\tans = (ans + A * B) % MOD\n\t\tH.update(p[k], 1)\n\t\tj = bisect_right(S, p[k])\n\t\tT += m - j\nprint(ans)\n"
    }
]